/*!
 * @brief geoportal-extensions-openlayers
 *
 * This software is released under the licence CeCILL-B (Free BSD compatible)
 * @see http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt
 * @see http://www.cecill.info/licences/Licence_CeCILL-B_V1-fr.txt
 * @see http://www.cecill.info/
 *
 * @copyright copyright (c) IGN 
 * @license CeCILL-B
 * @author IGN
 * @version 3.0.0
 * @date 01/02/2024
 *
 */

/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/packages/Controls/Utils/Markers.js":
/*!************************************************!*\
  !*** ./src/packages/Controls/Utils/Markers.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var Marker = {
  lightOrange: "data:image/png;base64,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IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpHSU1QPSJodHRwOi8vd3d3LmdpbXAub3JnL3htcC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgeG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOjkyYWVkNjM2LWY3MDMtNDAzOC1hNzM4LWZiYzYxYzZlMTljNCIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5NWMzZWI3NC0zYWRmLTRkYzUtOWZjZS1iODQ4NTc3Nzg4ODQiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0NjI3ZDg3NC1lZDIyLTRiZTUtYTlkNS00NDlmMzVhZDIxYzgiCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJMaW51eCIKICAgR0lNUDpUaW1lU3RhbXA9IjE2ODQ5NDE5Mjc4OTUzMDYiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4zMCIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIKICAgeG1wOkNyZWF0b3JUb29sPSJHSU1QIDIuMTAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDphM2U3ZWQ1MS0xNTI4LTRhYjAtODVjOS0zNzNkNzgxZGM2ZmMiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoTGludXgpIgogICAgICBzdEV2dDp3aGVuPSIyMDIzLTA1LTI0VDE3OjI1OjI3KzAyOjAwIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PofUkY4AAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnBRgPGRuA4VZTAAAFcElEQVRYw82YW2xbVRaGv7XP8bHjXByHQkNhWigdVX1AikRBMBoQ8wASl4fRqPDAAxIPKAVxeRqQRohHBEVCaoGKUBCl4qHcNKCZVKMRRQxtgTaACLRKqlwB14NzM2ni2D2XvXjgBFXQOnFiA1uy/HB89u9/7bX+vf4l1HnpK57hTNCE0AzqAS5gAAuEID5KiWSiLPf4tp7YUjcSu4yLZzdi2IJyNXANcBlwAdAKzAHTwDhwDKEPywC+GZWHbPi7IKOvZIWguAnlr8BtwJ+AxDJeDYCPgF6Ed0hkh+Weov5mZLTHJMDeBjwYk0itYJtKTOpZML3SbYNfnYz2SBr0buARYENcFytdFvga2AGyT7p14Vcjoz3ShOgdKDuAi+pUewpMIDyCypvSreWGk9HdroOEV2F4A1hfTxGJCX2D5U7U/UzuD6NaXq49NRJhBsOjwMVLEtE4gaL4W5cV3IsxPEoizDT0ZLTHcSH6M/BWLLlVwpQKuPzhb+i8sRkv04Y/e5rvPigxtnM9trKU2k0D28A5LN3RsmXbrbFOU8DtQLpqfJqu97nh6TydmzvwWpOI8VDbxqbrkmz62yk+/Ps6yoe8KkeV/hHHfgrMNyrNEkBX1SAktgRs3T7ApV1rSWayiEkDLmLSJDNZLu1ay9btAyS2BEsEuWuZ99WKyRhgHeCcn8wGw/qbOnAS3jmfOwmP9Td1kNhQDduJcUwjyciS0RJXMMkWkPPUo/z4XFxZRhZII8mEwFCsT+f5xXTE7FAOteduItVaZodyhNPVZDeKccJGkxmsChIMOvTt6aRSzIP+7A9rRKWYp29PJ8GgsyqcVauZSADaj+IDTecWvBlD4e01HKjM07XtOOuuy+A2X0BYmib/8SxfvLWRYm8LdqZaCvkI/SDBci6nld0ze7KCLa4F3gSurR4MB5x1FnMhiCeor9hJiPKmWpbGp3EU2IbJFuTe5XfStbczLxgP7K0IPcCFDWhnJoFuMAek2/oNbWdku/WxHATejT1JPZcPvINysFYiK+gAFkXTK6H+MyhXADeseJ9fmrVDM6X080/+p1M2/yFsD1zjEIauEeMAqNpQE16oaKiqwfjYeLk+fuYl10HDq7DsBTavxs8o6FzFKez/dM3rLx9LjUyVxcb7yVkfzmpXFbACJURHIxgyxkyu1ml6qL0Z4YX4xl7Jfrrgm9Ov9bX/e++x1tHCgkQ11lgELGA4sBp3iHRbH5GDwJPAFLXo6KJnDmTh/aG2w2/3t47VSGQxs1zAE9U2s9pEjx3hXuBloCa7G1rxv8o3f/7SkUz/UFFWMqGRWMpHAqsDbl00KGotIXM7MawF7gKSS5oJJRospI7v+rD96Ikp8aV2EgrkVPW4OnIy6SVL9ZubvZgyaOVyYDfwl2oNqVWiXNEb231oTe+/BrzvK9Gy01MFyoiOKzIEmqsEfjGf/39U1yHgosJFUXhlFMl+z9E/nkvhVNHZsjux+9Caf77RnyzMBaJLmW4RrWAlB3Y4Uh13HLOA4wQjo6O2IRPNxVV4JuG5Et2SSelzjtFLzsZQ0NIZ8/2rx7K9+/paxqbKvyh4Bc4AFQxzau23Dow7FS+nHmfEUz05OqINH8+evXJPJVOuE93XkY4eSziaXcQpB2b+vZNt7+/8IPPl2OxPRMJ4dDsLzIho3hpzamJ6aqJ0ei6qtZAasmZ2OS1RyOMd6egBIzSFVoKj4y1Hnvhv+8cD02ZOkEmgIKITVnXKWDs1ksvNrgbTbRSZ46cypY50aWcllIsyKXvr8GTyi9f6WvePFGVQhO8EPW2NzI+OfV2pF2bDTgbg8D/aJeVUspd1BK3/G24u7/skO3+iYP3h3LdhI/B+AGodUpo8WKwoAAAAAElFTkSuQmCC",
  darkOrange: "data:image/png;base64,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czpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpHSU1QPSJodHRwOi8vd3d3LmdpbXAub3JnL3htcC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgeG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOjIxNDZjMzUzLWIxZjItNGVjOC04NzQ3LTIwMGEyYWExM2ViMyIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2NGViNmI2Ni03Y2I2LTRkZGUtYTI3OS01MGY0ZWFiZGFhODAiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1ODRhM2VjZC1kNGFmLTQ3NjItYjA1ZS04ODk2MGQ4ZTk0Y2MiCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJMaW51eCIKICAgR0lNUDpUaW1lU3RhbXA9IjE2ODQ5NDE5MDM3ODI2MTQiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4zMCIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIKICAgeG1wOkNyZWF0b3JUb29sPSJHSU1QIDIuMTAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDoxYzNjOGRkZi1kMjVkLTQ4YzQtYTAwYS0yMmU3ZDYwMzg1YjYiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoTGludXgpIgogICAgICBzdEV2dDp3aGVuPSIyMDIzLTA1LTI0VDE3OjI1OjAzKzAyOjAwIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PuhCAHgAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnBRgPGQOTjc4FAAAFdklEQVRYw82YW2gcZRTHf+eb2dlkc9lsrFYr2notfSgWxKKiog8VvIFI9UFQEaWtYPFJfREfRRSEeqlttViLD/WGisYXrShWpfWC1WpSN5eN3cZumkuTzWY3c/mOD9lI0WSTTXbVA8M8zMz3n//5zvl/5xyhxqb3ewYvaERpAvUAFzCABUIQH6GAHyvKa76tJbbUjMRW4+LbC7GsQbgCWA+sAs4AWoA8MAxkgEMo32LoxDO98oIN/xdk9IGUYEYvRrgduAW4Gogt4NMA+BroQHkfm+qW3aP6n5HRTSYG9hZga5lEwyKWKZVJvQCmQ3bZ4F8no5skAXov8BiwspwXizUL9APPgOyVXTr5r5HRzdKI1TsRngHOqlHuKTCI8hhG3padWqw7GX3IddDwcixvAefXUkTKhH7HcBfifi8vh1E1H1cfGkGYxPI4cM68RGw5zf3y3S7IuedgeZwgTNZ1Z3Sz46LRNcA7Zcmd25yGgPWP/M7q65toTLZSHBvn6OcFDm07n6g0n9oNAxsR54DsjBYs2251QWAbgFuBREX/tF3rc9+zA6xa3U5jSxwxHmpbueyqOOvvOM7rj67g1JfedFTNagngVtR+B0zUK8xiwLqKTmhcE3Dblk4uXbecRDKFmATgIiZBIpni0nXLuW1LJ41rgnmcvG6B59WiyRhgBeDM+UZipWHthnbcmDf7b8Y81m5oJ7GyErZTxjH1JCPzesu4ghtvBpkjH2X6uXFlAVEg9SMjhEAamFsyp4Yjcuks1s6uXdZacuksU8OVZDcC0mW8OpFRQqBruvqdwwpdDh+9cjaF0QHQv/2wRhRGB6afdzkVkKZxtDoyVaqZBKCHEXygcXafjhi63l3G9tIEGzYe4ZKrksSbzmCqMEz6mzE+eedC+juaiUYqhZCPchgkqKB4SzxntqQEO7oceBu4srIzHIitsMTOBOMJ1leCkxAMmEpRWt6Vg8BGTConOxZeSVdfzmwxHmpvRtkJnFmHcuYksBkxH8tO69e1nJEd1sdhP/BBuUippfnA+3jsr5ZI9TnzV33mFcB/DuEi4LpFr/PPZu3LkanES08fOltWnxe2Ba5xCEPXiHEAVG2oMS9UNFTVINOXKdamn3nQdSC8HMMeYPVS+hkFzQdObl9m2Zu7+xt6hkKx5fXktGumdNXyZQUKiPZGkDbGnFxqp+kh9kaUHeUTezHr6WRkxt/oa/toT39Lby6QqMoci4BJDB8vpTtEdlkflf3A08AQ1ejoTM8cyeRnudYD72Zb+qokMhNZLuCJaqtZaqDLLi0i7EHYDVTV7oZW/J9PNf3wanfycLoki5nQSFnKewKrnW5NNMhtKRDlt6EsB+4G4vM2/UrUNd5w5Pl028FfiuJL9SQUyKrqEXXkaNyLF2o3N9vUYKB0AbAduKFSQWqVKFv0+rYfXdbx4aB3qqQLDk8VKCKaUSQNmi0F/ujAwB9RTYeAMwoXabg2QvZ5jl4ym8Ip6FjgDm7/bdl7bw3Ec/lItEJyWyAS0RJWsmC7I9WM45hJHCfo6e21dZlozlju3pjnSnRT0tMXHdFzT8dQ0EJoTr2eSXXs7W/uG/pnwiswBZQw5NXaYw5knJKXVY8p8VSP9vZo3cezp1v2nniDK9FD7V70RMxoaganGJmJT0+0frbtt+RPfVN/EQnLo9sxYEREB6wxxweHhwYL4/mo2kSqi43c5zRH8GS7Fz1shMZQJTg41PzVU7+2fdNZNHlBTgI5ER20qkPG2qGebHZsSTpULzJH8slCe6ywrWTlrGTM3tw9Ef/xjUzLvp6idIlwQtBxa2Sit6+/VCvMuu0MwIE726RBSqlViaDli6Gm4t6e1MQveet3Z4+F9cD7Ewo4WRJBbaaSAAAAAElFTkSuQmCC",
  red: "data:image/png;base64,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293bv2fa/f0ASM5yljz/NiUAAA0aaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA0LjQuMC1FeGl2MiI+CiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpHSU1QPSJodHRwOi8vd3d3LmdpbXAub3JnL3htcC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgeG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOmI5YjA2YTAwLWZkOTQtNDc5MC1hNzIzLTlkMGUwNGRiNTRlNyIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1MTQ3ZGU5Yi1kOTA0LTRlNWYtYjIyYy0wZmMzOGRmMWI3ZGEiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo4YzBjNTI2YS1lYTkyLTQxYWItODM5Yy05OWFhYTM0YjdlYzciCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJMaW51eCIKICAgR0lNUDpUaW1lU3RhbXA9IjE2ODQ5NDE2NDAxNTU0MjYiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4zMCIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIKICAgeG1wOkNyZWF0b3JUb29sPSJHSU1QIDIuMTAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDowMjQ4MDc5ZS1kMTYyLTQxZmItOGViYS1lMzY2NTRiNGRjMjYiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoTGludXgpIgogICAgICBzdEV2dDp3aGVuPSIyMDIzLTA1LTI0VDE3OjIwOjQwKzAyOjAwIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PkaovgIAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnBRgPFCiKn0kIAAAFfUlEQVRYw82YTWxc1RXHf+e+N2/GH+Px2IEEV02AgqIsIkwgoYS2ahepVGCBUOiCRRdsAAnECthErBBCICGFj4gqRQqBRSABUrVm1URtCSATJ5ASZCPHH0kGgx1/xJl5nvH7uIcFY4iIM/GzZyhHenqL994993/u+f/fOUeos+nNnkHCJoQWRD0UFzCARYhQCVB8NFWWTwNbT99SNxC3GZfIXg9sADYDWxCuRekEskARYQplFPgEOAr045ph6bXRzwKM3pEX5mduQLkHuAvYCqSW8GkIfAT0IBwknT8lH87o/w2M3mpSqL0LeLQKIrOMZSpVUC8hpkf6bPiTg9FbpBn0L8ATwLoqL5ZrFjgNPAeyV47p3E8GRjdLE6r3oTwHXF0n7ikwgfAEIvvlqJYbDkY3uw4a3YLyNrC2niJSBXQG4c+Ie0yORnGSj5OnRhzlUJ4ErrkikBAoAjPVe7ik4F6D8iRxlGvoyegmx4X4NwgHgM6a8fUyIfc8doZbf99Ca66N0uwF+v7tc3DnWoJK6gqep1C2g3NEjsdLlm03GXSbAe4GmmvGZ91vA3Y8P8aN6ztoyaYxxsPaNrbcnmbbvV/x9ONdnPnA+w71otaMcDfYPqDUmDQTUgjdNYPQsSHkgYf62di9mmwujzHNgIsxzWRzeTZ2r+aBh/rp2BDWDLLQjSzpf7VMMIpB6QKcy77Tuc6wdVsHbspbfJspj63bOuhcV8u3g9KFJtufWQbHakfLdQUv3YrI4qwQ+e65616Jr6mknE4KJgIGgctLZnEq5vRgAWsXLyKttZweLFCcqiW7cdVP1DgwQoQwUNPJxIDDG7vXMDszBvqjDWvM7MwYb+xew8SAUzNowgCSDEwyNVMJQU8AAdC06DvBtOG/76xirlLi3u0nufn2HJmWTir+FJ9+PMu7B66nr6eVYLpWCgUoJ0DCGoq3wv/MbXkhmlkN7Ad+XTMY4kBTl6XlKnA8IQ4U/xyUx8wlB3ZpKvcC23Hz49K79Ep6GeWM8VB7J8pfgasaUM6cAx5EzPvSZ4OGljNy1AYIh4C/L6lASWYBcBCHQ0mBJOfM94rk+WjwAsKvgN8te51LK7kPpm3zK89OrZH1v4zaQ9c4RJFrxDgAqjbSlBcpGqlqODoyWq5TP1OtnoU9wPqV9DMKWlRnfJ+/6q3XKpmhSRVbXU8uuhb6Hq1eVsBHdDiGQWPMuZV1mpuMB/aPCK8CXcsMjs6pufCm3/7PPZXs8LhKnJBjMTCH4f2VdIfIcRsgcgh4FpgkiY4u9Mwqc4fn2468M58dSQhkIbNcwBPVNrPSRJdjWgb2AK8BidrdSCX4PGw5/re53IlBK8uZ0EhVyodCq/1uXTTIzfrExZ0oq4H7gfQSmv54IMqcfNFv7/0ilkCSg1CgoKon1ZEv017ar9/cbEvGEFeuQ9mF8IdaBamFuBB7I7tKq3r+EXjnK0tPTxUoIzqqyCBooRIGM2NjX8d1HQIuKFys0cYY2eeJ3riYwinorHUndvmr3nt7Pj1eVNEa5LZALKIVrBTAnopVRx3HzOE44dDwsG3IRHPBxrtTnkv8p5yjLzvoLy72oaC+mvOvz+V79pZbRyYvJbwC80AFQ1GtPevAqFPxCuoxL57ql8ND2vDx7MVW2JTOuMQPdxDvSInmF/yU1ZT+Nd92eGcp97+RH4BE1XHHLDAtomPWmK8mpiYn/AvFOCmRGmLTm53WOOKpDhM/YqApQsLe+dYPnym1f9xvTVGQc8C4iE5Y1Ulj7eRQoTC7Ih1qFJiTQc7vwN9ZUbk6Z+ydp6L0Z2+Ws/uGrAyI8I2gF6yR0vDI6Uq9fDbsZACO3NQuGa3kr3XC7H+ClvJeP1/6IrbBqbNno0b4+xbMlmARngcRbAAAAABJRU5ErkJggg==",
  turquoiseBlue: "data:image/png;base64,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/MUi8H5G35QHBm+BvjV3bu1znD4AWZpV+gY4OARGS5S97vHu3u65/XunPb8fN2tyj8UDOK0AAA0aaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA0LjQuMC1FeGl2MiI+CiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpHSU1QPSJodHRwOi8vd3d3LmdpbXAub3JnL3htcC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgeG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOjEwNGNlNWFhLTE1YzctNGI4Yi1iOGU1LTFmYWQyNWFiYzBhZCIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpkNDMyZTY1Zi0xOThhLTQxM2EtYWYyMy1jNzhlNzczNGRlN2QiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDoyNzExODVkMi03MWZiLTRhZDMtYTJmMi1iNjM3OWU3MDc1OTEiCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJMaW51eCIKICAgR0lNUDpUaW1lU3RhbXA9IjE2ODQ5NDE4NjYyMzgzMjQiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4zMCIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIKICAgeG1wOkNyZWF0b3JUb29sPSJHSU1QIDIuMTAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo1NGFiYzNkYS1lZWJiLTRlZjctYjdjNS04ZDRjODY5OGVjODMiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoTGludXgpIgogICAgICBzdEV2dDp3aGVuPSIyMDIzLTA1LTI0VDE3OjI0OjI2KzAyOjAwIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/Pj0tlUwAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnBRgPGBru/VeEAAAABmJLR0QA/wD/AP+gvaeTAAAFO0lEQVRYw9WYe2xTVRzHTx97dYS5B1UHa+/tY12dDoOKWyIGlfgHkCkSNTHGwHxA3NiAP/A5x4CMKEzdYL29YyAyBxKQZbI+NvYIaowaH9Ogi2GRbGjcFrbBNrq2a2/9nq5LCFnbbfSOeZJPTs/t6Tm/7/39zu+cU0IiXc7WSImNX0BsZiVYAhigmah5tHklsZrjSYtJSuZtaeSiiJU3gHUwfC9oARfBIHBP1DzaPH1eRuzmp0E6aTgSNX9EWMwSvOkMGPgG+CpguG8a0H7nA78zkMYqye0V0lYXDSHrYUw7cE5TxM04/b+38+vJ+RPRt0eIjVeAAhhyCQizFDKJEBjndaCY49Di4+CRlzFxfwSE3Ciol9i4DSBujoRUy7HIszFxdwSF3CioBy8qm1g5ufhirHwyJqwHrrDGWTlg8hFL1URN2+EF0XFPkyYuSWwhUVgnT2CygXBG3dFcM7bz1/au1u7OK9/93eWidUlHe1dCc810EsUAsXOPQZCI3rGZ6Wb4EXAEM0SCUFnZduz6T/09l4bHXYOCz+f0+XxeWg+7XYM/4vnKtlqHJHSIOrAHlYMFYmawRNCKycaDGZLVfMRdf/nPDpfXM+abotDnpy93dtzXfNgdZg+im2uimJ6h66UTeIMZsrat1jvkdPRRb/imLt4hl6N3DfqFEIPvOMzDJYspJsWfbUKEyFNttcKoyzkKo4UgYoRRt3OE9guT1br984nsmQ7gCWbIipaj4xeu9v/hFQTPlG7B89+u9v9O+4UQQ8f/BSlaVM8kgBOhji4p9mpvwQ+Wfwddjp6bQw2u8g44HT3535/tTUa/0Eccvg4sFDE1m2PBZkx2LVRqVcLQvG/PDDX1/tVxze38x+UZH6O1He28b764qgwtxOcf327eBGLFE9NikiD3qzDZhVBJgCJH3KubDnkfbD4s5Jw74qM1bcvDnxq8/vHt1SrS9InIJ2m7OQ4UYsKhCB9lJqHj0gPsHJzPvsS9w8rRRPDptI40M8PlH9fOJ5M5K008rsZmIwi5gc4QN9Zja8zn+5epch9PTFepU1iGuVunVqeyS9g0iv8zy96l0WiSjIsXx28iJEJhaONkMGB5YP14bkmI1SzIz1T0pRa9VKnNzCjUMcwWUAS2BtgWYLJN+xTo1OyrOhW7xsAwqnSGkd3i+uGjkT5Xw6DLt3AdEKQNB4YXbdtwQpuVuRtG7pwhxWA7vJgRib0nDuSDvtkIkjYcHE3aVWjRLL9/zyyETPK2Vq3OidAaOhiPDLcbxo3MRIik0eReWPnO15pHHiqbpYhS6hkNw7wAz0To6GM5hAzH3wkDa6b7x4bEwnkUfMnP6idX7Nex7GxElIDNerV6hU6jSdbp9RHck2w0w/FaGGoJm7KtnCfmWNlF1fOrK3Q6bekMRFABO7QM8yxewFLUi+5JSxPpAmcxy0gjt1Rytir4NcHKCfJTH/al5j1j1hr0pWEML55YD+x2GP6cVqNZZjQYEvUsG4vP4v8jKju5L1p6qnytxGKa6qogyOorBpVbXvxMe69xdxABb9I0DAGvIIRWp7NsBsJIoWVZKfaXuf+jMKp2b6z8+Adb4aErNwpCCh5J2pnfoH0ga08g7invBfaQjXjjuQifhyEgLdNolJP5UqR17y+QnSwvk1i565OZK6F8RzubvWwvDH8LvKZnmHXY8HKws+sNLJtI5muJ/7hYElOzJ1V+fN9R7CVDClPJOVXuqo06vS4HQjTwgDKDZRXk/1JiD7wrieFLk6T1lczCXUVK7aPZinS9XrTw+Q+Tql7SUmvGuQAAAABJRU5ErkJggg==",
  defaultOffset: [-25.5, -32]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Marker);

/***/ }),

/***/ "./src/packages/Formats/Styling.js":
/*!*****************************************!*\
  !*** ./src/packages/Formats/Styling.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/ColorUtils */ "./src/packages/Utils/ColorUtils.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
/* harmony import */ var _Controls_Utils_Markers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Controls/Utils/Markers */ "./src/packages/Controls/Utils/Markers.js");
/* harmony import */ var ol_Feature__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ol/Feature */ "ol/Feature");
/* harmony import */ var ol_Feature__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_Feature__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_style_Style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ol/style/Style */ "ol/style/Style");
/* harmony import */ var ol_style_Style__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_style_Style__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ol_style_Circle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ol/style/Circle */ "ol/style/Circle");
/* harmony import */ var ol_style_Circle__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ol_style_Circle__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var ol_style_Icon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ol/style/Icon */ "ol/style/Icon");
/* harmony import */ var ol_style_Icon__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ol_style_Icon__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var ol_style_Fill__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ol/style/Fill */ "ol/style/Fill");
/* harmony import */ var ol_style_Fill__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(ol_style_Fill__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var ol_style_Stroke__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ol/style/Stroke */ "ol/style/Stroke");
/* harmony import */ var ol_style_Stroke__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(ol_style_Stroke__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var ol_style_Text__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ol/style/Text */ "ol/style/Text");
/* harmony import */ var ol_style_Text__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(ol_style_Text__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var ol_geom_Polygon__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ol/geom/Polygon */ "ol/geom/Polygon");
/* harmony import */ var ol_geom_Polygon__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(ol_geom_Polygon__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var ol_geom_MultiPolygon__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ol/geom/MultiPolygon */ "ol/geom/MultiPolygon");
/* harmony import */ var ol_geom_MultiPolygon__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(ol_geom_MultiPolygon__WEBPACK_IMPORTED_MODULE_11__);



// import ol

// import Style






// import geom


var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__["default"].getLogger("styling");
(ol_Feature__WEBPACK_IMPORTED_MODULE_3___default().prototype).setPropertyFill = function () {
  var style = this.getStyle();
  if (!style) {
    return;
  }
  if (Array.isArray(style) && style.length === 0) {
    return;
  }
  var fill = style.getFill();
  if (fill) {
    var colorFill = fill.getColor();
    // array
    if (Array.isArray(colorFill)) {
      var cf = "rgba(";
      cf += colorFill[0] + ",";
      cf += colorFill[1] + ",";
      cf += colorFill[2] + ",";
      cf += colorFill[3] + ")";
      colorFill = cf;
    }
    if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].isRGB(colorFill)) {
      var oColorFill = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].rgbaToHex(colorFill);
      this.set("fill", oColorFill.hex);
      this.set("fill-opacity", oColorFill.opacity);
    } else {
      this.set("fill", colorFill);
      this.set("fill-opacity", 1);
    }
  }
};
(ol_Feature__WEBPACK_IMPORTED_MODULE_3___default().prototype).setPropertyStroke = function () {
  var style = this.getStyle();
  if (!style) {
    return;
  }
  if (Array.isArray(style) && style.length === 0) {
    return;
  }
  var stroke = style.getStroke();
  if (stroke) {
    var colorStroke = stroke.getColor();
    // array
    if (Array.isArray(colorStroke)) {
      var cs = "rgba(";
      cs += colorStroke[0] + ",";
      cs += colorStroke[1] + ",";
      cs += colorStroke[2] + ",";
      cs += colorStroke[3] + ")";
      colorStroke = cs;
    }
    if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].isRGB(colorStroke)) {
      var oColorStroke = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].rgbaToHex(colorStroke);
      this.set("stroke", oColorStroke.hex);
      this.set("stroke-opacity", oColorStroke.opacity);
    } else {
      this.set("stroke", colorStroke);
      this.set("stroke-opacity", 1);
    }
    this.set("stroke-width", stroke.getWidth());
  }
};
(ol_Feature__WEBPACK_IMPORTED_MODULE_3___default().prototype).setPropertyLabel = function () {
  var style = this.getStyle();
  if (!style) {
    return;
  }
  if (Array.isArray(style) && style.length === 0) {
    return;
  }
  var isName = this.get("name") !== undefined;
  var label = style.getText();
  if (label && isName) {
    var fill = style.getText().getFill();
    if (fill) {
      var colorFill = fill.getColor();
      // array
      if (Array.isArray(colorFill)) {
        var cf = "rgba(";
        cf += colorFill[0] + ",";
        cf += colorFill[1] + ",";
        cf += colorFill[2] + ",";
        cf += colorFill[3] + ")";
        colorFill = cf;
      }
      if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].isRGB(colorFill)) {
        var oColorFill = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].rgbaToHex(colorFill);
        this.set("label-fill", oColorFill.hex);
        this.set("label-fill-opacity", oColorFill.opacity);
      } else {
        this.set("label-fill", colorFill);
        this.set("label-fill-opacity", 1);
      }
    }
    var stroke = style.getText().getStroke();
    if (stroke) {
      var colorStroke = stroke.getColor();
      // array
      if (Array.isArray(colorStroke)) {
        var cs = "rgba(";
        cs += colorStroke[0] + ",";
        cs += colorStroke[1] + ",";
        cs += colorStroke[2] + ",";
        cs += colorStroke[3] + ")";
        colorStroke = cs;
      }
      if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].isRGB(colorStroke)) {
        var oColorStroke = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].rgbaToHex(colorStroke);
        this.set("label-stroke", oColorStroke.hex);
        this.set("label-stroke-opacity", oColorStroke.opacity);
      } else {
        this.set("label-stroke", colorStroke);
        this.set("label-stroke-opacity", 1);
      }
      this.set("label-stroke-width", stroke.getWidth());
    }
    this.set("label-font", style.getText().getFont() || Styling.DEFAULT_TEXT.font);
    this.set("label-textAlign", style.getText().getTextAlign() || Styling.DEFAULT_TEXT.textAlign);
  }
};
(ol_Feature__WEBPACK_IMPORTED_MODULE_3___default().prototype).setPropertyMarker = function () {
  var style = this.getStyle();
  if (!style) {
    return;
  }
  if (Array.isArray(style) && style.length === 0) {
    return;
  }
  var image = style.getImage();
  if (image) {
    // si le tag image est seul...
    // c'est soit un marker ou soit un cercle !
    if (image instanceof (ol_style_Icon__WEBPACK_IMPORTED_MODULE_6___default())) {
      var color = image.getColor();
      // array
      if (Array.isArray(color)) {
        var c = "rgba(";
        c += color[0] + ",";
        c += color[1] + ",";
        c += color[2] + ",";
        c += color[3] + ")";
        color = c;
      }
      // feature.set("marker-color", ""); // par defaut
      if (color) {
        var colorIcon = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].rgbaToHex(color);
        this.set("marker-color", colorIcon.hex);
      }
      var scaleIcon = image.getScale();
      switch (Math.round(scaleIcon * 2) / 2) {
        case 0:
        case 0.5:
          this.set("marker-size", "small");
          break;
        case 1:
          this.set("marker-size", "medium");
          break;
        case 1.5:
        case 2:
          this.set("marker-size", "large");
          break;
        default:
          // this.set("marker-size", ""); // par defaut
          break;
      }
      // feature.set("marker-symbol", ""); // par defaut
      var srcImage = image.getSrc();
      if (srcImage) {
        this.set("marker-symbol", srcImage);
      }
      // INFO
      // cas particulier où un objet est transformé :
      //  * un cercle est transformé en icone
      //  > les attributs du cercle sont à supprimer !
      this.unset("circle-fill");
      this.unset("circle-fill-opacity");
      this.unset("circle-stroke");
      this.unset("circle-stroke-width");
      this.unset("circle-stroke-opacity");
      this.unset("circle-radius");
    } else {
      var fillImg = image.getFill();
      if (fillImg) {
        var colorFillImg = fillImg.getColor();
        // array
        if (Array.isArray(colorFillImg)) {
          var cfi = "rgba(";
          cfi += colorFillImg[0] + ",";
          cfi += colorFillImg[1] + ",";
          cfi += colorFillImg[2] + ",";
          cfi += colorFillImg[3] + ")";
          colorFillImg = cfi;
        }
        if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].isRGB(colorFillImg)) {
          var oColorFillImg = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].rgbaToHex(colorFillImg);
          this.set("circle-fill", oColorFillImg.hex);
          this.set("circle-fill-opacity", oColorFillImg.opacity);
        } else {
          this.set("circle-fill", colorFillImg);
          this.set("circle-fill-opacity", 1);
        }
      }
      var strokeImg = image.getStroke();
      if (strokeImg) {
        var colorStrokeImg = strokeImg.getColor();
        // array
        if (Array.isArray(colorStrokeImg)) {
          var csi = "rgba(";
          csi += colorStrokeImg[0] + ",";
          csi += colorStrokeImg[1] + ",";
          csi += colorStrokeImg[2] + ",";
          csi += colorStrokeImg[3] + ")";
          colorStrokeImg = csi;
        }
        if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].isRGB(colorStrokeImg)) {
          var oColorStrokeImg = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].rgbaToHex(colorStrokeImg);
          this.set("circle-stroke", oColorStrokeImg.hex);
          this.set("circle-stroke-opacity", oColorStrokeImg.opacity);
        } else {
          this.set("circle-stroke", colorStrokeImg);
          this.set("circle-stroke-opacity", 1);
        }
        this.set("circle-stroke-width", strokeImg.getWidth());
      }
      var radius = image.getRadius();
      this.set("circle-radius", radius);
    }
  }
};

/**
 * @module Styling
 * @alias Gp.Styling
 * @private
 * @todo ...
 * @description
 * A simple specification for styling GeoJSON / GPX / KML data.
 *
 * @see ol.format.GeoJSONExtended
 * @see ol.format.KMLExtended
 * @see ol.format.GPXExtended
 *
 * @example
 * feature.getStyle(); // null
 * feature.getProperties(); // {"stroke": "#ff0000", "stroke-width": 2}
 * Styling.defineStyleFromProperties(feature);
 * feature.getStyle(); // [Object Style]
 *
 * feature.getStyle(); // [Object Style]
 * feature.getProperties(); // {}
 * Styling.definePropertiesFromStyle(feature);
 * feature.getProperties(); // {"stroke": "#ff0000", "stroke-width": 2}
 *
 * var style = feature.getStyle(); // [Object Style]
 * var tag = Styling.setTag(style, "GPX");
 *
 * ex. output GeoJSON:
 * ```json
 *  "properties": {
 *   "stroke": "#ff0000",
 *   "stroke-width": 2
 *  }
 * ```
 */
var Styling = {
  /**
   * Options to convert geometry
   */
  APPLY_CONVERT_GEOM_GPX: true,
  /**
   * Default icon style options
   */
  DEFAULT_ICON: {
    src: _Controls_Utils_Markers__WEBPACK_IMPORTED_MODULE_2__["default"]["lightOrange"],
    anchor: [0.5, 1],
    scale: 1
  },
  /**
   * Default circle style options
   */
  DEFAULT_CIRCLE: {
    radius: 10,
    fill: {
      opacity: 1,
      color: [0, 0, 0, 1]
    },
    stroke: {
      width: 1,
      opacity: 1,
      color: [0, 0, 0, 1]
    }
  },
  /**
   * Default stroke style options
   */
  DEFAULT_STROKE: {
    width: 5,
    opacity: 1,
    color: [250, 250, 250, 1]
  },
  /**
   * Default fill style options
   */
  DEFAULT_FILL: {
    opacity: 1,
    color: [0, 0, 0, 1]
  },
  /**
   * Default text style options
   * @see https://openlayers.org/en/v6.15.1/apidoc/module-ol_style_Text-Text.html
   */
  DEFAULT_TEXT: {
    font: "16px sans",
    textAlign: "left",
    stroke: {
      color: [250, 250, 250, 1],
      width: 5,
      opactity: 1
    },
    fill: {
      opacity: 1,
      color: [0, 0, 0, 1]
    }
    // offsetX
    // offsetY
    // placement
    // scale
    // rotation
    // justify
    // padding
  },
  /**
   * All styling tags
   * @function getListTags
   * @returns {Array} all styling tags
   * @example
   * "type", // type de geometrie
   * "fill",
   * "fill-opacity",
   * "stroke",
   * "stroke-opacity",
   * "stroke-width",
   * "circle-fill",
   * "circle-fill-opacity",
   * "circle-stroke",
   * "circle-stroke-opacity",
   * "circle-stroke-width",
   * "circle-radius",
   * "marker-symbol",
   * "marker-color",
   * "marker-size"
   */
  getListTags: function getListTags() {
    return ["type", "fill", "fill-opacity", "stroke", "stroke-opacity", "stroke-width", "circle-fill", "circle-fill-opacity", "circle-stroke", "circle-stroke-opacity", "circle-stroke-width", "circle-radius", "marker-symbol", "marker-color", "marker-size", "label-fill", "label-fill-opacity", "label-stroke", "label-stroke-width", "label-stroke-opacity", "label-font", "label-textAlign"];
  },
  /**
   * Transform feature properties to a native style
   *
   * @function defineStyleFromProperties
   * @param {*} feature - ...
   * @returns {*} style - ...
   * @public
   *
   * @description
   * A la lecture du format :
   * > tag styling ---> feature properties ---> feature style
   *
   * Les balises de 'styling' du fichier sont ajoutées dans les properties de chaque features
   * (opération native sous OpenLayers):
   *
   * Ex. avec le format GeoJSON :
   * ```json
   * "properties": {
   *    "stroke": "#000000",      -> feature.get("stroke");
   *    "stroke-width": 13,       -> feature.get("stroke-width");
   *    "stroke-opacity": 0.8,    -> feature.get("stroke-opacity");
   *    "fill": "#a03737",        -> feature.get("fill");
   *    "fill-opacity": 0.5       -> feature.get("fill-opacity");
   * }
   * ```
   *
   * Ensuite, les properties des features sont transformées dans le style natif :
   *
   * ```js
   * // Ex.
   * feature.setStyle(new Style({
   *  fill : new FillStyle({
   *      color : Color.hexToRgba(feature.get("fill"), feature.get("fill-opacity") || 1)
   *  }),
   *  stroke : new StrokeStyle({
   *      color : Color.hexToRgba(feature.get("stroke"), feature.get("stroke-opacity"))
   *      width : feature.get("stroke-width")
   *  })
   * }));
   * ```
   */
  defineStyleFromProperties: function defineStyleFromProperties(feature) {
    // style
    var style = null;

    // les options de styles définis dans le format
    var options = {};

    // properties :
    // "marker-size" -> icon
    // "marker-symbol" -> icon
    // "marker-color" -> icon
    var marker = null;
    if (feature.get("marker-color") || feature.get("marker-size") || feature.get("marker-symbol")) {
      marker = {};
      // icone par defaut
      marker["src"] = this.DEFAULT_ICON.src;
      marker["anchor"] = this.DEFAULT_ICON.anchor;
      var symbolMarker = feature.get("marker-symbol");
      if (symbolMarker) {
        if (symbolMarker.search("data:image/png;base64") !== -1) {
          // icone du portail
          marker["src"] = symbolMarker;
        } else {
          // TODO
          // utiliser les symboles de Maki
          // (cf. https://labs.mapbox.com/maki-icons/)
        }
      }
      var colorMarker = feature.get("marker-color");
      if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].isHex(colorMarker)) {
        marker["color"] = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].hexToRgba(colorMarker, 1);
      }
      var size = feature.get("marker-size");
      if (size) {
        switch (size) {
          case "small":
            marker["scale"] = 0.5;
            break;
          case "medium":
            marker["scale"] = 1;
            break;
          case "large":
            marker["scale"] = 1.5;
            break;
          default:
            marker["scale"] = this.DEFAULT_ICON.scale;
            break;
        }
      }
    }

    // properties :
    // "stroke" -> line / polygon
    // "stroke-opacity" -> line / polygon
    // "stroke-width" -> line / polygon
    var stroke = null;
    if (feature.get("stroke") || feature.get("stroke-opacity") || feature.get("stroke-width")) {
      stroke = {};
      stroke["color"] = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].hexToRgba(feature.get("stroke"), +feature.get("stroke-opacity") || this.DEFAULT_STROKE.opacity);
      stroke["width"] = +feature.get("stroke-width") || this.DEFAULT_STROKE.width;
    }

    // properties :
    // "fill" -> polygon
    // "fill-opacity" -> polygon
    var fill = null;
    if (feature.get("fill") || feature.get("fill-opacity")) {
      fill = {};
      fill["color"] = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].hexToRgba(feature.get("fill"), +feature.get("fill-opacity") || this.DEFAULT_FILL.opacity);
    }

    // properties :
    // "label-fill",
    // "label-fill-opacity",
    // "label-stroke",
    // "label-stroke-width",
    // "label-stroke-opacity",
    // "label-font",
    // "label-textAlign"
    // "name" -> text
    var labelStroke = null;
    var labelFill = null;
    var isLabel = feature.get("name") !== "";
    if (isLabel) {
      if (feature.get("label-fill") || feature.get("label-fill-opacity")) {
        labelFill = {};
        labelFill["color"] = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].hexToRgba(feature.get("label-fill"), +feature.get("label-fill-opacity") || this.DEFAULT_TEXT.fill.opacity);
      }
      if (feature.get("label-stroke") || feature.get("label-stroke-opacity") || feature.get("label-stroke-width")) {
        labelStroke = {};
        labelStroke["color"] = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].hexToRgba(feature.get("label-stroke"), +feature.get("label-stroke-opacity") || this.DEFAULT_TEXT.stroke.opacity);
        labelStroke["width"] = +feature.get("label-stroke-width") || this.DEFAULT_TEXT.stroke.width;
      }
    }

    // properties :
    // "circle-fill"
    // "circle-stroke"
    // "circle-stroke-width"
    // "circle-radius"
    var circleRadius = feature.get("circle-radius") || this.DEFAULT_CIRCLE.radius;
    var circleStroke = null;
    if (feature.get("circle-stroke") || feature.get("circle-stroke-opacity") || feature.get("circle-stroke-width")) {
      circleStroke = {};
      circleStroke["color"] = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].hexToRgba(feature.get("circle-stroke"), +feature.get("circle-stroke-opacity") || this.DEFAULT_CIRCLE.stroke.opacity);
      circleStroke["width"] = +feature.get("circle-stroke-width") || this.DEFAULT_CIRCLE.stroke.width;
    }
    var circleFill = null;
    if (feature.get("circle-fill") || feature.get("circle-fill-opacity")) {
      circleFill = {};
      circleFill["color"] = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].hexToRgba(feature.get("circle-fill"), +feature.get("circle-fill-opacity") || this.DEFAULT_CIRCLE.fill.opacity);
    }

    // options du Style en fonction du type de geometrie
    var type = feature.getGeometry().getType();
    switch (type) {
      case "Circle":
      case "Point":
      case "MultiPoint":
        // Cercle
        var isCircle = false;
        var optionsCircle = {};
        if (circleStroke) {
          optionsCircle["stroke"] = new (ol_style_Stroke__WEBPACK_IMPORTED_MODULE_8___default())(circleStroke);
        }
        if (circleFill) {
          optionsCircle["fill"] = new (ol_style_Fill__WEBPACK_IMPORTED_MODULE_7___default())(circleFill);
        }
        if (Object.keys(optionsCircle).length !== 0) {
          isCircle = true;
          optionsCircle["radius"] = +circleRadius; // Conversion en nombre
          options["image"] = new (ol_style_Circle__WEBPACK_IMPORTED_MODULE_5___default())(optionsCircle);
        }
        // Ponctuel
        if (marker) {
          options["image"] = new (ol_style_Icon__WEBPACK_IMPORTED_MODULE_6___default())(marker);
        }
        // Label
        if (isLabel) {
          var optionsText = {};
          if (labelStroke) {
            optionsText["stroke"] = new (ol_style_Stroke__WEBPACK_IMPORTED_MODULE_8___default())(labelStroke);
          }
          if (labelFill) {
            optionsText["fill"] = new (ol_style_Fill__WEBPACK_IMPORTED_MODULE_7___default())(labelFill);
          }
          if (Object.keys(optionsText).length !== 0) {
            optionsText["text"] = feature.get("name");
            optionsText["textAlign"] = feature.get("label-textAlign") || this.DEFAULT_TEXT.textAlign;
            optionsText["font"] = feature.get("label-font") || this.DEFAULT_TEXT.font;
            options["text"] = new (ol_style_Text__WEBPACK_IMPORTED_MODULE_9___default())(Object.assign({}, this.DEFAULT_TEXT, optionsText));
          } else {
            // on applique un style par defaut sur le label
            // pour un marker ou un cercle
            if (marker || isCircle) {
              var styleText = new (ol_style_Text__WEBPACK_IMPORTED_MODULE_9___default())(Object.assign({}, this.DEFAULT_TEXT, {
                fill: new (ol_style_Fill__WEBPACK_IMPORTED_MODULE_7___default())(this.DEFAULT_TEXT.fill),
                stroke: new (ol_style_Stroke__WEBPACK_IMPORTED_MODULE_8___default())(this.DEFAULT_TEXT.stroke)
              }));
              if (styleText) {
                var cloneStyleText = styleText.clone();
                cloneStyleText.setText(feature.get("name"));
                options["text"] = cloneStyleText;
              }
            }
          }
        }
        break;
      case "Polygon":
      case "MultiPolygon":
        if (stroke) {
          options["stroke"] = new (ol_style_Stroke__WEBPACK_IMPORTED_MODULE_8___default())(stroke);
        }
        if (fill) {
          options["fill"] = new (ol_style_Fill__WEBPACK_IMPORTED_MODULE_7___default())(fill);
        }
        break;
      case "LineString":
      case "MultiLineString":
        if (stroke) {
          options["stroke"] = new (ol_style_Stroke__WEBPACK_IMPORTED_MODULE_8___default())(stroke);
        }
        if (this.APPLY_CONVERT_GEOM_GPX && fill) {
          // INFO
          // Lors d'une transformation de type de geometrie, le type est renseigné.
          // Pour le format GPX,
          // -> on transforme une surface vers ligne lors de l'écriture
          // -> on transforme une ligne vers une surface lors de la lecture si le type est précisé !
          var initType = feature.get("type");
          if (initType && (initType === "Polygon" || initType === "MultiPolygon")) {
            options["fill"] = new (ol_style_Fill__WEBPACK_IMPORTED_MODULE_7___default())(fill);
            var f = feature.clone();
            var ClassPoly = type === "LineString" ? (ol_geom_Polygon__WEBPACK_IMPORTED_MODULE_10___default()) : (ol_geom_MultiPolygon__WEBPACK_IMPORTED_MODULE_11___default());
            feature.setGeometry(new ClassPoly([f.getGeometry().getCoordinates()]));
          }
        }
        break;
      default:
        break;
    }

    // si aucun style disponible, on utilisera le style par defaut defini
    // par l'utilisateur ou l'application
    if (Object.keys(options).length !== 0) {
      style = new (ol_style_Style__WEBPACK_IMPORTED_MODULE_4___default())(options);
    }
    return style;
  },
  /**
   * Define a default style function to apply to a feature
   *
   * @function defineStyleFunctionByDefault
   * @param {Object} defaultStyle - ...
   * @returns {Function} style function
   * @public
   *
   * @description
   * ...
   */
  defineStyleFunctionByDefault: function defineStyleFunctionByDefault(defaultStyle) {
    if (!defaultStyle) {
      return [];
    }
    if (Object.keys(defaultStyle).length === 0) {
      return [];
    }

    // les styles par defaut
    var styleFunction = function styleFunction(feature, resolution) {
      var style = null;
      var type = feature.getGeometry().getType();
      switch (type) {
        case "Point":
        case "MultiPoint":
          // on n'a aucune information sur le type de style à appliquer sur un "Point" :
          // * label ou
          // * marker ou
          // * marker avec label
          // donc, c'est en fonction des styles par defaut...
          var opts = {};
          if (defaultStyle.getImage()) {
            opts["image"] = defaultStyle.getImage();
          }
          if (defaultStyle.getText() && feature.get("name")) {
            var styleText = defaultStyle.getText().clone();
            styleText.setText(feature.get("name"));
            opts["text"] = styleText;
          }
          style = new (ol_style_Style__WEBPACK_IMPORTED_MODULE_4___default())(opts);
          break;
        case "Circle":
          var optsc = {};
          var optsCircle = {};
          if (defaultStyle.getFill()) {
            optsCircle.fill = defaultStyle.getFill();
          }
          if (defaultStyle.getStroke()) {
            optsCircle.stroke = defaultStyle.getStroke();
          }
          if (defaultStyle.getText() && feature.get("name")) {
            var styleTextCircle = defaultStyle.getText().clone();
            styleTextCircle.setText(feature.get("name"));
            optsc.text = styleTextCircle;
          }
          if (Object.keys(optsCircle).length !== 0) {
            // FIXME param radius ?
            optsCircle.radius = 3;
            optsc.image = new (ol_style_Circle__WEBPACK_IMPORTED_MODULE_5___default())(optsCircle);
          }
          style = new (ol_style_Style__WEBPACK_IMPORTED_MODULE_4___default())(optsc);
          break;
        case "Polygon":
        case "MultiPolygon":
          var optsp = {};
          if (defaultStyle.getFill()) {
            optsp.fill = defaultStyle.getFill();
          }
          if (defaultStyle.getStroke()) {
            optsp.stroke = defaultStyle.getStroke();
          }
          style = new (ol_style_Style__WEBPACK_IMPORTED_MODULE_4___default())(optsp);
          break;
        case "LineString":
        case "LinearRing":
        case "MultiLineString":
          var optsl = {};
          if (defaultStyle.getStroke()) {
            optsl.stroke = defaultStyle.getStroke();
          }
          style = new (ol_style_Style__WEBPACK_IMPORTED_MODULE_4___default())(optsl);
          break;
      }
      return [style];
    };
    return styleFunction;
  },
  /**
   * Transform a native style to feature properties by type of geometry
   *
   * @todo not yet implemented !
   * @param {*} feature - feature
   */
  definePropertiesFromStyleByType: function definePropertiesFromStyleByType(feature) {
    var geomType = feature.getGeometry().getType();
    switch (geomType) {
      case "Point":
      case "MultiPoint":
        feature.setPropertyMarker();
        feature.setPropertyLabel();
        break;
      case "LineString":
      case "MultiLineString":
        feature.setPropertyStroke();
        break;
      case "Polygon":
      case "MultiPolygon":
        feature.setPropertyStroke();
        feature.setPropertyFill();
        break;
      default:
        break;
    }
  },
  /**
   * Transform a native style to feature properties
   *
   * @function definePropertiesFromStyle
   * @param {*} feature - ...
   * @public
   *
   * @description
   * A l'écriture du format.
   * > feature style --> feature properties --> tag styling
   *
   * Le style natif est récupéré pour chaque feature :
   *
   * ```js
   * // Ex.
   * var style = feature.getStyle();
   * ```
   *
   * Ensuite, le style natif est transformé en properties pour chaque feature :
   *
   * ```js
   * // Ex.
   * var stroke = style.getStroke();
   * var oColorStroke = Color.rgbaToHex(stroke.getColor());
   * feature.set("stroke", oColorStroke.hex); // #000000
   * feature.set("stroke-opacity", oColorStroke.opacity); // 0.8
   * ```
   *
   * Et, chaque properties des features sont ecrites dans le format du fichier
   * (opération native sous OpenLayers) :
   *
   * Ex. avec le format GeoJSON :
   * ```json
   * "properties": {
   *    "stroke": "#000000",
   *    "stroke-opacity": 0.8
   * }
   * ```
   */
  definePropertiesFromStyle: function definePropertiesFromStyle(feature) {
    var style = feature.getStyle() || feature.getStyleFunction();
    if (style) {
      // style ajouté via une fonction, pour les styles par defaut par ex.
      if (typeof style === "function") {
        var styles = style.call(this, feature, 0);
        if (styles && styles.length !== 0) {
          style = Array.isArray(styles) ? styles[0] : styles;
          feature.setStyle(style);
        } else {
          // au cas où...
          return;
        }
      }
      this.definePropertiesFromStyleByType(feature);
    }
  },
  /**
   * Transform a native style to tags 'styling' into the format
   *
   * @function defineTagFromStyle
   * @param {*} style - ...
   * @param {String} format - ...
   * @returns {String} tags stringify into the format (json / xml)
   * @todo
   * @public
   *
   * @description
   * A partir d'un style natif, on le transforme en balise de 'styling' dans le format demandé,
   * que l'on peut ensuite inserer dans le fichier.
   * > style ---> tag styling
   *
   */
  defineTagFromStyle: function defineTagFromStyle(style, format) {
    logger.trace("todo...");
    return null;
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Styling);

/***/ }),

/***/ "./src/packages/Utils/ColorUtils.js":
/*!******************************************!*\
  !*** ./src/packages/Utils/ColorUtils.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ColorUtils
 * @alias module:~utils/ColorUtils
 * @description
 * ...
 *
 * @example
 * import ColorUtils from "gpf-ext-ol/utils/ColorUtils"
 * ou 
 * import {ColorUtils} from "gpf-ext-ol
 * 
 * ColorUtils.hex();
 * ColorUtils.num();
 * ColorUtils.arrayTorgba();
 * ColorUtils.arrayToHex();
 * ColorUtils.rgbaToHex();
 * ColorUtils.hexToRgba();
 * ColorUtils.isHex();
 * ColorUtils.isRGB();
 */
var ColorUtils = {
  /**
   * Number to hex conversion
   *
   * @param {Number} number - 0-255
   * @returns {String} hex value
   */
  hex: function hex(number) {
    if (number > 255) {
      throw new Error("'" + number + "'' is greater than 255(0xff);");
    }
    var str = Number(number).toString(16);
    return ("0" + str).slice(-2);
  },
  /**
   * Hexa to number conversion
   *
   * @param {*} hexa 00-FF
   * @returns {Number} number value
   */
  num: function num(hexa) {
    return parseInt(hexa, 16);
  },
  /**
   * Converts an array ([255,255,255,1]) to rgba string
   *
   * @function arrayToRgba
   * @param {Array} values - array of values
   * @returns {String} A color of RGB or RGBA format
   */
  arrayToRgba: function arrayToRgba(values) {
    if (!Array.isArray(values)) {
      throw new Error("Not an array !");
    }
    var red = values[0];
    var green = values[1];
    var blue = values[2];
    var alpha = values[3] || 1;
    var result = "rgba(" + red + ", " + green + ", " + blue + ", " + parseFloat(alpha) + ")";
    return result;
  },
  /**
   * Converts an array ([255,255,255,1]) to #RRGGBBAA
   *
   * @function arrayToHex
   * @param {Array} values - array of values
   * @returns {Object}  hex and opacity formated values
   */
  arrayToHex: function arrayToHex(values) {
    if (!Array.isArray(values)) {
      throw new Error("Not an array !");
    }
    var red = values[0];
    var green = values[1];
    var blue = values[2];
    var alpha = values[3];
    var elems = [this.hex(red), this.hex(green), this.hex(blue)];
    var result = {};
    result.hex = "#" + elems.join("");
    if (alpha) {
      // elems.push(hex(alpha));
      result.opacity = parseFloat(alpha);
    }
    return result;
  },
  /**
   * Converts rgba string to #RRGGBBAA
   * (Code adapted from : https://gist.github.com/mstssk/afda4ce9e5c335fd79cd)
   *
   * @function rgbaToHex
   * @param {String} rgba - A color of RGB or RGBA format.
   * @returns {Object} hex and opacity formated values
   */
  rgbaToHex: function rgbaToHex(rgba) {
    var regex = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(0?.?\d+)\s*)?\)/;
    var parsed = regex.exec(rgba);
    if (!parsed) {
      throw new Error("Invalid format: " + rgba);
    }
    var red = parsed[1];
    var green = parsed[2];
    var blue = parsed[3];
    var alpha = parsed[4];
    var elems = [this.hex(red), this.hex(green), this.hex(blue)];
    var result = {};
    result.hex = "#" + elems.join("");
    if (alpha) {
      // elems.push(hex(alpha));
      result.opacity = parseFloat(alpha);
    }
    return result;
  },
  /**
   * Converts hex color and opacity value to rgba string.
   * (Code adapted from : http://stackoverflow.com/a/5624139)
   *
   * @function hexToRgba
   * @param {String} hex - A color value on RGB format (hexa).
   * @param {Number} opacity - A opacity value.
   * @returns {String} A color of RGB or RGBA format
   */
  hexToRgba: function hexToRgba(hex, opacity) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    if (!hex) {
      throw new Error("Invalid format");
    }
    hex = hex.replace(shorthandRegex, function (m, r, g, b) {
      return r + r + g + g + b + b;
    });
    var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    rgb = rgb ? {
      r: parseInt(rgb[1], 16),
      g: parseInt(rgb[2], 16),
      b: parseInt(rgb[3], 16)
    } : null;
    var result = rgb ? "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", " + opacity + ")" : null;
    return result;
  },
  /**
   * Determine if value is a correct hexa color.
   * @param {*} value - hex color (#FFFFFF)
   * @returns {Boolean} True if value is a hexa color
   */
  isHex: function isHex(value) {
    if (!value) {
      return false;
    }
    if (value.charAt(0) !== "#") {
      return false;
    }
    var regex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
    var parsed = regex.exec(value);
    if (!parsed) {
      return false;
    }
    return true;
  },
  /**
   * Determine if value is a correct rgba color.
   * @param {*} value - rgba color (rgba(125,125,125,1))
   * @returns {Boolean} True if value is a rgba color
   */
  isRGB: function isRGB(value) {
    if (!value) {
      return false;
    }
    var regex = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(0?.?\d+)\s*)?\)/;
    var parsed = regex.exec(value);
    if (!parsed) {
      return false;
    }
    return true;
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ColorUtils);

/***/ }),

/***/ "./src/packages/Utils/Helper.js":
/*!**************************************!*\
  !*** ./src/packages/Utils/Helper.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/**
* @module Helper
* @alias module:~utils/HelperUtils
* @description
* ...
*
* @example
* import HelperUtils from "gpf-ext-ol/utils/HelperUtils"
* ou 
* import {HelperUtils} from "gpf-ext-ol
* 
* HelperUtils.detectSupport();
* HelperUtils.assign();
* HelperUtils.mergeParams();
*/
var Helper = {
  /**
   * this method is called by the constructor.
   * this information is useful to switch to touch mode.
   * Detection : test for desktop or tactile
   *
   * @function detectSupport
   * @returns {Boolean} isDesktop - true for desktop userAgent, false for mobile
   */
  detectSupport: function detectSupport() {
    var isDesktop = true;
    var userAgent = window.navigator.userAgent.toLowerCase();
    if (userAgent.indexOf("iphone") !== -1 || userAgent.indexOf("ipod") !== -1 || userAgent.indexOf("ipad") !== -1 || userAgent.indexOf("android") !== -1 || userAgent.indexOf("mobile") !== -1 || userAgent.indexOf("blackberry") !== -1 || userAgent.indexOf("tablet") !== -1 || userAgent.indexOf("phone") !== -1 || userAgent.indexOf("touch") !== -1) {
      isDesktop = false;
    }
    if (userAgent.indexOf("msie") !== -1 || userAgent.indexOf("trident") !== -1) {
      isDesktop = true;
    }
    return isDesktop;
  },
  /**
   *  Copies all source object members to dest
   *
   * @function assign
   * @param {Object} dest - destination object where properties and method will be copied
   * @param {Object} source - source object from which properties and method will be copied
   * @returns {Object} dest
   */
  assign: function assign(dest, source) {
    dest = dest || {};
    for (var prop in source) {
      if (source.hasOwnProperty(prop)) {
        dest[prop] = source[prop];
      }
    }
    return dest;
  },
  /**
   * Merge two objects parameters (deeper than assign)
   *
   * @function mergeParams
   * @param {Object} dest     - destination object where properties and method will be merge
   * @param {Object} source   - source object from which properties and method will be merge
   * @param {Boolean} replace - replace destination value by source if exists or not (true by default)
   */
  mergeParams: function mergeParams(dest, source, replace) {
    if (!dest || !source) {
      return;
    }
    if (typeof replace === "undefined") {
      replace = true;
    }
    for (var param in source) {
      if (source.hasOwnProperty(param)) {
        if (_typeof(source[param]) === "object") {
          if (dest.hasOwnProperty(param)) {
            this.mergeParams(dest[param], source[param], replace);
          } else {
            dest[param] = source[param];
          }
        } else {
          if (dest.hasOwnProperty(param)) {
            if (replace) {
              dest[param] = source[param];
            }
          } else {
            dest[param] = source[param];
          }
        }
      }
    }
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Helper);

/***/ }),

/***/ "./src/packages/Utils/LoggerByDefault.js":
/*!***********************************************!*\
  !*** ./src/packages/Utils/LoggerByDefault.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! loglevel */ "./node_modules/loglevel/lib/loglevel.js");
/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);


/**
 * @module LoggerByDefault
 * @alias module:~utils/Logger
 * @description
 * ...
 *
 * @example
 * import Logger from "gpf-ext-ol/utils/LoggerByDefault"
 * ou 
 * import {Logger} from "gpf-ext-ol
 * 
 * Logger.getLogger();
 * Logger.disableAll();
 * Logger.enableAll();
 */
var LoggerByDefault = {
  /**
   * creation d'un logger statique
   *
   * @function getLogger
   * @param {String} [name="default"] - the logger name
   * @returns {Object} logger
   */
  getLogger: function getLogger(name) {
    // on définit process si non défini dans l'environnement
    if (typeof process === "undefined") {
      var process = {};
      process.env = {
        VERBOSE: false
      };
    }
    process.env.VERBOSE ? loglevel__WEBPACK_IMPORTED_MODULE_0__.enableAll() : loglevel__WEBPACK_IMPORTED_MODULE_0__.disableAll();
    var logname = name || "default";
    return loglevel__WEBPACK_IMPORTED_MODULE_0__.getLogger(logname);
  },
  /**
   * desactive tous les loggers
   * @function disableAll
   */
  disableAll: function disableAll() {
    var loggers = loglevel__WEBPACK_IMPORTED_MODULE_0__.getLoggers();
    for (var key in loggers) {
      if (Object.hasOwnProperty.call(loggers, key)) {
        var logger = loggers[key];
        logger.disableAll();
      }
    }
  },
  /**
   * active tous les loggers
   * @function enableAll
   */
  enableAll: function enableAll() {
    var loggers = loglevel__WEBPACK_IMPORTED_MODULE_0__.getLoggers();
    for (var key in loggers) {
      if (Object.hasOwnProperty.call(loggers, key)) {
        var logger = loggers[key];
        logger.enableAll();
      }
    }
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LoggerByDefault);

/***/ }),

/***/ "./src/packages/Utils/Parser.js":
/*!**************************************!*\
  !*** ./src/packages/Utils/Parser.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }

var logger = _LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("parser");

/**
* @module Parser
* @alias module:~utils/Parser
* @description
* ...
*
* @example
* parse();
* toString();
*/
var Parser = {
  /**
   * ...
   *
   * @param {String} xml - XML string
   * @returns {DOMElement} doc
   */
  parse: function parse(xml) {
    var doc = null;
    var parser = null;
    var scope = typeof window !== "undefined" ? window : null;
    if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && window === null) {
      // code for nodejs
      var DOMParser = (__webpack_require__(/*! xmldom */ "xmldom").DOMParser);
      parser = new DOMParser();
      doc = parser.parseFromString(xml, "text/xml");
    } else if (scope.DOMParser) {
      // code for modern browsers
      parser = new scope.DOMParser();
      doc = parser.parseFromString(xml, "text/xml");
    } else if (scope.ActiveXObject) {
      // code for old IE browsers
      doc = new scope.ActiveXObject("Microsoft.XMLDOM");
      doc.async = false;
      doc.loadXML(xml);
    } else {
      logger.log("Incompatible environment for DOM Parser !");
    }
    var errorNode = doc.querySelector("parsererror");
    if (errorNode) {
      // INFO parsing failed
      // eslint-disable-next-line no-console
      console.error(errorNode);
      return null;
    }
    logger.trace(doc);
    return doc;
  },
  /**
   * ...
   *
   * @param {DOMElement} doc - doc
   * @returns {String} XML string
   */
  toString: function toString(doc) {
    // TODO
    // try catch pour les exceptions !
    // cf. https://developer.mozilla.org/en-US/docs/Web/API/XMLSerializer/serializeToString
    var oSerializer = new XMLSerializer();
    var xml = oSerializer.serializeToString(doc);
    logger.trace(xml);
    return xml;
  },
  /**
   * ...
   * cf. https://stackoverflow.com/questions/376373/pretty-printing-xml-with-javascript/
   *
   * @param {String} xml - XML string
   * @returns {String} XML string formatted
   */
  format: function format(xml) {
    var reg = /(>)\s*(<)(\/*)/g; // updated Mar 30, 2015
    var wsexp = / *(.*) +\n/g;
    var contexp = /(<.+>)(.+\n)/g;
    xml = xml.replace(reg, "$1\n$2$3").replace(wsexp, "$1\n").replace(contexp, "$1\n$2");
    var formatted = "";
    var lines = xml.split("\n");
    var indent = 0;
    var lastType = "other";
    // 4 types of tags - single, closing, opening, other (text, doctype, comment) - 4*4 = 16 transitions
    var transitions = {
      "single->single": 0,
      "single->closing": -1,
      "single->opening": 0,
      "single->other": 0,
      "closing->single": 0,
      "closing->closing": -1,
      "closing->opening": 0,
      "closing->other": 0,
      "opening->single": 1,
      "opening->closing": 0,
      "opening->opening": 1,
      "opening->other": 1,
      "other->single": 0,
      "other->closing": -1,
      "other->opening": 0,
      "other->other": 0
    };
    for (var i = 0; i < lines.length; i++) {
      var ln = lines[i];
      var single = Boolean(ln.match(/<.+\/>/)); // is this line a single tag? ex. <br />
      var closing = Boolean(ln.match(/<\/.+>/)); // is this a closing tag? ex. </a>
      var opening = Boolean(ln.match(/<[^!].*>/)); // is this even a tag (that's not <!something>)
      var type = single ? "single" : closing ? "closing" : opening ? "opening" : "other";
      var fromTo = lastType + "->" + type;
      lastType = type;
      var padding = "";
      indent += transitions[fromTo];
      for (var j = 0; j < indent; j++) {
        padding += "\t";
      }
      if (fromTo === "opening->closing") {
        formatted = formatted.substr(0, formatted.length - 1) + ln + "\n"; // substr removes line break (\n) from prev loop
      } else {
        formatted += padding + ln + "\n";
      }
    }
    logger.trace(formatted);
    return formatted;
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Parser);

/***/ }),

/***/ "./node_modules/loglevel/lib/loglevel.js":
/*!***********************************************!*\
  !*** ./node_modules/loglevel/lib/loglevel.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    var _loggersByName = {};
    var defaultLogger = null;

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods() {
        /*jshint validthis:true */
        var level = this.getLevel();

        // Replace the actual methods.
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, this.name);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;

        // Return any important warnings.
        if (typeof console === undefinedType && level < this.levels.SILENT) {
            return "No console available for logging";
        }
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, _level, _loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, factory) {
      // Private instance variables.
      var self = this;
      /**
       * The level inherited from a parent logger (or a global default). We
       * cache this here rather than delegating to the parent so that it stays
       * in sync with the actual logging methods that we have installed (the
       * parent could change levels but we might not have rebuilt the loggers
       * in this child yet).
       * @type {number}
       */
      var inheritedLevel;
      /**
       * The default level for this logger, if any. If set, this overrides
       * `inheritedLevel`.
       * @type {number|null}
       */
      var defaultLevel;
      /**
       * A user-specific level for this logger. If set, this overrides
       * `defaultLevel`.
       * @type {number|null}
       */
      var userLevel;

      var storageKey = "loglevel";
      if (typeof name === "string") {
        storageKey += ":" + name;
      } else if (typeof name === "symbol") {
        storageKey = undefined;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType || !storageKey) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType || !storageKey) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var cookieName = encodeURIComponent(storageKey);
                  var location = cookie.indexOf(cookieName + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(
                          cookie.slice(location + cookieName.length + 1)
                      )[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey) return;

          // Use localStorage if available
          try {
              window.localStorage.removeItem(storageKey);
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {}
      }

      function normalizeLevel(input) {
          var level = input;
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              return level;
          } else {
              throw new TypeError("log.setLevel() called with invalid level: " + input);
          }
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          if (userLevel != null) {
            return userLevel;
          } else if (defaultLevel != null) {
            return defaultLevel;
          } else {
            return inheritedLevel;
          }
      };

      self.setLevel = function (level, persist) {
          userLevel = normalizeLevel(level);
          if (persist !== false) {  // defaults to true
              persistLevelIfPossible(userLevel);
          }

          // NOTE: in v2, this should call rebuild(), which updates children.
          return replaceLoggingMethods.call(self);
      };

      self.setDefaultLevel = function (level) {
          defaultLevel = normalizeLevel(level);
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.resetLevel = function () {
          userLevel = null;
          clearPersistedLevel();
          replaceLoggingMethods.call(self);
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      self.rebuild = function () {
          if (defaultLogger !== self) {
              inheritedLevel = normalizeLevel(defaultLogger.getLevel());
          }
          replaceLoggingMethods.call(self);

          if (defaultLogger === self) {
              for (var childName in _loggersByName) {
                _loggersByName[childName].rebuild();
              }
          }
      };

      // Initialize all the internal levels.
      inheritedLevel = normalizeLevel(
          defaultLogger ? defaultLogger.getLevel() : "WARN"
      );
      var initialLevel = getPersistedLevel();
      if (initialLevel != null) {
          userLevel = normalizeLevel(initialLevel);
      }
      replaceLoggingMethods.call(self);
    }

    /*
     *
     * Top-level API
     *
     */

    defaultLogger = new Logger();

    defaultLogger.getLogger = function getLogger(name) {
        if ((typeof name !== "symbol" && typeof name !== "string") || name === "") {
            throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
            logger = _loggersByName[name] = new Logger(
                name,
                defaultLogger.methodFactory
            );
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    // ES6 default export, for compatibility
    defaultLogger['default'] = defaultLogger;

    return defaultLogger;
}));


/***/ }),

/***/ "ol/Feature":
/*!*****************************!*\
  !*** external "ol.Feature" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = ol.Feature;

/***/ }),

/***/ "ol/format/GPX":
/*!********************************!*\
  !*** external "ol.format.GPX" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.format.GPX;

/***/ }),

/***/ "ol/format/GeoJSON":
/*!************************************!*\
  !*** external "ol.format.GeoJSON" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = ol.format.GeoJSON;

/***/ }),

/***/ "ol/format/KML":
/*!********************************!*\
  !*** external "ol.format.KML" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.format.KML;

/***/ }),

/***/ "ol/geom/LineString":
/*!*************************************!*\
  !*** external "ol.geom.LineString" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = ol.geom.LineString;

/***/ }),

/***/ "ol/geom/MultiLineString":
/*!******************************************!*\
  !*** external "ol.geom.MultiLineString" ***!
  \******************************************/
/***/ ((module) => {

"use strict";
module.exports = ol.geom.MultiLineString;

/***/ }),

/***/ "ol/geom/MultiPolygon":
/*!***************************************!*\
  !*** external "ol.geom.MultiPolygon" ***!
  \***************************************/
/***/ ((module) => {

"use strict";
module.exports = ol.geom.MultiPolygon;

/***/ }),

/***/ "ol/geom/Polygon":
/*!**********************************!*\
  !*** external "ol.geom.Polygon" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.geom.Polygon;

/***/ }),

/***/ "ol/style":
/*!***************************!*\
  !*** external "ol.style" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = ol.style;

/***/ }),

/***/ "ol/style/Circle":
/*!**********************************!*\
  !*** external "ol.style.Circle" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.style.Circle;

/***/ }),

/***/ "ol/style/Fill":
/*!********************************!*\
  !*** external "ol.style.Fill" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.style.Fill;

/***/ }),

/***/ "ol/style/Icon":
/*!********************************!*\
  !*** external "ol.style.Icon" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.style.Icon;

/***/ }),

/***/ "ol/style/Stroke":
/*!**********************************!*\
  !*** external "ol.style.Stroke" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.style.Stroke;

/***/ }),

/***/ "ol/style/Style":
/*!*********************************!*\
  !*** external "ol.style.Style" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.style.Style;

/***/ }),

/***/ "ol/style/Text":
/*!********************************!*\
  !*** external "ol.style.Text" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.style.Text;

/***/ }),

/***/ "xmldom":
/*!***************************************************************************!*\
  !*** external {"commonjs2":"xmldom","commonjs":"xmldom","amd":"require"} ***!
  \***************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = undefined;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var __webpack_exports__ = {};
/*!*****************************************!*\
  !*** ./src/packages/Formats/GeoJSON.js ***!
  \*****************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ol/format/GeoJSON */ "ol/format/GeoJSON");
/* harmony import */ var ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Styling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Styling */ "./src/packages/Formats/Styling.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
// import openlayers

// import local


/**
 * @classdesc
 *
 * Extended Styles GeoJSON format to export (internal use only !)
 *
 * SPEC
 * cf. https://github.com/mapbox/simplestyle-spec/
 * cf. https://geojson.org/
 *
 *
 * @constructor
 * @alias ol.format.GeoJSONExtended
 * @extends {ol.format.GeoJSON}
 * @type {ol.format.GeoJSONExtended}
 * @param {Object} options - Options
 * @param {Object} [options.defaultStyle] - Styles by default
 * @param {Object} [options.extensions] - Add properties to file root
 */
var GeoJSON = /*#__PURE__*/function (_olGeoJSON) {
  /**
   * See {@link ol.format.GeoJSONExtended}
   * @module GeoJSONExtended
   * @alias module:~formats/GeoJSONExtended
   * @param {*} options - options
   * @example
   * import GeoJSONExtended from "gpf-ext-ol/formats/GeoJSONExtended"
   * ou 
   * import { GeoJSONExtended } from "gpf-ext-ol"
   */
  function GeoJSON(options) {
    var _this;
    _classCallCheck(this, GeoJSON);
    _this = _callSuper(this, GeoJSON, [options]);
    if (!(_this instanceof GeoJSON)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    _this.options = options || {};

    // INFO
    // defaultStyle est un objet de type Style
    if (_this.options.defaultStyle === null || typeof _this.options.defaultStyle === "undefined") {
      _this.options.defaultStyle = {};
    }
    _this.source = null;
    return _possibleConstructorReturn(_this, _this);
  }

  /**
   * Read Extend Styles for Features.
   * This function overloads ol.format.GeoJSON.readFeatures ...
   *
   * @see ol.format.GeoJSON.prototype.readFeatures
   * @param {Object|String} source - Source.
   * @param {olx.format.ReadOptions} [options] - Options.
   * @return {Array.<ol.Feature>} Features.
   */
  _inherits(GeoJSON, _olGeoJSON);
  return _createClass(GeoJSON, [{
    key: "readFeatures",
    value: function readFeatures(source, options) {
      var _this2 = this;
      var features = _get(_getPrototypeOf(GeoJSON.prototype), "readFeatures", this).call(this, source, options);

      // String ou Object
      if (typeof source === "string") {
        this.source = JSON.parse(source);
      } else if (source !== null) {
        this.source = source;
      }
      features.forEach(function (feature) {
        var featureStyleFunction = feature.getStyleFunction();
        // existe t il déjà une fonction de style ?
        // si oui, on l'applique !
        if (featureStyleFunction) {
          var styles = featureStyleFunction.call(_this2, feature, 0);
          if (styles && styles.length !== 0) {
            feature.setStyle(styles[0]);
          }
        } else {
          // à ce niveau, il n'existe pas de styles, donc :
          // soit, on applique les styles par defaut
          // soit, on prend en compte les styles definis dans les properties / tag du fichier
          // les styles définis ecrasent les styles par defaut...
          var style = _Styling__WEBPACK_IMPORTED_MODULE_1__["default"].defineStyleFromProperties(feature);
          if (style) {
            feature.setStyle(style);
          } else {
            // si aucun style disponible, on utilisera le style par defaut defini
            // par l'utilisateur ou l'application
            var styleFunction = _Styling__WEBPACK_IMPORTED_MODULE_1__["default"].defineStyleFunctionByDefault(_this2.options.defaultStyle);
            if (styleFunction) {
              feature.setStyle(styleFunction);
              _Styling__WEBPACK_IMPORTED_MODULE_1__["default"].definePropertiesFromStyle(feature);
            }
          }
        }
      });
      return features;
    }

    /**
     * Write Extend Styles for Features.
     * This function overloads ol.format.GeoJSON.writeFeatures ...
     *
     * @see ol.format.GeoJSON.prototype.writeFeatures
     * @param {Array.<ol.Feature>} features - Features.
     * @param {Object} [options] - Options.
     *
     * @return {String} Result.
     */
  }, {
    key: "writeFeatures",
    value: function writeFeatures(features, options) {
      // on met à jour les properties de styles
      features.forEach(function (feature) {
        _Styling__WEBPACK_IMPORTED_MODULE_1__["default"].definePropertiesFromStyle(feature);
      });
      var geoJSONObject = this.writeFeaturesObject(features, options);

      // ajout des properties à la racine du fichier
      // ex. options : {
      //   extensions : { /* liste des objets à ajouter */ }
      // }
      if (this.options.hasOwnProperty("extensions")) {
        Object.assign(geoJSONObject, this.options.extensions);
      }
      return JSON.stringify(geoJSONObject);
    }

    /**
     * ...
     * @param {*} key ...
     * @returns {Object} json
     */
  }, {
    key: "readRootExtensions",
    value: function readRootExtensions(key) {
      return this.source[key];
    }
  }]);
}((ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_0___default()));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeoJSON);

// Expose GeoJSON as ol.source.GeoJSONExtended. (for a build bundle)
if (window.ol && window.ol.format) {
  window.ol.format.GeoJSONExtended = GeoJSON;
}
})();

// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var __webpack_exports__ = {};
/*!*************************************!*\
  !*** ./src/packages/Formats/KML.js ***!
  \*************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ol_format_KML__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ol/format/KML */ "ol/format/KML");
/* harmony import */ var ol_format_KML__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_format_KML__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ol/style */ "ol/style");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_style__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Styling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Styling */ "./src/packages/Formats/Styling.js");
/* harmony import */ var _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Utils/ColorUtils */ "./src/packages/Utils/ColorUtils.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_Parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Utils/Parser */ "./src/packages/Utils/Parser.js");
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Utils/Helper */ "./src/packages/Utils/Helper.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
// import openlayers


// import local





var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__["default"].getLogger("extended KML format");

/**
 * @classdesc
 *
 * Extended Styles KML format to export (internal use only !)
 *
 * INFO
 * only ol.Control is a user-extendable class.
 * Everything else requires integration with the original openlayers source and a new ol.js
 * to be built with your new classes incorporated.
 *
 * SPEC
 * cf. https://developers.google.com/kml/forum/advanced
 *
 * ISSUES
 * cf. https://github.com/openlayers/openlayers/issues/4829
 * cf. https://github.com/openlayers/openlayers/issues/4460
 * cf. https://github.com/openlayers/openlayers/pull/5590
 * cf. https://github.com/openlayers/openlayers/issues/5229
 * cf. https://github.com/openlayers/openlayers/issues/3371
 *
 * @constructor
 * @alias ol.format.KMLExtended
 * @type {ol.format.KMLExtended}
 * @extends {ol.format.KML}
 * @param {Object} options - Options
 * @param {Object} [options.extensions] - Add properties to file root
 */
var KML = /*#__PURE__*/function (_olKML) {
  /**
   * See {@link ol.format.KMLExtended}
   * @module KMLExtended
   * @alias module:~formats/KMLExtended
   * @param {*} options - options
   * @example
   * import KMLExtended from "gpf-ext-ol/formats/KMLExtended"
   * ou 
   * import { KMLExtended } from "gpf-ext-ol"
   */
  function KML(options) {
    var _this;
    _classCallCheck(this, KML);
    _this = _callSuper(this, KML, [options]);
    if (!(_this instanceof KML)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    options = options || {};

    // INFO
    // source DOM (Document ou Node)
    _this.source = null;

    // INFO
    // gestion des extensions
    _this.extensions = options.extensions || null;

    // INFO
    // defaultStyle est un tableau d'objet de type Style
    if (options.defaultStyle && !Array.isArray(options.defaultStyle)) {
      options.defaultStyle = [options.defaultStyle];
    }
    if (options.defaultStyle === null || typeof options.defaultStyle === "undefined") {
      options.defaultStyle = [];
    }
    return _possibleConstructorReturn(_this, _this);
  }

  /**
   *
   * En lecture, on surcharge la méthode readFeatures.
   * ✔️ In : kml string + features du format original
   * ✔️ Out : features étendus avec des styles, et des metadatas (name ou extendData)
   * > on modifie les features du format original avec les fonctionnalités non gérées.
   *
   * En écriture, on surcharge la méthode writeFearures.
   * ✔️ In : kml du format original + features étendus
   * ✔️ Out : kml étendu avec des styles, et des metadatas (name ou extendData)
   * > on modifie le kml généré par le format original avec les fonctionnalités que nous avons ajoutées aux features.
   *
   * Le principe
   * On parse le kml, et on lit (get) ou on ajoute (set) des fonctionnalités.
   *
   * Les getters vont lire le kml (ex. LabelExtendStyle), et ajouter le style ainsi que le nom du label dans le feature original.
   * getLabelIconStyle (appel des 2 fonctions suivantes)
   * getLabelExtendStyle (New)
   * getHotSpotIconStyle (Bug sur la lecture du  hotspot)
   * getExtendData (New)
   *
   * Les setters vont écrire dans le dom du kml original les fonctionnalités ajoutées dans les features.
   * setLabelExtendStyle (New)
   * setHotSpotIconStyle (Bug sur l'écriture du hotspot)
   * setNameData (Bug suppression de cette balise du format par défaut).
   *
   */

  /**
   * Fonction de lecture du KML avec fonction de traitement en fonction du type
   * PlaceMark (Label ou Marker).
   * Les traitements sont de 2 types :
   *  - creation de styles étendus ou correctifs sur le KML
   *  - ajout de styles étendus sur les features
   *
   * @param {DOMElement} kmlNode - kml nodes
   * @param {Object[]} features - features
   * @param {Object} process - process
   *
   * @example
   * // ajoute des fonctionnalités dans le KML
   * _processKml(kmlDoc, {
   *   labelStyle : createStyleLabel,
   *   iconStyle  : createStyleIcon
   * });
   *
   * // lit des fonctionnalités du KML non impl. par OpenLayers
   * _processKml(kmlNode, {
   *   labelStyle : getStyleToFeatureLabel,
   *   iconStyle  : getStyleToFeatureIcon,
   *   extendedData : getExtendedData
   * });
   */
  _inherits(KML, _olKML);
  return _createClass(KML, [{
    key: "_processKml",
    value: function _processKml(kmlNode, features, process) {
      var firstNodeLevel = kmlNode.nodeName === "#document" ? kmlNode.childNodes[0].childNodes : kmlNode.childNodes;

      // Si le DOM contient un seul objet, le noeud est directement un PlaceMark
      // sinon, c'est un ensemble de noeuds PlaceMark contenus dans le noeud Document.
      var nodes = firstNodeLevel;
      for (var ik = 0; ik < firstNodeLevel.length; ik++) {
        var element = firstNodeLevel[ik];
        if (element.nodeName === "Document") {
          nodes = element.childNodes;
          break;
        }
        if (element.nodeName === "Placemark") {
          nodes = [element];
          break;
        }
      }

      // On recherche les PlaceMark de type Point ayant un Style...
      // Le style peut être placé directement dans le PlaceMark
      // ou lié avec un id (share)
      var stylesUrl = {}; // listes des styles
      var index = -1; // index du features...
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        switch (node.nodeName) {
          case "Style":
            // INFO
            // pour le traitement des balises Styles liées avec styleUrl,
            // elles doivent être toujours déclarées avant les PlaceMark !
            // On ne prend en compte que celles qui sont identifiées via un ID !
            var id = node.attributes[0];
            if (id && id.nodeName === "id") {
              var _k = id.nodeValue;
              var _v = node;
              stylesUrl[_k] = _v;
            }
            break;
          case "Placemark":
            index++;
            var types = node.childNodes; // Point, LineString, Polygon, Style, ...
            var point = false;
            var line = false;
            var poly = false;
            var domStyles = null; // dom
            var hdlDomStyle = null; // dom
            var domExtendedData = null; // dom
            var domNameTag = node; // dom
            for (var j = 0; j < types.length; j++) {
              switch (types[j].nodeName) {
                case "Polygon":
                  poly = true;
                  break;
                case "LineString":
                  line = true;
                  break;
                case "Point":
                  point = true;
                  break;
                case "Style":
                  hdlDomStyle = types[j];
                  domStyles = types[j].childNodes; // liste de styles
                  break;
                case "styleUrl":
                  // style avec lien vers...
                  var _idStyle = types[j].textContent.slice(1);
                  if (stylesUrl[_idStyle]) {
                    domStyles = stylesUrl[_idStyle].childNodes;
                  }
                  break;
                case "ExtendedData":
                  domExtendedData = types[j].childNodes;
                  break;
                case "name":
                  domNameTag = null;
                  break;
                default:
                // on ne traite pas les autres informations ...
                // car elles seront gérées par defaut par le format standard...
              }
            }

            // On traite les balises kml:extendedData pour tous les objets !
            if (domExtendedData) {
              logger.log("ExtendedData :", domExtendedData);
              var fctExtend = process.extendedData;
              if (fctExtend && typeof fctExtend === "function") {
                fctExtend(features[index], domExtendedData);
              }
            }

            // On traite la balise kml:name
            if (domNameTag) {
              logger.log("Name :", domNameTag);
              var fctName = process.nameData;
              if (fctName && typeof fctName === "function") {
                fctName(features[index], domNameTag);
              }
            }

            // On a un Marker avec un Style.
            // Il peut être associé avec un Label !
            // Les markers sans styles ne doivent pas être gérées par les styles par defaut
            // car le KML met en place une punaise google !
            if (point && domStyles && domStyles.length !== 0) {
              var labelStyleDom = null;
              var iconStyleDom = null;
              // On recherche le type de Style
              for (var k = 0; k < domStyles.length; k++) {
                switch (domStyles[k].nodeName) {
                  case "LabelStyle":
                    labelStyleDom = domStyles[k];
                    break;
                  case "IconStyle":
                    iconStyleDom = domStyles[k];
                    break;
                  default:
                  // on ne traite pas les autres informations ...
                }
              }

              // Pour un label, il nous faut un titre !
              var labelName = features[index].getProperties().name;
              var labelDescription = features[index].getProperties().description;
              var value = labelName || labelDescription;
              logger.trace(value);

              // C'est uniquement un Label !
              if (!iconStyleDom && labelStyleDom) {
                var fctLabel = process.labelStyle;
                if (fctLabel && typeof fctLabel === "function") {
                  fctLabel(features[index], labelStyleDom);
                }
                // C'est uniquement un marker !
              } else if (iconStyleDom && !labelStyleDom) {
                var fctIcon = process.iconStyle;
                if (fctIcon && typeof fctIcon === "function") {
                  fctIcon(features[index], iconStyleDom);
                }
                // C'est un marker avec un label !
              } else if (iconStyleDom && labelStyleDom) {
                var fctIconLabel = process.iconLabelStyle;
                if (fctIconLabel && typeof fctIconLabel === "function") {
                  fctIconLabel(features[index], iconStyleDom, labelStyleDom);
                }
              } else {
                // ...
              }
            } else {
              var feature = features[index];
              var style = feature.getStyle();
              if (style && typeof style === "function") {
                var fstyles = style.call(this, feature, 0);
                if (fstyles && fstyles.length !== 0) {
                  style = fstyles[0];
                }
              }
              if (poly) {
                var fctPoly = process.polygonStyle;
                if (fctPoly && typeof fctPoly === "function") {
                  fctPoly(features[index], domStyles);
                }
              }
              if (line) {
                var fctLine = process.lineStringStyle;
                if (fctLine && typeof fctLine === "function") {
                  fctLine(features[index], domStyles);
                }
              }

              // INFO
              // On est sur un Point mais sans style dans le DOM.
              // On regarde le style dans le Feature : Icon ou Circle ?
              if (point && style) {
                var image = style.getImage();
                if (image && image instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__.Circle) {
                  var fctCircle = process.circleStyle;
                  if (fctCircle && typeof fctCircle === "function") {
                    fctCircle(features[index], hdlDomStyle);
                  }
                } else if (image && image instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__.Icon) {
                  var fctPoint = process.pointStyle;
                  if (fctPoint && typeof fctPoint === "function") {
                    fctPoint(features[index], hdlDomStyle);
                  }
                } else {
                  // ...
                }
              }
            }
            break;
          default:
            logger.trace("tag is not processing !");
        }
      }
    }

    /**
     * Write Extend for Features.
     * This function overloads ol.format.KML.writeFeatures ...
     *
     * @see ol.format.KML.prototype.writeFeatures
     * @param {Object[]} features - Features.
     * @param {Object} options - Options.
     *
     * @return {String} kml string formatted
     */
  }, {
    key: "writeFeatures",
    value: function writeFeatures(features, options) {
      logger.log("overload : ol.format.KML.writeFeatures");
      var kmlNode = _get(_getPrototypeOf(KML.prototype), "writeFeaturesNode", this).call(this, features, options);
      if (kmlNode === null) {
        return null;
      }

      // on ajoute les extensions à la racine pour les metadonnées de calcul
      if (this.hasOwnProperty("extensions")) {
        this._writeRootExtensions(kmlNode, this.extensions);
      }

      // On ajoute les styles étendus
      var kmlStringExtended = this._writeExtendStylesFeatures(kmlNode, features, options);

      // On realise un formattage du KML
      var kmlStringFormatted = _Utils_Parser__WEBPACK_IMPORTED_MODULE_5__["default"].format(kmlStringExtended);
      if (kmlStringFormatted === "") {
        return null;
      }
      return kmlStringFormatted;
    }
  }, {
    key: "_writeExtendStylesFeatures",
    value:
    /**
     * Write Extended Styles for each features
     *
     * @param {DOMElement} kmlNode - kml nodes
     * @param {Object[]} features - features
     * @param {Object} options - options
     *
     * @returns {String} kml string extended
     *
     * @private
     */
    function _writeExtendStylesFeatures(kmlNode, features, options) {
      // RGB Colors (RRGGBB) To KML Colors (AABBGGRR)
      function __convertRGBColorsToKML(data, opacity) {
        var strColor = data.toString(16);
        if (strColor.charAt(0) === "#") {
          strColor = strColor.slice(1);
        }
        opacity = opacity || 1;
        opacity = parseInt(opacity * 255, 10);
        opacity = opacity.toString(16);
        var color = opacity;
        color = color + strColor.substr(4, 2);
        color = color + strColor.substr(2, 2);
        color = color + strColor.substr(0, 2);
        return color.toLowerCase();
      }

      /**
       * C'est un Label !
       * On va donc y ajouter qq styles sur le Label (police, halo, ...) :
       * Insertion : PlaceMark>Style>LabelStyle
       *
       * @param {Object} feature - feature
       * @param {DOMElement} node - node
       *
       * @example
       *      <LabelStyleSimpleExtensionGroup fontFamily="Arial" haloColor="16777215" haloRadius="2" haloOpacity="1"/>
       */
      var __createExtendedStyleLabel = function __createExtendedStyleLabel(feature, node) {
        logger.trace("label with style :", node);
        if (!feature) {
          return;
        }

        // Si pas de style defini, c'est donc que l'on va utiliser celui par defaut...
        if (feature.getStyle() instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__.Style) {
          var textStyle = feature.getStyle().getText();
          if (!textStyle) {
            return;
          }
          var _fontFamily = "Sans";
          var _fontSize = "16px";
          var _font = textStyle.getFont();
          if (_font) {
            var splits = _font.split(" ", 2);
            _fontSize = splits[0];
            _fontFamily = splits[1];
          }
          var strokeTextStyle = feature.getStyle().getText().getStroke();
          if (!strokeTextStyle) {
            return;
          }
          if (strokeTextStyle instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__.Stroke) {
            var _haloColor = __convertRGBColorsToKML("#FFFFFF"); // Par defaut
            var color = strokeTextStyle.getColor();
            // array ?
            if (Array.isArray(color)) {
              var cf = "rgba(";
              cf += color[0] + ",";
              cf += color[1] + ",";
              cf += color[2] + ",";
              cf += color[3] + ")";
              color = cf;
            }
            if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].isRGB(color)) {
              var colorHex = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].rgbaToHex(color);
              _haloColor = __convertRGBColorsToKML(colorHex.hex, colorHex.opacity);
            } else {
              _haloColor = __convertRGBColorsToKML(color);
            }
            var _haloRadius = strokeTextStyle.getWidth() || "0";
            var _haloOpacity = "1"; // TODO lire param

            if (node && node.getElementsByTagName("LabelStyleSimpleExtensionGroup").length === 0) {
              var labelExtended = document.createElementNS(kmlNode.namespaceURI, "LabelStyleSimpleExtensionGroup");
              labelExtended.setAttribute("fontSize", _fontSize);
              labelExtended.setAttribute("fontFamily", _fontFamily);
              labelExtended.setAttribute("haloColor", _haloColor);
              labelExtended.setAttribute("haloRadius", _haloRadius);
              labelExtended.setAttribute("haloOpacity", _haloOpacity);
              node.appendChild(labelExtended);
            }
          }
          var fImageStyle = feature.getStyle().getImage();
          if (!fImageStyle) {
            return;
          }
          if (fImageStyle instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__.Circle) {
            var strokeColor = null;
            var strokeWidth = null;
            if (fImageStyle.getStroke()) {
              strokeWidth = fImageStyle.getStroke().getWidth();
              strokeColor = fImageStyle.getStroke().getColor();
              // array ?
              if (Array.isArray(strokeColor)) {
                var cfs = "rgba(";
                cfs += strokeColor[0] + ",";
                cfs += strokeColor[1] + ",";
                cfs += strokeColor[2] + ",";
                cfs += strokeColor[3] + ")";
                strokeColor = cfs;
              }
              if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].isRGB(strokeColor)) {
                var strokeColorHex = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].rgbaToHex(strokeColor);
                strokeColor = __convertRGBColorsToKML(strokeColorHex.hex, strokeColorHex.opacity);
              } else {
                strokeColor = __convertRGBColorsToKML(strokeColor);
              }
            }
            var fillColor = null;
            if (fImageStyle.getFill()) {
              fillColor = fImageStyle.getFill().getColor();
              // array ?
              if (Array.isArray(fillColor)) {
                var cff = "rgba(";
                cff += fillColor[0] + ",";
                cff += fillColor[1] + ",";
                cff += fillColor[2] + ",";
                cff += fillColor[3] + ")";
                fillColor = cff;
              }
              if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].isRGB(fillColor)) {
                var fillColorHex = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].rgbaToHex(fillColor);
                fillColor = __convertRGBColorsToKML(fillColorHex.hex, fillColorHex.opacity);
              } else {
                fillColor = __convertRGBColorsToKML(fillColor);
              }
            }
            if (node && node.getElementsByTagName("ObjectSimpleExtensionGroup").length === 0) {
              var iconExtended = document.createElementNS(kmlNode.namespaceURI, "ObjectSimpleExtensionGroup");
              iconExtended.setAttribute("type", "circle"); // FIXME type circle only !
              iconExtended.setAttribute("radius", fImageStyle.getRadius());
              iconExtended.setAttribute("fillColor", fillColor);
              iconExtended.setAttribute("strokeColor", strokeColor);
              iconExtended.setAttribute("strokeWidth", strokeWidth);
              node.appendChild(iconExtended);
            }
          }
        }
      };

      /**
       * C'est un marker !
       * On va donc ajouter la balise hotspot :
       *  Traiter le cas où les unités sont de type
       *   - FRACTION
       *   - PIXELS
       *  Insertion du correctif dans le noeud : <PlaceMark><Style>IconStyle
       *
       * @param {Object} feature - ol feature
       * @param {DOMElement} node - node
       *
       *  @example
       *  <Style><IconStyle>
       *      <hotSpot x="0.5"  y="1" xunits="fraction" yunits="fraction"/>
       *  </IconStyle></Style>
       */
      var __createExtendedStyleIcon = function __createExtendedStyleIcon(feature, node) {
        logger.trace("marker with style (hotspot):", node);
        if (!feature) {
          return;
        }

        // Si pas de style defini, c'est donc que l'on va utiliser celui par defaut...
        if (feature.getStyle() instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__.Style) {
          var fImageStyle = feature.getStyle().getImage();
          if (!fImageStyle) {
            return;
          }
          if (fImageStyle instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__.Icon) {
            var x = 0;
            var y = 0;
            var xunits = "pixels";
            var yunits = "pixels";
            var size = fImageStyle.getSize();
            var anchor = fImageStyle.getAnchor(); // pixels ! but anchor_ in the current unit !

            if (anchor.length) {
              x = anchor[0];
              y = anchor[1];
              if (yunits === "fraction") {
                y = y === 1 ? 0 : 1 - y; // cf. fixme contribution à faire !
              } else {
                y = yunits === "pixels" && y === size[1] ? 0 : size[1] - y; // cf. fixme contribution à faire !
              }
            }
            if (node && node.getElementsByTagName("hotSpot").length === 0) {
              var hotspot = document.createElementNS(kmlNode.namespaceURI, "hotSpot");
              hotspot.setAttribute("x", x);
              hotspot.setAttribute("y", y);
              hotspot.setAttribute("xunits", xunits);
              hotspot.setAttribute("yunits", yunits);
              node.appendChild(hotspot);
            }
          }
        }
      };

      /**
       * ...
       * @param {*} feature - feature
       * @param {DOMElement} node - node
       */
      var __createExtendedStyleToCircle = function __createExtendedStyleToCircle(feature, node) {
        if (!feature) {
          return;
        }

        // Si pas de style defini, c'est donc que l'on va utiliser celui par defaut...
        if (feature.getStyle() instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__.Style) {
          var fImageStyle = feature.getStyle().getImage();
          if (!fImageStyle) {
            return;
          }
          if (fImageStyle instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__.Circle) {
            var strokeColor = null;
            var strokeWidth = null;
            if (fImageStyle.getStroke()) {
              strokeWidth = fImageStyle.getStroke().getWidth();
              strokeColor = fImageStyle.getStroke().getColor();
              // array ?
              if (Array.isArray(strokeColor)) {
                var cf = "rgba(";
                cf += strokeColor[0] + ",";
                cf += strokeColor[1] + ",";
                cf += strokeColor[2] + ",";
                cf += strokeColor[3] + ")";
                strokeColor = cf;
              }
              if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].isRGB(strokeColor)) {
                var colorHex = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].rgbaToHex(strokeColor);
                strokeColor = __convertRGBColorsToKML(colorHex.hex, colorHex.opacity);
              } else {
                strokeColor = __convertRGBColorsToKML(strokeColor);
              }
            }
            var fillColor = null;
            if (fImageStyle.getFill()) {
              fillColor = fImageStyle.getFill().getColor();
              // array ?
              if (Array.isArray(fillColor)) {
                var cfi = "rgba(";
                cfi += fillColor[0] + ",";
                cfi += fillColor[1] + ",";
                cfi += fillColor[2] + ",";
                cfi += fillColor[3] + ")";
                fillColor = cfi;
              }
              if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].isRGB(fillColor)) {
                var fillColorImgHex = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].rgbaToHex(fillColor);
                fillColor = __convertRGBColorsToKML(fillColorImgHex.hex, fillColorImgHex.opacity);
              } else {
                fillColor = __convertRGBColorsToKML(fillColor);
              }
            }
            if (node && node.getElementsByTagName("ObjectSimpleExtensionGroup").length === 0) {
              var labelStyle = document.createElementNS(kmlNode.namespaceURI, "LabelStyle");
              var circleExtended = document.createElementNS(kmlNode.namespaceURI, "ObjectSimpleExtensionGroup");
              circleExtended.setAttribute("type", "circle"); // FIXME type circle only !
              circleExtended.setAttribute("radius", fImageStyle.getRadius());
              circleExtended.setAttribute("fillColor", fillColor);
              circleExtended.setAttribute("strokeColor", strokeColor);
              circleExtended.setAttribute("strokeWidth", strokeWidth);
              labelStyle.appendChild(circleExtended);
              node.appendChild(labelStyle);
            }
          }
        }
      };

      /**
       * ...
       * @param {*} feature - feature
       * @param {DOMElement} node - node
       */
      var __createExtendedStyleToPoint = function __createExtendedStyleToPoint(feature, node) {};

      // TODO
      var __createExtendedStyleToIconLabel = function __createExtendedStyleToIconLabel(feature, nodeIconStyle, nodeLabelStyle) {
        logger.trace("write an icon with a label");
        __createExtendedStyleIcon(feature, nodeIconStyle);
        __createExtendedStyleLabel(feature, nodeLabelStyle);
      };

      // TODO
      var __setNameData = function __setNameData(feature, tags) {
        for (var i = 0; i < tags.length; i++) {
          var tag = tags[i];
          if (tag.nodeName === "name") {
            return;
          }
        }
        var labelName = feature.getProperties().name;
        if (labelName) {
          var name = document.createElement("name");
          name.innerHTML = labelName;
          tags.appendChild(name);
        }
      };

      // TODO
      var _setExtendedDataStyle = function _setExtendedDataStyle(feature, node) {
        if (node && node.length) {
          var removeNodes = [];
          for (var k = 0; k < node.length; k++) {
            var element = node[k];
            if (element.nodeName === "Data") {
              var key = element.getAttribute("name");
              if (_Styling__WEBPACK_IMPORTED_MODULE_2__["default"].getListTags().includes(key)) {
                removeNodes.push(element);
              }
            }
          }
          if (removeNodes && removeNodes.length) {
            removeNodes.forEach(function (e) {
              e.remove();
            });
          }
        }
      };

      // On ajoute les styles étendus dans le DOM
      this._processKml(kmlNode, features, {
        labelStyle: __createExtendedStyleLabel,
        iconStyle: __createExtendedStyleIcon,
        iconLabelStyle: __createExtendedStyleToIconLabel,
        circleStyle: __createExtendedStyleToCircle,
        pointStyle: __createExtendedStyleToPoint,
        nameData: __setNameData,
        extendedData: _setExtendedDataStyle
      });

      // On convertit le DOM en String...
      var kmlStringExtended = _Utils_Parser__WEBPACK_IMPORTED_MODULE_5__["default"].toString(kmlNode);
      if (!kmlStringExtended) {
        return null;
      }
      return kmlStringExtended;
    }
  }, {
    key: "_writeRootExtensions",
    value:
    /**
     * ...
     *
     * @param {*} kmlNode - ...
     * @param {*} extensions - ...
     */
    function _writeRootExtensions(kmlNode, extensions) {
      var extendDataElement = document.createElementNS(kmlNode.namespaceURI, "ExtendedData");
      // on boucle sur toutes les clefs
      for (var key in extensions) {
        if (Object.hasOwnProperty.call(extensions, key)) {
          var value = extensions[key];
          var dataElement = document.createElementNS(kmlNode.namespaceURI, "Data");
          dataElement.setAttribute("name", key);
          var data = document.createTextNode(JSON.stringify(value));
          dataElement.appendChild(data);
          extendDataElement.appendChild(dataElement);
        }
      }
      // insertion en 1ere place !
      var firstChild = kmlNode.firstChild;
      kmlNode.insertBefore(extendDataElement, firstChild);
    }

    /**
     * Read Extend for Features.
     * This function overloads ol.format.KML.readFeatures ...
     *
     * @see ol.format.KML.prototype.readFeatures
     * @param {Document|Node} source - Source.
     * @param {olx.format.ReadOptions=} options - options.
     * @return {Array.<ol.Feature>} Features.
     */
  }, {
    key: "readFeatures",
    value: function readFeatures(source, options) {
      logger.log("overload : ol.format.KML.readFeatures");

      // String ou Dom
      if (typeof source === "string") {
        this.source = _Utils_Parser__WEBPACK_IMPORTED_MODULE_5__["default"].parse(source);
      } else if (source !== null) {
        this.source = source;
      }
      var features = this._readExtendStylesFeatures(source, options);
      logger.trace("Styles étendus", features);

      // On met à jour les attributs de style dans les features
      features.forEach(function (feature) {
        _Styling__WEBPACK_IMPORTED_MODULE_2__["default"].definePropertiesFromStyle(feature);
      });
      return features;
    }
  }, {
    key: "_readExtendStylesFeatures",
    value:
    /**
     * Read Extended Styles for each features
     *
     * @param {(Document|Node|ArrayBuffer|Object|String)} source - source
     * @param {olx.format.ReadOptions=} options - options
     *
     * @returns {Object[]} features
     *
     * @private
     */
    function _readExtendStylesFeatures(source, options) {
      var features = _get(_getPrototypeOf(KML.prototype), "readFeatures", this).call(this, source, options);
      var kmlDoc = null;
      var kmlString = "";
      if (typeof source === "string") {
        kmlString = source;
      } else {
        kmlString = source.documentElement.outerHTML;
      }

      // On 'deformatte' le KML afin d'eviter des pb de parsing...
      kmlString = kmlString.replace(/\n/g, "");
      kmlString = kmlString.replace(/(>)\s*(<)/g, "$1$2");

      // On met en place un Parser sur le KML
      kmlDoc = _Utils_Parser__WEBPACK_IMPORTED_MODULE_5__["default"].parse(kmlString);
      if (kmlDoc === null) {
        // au cas où...
        return features;
      }

      // KML Colors (AABBGGRR) To RGB Colors (RRGGBB)
      function __convertKMLColorsToRGB(data) {
        var color = "";
        color = color + data.substr(6, 2);
        color = color + data.substr(4, 2);
        color = color + data.substr(2, 2);
        var hex = parseInt(color, 16).toString(16);
        var comp = "";
        var len = hex.length || 0;
        for (var i = 0; i < 6 - len; i++) {
          comp += "0";
        }
        hex = "#" + comp + hex;
        return hex;
      }

      /**
       * Gestion des styles étendus sur le Label
       *
       * @param {Object} feature - ol feature
       * @param {DOMElement} node - node
       *
       * @example
       * <Placemark>
       *  <description>Un label</description>
       *  <name>C'est un label étendu !</name>
       *  <Style>
       *    <IconStyle>
       *      <Icon>
       *        <href>data:image/png;base64,...</href>
       *      </Icon>
       *    </IconStyle>
       *    <LabelStyle>
       *      <color>ffffffff</color>
       *      <colorMode>normal</colorMode>
       *      <scale>1.85</scale>
       *      <LabelStyleSimpleExtensionGroup haloColor="16711680" haloRadius="5" haloOpacity="1"/>
       *    </LabelStyle>
       *  </Style>
       *  <Point>
       *    <coordinates>2,48</coordinates>
       *  </Point>
       * </Placemark>
       */
      var __getExtendedStyleToFeatureLabel = function __getExtendedStyleToFeatureLabel(feature, node) {
        logger.trace("label with style :", node);
        if (!feature) {
          return;
        }

        // label
        var _text = feature.getProperties().name;
        var _color = __convertKMLColorsToRGB("ff000000"); // "#000000"
        var _colorHalo = "#FFFFFF";
        var _radiusHalo = 0;
        // var _opacityHalo = 1; // TODO
        var _font = "Sans";
        var _fontSize = "16px";

        // cercle
        var _circleType = null;
        var _circleRadius = 5;
        var _circleFillColor = "#000000";
        var _circleStrokeColor = "#ffffff";
        var _circleStrokeWidth = 1;

        // On recherche les balises du Style
        var bLabelStyleSimpleExtensionGroup = false;
        var bObjectSimpleExtensionGroup = false;
        var nodeStyles = node.childNodes;
        for (var k = 0; k < nodeStyles.length; k++) {
          switch (nodeStyles[k].nodeName) {
            case "scale":
              // TODO
              break;
            case "colorMode":
              // TODO
              break;
            case "color":
              _color = __convertKMLColorsToRGB(nodeStyles[k].textContent);
              break;
            case "LabelStyleSimpleExtensionGroup":
              bLabelStyleSimpleExtensionGroup = true;
              var attributs = nodeStyles[k].attributes;
              for (var l = 0; l < attributs.length; l++) {
                switch (attributs[l].nodeName) {
                  case "fontFamily":
                    _font = attributs[l].nodeValue;
                    break;
                  case "fontSize":
                    _fontSize = attributs[l].nodeValue;
                    break;
                  case "haloColor":
                    _colorHalo = __convertKMLColorsToRGB(attributs[l].nodeValue);
                    break;
                  case "haloRadius":
                    _radiusHalo = parseInt(attributs[l].nodeValue, 10);
                    break;
                  case "haloOpacity":
                    // _opacityHalo = parseFloat(attributs[l].nodeValue);
                    // TODO opacité !
                    // if (_opacityHalo !== 1) {
                    //     _colorHalo = Color.hexToRgba(_colorHalo, _opacityHalo);
                    // }
                    break;
                  default:
                }
              }
              break;
            case "ObjectSimpleExtensionGroup":
              bObjectSimpleExtensionGroup = true;
              var attributsExt = nodeStyles[k].attributes;
              for (var ll = 0; ll < attributsExt.length; ll++) {
                // type="circle" radius="15" fillColor="7f3737a0" strokeColor="cc000000" strokeWidth="2"
                switch (attributsExt[ll].nodeName) {
                  case "type":
                    _circleType = attributsExt[ll].nodeValue;
                    break;
                  case "radius":
                    _circleRadius = parseInt(attributsExt[ll].nodeValue, 10);
                    break;
                  case "fillColor":
                    var fillColorValue = attributsExt[ll].nodeValue;
                    var fillOpacity = Math.round(_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].num(fillColorValue.substr(0, 2)) / 255 * 10) / 10;
                    var fillColorHexa = __convertKMLColorsToRGB(fillColorValue);
                    _circleFillColor = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].hexToRgba(fillColorHexa, fillOpacity);
                    break;
                  case "strokeColor":
                    var strokeColorValue = attributsExt[ll].nodeValue;
                    var strokeOpacity = Math.round(_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].num(strokeColorValue.substr(0, 2)) / 255 * 10) / 10;
                    var strokeColorHexa = __convertKMLColorsToRGB(strokeColorValue);
                    _circleStrokeColor = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].hexToRgba(strokeColorHexa, strokeOpacity);
                    break;
                  case "strokeWidth":
                    _circleStrokeWidth = parseInt(attributsExt[ll].nodeValue, 10);
                    break;
                  default:
                }
              }
              break;
            default:
            // on ne traite pas les autres informations ...
          }
        }
        var StyleInstance = null;
        if (bObjectSimpleExtensionGroup && _circleType === "circle") {
          StyleInstance = new ol_style__WEBPACK_IMPORTED_MODULE_1__.Circle({
            radius: _circleRadius,
            fill: new ol_style__WEBPACK_IMPORTED_MODULE_1__.Fill({
              color: _circleFillColor
            }),
            stroke: new ol_style__WEBPACK_IMPORTED_MODULE_1__.Stroke({
              color: _circleStrokeColor,
              width: _circleStrokeWidth
            })
          });
        } else if (bLabelStyleSimpleExtensionGroup) {
          // INFO
          // on ajoute une image magique 1x1 pixel invisible
          // afin d'eviter l'affichage d'une punaise google !
          StyleInstance = new ol_style__WEBPACK_IMPORTED_MODULE_1__.Icon({
            src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNiYAAAAAkAAxkR2eQAAAAASUVORK5CYII=",
            size: [51, 38],
            anchor: [25.5, 38],
            anchorOrigin: "top-left",
            anchorXUnits: "pixels",
            anchorYUnits: "pixels"
          });
        } else {
          // ...
        }
        // On reconstruit le style !
        feature.setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_1__.Style({
          image: StyleInstance,
          text: new ol_style__WEBPACK_IMPORTED_MODULE_1__.Text({
            font: _fontSize + " " + _font,
            textAlign: "left",
            text: _text,
            // offsetX : 5, // FIXME valeur arbitraire MAIS esthétique !
            fill: new ol_style__WEBPACK_IMPORTED_MODULE_1__.Fill({
              color: _color
            }),
            stroke: new ol_style__WEBPACK_IMPORTED_MODULE_1__.Stroke({
              color: _colorHalo,
              width: _radiusHalo
            })
          })
        }));
      };

      /**
       * Gestion des styles étendus sur un Marker
       *
       * > correctif sur la balise kml:hostSpot
       * - problème avec 'hotspot y === 0' (?)
       *
       * @param {Object} feature - ol feature
       * @param {DOMElement} node - node
       *
       * @example
       * <Placemark>
       *   <Style>
       *     <IconStyle>
       *       <Icon>
       *         <href>data:image/png;base64,...</href>
       *       </Icon>
       *       <hotSpot x="25.5" y="0" xunits="pixels" yunits="pixels"/>
       *     </IconStyle>
       *   </Style>
       *   <Point>
       *     <coordinates>2,48</coordinates>
       *   </Point>
       * </Placemark>
       */
      var __getExtendedStyleToFeatureIcon = function __getExtendedStyleToFeatureIcon(feature, node) {
        logger.trace("hotspot :", node);

        // marker
        var _src = null;
        var _scale = null;
        var _color = __convertKMLColorsToRGB("ffffffff");
        var _bSizeIcon = false;
        var _sizeW = 51;
        var _sizeH = 38;
        var _bHotSpot = false;
        var _anchorX = 25.5;
        var _anchorXUnits = "pixels";
        var _anchorY = 38;
        var _anchorYUnits = "pixels";
        var nodeStyles = node.childNodes;
        var bIconStyle = false;
        for (var k = 0; k < nodeStyles.length; k++) {
          switch (nodeStyles[k].nodeName) {
            case "Icon":
              bIconStyle = true;
              var nodes = nodeStyles[k].childNodes;
              for (var i = 0; i < nodes.length; i++) {
                switch (nodes[i].nodeName) {
                  case "href":
                    _src = nodes[i].textContent;
                    break;
                  case "gx:w":
                    _bSizeIcon = true;
                    _sizeW = parseFloat(nodes[i].textContent);
                    break;
                  case "gx:h":
                    _bSizeIcon = true;
                    _sizeH = parseFloat(nodes[i].textContent);
                    break;
                  default:
                }
              }
              break;
            case "hotSpot":
              _bHotSpot = true;
              var attributs = nodeStyles[k].attributes;
              for (var l = 0; l < attributs.length; l++) {
                switch (attributs[l].nodeName) {
                  case "x":
                    _anchorX = parseFloat(attributs[l].nodeValue);
                    break;
                  case "y":
                    _anchorY = parseFloat(attributs[l].nodeValue);
                    break;
                  case "yunits":
                    _anchorXUnits = attributs[l].nodeValue;
                    break;
                  case "xunits":
                    _anchorYUnits = attributs[l].nodeValue;
                    break;
                  default:
                }
              }
              break;
            case "scale":
              _scale = parseFloat(nodeStyles[k].textContent);
              break;
            case "color":
              _color = __convertKMLColorsToRGB(nodeStyles[k].textContent);
              break;
            default:
            // on ne traite pas les autres informations ...
          }
        }
        var StyleInstance = null;
        if (bIconStyle) {
          // une image magique 1x1 pixel invisible
          var optionsIcon = {
            src: _src || "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNiYAAAAAkAAxkR2eQAAAAASUVORK5CYII=",
            color: _color,
            crossOrigin: "anonymous",
            // cf. https://gis.stackexchange.com/questions/121555/wms-server-with-cors-enabled/147403#147403
            scale: _scale || 1
          };
          if (_bSizeIcon) {
            _Utils_Helper__WEBPACK_IMPORTED_MODULE_6__["default"].mergeParams(optionsIcon, {
              size: [_sizeW, _sizeH]
            });
          }
          if (_bHotSpot) {
            _Utils_Helper__WEBPACK_IMPORTED_MODULE_6__["default"].mergeParams(optionsIcon, {
              anchor: [_anchorX, _anchorY],
              anchorOrigin: "bottom-left",
              anchorXUnits: _anchorXUnits || "pixels",
              anchorYUnits: _anchorYUnits || "pixels"
            });
          }
          StyleInstance = new ol_style__WEBPACK_IMPORTED_MODULE_1__.Icon(optionsIcon);
        }

        // existe il déjà le style du label ?
        var featureStyleFunction = feature.getStyleFunction();
        if (featureStyleFunction) {
          var _styles = featureStyleFunction(feature, 0);
          if (_styles && !Array.isArray(_styles)) {
            _styles = [_styles];
          }
          if (_styles && _styles.length !== 0) {
            var _style = _styles.length === 1 ? _styles[0] : _styles[_styles.length - 1];
            // on écrase l'icone magic du label !
            feature.setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_1__.Style({
              image: StyleInstance,
              text: _style.getText()
            }));
          }
        }
      };

      /**
       * Gestion de la balise kml:ExtendedData
       *
       * @param {Object} feature - ol feature
       * @param {DOMElement[]} extend - extend
       *
       * @example
       * //--> Marker (Point), LineString, Polygon
       * <ExtendedData>
       *    <Data name="attributetitle">
       *        <displayName>title</displayName>
       *        <value>Titre à concatener avec la valeur de la balise "kml:description"</value>
       *    </Data>
       * </ExtendedData>
       * //--> Label
       * <ExtendedData>
       *    <Data name="label">
       *        <value>PARIS</value> // valeur à remplacer dans "kml:name"
       *    </Data>
       *    <Data name="attributetitle">
       *        <displayName>title</displayName>
       *        <value>Titre à concatener avec la valeur de la balise "kml:description"</value>
       *    </Data>
       * </ExtendedData>
       */
      var __getExtendedData = function __getExtendedData(feature, extend) {
        logger.trace("extendData :", extend);
        if (!feature) {
          return;
        }
        var props = {};
        var _fname = feature.get("name") || "";
        var _fdescription = feature.get("description") || "";
        var _ftitle = null;
        for (var i = 0; i < extend.length; i++) {
          var data = extend[i];
          var name = data.attributes[0]; // 1 seul attribut !
          var nodes = data.childNodes;
          if (name.nodeName === "name") {
            switch (name.nodeValue) {
              // compatibilité ancien geoportail !
              case "label":
                _fname = data.textContent;
                props.name = _fname;
                break;
              // compatibilité ancien geoportail !
              case "title":
              case "attributetitle":
                for (var j = 0; j < nodes.length; j++) {
                  if (nodes[j].nodeName === "value") {
                    _ftitle = nodes[j].textContent;
                  }
                }
                break;
              default:
                props[name.nodeValue] = data.textContent;
                break;
            }
          }
        }

        // Modification des properties "name" et "description"
        if (_ftitle) {
          _fdescription = _fdescription ? _ftitle + " : " + _fdescription : _ftitle;
          props.description = _fdescription;
        }
        if (Object.keys(props).length) {
          feature.setProperties(props, true);
        }
      };

      /**
       * TODO
       * ...
       *
       * @param {Object} feature - ol feature
       * @param {DOMElement} nodeIconStyle - icon style
       * @param {DOMElement} nodeLabelStyle - label style
       * @example
       * ...
       */
      var __getExtendedStyleToFeatureIconLabel = function __getExtendedStyleToFeatureIconLabel(feature, nodeIconStyle, nodeLabelStyle) {
        logger.trace("display icon and label");
        __getExtendedStyleToFeatureLabel(feature, nodeLabelStyle);
        __getExtendedStyleToFeatureIcon(feature, nodeIconStyle);
      };

      // TODO...
      var __getStyleToDefaultFeature = function __getStyleToDefaultFeature(feature, node) {};

      // On lit les styles étendus et on les ajoute aux features
      this._processKml(kmlDoc, features, {
        lineStringStyle: __getStyleToDefaultFeature,
        polygonStyle: __getStyleToDefaultFeature,
        pointStyle: __getStyleToDefaultFeature,
        labelStyle: this.showPointNames_ ? __getExtendedStyleToFeatureLabel : null,
        iconStyle: __getExtendedStyleToFeatureIcon,
        iconLabelStyle: this.showPointNames_ ? __getExtendedStyleToFeatureIconLabel : __getExtendedStyleToFeatureIcon,
        extendedData: __getExtendedData
      });
      return features;
    }
  }, {
    key: "readRootExtensions",
    value:
    /**
     * ...
     * @param {*} key ...
     * @returns {Object} json
     */
    function readRootExtensions(key) {
      var value = {};
      // Rechercher le tag avec la clef : geoportail:compute
      // <ExtendedData>
      //   <Data name="geoportail:compute">{...}</Data>
      // </ExtendedData>
      var firstNodeLevelKml = this.source.nodeName === "#document" ? this.source.childNodes[0] : this.source;
      var childNodesLevel = firstNodeLevelKml.childNodes;
      for (var i = 0; i < childNodesLevel.length; i++) {
        var node1 = childNodesLevel[i];
        if (node1.nodeName === "ExtendedData") {
          var childNodesExtended = node1.childNodes;
          for (var j = 0; j < childNodesExtended.length; j++) {
            var node2 = childNodesExtended[j];
            if (node2.nodeName === "Data") {
              var name = node2.attributes[0];
              if (name && name.nodeName === "name") {
                if (name.nodeValue === key) {
                  value = JSON.parse(node2.textContent);
                  break;
                }
              }
            }
          }
        }
      }
      return value;
    }
  }]);
}((ol_format_KML__WEBPACK_IMPORTED_MODULE_0___default()));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KML);

// Expose KML as ol.source.KMLExtended. (for a build bundle)
if (window.ol && window.ol.format) {
  window.ol.format.KMLExtended = KML;
}
})();

// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!*************************************!*\
  !*** ./src/packages/Formats/GPX.js ***!
  \*************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ol_format_GPX__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ol/format/GPX */ "ol/format/GPX");
/* harmony import */ var ol_format_GPX__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_format_GPX__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_geom_MultiLineString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ol/geom/MultiLineString */ "ol/geom/MultiLineString");
/* harmony import */ var ol_geom_MultiLineString__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_geom_MultiLineString__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_geom_LineString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ol/geom/LineString */ "ol/geom/LineString");
/* harmony import */ var ol_geom_LineString__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_geom_LineString__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Styling__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Styling */ "./src/packages/Formats/Styling.js");
/* harmony import */ var _Utils_Parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Utils/Parser */ "./src/packages/Utils/Parser.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
// import openlayers

// import Geometry


// import local



/**
 * @classdesc
 *
 * Extended Styles GPX format to export (internal use only !)
 *
 * SPEC
 * cf. https://www.topografix.com/gpx.asp
 *
 *
 * @constructor
 * @alias ol.format.GPXExtended
 * @extends {ol.format.GPX}
 * @type {ol.format.GPXExtended}
 * @param {Object} options - Options
 * @param {Object} [options.defaultStyle] - Styles by default
 * @param {String} [options.orderBy] - Sort by key the feature before writing. By default, no sorting
 * @param {Object} [options.extensions] - Add properties to file root
 * @param {function} [options.readExtensions] - Reading extensions (native)
 */
var GPX = /*#__PURE__*/function (_olGPX) {
  /**
   * See {@link ol.format.GPXExtended}
   * @module GPXExtended
   * @alias module:~formats/GPXExtended
   * @param {*} options - options
   * @example
   * import GPXExtended from from "gpf-ext-ol/formats/GPXExtended"
   * ou 
   * import { GPXExtended } from "gpf-ext-ol"
   */
  function GPX(options) {
    var _this;
    _classCallCheck(this, GPX);
    _this = _callSuper(this, GPX, [options]);
    if (!(_this instanceof GPX)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    _this.options = options || {};

    // INFO
    // surcharge de la callback : readExtensions
    if (_this.options.readExtensions && typeof _this.options.readExtensions === "function") {
      var clbk = _this.options.readExtensions; // callback definie par l'utilisateur
      _this.options.readExtensions = function (feature, node) {
        this.readExtensions(feature, node);
        clbk.call(this, feature, node);
      };
    } else {
      _this.options.readExtensions = _this.readExtensions;
    }

    // INFO
    // defaultStyle est un objet de type Style
    if (_this.options.defaultStyle === null || typeof _this.options.defaultStyle === "undefined") {
      _this.options.defaultStyle = {};
    }
    _this.source = null;
    return _possibleConstructorReturn(_this, _this);
  }

  /**
   * Read Extend Styles for Features.
   * This function overloads ol.format.GPX.readFeatures ...
   *
   * @see ol.format.GPX.prototype.readFeatures
   * @param {Document|Node} source - Source.
   * @param {olx.format.ReadOptions=} options - options.
   * @return {Array.<ol.Feature>} Features.
   */
  _inherits(GPX, _olGPX);
  return _createClass(GPX, [{
    key: "readFeatures",
    value: function readFeatures(source, options) {
      // INFO
      // le travail de lecture des extensions du format est porté
      // par la callback des options : readExtensions
      var features = _get(_getPrototypeOf(GPX.prototype), "readFeatures", this).call(this, source, options);

      // String ou Dom
      if (typeof source === "string") {
        this.source = _Utils_Parser__WEBPACK_IMPORTED_MODULE_4__["default"].parse(source);
      } else if (source !== null) {
        this.source = source;
      }

      // INFO
      // on applique les styles par defaut definis avec l'option defaultStyle
      // sauf sur les features qui possèdent des extensions.
      // les features avec extensions sont traité au préalable
      // dans la callback des options : readExtensions
      var self = this;
      features.forEach(function (feature, index, array) {
        feature.setId(index + 1);
        // HACK : enregistrement de la description de la balise 'desc' du format GPX
        var value = feature.getProperties().desc;
        if (value) {
          feature.setProperties({
            description: value
          });
        }
        var featureStyleFunction = feature.getStyleFunction();
        if (!featureStyleFunction) {
          var styleFunction = _Styling__WEBPACK_IMPORTED_MODULE_3__["default"].defineStyleFunctionByDefault(self.options.defaultStyle);
          if (styleFunction) {
            feature.setStyle(styleFunction);
          }
        }
      });
      return features;
    }

    /**
     * Write Extend Styles for Features.
     * This function overloads ol.format.GPX.writeFeatures ...
     *
     * @see ol.format.GPX.prototype.writeFeatures
     * @param {Object[]} features - Features.
     * @param {Object} options - Options.
     *
     * @return {String} Result or null.
     */
  }, {
    key: "writeFeatures",
    value: function writeFeatures(features, options) {
      // INFO
      // il n'est pas possible de surcharger les parsers d'OpenLayers (private),
      // on decide de (re)parser la sortie d'OpenLayers afin d'y placer les balises
      // d'extensions

      // on met à jour les properties de styles
      features.forEach(function (feature, index, array) {
        // HACK : enregistrement de la description dans la balise 'desc' du format GPX
        var value = feature.getProperties().description;
        if (value) {
          feature.setProperties({
            desc: value
          });
        }
        _Styling__WEBPACK_IMPORTED_MODULE_3__["default"].definePropertiesFromStyle(feature);

        // HACK : Le type surfacique n'existe pas au format GPX,
        // on doit la transformer en un lineaire.
        // Par contre, on garde un trace de la transformation :
        // * le style surfacique
        // * le type de geometrie initiale
        var type = feature.getGeometry().getType();
        if (type === "Polygon") {
          // creation d'une copie pour ne pas modifier les features de carte
          var fp = feature.clone();
          fp.set("type", type);
          fp.setGeometry(new (ol_geom_LineString__WEBPACK_IMPORTED_MODULE_2___default())(feature.getGeometry().getCoordinates()));
          features.push(fp);
          // feature à supprimer de l'export
          array.splice(index, 1);
        } else if (type === "MultiPolygon") {
          // creation d'une copie pour ne pas modifier les features de carte
          var fm = feature.clone();
          fm.set("type", type);
          fm.setGeometry(new (ol_geom_MultiLineString__WEBPACK_IMPORTED_MODULE_1___default())(feature.getGeometry().getCoordinates()));
          features.push(fm);
          // feature à supprimer de l'export
          array.splice(index, 1);
        }
      });

      // tri des features en fonction de la balise "number" || "id" || "order"
      if (this.options.orderBy !== undefined) {
        var key = this.options.orderBy;
        if (key) {
          var sortFct = function sortFct(a, b) {
            var cmpA = a.get(key) || 0;
            var cmpB = b.get(key) || 0;
            return cmpA.toString().localeCompare(cmpB.toString(), undefined, {
              numeric: true
            });
          };
          features.sort(sortFct);
        }
      }

      // nodes
      var gpxNode = _get(_getPrototypeOf(GPX.prototype), "writeFeaturesNode", this).call(this, features, options);
      if (gpxNode === null) {
        return null;
      }

      // on ajoute les extensions à la racine pour les metadonnées de calcul
      if (this.options.hasOwnProperty("extensions")) {
        this.writeRootExtensions_(gpxNode, this.options.extensions);
      }

      // INFO
      // à chaque fois qu'un style est trouvé dans un feature,
      // on appelle la fonction d'insertion des balises extensions dans le DOM.
      this.processExtensions_(gpxNode, features, {
        extensions: this.writeExtensions_
      });

      // dom -> string
      var gpxStringExtended = _Utils_Parser__WEBPACK_IMPORTED_MODULE_4__["default"].toString(gpxNode);
      if (!gpxStringExtended) {
        return null;
      }

      // format string
      var gpxStringFormatted = _Utils_Parser__WEBPACK_IMPORTED_MODULE_4__["default"].format(gpxStringExtended);
      if (gpxStringFormatted === "") {
        return null;
      }
      return gpxStringFormatted;
    }

    /**
     * Callback to read extensions from options : readExtensions
     *
     * @param {*} feature - ...
     * @param {*} node - ...
     */
  }, {
    key: "readExtensions",
    value: function readExtensions(feature, node) {
      var _node = node;
      // recherche de la properties de type Node ou Element
      // si le node n'est pas renseigné...
      if (!node) {
        var props = feature.getProperties();
        for (var key in props) {
          if (Object.hasOwnProperty.call(props, key)) {
            var _element = props[key];
            if (_element instanceof Node) {
              _node = _element;
              break;
            }
          }
        }
      }
      if (!_node) {
        // eslint-disable-next-line no-console
        console.warn("node not found !");
        return;
      }

      // ex. de nodes :
      // <extensions>
      //     <marker-size>medium</marker-size>
      //     <marker-symbol></marker-symbol>
      //     <marker-color>#ffffff</marker-color>
      // </extensions>
      for (var index = 0; index < _node.childNodes.length; index++) {
        var element = _node.childNodes[index];
        if (element.nodeType === 1) {
          feature.set(element.nodeName, element.textContent);
        }
      }

      // cas particulier du format GPX :
      // il n'existe pas de surfacique sur ce format, mais il est possible de forcer
      // la transformation en polygone pour des besoins particuliers de visualisation
      _Styling__WEBPACK_IMPORTED_MODULE_3__["default"].APPLY_CONVERT_GEOM_GPX = true;
      var style = _Styling__WEBPACK_IMPORTED_MODULE_3__["default"].defineStyleFromProperties(feature);
      if (style) {
        feature.setStyle(style);
      }
    }

    /**
     * ...
     * @param {*} key ...
     * @returns {Object} json
     * @todo
     */
  }, {
    key: "readRootExtensions",
    value: function readRootExtensions(key) {
      var value = {};
      // Rechercher :
      // <metadata>
      //   <extensions xmlns="http://www.w3.org/1999/xhtml">
      //     <data name="geoportail:compute">{...}</data>
      //   </extensions>
      // </metadata>

      var firstNodeLevelGpx = this.source.childNodes[0]; // gpx
      var searchChildNodesMeta = firstNodeLevelGpx.childNodes; // search metadata
      for (var k = 0; k < searchChildNodesMeta.length; k++) {
        var nodeMeta = searchChildNodesMeta[k];
        if (nodeMeta.nodeName === "metadata") {
          var searchChildNodesExt = nodeMeta.childNodes; // search extensions
          for (var i = 0; i < searchChildNodesExt.length; i++) {
            var nodeExt = searchChildNodesExt[i];
            if (nodeExt.nodeName === "extensions") {
              var searchChildNodesData = nodeExt.childNodes; // search data
              for (var j = 0; j < searchChildNodesData.length; j++) {
                var nodeData = searchChildNodesData[j];
                if (nodeData.nodeName === "data") {
                  var name = nodeData.attributes[0];
                  if (name && name.nodeName === "name") {
                    if (name.nodeValue === key) {
                      value = JSON.parse(nodeData.textContent);
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      }
      return value;
    }

    /**
     * ...
     *
     * @param {*} doc - ...
     * @param {*} extensions - ...
     * @param {Boolean} [xml=false] - write tag xml or json
     */
  }, {
    key: "writeRootExtensions_",
    value: function writeRootExtensions_(doc, extensions, xml) {
      // TODO namespace ?
      var metadata = document.createElement("metadata");
      var extensionsRoot = document.createElement("extensions");
      // INFO
      // convert JSON to XML (dom)
      // * type string :
      // { typestring: "string" } -> <typestring>string</typestring>
      //
      // * type object :
      // { typeobject: { typestring1: "string", typestring2: "string" } }
      // -> <typeobject>
      //      <typestring1>string</typestring1>
      //      <typestring2>string</typestring2>
      //    </typeobject>
      //
      // * type array :
      // { typearray : ["item1", "item2"] }
      // -> <typearray type="array" index=2>
      //      <value>item1</value>
      //      <value>item2</value>
      //    </typearray>
      //
      // * type array of array
      // -> <typearray type="array" index=1>
      //      <value type="array" index=2>
      //          <value>1</value>
      //          <value>2</value>
      //      </value>
      //    </typearray>
      //
      // * type array of object
      // -> <typearray type="array" index=2>
      //      <value>
      //          <typestring1>string</typestring1>
      //          <typestring2>string</typestring2>
      //      </value>
      //      <value>
      //          <typestring1>string</typestring1>
      //          <typestring2>string</typestring2>
      //      </value>
      //    </typearray>
      function toDOM(node, json) {
        for (var key in json) {
          if (Object.hasOwnProperty.call(json, key)) {
            var element = json[key] || ""; // au cas où...
            var tag = document.createElement(key);
            // eslint-disable-next-line valid-typeof
            if (typeof element === "string" || typeof element === "number") {
              tag.innerHTML = element;
              node.appendChild(tag);
            } else if (element instanceof Array) {
              tag.setAttribute("type", "array");
              tag.setAttribute("index", element.length);
              for (var index = 0; index < element.length; index++) {
                var item = element[index] || ""; // au cas où...
                var n = document.createElement("value");
                if (typeof item === "string" || typeof item === "number") {
                  n.innerHTML = item;
                  tag.appendChild(n);
                } else if (item instanceof Array) {
                  n.setAttribute("type", "array");
                  n.setAttribute("index", item.length);
                  for (var i = 0; i < item.length; i++) {
                    var value = item[i] || ""; // au cas où...
                    var k = document.createElement("value");
                    if (typeof value === "string" || typeof value === "number") {
                      k.innerHTML = value;
                      n.appendChild(k);
                    }
                  }
                  tag.appendChild(n);
                } else if (item instanceof Object) {
                  tag.appendChild(toDOM(n, item));
                } else {
                  // "Unknown element !"
                }
              }
              node.appendChild(tag);
            } else if (element instanceof Object) {
              node.appendChild(toDOM(tag, element));
            } else {
              // "Unknown element !"
            }
          }
        }
        return node;
      }
      if (xml) {
        // structure xml
        toDOM(extensionsRoot, extensions);
      } else {
        // structure json par defaut
        // ex.
        // <metadata>
        //   <extensions xmlns="http://www.w3.org/1999/xhtml">
        //     <data name="geoportail:compute">{...}</data>
        //   </extensions>
        // </metadata>
        for (var key in extensions) {
          if (Object.hasOwnProperty.call(extensions, key)) {
            var value = extensions[key];
            var dataElement = document.createElement("data");
            dataElement.setAttribute("name", key);
            var data = document.createTextNode(JSON.stringify(value));
            dataElement.appendChild(data);
            extensionsRoot.appendChild(dataElement);
          }
        }
      }
      metadata.appendChild(extensionsRoot);
      // insertion en 1ere place !
      var firstChild = doc.firstChild;
      doc.insertBefore(metadata, firstChild);
    }

    /**
     * ...
     *
     * @param {Object} feature - ...
     * @param {DOMElement} node - ...
     * @private
     */
  }, {
    key: "writeExtensions_",
    value: function writeExtensions_(feature, node) {
      // creation du DOM
      var extensionsNode = document.createElementNS(node.parentNode.namespaceURI, "extensions");
      _Styling__WEBPACK_IMPORTED_MODULE_3__["default"].getListTags().forEach(function (key) {
        if (feature.get(key)) {
          var extension = document.createElementNS(node.parentNode.namespaceURI, key);
          extension.innerHTML = feature.get(key);
          extensionsNode.appendChild(extension);
        }
      });
      node.appendChild(extensionsNode);
    }

    /**
     * ...
     *
     * @param {DOMElement} doc - ...
     * @param {Object} features - ...
     * @param {Object} actions - ...
     * @private
     */
  }, {
    key: "processExtensions_",
    value: function processExtensions_(doc, features, actions) {
      // INFO
      // OpenLayers ne gère pas tous les tags du format GPX : ex. metadata
      // Liste des tags :
      // * wpt
      // * rte
      // * trk
      // On peut y placer nos balises extensions.

      var index = -1;
      var nodes = doc.childNodes;
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        switch (node.nodeName) {
          case "wpt":
          case "rte":
          case "trk":
            index++;
            var feature = features[index];
            var style = feature.getStyle();
            if (style) {
              var fct = actions.extensions;
              if (fct && typeof fct === "function") {
                fct(feature, node);
              }
            }
            break;
          case "metadata":
            break;
          default:
            // on ne devrait jamais passer à ce niveau !?
            // eslint-disable-next-line no-console
            console.warn("nodename unknown :", node.nodeName);
            break;
        }
      }
    }
  }]);
}((ol_format_GPX__WEBPACK_IMPORTED_MODULE_0___default()));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GPX);

// Expose GPX as ol.source.GPXExtended. (for a build bundle)
if (window.ol && window.ol.format) {
  window.ol.format.GPXExtended = GPX;
}
})();

Formats = __webpack_exports__["default"];
/******/ })()
;
//# sourceMappingURL=Formats.js.map