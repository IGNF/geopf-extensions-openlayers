/*!
 * @brief geoportal-extensions-openlayers
 *
 * This software is released under the licence CeCILL-B (Free BSD compatible)
 * @see http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.txt
 * @see http://www.cecill.info/licences/Licence_CeCILL-B_V1-fr.txt
 * @see http://www.cecill.info/
 *
 * @copyright copyright (c) IGN 
 * @license CeCILL-B
 * @author IGN
 * @version 3.0.0
 * @date 01/02/2024
 *
 */

/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@xmldom/xmldom/lib/conventions.js":
/*!********************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/conventions.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Ponyfill for `Array.prototype.find` which is only available in ES6 runtimes.
 *
 * Works with anything that has a `length` property and index access properties, including NodeList.
 *
 * @template {unknown} T
 * @param {Array<T> | ({length:number, [number]: T})} list
 * @param {function (item: T, index: number, list:Array<T> | ({length:number, [number]: T})):boolean} predicate
 * @param {Partial<Pick<ArrayConstructor['prototype'], 'find'>>?} ac `Array.prototype` by default,
 * 				allows injecting a custom implementation in tests
 * @returns {T | undefined}
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
 * @see https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.find
 */
function find(list, predicate, ac) {
	if (ac === undefined) {
		ac = Array.prototype;
	}
	if (list && typeof ac.find === 'function') {
		return ac.find.call(list, predicate);
	}
	for (var i = 0; i < list.length; i++) {
		if (Object.prototype.hasOwnProperty.call(list, i)) {
			var item = list[i];
			if (predicate.call(undefined, item, i, list)) {
				return item;
			}
		}
	}
}

/**
 * "Shallow freezes" an object to render it immutable.
 * Uses `Object.freeze` if available,
 * otherwise the immutability is only in the type.
 *
 * Is used to create "enum like" objects.
 *
 * @template T
 * @param {T} object the object to freeze
 * @param {Pick<ObjectConstructor, 'freeze'> = Object} oc `Object` by default,
 * 				allows to inject custom object constructor for tests
 * @returns {Readonly<T>}
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
 */
function freeze(object, oc) {
	if (oc === undefined) {
		oc = Object
	}
	return oc && typeof oc.freeze === 'function' ? oc.freeze(object) : object
}

/**
 * Since we can not rely on `Object.assign` we provide a simplified version
 * that is sufficient for our needs.
 *
 * @param {Object} target
 * @param {Object | null | undefined} source
 *
 * @returns {Object} target
 * @throws TypeError if target is not an object
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 * @see https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.assign
 */
function assign(target, source) {
	if (target === null || typeof target !== 'object') {
		throw new TypeError('target is not an object')
	}
	for (var key in source) {
		if (Object.prototype.hasOwnProperty.call(source, key)) {
			target[key] = source[key]
		}
	}
	return target
}

/**
 * All mime types that are allowed as input to `DOMParser.parseFromString`
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#Argument02 MDN
 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#domparsersupportedtype WHATWG HTML Spec
 * @see DOMParser.prototype.parseFromString
 */
var MIME_TYPE = freeze({
	/**
	 * `text/html`, the only mime type that triggers treating an XML document as HTML.
	 *
	 * @see DOMParser.SupportedType.isHTML
	 * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
	 * @see https://en.wikipedia.org/wiki/HTML Wikipedia
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
	 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
	 */
	HTML: 'text/html',

	/**
	 * Helper method to check a mime type if it indicates an HTML document
	 *
	 * @param {string} [value]
	 * @returns {boolean}
	 *
	 * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
	 * @see https://en.wikipedia.org/wiki/HTML Wikipedia
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
	 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
	isHTML: function (value) {
		return value === MIME_TYPE.HTML
	},

	/**
	 * `application/xml`, the standard mime type for XML documents.
	 *
	 * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
	 * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
	 * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
	 */
	XML_APPLICATION: 'application/xml',

	/**
	 * `text/html`, an alias for `application/xml`.
	 *
	 * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
	 * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
	 * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
	 */
	XML_TEXT: 'text/xml',

	/**
	 * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
	 * but is parsed as an XML document.
	 *
	 * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
	 * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
	 */
	XML_XHTML_APPLICATION: 'application/xhtml+xml',

	/**
	 * `image/svg+xml`,
	 *
	 * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
	 * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
	 * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
	 */
	XML_SVG_IMAGE: 'image/svg+xml',
})

/**
 * Namespaces that are used in this code base.
 *
 * @see http://www.w3.org/TR/REC-xml-names
 */
var NAMESPACE = freeze({
	/**
	 * The XHTML namespace.
	 *
	 * @see http://www.w3.org/1999/xhtml
	 */
	HTML: 'http://www.w3.org/1999/xhtml',

	/**
	 * Checks if `uri` equals `NAMESPACE.HTML`.
	 *
	 * @param {string} [uri]
	 *
	 * @see NAMESPACE.HTML
	 */
	isHTML: function (uri) {
		return uri === NAMESPACE.HTML
	},

	/**
	 * The SVG namespace.
	 *
	 * @see http://www.w3.org/2000/svg
	 */
	SVG: 'http://www.w3.org/2000/svg',

	/**
	 * The `xml:` namespace.
	 *
	 * @see http://www.w3.org/XML/1998/namespace
	 */
	XML: 'http://www.w3.org/XML/1998/namespace',

	/**
	 * The `xmlns:` namespace
	 *
	 * @see https://www.w3.org/2000/xmlns/
	 */
	XMLNS: 'http://www.w3.org/2000/xmlns/',
})

exports.assign = assign;
exports.find = find;
exports.freeze = freeze;
exports.MIME_TYPE = MIME_TYPE;
exports.NAMESPACE = NAMESPACE;


/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/dom-parser.js":
/*!*******************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/dom-parser.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var conventions = __webpack_require__(/*! ./conventions */ "./node_modules/@xmldom/xmldom/lib/conventions.js");
var dom = __webpack_require__(/*! ./dom */ "./node_modules/@xmldom/xmldom/lib/dom.js")
var entities = __webpack_require__(/*! ./entities */ "./node_modules/@xmldom/xmldom/lib/entities.js");
var sax = __webpack_require__(/*! ./sax */ "./node_modules/@xmldom/xmldom/lib/sax.js");

var DOMImplementation = dom.DOMImplementation;

var NAMESPACE = conventions.NAMESPACE;

var ParseError = sax.ParseError;
var XMLReader = sax.XMLReader;

/**
 * Normalizes line ending according to https://www.w3.org/TR/xml11/#sec-line-ends:
 *
 * > XML parsed entities are often stored in computer files which,
 * > for editing convenience, are organized into lines.
 * > These lines are typically separated by some combination
 * > of the characters CARRIAGE RETURN (#xD) and LINE FEED (#xA).
 * >
 * > To simplify the tasks of applications, the XML processor must behave
 * > as if it normalized all line breaks in external parsed entities (including the document entity)
 * > on input, before parsing, by translating all of the following to a single #xA character:
 * >
 * > 1. the two-character sequence #xD #xA
 * > 2. the two-character sequence #xD #x85
 * > 3. the single character #x85
 * > 4. the single character #x2028
 * > 5. any #xD character that is not immediately followed by #xA or #x85.
 *
 * @param {string} input
 * @returns {string}
 */
function normalizeLineEndings(input) {
	return input
		.replace(/\r[\n\u0085]/g, '\n')
		.replace(/[\r\u0085\u2028]/g, '\n')
}

/**
 * @typedef Locator
 * @property {number} [columnNumber]
 * @property {number} [lineNumber]
 */

/**
 * @typedef DOMParserOptions
 * @property {DOMHandler} [domBuilder]
 * @property {Function} [errorHandler]
 * @property {(string) => string} [normalizeLineEndings] used to replace line endings before parsing
 * 						defaults to `normalizeLineEndings`
 * @property {Locator} [locator]
 * @property {Record<string, string>} [xmlns]
 *
 * @see normalizeLineEndings
 */

/**
 * The DOMParser interface provides the ability to parse XML or HTML source code
 * from a string into a DOM `Document`.
 *
 * _xmldom is different from the spec in that it allows an `options` parameter,
 * to override the default behavior._
 *
 * @param {DOMParserOptions} [options]
 * @constructor
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser
 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-parsing-and-serialization
 */
function DOMParser(options){
	this.options = options ||{locator:{}};
}

DOMParser.prototype.parseFromString = function(source,mimeType){
	var options = this.options;
	var sax =  new XMLReader();
	var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
	var errorHandler = options.errorHandler;
	var locator = options.locator;
	var defaultNSMap = options.xmlns||{};
	var isHTML = /\/x?html?$/.test(mimeType);//mimeType.toLowerCase().indexOf('html') > -1;
  	var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
	if(locator){
		domBuilder.setDocumentLocator(locator)
	}

	sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
	sax.domBuilder = options.domBuilder || domBuilder;
	if(isHTML){
		defaultNSMap[''] = NAMESPACE.HTML;
	}
	defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
	var normalize = options.normalizeLineEndings || normalizeLineEndings;
	if (source && typeof source === 'string') {
		sax.parse(
			normalize(source),
			defaultNSMap,
			entityMap
		)
	} else {
		sax.errorHandler.error('invalid doc source')
	}
	return domBuilder.doc;
}
function buildErrorHandler(errorImpl,domBuilder,locator){
	if(!errorImpl){
		if(domBuilder instanceof DOMHandler){
			return domBuilder;
		}
		errorImpl = domBuilder ;
	}
	var errorHandler = {}
	var isCallback = errorImpl instanceof Function;
	locator = locator||{}
	function build(key){
		var fn = errorImpl[key];
		if(!fn && isCallback){
			fn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;
		}
		errorHandler[key] = fn && function(msg){
			fn('[xmldom '+key+']\t'+msg+_locator(locator));
		}||function(){};
	}
	build('warning');
	build('error');
	build('fatalError');
	return errorHandler;
}

//console.log('#\n\n\n\n\n\n\n####')
/**
 * +ContentHandler+ErrorHandler
 * +LexicalHandler+EntityResolver2
 * -DeclHandler-DTDHandler
 *
 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
 */
function DOMHandler() {
    this.cdata = false;
}
function position(locator,node){
	node.lineNumber = locator.lineNumber;
	node.columnNumber = locator.columnNumber;
}
/**
 * @see org.xml.sax.ContentHandler#startDocument
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
 */
DOMHandler.prototype = {
	startDocument : function() {
    	this.doc = new DOMImplementation().createDocument(null, null, null);
    	if (this.locator) {
        	this.doc.documentURI = this.locator.systemId;
    	}
	},
	startElement:function(namespaceURI, localName, qName, attrs) {
		var doc = this.doc;
	    var el = doc.createElementNS(namespaceURI, qName||localName);
	    var len = attrs.length;
	    appendElement(this, el);
	    this.currentElement = el;

		this.locator && position(this.locator,el)
	    for (var i = 0 ; i < len; i++) {
	        var namespaceURI = attrs.getURI(i);
	        var value = attrs.getValue(i);
	        var qName = attrs.getQName(i);
			var attr = doc.createAttributeNS(namespaceURI, qName);
			this.locator &&position(attrs.getLocator(i),attr);
			attr.value = attr.nodeValue = value;
			el.setAttributeNode(attr)
	    }
	},
	endElement:function(namespaceURI, localName, qName) {
		var current = this.currentElement
		var tagName = current.tagName;
		this.currentElement = current.parentNode;
	},
	startPrefixMapping:function(prefix, uri) {
	},
	endPrefixMapping:function(prefix) {
	},
	processingInstruction:function(target, data) {
	    var ins = this.doc.createProcessingInstruction(target, data);
	    this.locator && position(this.locator,ins)
	    appendElement(this, ins);
	},
	ignorableWhitespace:function(ch, start, length) {
	},
	characters:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
		//console.log(chars)
		if(chars){
			if (this.cdata) {
				var charNode = this.doc.createCDATASection(chars);
			} else {
				var charNode = this.doc.createTextNode(chars);
			}
			if(this.currentElement){
				this.currentElement.appendChild(charNode);
			}else if(/^\s*$/.test(chars)){
				this.doc.appendChild(charNode);
				//process xml
			}
			this.locator && position(this.locator,charNode)
		}
	},
	skippedEntity:function(name) {
	},
	endDocument:function() {
		this.doc.normalize();
	},
	setDocumentLocator:function (locator) {
	    if(this.locator = locator){// && !('lineNumber' in locator)){
	    	locator.lineNumber = 0;
	    }
	},
	//LexicalHandler
	comment:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
	    var comm = this.doc.createComment(chars);
	    this.locator && position(this.locator,comm)
	    appendElement(this, comm);
	},

	startCDATA:function() {
	    //used in characters() methods
	    this.cdata = true;
	},
	endCDATA:function() {
	    this.cdata = false;
	},

	startDTD:function(name, publicId, systemId) {
		var impl = this.doc.implementation;
	    if (impl && impl.createDocumentType) {
	        var dt = impl.createDocumentType(name, publicId, systemId);
	        this.locator && position(this.locator,dt)
	        appendElement(this, dt);
					this.doc.doctype = dt;
	    }
	},
	/**
	 * @see org.xml.sax.ErrorHandler
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
	 */
	warning:function(error) {
		console.warn('[xmldom warning]\t'+error,_locator(this.locator));
	},
	error:function(error) {
		console.error('[xmldom error]\t'+error,_locator(this.locator));
	},
	fatalError:function(error) {
		throw new ParseError(error, this.locator);
	}
}
function _locator(l){
	if(l){
		return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
	}
}
function _toString(chars,start,length){
	if(typeof chars == 'string'){
		return chars.substr(start,length)
	}else{//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
		if(chars.length >= start+length || start){
			return new java.lang.String(chars,start,length)+'';
		}
		return chars;
	}
}

/*
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
 * used method of org.xml.sax.ext.LexicalHandler:
 *  #comment(chars, start, length)
 *  #startCDATA()
 *  #endCDATA()
 *  #startDTD(name, publicId, systemId)
 *
 *
 * IGNORED method of org.xml.sax.ext.LexicalHandler:
 *  #endDTD()
 *  #startEntity(name)
 *  #endEntity(name)
 *
 *
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
 * IGNORED method of org.xml.sax.ext.DeclHandler
 * 	#attributeDecl(eName, aName, type, mode, value)
 *  #elementDecl(name, model)
 *  #externalEntityDecl(name, publicId, systemId)
 *  #internalEntityDecl(name, value)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
 * IGNORED method of org.xml.sax.EntityResolver2
 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
 *  #resolveEntity(publicId, systemId)
 *  #getExternalSubset(name, baseURI)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
 * IGNORED method of org.xml.sax.DTDHandler
 *  #notationDecl(name, publicId, systemId) {};
 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
 */
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
	DOMHandler.prototype[key] = function(){return null}
})

/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
function appendElement (hander,node) {
    if (!hander.currentElement) {
        hander.doc.appendChild(node);
    } else {
        hander.currentElement.appendChild(node);
    }
}//appendChild and setAttributeNS are preformance key

exports.__DOMHandler = DOMHandler;
exports.normalizeLineEndings = normalizeLineEndings;
exports.DOMParser = DOMParser;


/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/dom.js":
/*!************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/dom.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var conventions = __webpack_require__(/*! ./conventions */ "./node_modules/@xmldom/xmldom/lib/conventions.js");

var find = conventions.find;
var NAMESPACE = conventions.NAMESPACE;

/**
 * A prerequisite for `[].filter`, to drop elements that are empty
 * @param {string} input
 * @returns {boolean}
 */
function notEmptyString (input) {
	return input !== ''
}
/**
 * @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace
 * @see https://infra.spec.whatwg.org/#ascii-whitespace
 *
 * @param {string} input
 * @returns {string[]} (can be empty)
 */
function splitOnASCIIWhitespace(input) {
	// U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, U+0020 SPACE
	return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : []
}

/**
 * Adds element as a key to current if it is not already present.
 *
 * @param {Record<string, boolean | undefined>} current
 * @param {string} element
 * @returns {Record<string, boolean | undefined>}
 */
function orderedSetReducer (current, element) {
	if (!current.hasOwnProperty(element)) {
		current[element] = true;
	}
	return current;
}

/**
 * @see https://infra.spec.whatwg.org/#ordered-set
 * @param {string} input
 * @returns {string[]}
 */
function toOrderedSet(input) {
	if (!input) return [];
	var list = splitOnASCIIWhitespace(input);
	return Object.keys(list.reduce(orderedSetReducer, {}))
}

/**
 * Uses `list.indexOf` to implement something like `Array.prototype.includes`,
 * which we can not rely on being available.
 *
 * @param {any[]} list
 * @returns {function(any): boolean}
 */
function arrayIncludes (list) {
	return function(element) {
		return list && list.indexOf(element) !== -1;
	}
}

function copy(src,dest){
	for(var p in src){
		if (Object.prototype.hasOwnProperty.call(src, p)) {
			dest[p] = src[p];
		}
	}
}

/**
^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
 */
function _extends(Class,Super){
	var pt = Class.prototype;
	if(!(pt instanceof Super)){
		function t(){};
		t.prototype = Super.prototype;
		t = new t();
		copy(pt,t);
		Class.prototype = pt = t;
	}
	if(pt.constructor != Class){
		if(typeof Class != 'function'){
			console.error("unknown Class:"+Class)
		}
		pt.constructor = Class
	}
}

// Node Types
var NodeType = {}
var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

// ExceptionCode
var ExceptionCode = {}
var ExceptionMessage = {};
var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
//level2
var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);

/**
 * DOM Level 2
 * Object DOMException
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
 */
function DOMException(code, message) {
	if(message instanceof Error){
		var error = message;
	}else{
		error = this;
		Error.call(this, ExceptionMessage[code]);
		this.message = ExceptionMessage[code];
		if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
	}
	error.code = code;
	if(message) this.message = this.message + ": " + message;
	return error;
};
DOMException.prototype = Error.prototype;
copy(ExceptionCode,DOMException)

/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
 * The items in the NodeList are accessible via an integral index, starting from 0.
 */
function NodeList() {
};
NodeList.prototype = {
	/**
	 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
	 * @standard level1
	 */
	length:0,
	/**
	 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
	 * @standard level1
	 * @param index  unsigned long
	 *   Index into the collection.
	 * @return Node
	 * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
	 */
	item: function(index) {
		return index >= 0 && index < this.length ? this[index] : null;
	},
	toString:function(isHTML,nodeFilter){
		for(var buf = [], i = 0;i<this.length;i++){
			serializeToString(this[i],buf,isHTML,nodeFilter);
		}
		return buf.join('');
	},
	/**
	 * @private
	 * @param {function (Node):boolean} predicate
	 * @returns {Node[]}
	 */
	filter: function (predicate) {
		return Array.prototype.filter.call(this, predicate);
	},
	/**
	 * @private
	 * @param {Node} item
	 * @returns {number}
	 */
	indexOf: function (item) {
		return Array.prototype.indexOf.call(this, item);
	},
};

function LiveNodeList(node,refresh){
	this._node = node;
	this._refresh = refresh
	_updateLiveList(this);
}
function _updateLiveList(list){
	var inc = list._node._inc || list._node.ownerDocument._inc;
	if (list._inc !== inc) {
		var ls = list._refresh(list._node);
		__set__(list,'length',ls.length);
		if (!list.$$length || ls.length < list.$$length) {
			for (var i = ls.length; i in list; i++) {
				if (Object.prototype.hasOwnProperty.call(list, i)) {
					delete list[i];
				}
			}
		}
		copy(ls,list);
		list._inc = inc;
	}
}
LiveNodeList.prototype.item = function(i){
	_updateLiveList(this);
	return this[i] || null;
}

_extends(LiveNodeList,NodeList);

/**
 * Objects implementing the NamedNodeMap interface are used
 * to represent collections of nodes that can be accessed by name.
 * Note that NamedNodeMap does not inherit from NodeList;
 * NamedNodeMaps are not maintained in any particular order.
 * Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index,
 * but this is simply to allow convenient enumeration of the contents of a NamedNodeMap,
 * and does not imply that the DOM specifies an order to these Nodes.
 * NamedNodeMap objects in the DOM are live.
 * used for attributes or DocumentType entities
 */
function NamedNodeMap() {
};

function _findNodeIndex(list,node){
	var i = list.length;
	while(i--){
		if(list[i] === node){return i}
	}
}

function _addNamedNode(el,list,newAttr,oldAttr){
	if(oldAttr){
		list[_findNodeIndex(list,oldAttr)] = newAttr;
	}else{
		list[list.length++] = newAttr;
	}
	if(el){
		newAttr.ownerElement = el;
		var doc = el.ownerDocument;
		if(doc){
			oldAttr && _onRemoveAttribute(doc,el,oldAttr);
			_onAddAttribute(doc,el,newAttr);
		}
	}
}
function _removeNamedNode(el,list,attr){
	//console.log('remove attr:'+attr)
	var i = _findNodeIndex(list,attr);
	if(i>=0){
		var lastIndex = list.length-1
		while(i<lastIndex){
			list[i] = list[++i]
		}
		list.length = lastIndex;
		if(el){
			var doc = el.ownerDocument;
			if(doc){
				_onRemoveAttribute(doc,el,attr);
				attr.ownerElement = null;
			}
		}
	}else{
		throw new DOMException(NOT_FOUND_ERR,new Error(el.tagName+'@'+attr))
	}
}
NamedNodeMap.prototype = {
	length:0,
	item:NodeList.prototype.item,
	getNamedItem: function(key) {
//		if(key.indexOf(':')>0 || key == 'xmlns'){
//			return null;
//		}
		//console.log()
		var i = this.length;
		while(i--){
			var attr = this[i];
			//console.log(attr.nodeName,key)
			if(attr.nodeName == key){
				return attr;
			}
		}
	},
	setNamedItem: function(attr) {
		var el = attr.ownerElement;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		var oldAttr = this.getNamedItem(attr.nodeName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},
	/* returns Node */
	setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
		var el = attr.ownerElement, oldAttr;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},

	/* returns Node */
	removeNamedItem: function(key) {
		var attr = this.getNamedItem(key);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;


	},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR

	//for level2
	removeNamedItemNS:function(namespaceURI,localName){
		var attr = this.getNamedItemNS(namespaceURI,localName);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
	},
	getNamedItemNS: function(namespaceURI, localName) {
		var i = this.length;
		while(i--){
			var node = this[i];
			if(node.localName == localName && node.namespaceURI == namespaceURI){
				return node;
			}
		}
		return null;
	}
};

/**
 * The DOMImplementation interface represents an object providing methods
 * which are not dependent on any particular document.
 * Such an object is returned by the `Document.implementation` property.
 *
 * __The individual methods describe the differences compared to the specs.__
 *
 * @constructor
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation MDN
 * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490 DOM Level 1 Core (Initial)
 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-102161490 DOM Level 2 Core
 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-102161490 DOM Level 3 Core
 * @see https://dom.spec.whatwg.org/#domimplementation DOM Living Standard
 */
function DOMImplementation() {
}

DOMImplementation.prototype = {
	/**
	 * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
	 * The different implementations fairly diverged in what kind of features were reported.
	 * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
	 *
	 * @deprecated It is deprecated and modern browsers return true in all cases.
	 *
	 * @param {string} feature
	 * @param {string} [version]
	 * @returns {boolean} always true
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
	 * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
	 */
	hasFeature: function(feature, version) {
			return true;
	},
	/**
	 * Creates an XML Document object of the specified type with its document element.
	 *
	 * __It behaves slightly different from the description in the living standard__:
	 * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
	 * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
	 * - this implementation is not validating names or qualified names
	 *   (when parsing XML strings, the SAX parser takes care of that)
	 *
	 * @param {string|null} namespaceURI
	 * @param {string} qualifiedName
	 * @param {DocumentType=null} doctype
	 * @returns {Document}
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
	 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
	 *
	 * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
	 * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
	 * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
	 */
	createDocument: function(namespaceURI,  qualifiedName, doctype){
		var doc = new Document();
		doc.implementation = this;
		doc.childNodes = new NodeList();
		doc.doctype = doctype || null;
		if (doctype){
			doc.appendChild(doctype);
		}
		if (qualifiedName){
			var root = doc.createElementNS(namespaceURI, qualifiedName);
			doc.appendChild(root);
		}
		return doc;
	},
	/**
	 * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
	 *
	 * __This behavior is slightly different from the in the specs__:
	 * - this implementation is not validating names or qualified names
	 *   (when parsing XML strings, the SAX parser takes care of that)
	 *
	 * @param {string} qualifiedName
	 * @param {string} [publicId]
	 * @param {string} [systemId]
	 * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
	 * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
	 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
	 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
	 *
	 * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
	 * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
	 * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
	 */
	createDocumentType: function(qualifiedName, publicId, systemId){
		var node = new DocumentType();
		node.name = qualifiedName;
		node.nodeName = qualifiedName;
		node.publicId = publicId || '';
		node.systemId = systemId || '';

		return node;
	}
};


/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
 */

function Node() {
};

Node.prototype = {
	firstChild : null,
	lastChild : null,
	previousSibling : null,
	nextSibling : null,
	attributes : null,
	parentNode : null,
	childNodes : null,
	ownerDocument : null,
	nodeValue : null,
	namespaceURI : null,
	prefix : null,
	localName : null,
	// Modified in DOM Level 2:
	insertBefore:function(newChild, refChild){//raises
		return _insertBefore(this,newChild,refChild);
	},
	replaceChild:function(newChild, oldChild){//raises
		_insertBefore(this, newChild,oldChild, assertPreReplacementValidityInDocument);
		if(oldChild){
			this.removeChild(oldChild);
		}
	},
	removeChild:function(oldChild){
		return _removeChild(this,oldChild);
	},
	appendChild:function(newChild){
		return this.insertBefore(newChild,null);
	},
	hasChildNodes:function(){
		return this.firstChild != null;
	},
	cloneNode:function(deep){
		return cloneNode(this.ownerDocument||this,this,deep);
	},
	// Modified in DOM Level 2:
	normalize:function(){
		var child = this.firstChild;
		while(child){
			var next = child.nextSibling;
			if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
				this.removeChild(next);
				child.appendData(next.data);
			}else{
				child.normalize();
				child = next;
			}
		}
	},
  	// Introduced in DOM Level 2:
	isSupported:function(feature, version){
		return this.ownerDocument.implementation.hasFeature(feature,version);
	},
    // Introduced in DOM Level 2:
    hasAttributes:function(){
    	return this.attributes.length>0;
    },
	/**
	 * Look up the prefix associated to the given namespace URI, starting from this node.
	 * **The default namespace declarations are ignored by this method.**
	 * See Namespace Prefix Lookup for details on the algorithm used by this method.
	 *
	 * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
	 *
	 * @param {string | null} namespaceURI
	 * @returns {string | null}
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
	 * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
	 * @see https://github.com/xmldom/xmldom/issues/322
	 */
    lookupPrefix:function(namespaceURI){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			for(var n in map){
						if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
							return n;
						}
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI:function(prefix){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			if(Object.prototype.hasOwnProperty.call(map, prefix)){
    				return map[prefix] ;
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace:function(namespaceURI){
    	var prefix = this.lookupPrefix(namespaceURI);
    	return prefix == null;
    }
};


function _xmlEncoder(c){
	return c == '<' && '&lt;' ||
         c == '>' && '&gt;' ||
         c == '&' && '&amp;' ||
         c == '"' && '&quot;' ||
         '&#'+c.charCodeAt()+';'
}


copy(NodeType,Node);
copy(NodeType,Node.prototype);

/**
 * @param callback return true for continue,false for break
 * @return boolean true: break visit;
 */
function _visitNode(node,callback){
	if(callback(node)){
		return true;
	}
	if(node = node.firstChild){
		do{
			if(_visitNode(node,callback)){return true}
        }while(node=node.nextSibling)
    }
}



function Document(){
	this.ownerDocument = this;
}

function _onAddAttribute(doc,el,newAttr){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns === NAMESPACE.XMLNS){
		//update namespace
		el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value
	}
}

function _onRemoveAttribute(doc,el,newAttr,remove){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns === NAMESPACE.XMLNS){
		//update namespace
		delete el._nsMap[newAttr.prefix?newAttr.localName:'']
	}
}

/**
 * Updates `el.childNodes`, updating the indexed items and it's `length`.
 * Passing `newChild` means it will be appended.
 * Otherwise it's assumed that an item has been removed,
 * and `el.firstNode` and it's `.nextSibling` are used
 * to walk the current list of child nodes.
 *
 * @param {Document} doc
 * @param {Node} el
 * @param {Node} [newChild]
 * @private
 */
function _onUpdateChild (doc, el, newChild) {
	if(doc && doc._inc){
		doc._inc++;
		//update childNodes
		var cs = el.childNodes;
		if (newChild) {
			cs[cs.length++] = newChild;
		} else {
			var child = el.firstChild;
			var i = 0;
			while (child) {
				cs[i++] = child;
				child = child.nextSibling;
			}
			cs.length = i;
			delete cs[cs.length];
		}
	}
}

/**
 * Removes the connections between `parentNode` and `child`
 * and any existing `child.previousSibling` or `child.nextSibling`.
 *
 * @see https://github.com/xmldom/xmldom/issues/135
 * @see https://github.com/xmldom/xmldom/issues/145
 *
 * @param {Node} parentNode
 * @param {Node} child
 * @returns {Node} the child that was removed.
 * @private
 */
function _removeChild (parentNode, child) {
	var previous = child.previousSibling;
	var next = child.nextSibling;
	if (previous) {
		previous.nextSibling = next;
	} else {
		parentNode.firstChild = next;
	}
	if (next) {
		next.previousSibling = previous;
	} else {
		parentNode.lastChild = previous;
	}
	child.parentNode = null;
	child.previousSibling = null;
	child.nextSibling = null;
	_onUpdateChild(parentNode.ownerDocument, parentNode);
	return child;
}

/**
 * Returns `true` if `node` can be a parent for insertion.
 * @param {Node} node
 * @returns {boolean}
 */
function hasValidParentNodeType(node) {
	return (
		node &&
		(node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE)
	);
}

/**
 * Returns `true` if `node` can be inserted according to it's `nodeType`.
 * @param {Node} node
 * @returns {boolean}
 */
function hasInsertableNodeType(node) {
	return (
		node &&
		(isElementNode(node) ||
			isTextNode(node) ||
			isDocTypeNode(node) ||
			node.nodeType === Node.DOCUMENT_FRAGMENT_NODE ||
			node.nodeType === Node.COMMENT_NODE ||
			node.nodeType === Node.PROCESSING_INSTRUCTION_NODE)
	);
}

/**
 * Returns true if `node` is a DOCTYPE node
 * @param {Node} node
 * @returns {boolean}
 */
function isDocTypeNode(node) {
	return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
}

/**
 * Returns true if the node is an element
 * @param {Node} node
 * @returns {boolean}
 */
function isElementNode(node) {
	return node && node.nodeType === Node.ELEMENT_NODE;
}
/**
 * Returns true if `node` is a text node
 * @param {Node} node
 * @returns {boolean}
 */
function isTextNode(node) {
	return node && node.nodeType === Node.TEXT_NODE;
}

/**
 * Check if en element node can be inserted before `child`, or at the end if child is falsy,
 * according to the presence and position of a doctype node on the same level.
 *
 * @param {Document} doc The document node
 * @param {Node} child the node that would become the nextSibling if the element would be inserted
 * @returns {boolean} `true` if an element can be inserted before child
 * @private
 * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 */
function isElementInsertionPossible(doc, child) {
	var parentChildNodes = doc.childNodes || [];
	if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
		return false;
	}
	var docTypeNode = find(parentChildNodes, isDocTypeNode);
	return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
}

/**
 * Check if en element node can be inserted before `child`, or at the end if child is falsy,
 * according to the presence and position of a doctype node on the same level.
 *
 * @param {Node} doc The document node
 * @param {Node} child the node that would become the nextSibling if the element would be inserted
 * @returns {boolean} `true` if an element can be inserted before child
 * @private
 * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 */
function isElementReplacementPossible(doc, child) {
	var parentChildNodes = doc.childNodes || [];

	function hasElementChildThatIsNotChild(node) {
		return isElementNode(node) && node !== child;
	}

	if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
		return false;
	}
	var docTypeNode = find(parentChildNodes, isDocTypeNode);
	return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
}

/**
 * @private
 * Steps 1-5 of the checks before inserting and before replacing a child are the same.
 *
 * @param {Node} parent the parent node to insert `node` into
 * @param {Node} node the node to insert
 * @param {Node=} child the node that should become the `nextSibling` of `node`
 * @returns {Node}
 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
 * @throws DOMException if `child` is provided but is not a child of `parent`.
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 * @see https://dom.spec.whatwg.org/#concept-node-replace
 */
function assertPreInsertionValidity1to5(parent, node, child) {
	// 1. If `parent` is not a Document, DocumentFragment, or Element node, then throw a "HierarchyRequestError" DOMException.
	if (!hasValidParentNodeType(parent)) {
		throw new DOMException(HIERARCHY_REQUEST_ERR, 'Unexpected parent node type ' + parent.nodeType);
	}
	// 2. If `node` is a host-including inclusive ancestor of `parent`, then throw a "HierarchyRequestError" DOMException.
	// not implemented!
	// 3. If `child` is non-null and its parent is not `parent`, then throw a "NotFoundError" DOMException.
	if (child && child.parentNode !== parent) {
		throw new DOMException(NOT_FOUND_ERR, 'child not in parent');
	}
	if (
		// 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
		!hasInsertableNodeType(node) ||
		// 5. If either `node` is a Text node and `parent` is a document,
		// the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
		// || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
		// or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
		(isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE)
	) {
		throw new DOMException(
			HIERARCHY_REQUEST_ERR,
			'Unexpected node type ' + node.nodeType + ' for parent node type ' + parent.nodeType
		);
	}
}

/**
 * @private
 * Step 6 of the checks before inserting and before replacing a child are different.
 *
 * @param {Document} parent the parent node to insert `node` into
 * @param {Node} node the node to insert
 * @param {Node | undefined} child the node that should become the `nextSibling` of `node`
 * @returns {Node}
 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
 * @throws DOMException if `child` is provided but is not a child of `parent`.
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 * @see https://dom.spec.whatwg.org/#concept-node-replace
 */
function assertPreInsertionValidityInDocument(parent, node, child) {
	var parentChildNodes = parent.childNodes || [];
	var nodeChildNodes = node.childNodes || [];

	// DocumentFragment
	if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
		var nodeChildElements = nodeChildNodes.filter(isElementNode);
		// If node has more than one element child or has a Text node child.
		if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');
		}
		// Otherwise, if `node` has one element child and either `parent` has an element child,
		// `child` is a doctype, or `child` is non-null and a doctype is following `child`.
		if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');
		}
	}
	// Element
	if (isElementNode(node)) {
		// `parent` has an element child, `child` is a doctype,
		// or `child` is non-null and a doctype is following `child`.
		if (!isElementInsertionPossible(parent, child)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');
		}
	}
	// DocumentType
	if (isDocTypeNode(node)) {
		// `parent` has a doctype child,
		if (find(parentChildNodes, isDocTypeNode)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');
		}
		var parentElementChild = find(parentChildNodes, isElementNode);
		// `child` is non-null and an element is preceding `child`,
		if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');
		}
		// or `child` is null and `parent` has an element child.
		if (!child && parentElementChild) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can not be appended since element is present');
		}
	}
}

/**
 * @private
 * Step 6 of the checks before inserting and before replacing a child are different.
 *
 * @param {Document} parent the parent node to insert `node` into
 * @param {Node} node the node to insert
 * @param {Node | undefined} child the node that should become the `nextSibling` of `node`
 * @returns {Node}
 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
 * @throws DOMException if `child` is provided but is not a child of `parent`.
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 * @see https://dom.spec.whatwg.org/#concept-node-replace
 */
function assertPreReplacementValidityInDocument(parent, node, child) {
	var parentChildNodes = parent.childNodes || [];
	var nodeChildNodes = node.childNodes || [];

	// DocumentFragment
	if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
		var nodeChildElements = nodeChildNodes.filter(isElementNode);
		// If `node` has more than one element child or has a Text node child.
		if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');
		}
		// Otherwise, if `node` has one element child and either `parent` has an element child that is not `child` or a doctype is following `child`.
		if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');
		}
	}
	// Element
	if (isElementNode(node)) {
		// `parent` has an element child that is not `child` or a doctype is following `child`.
		if (!isElementReplacementPossible(parent, child)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');
		}
	}
	// DocumentType
	if (isDocTypeNode(node)) {
		function hasDoctypeChildThatIsNotChild(node) {
			return isDocTypeNode(node) && node !== child;
		}

		// `parent` has a doctype child that is not `child`,
		if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');
		}
		var parentElementChild = find(parentChildNodes, isElementNode);
		// or an element is preceding `child`.
		if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');
		}
	}
}

/**
 * @private
 * @param {Node} parent the parent node to insert `node` into
 * @param {Node} node the node to insert
 * @param {Node=} child the node that should become the `nextSibling` of `node`
 * @returns {Node}
 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
 * @throws DOMException if `child` is provided but is not a child of `parent`.
 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
 */
function _insertBefore(parent, node, child, _inDocumentAssertion) {
	// To ensure pre-insertion validity of a node into a parent before a child, run these steps:
	assertPreInsertionValidity1to5(parent, node, child);

	// If parent is a document, and any of the statements below, switched on the interface node implements,
	// are true, then throw a "HierarchyRequestError" DOMException.
	if (parent.nodeType === Node.DOCUMENT_NODE) {
		(_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
	}

	var cp = node.parentNode;
	if(cp){
		cp.removeChild(node);//remove and update
	}
	if(node.nodeType === DOCUMENT_FRAGMENT_NODE){
		var newFirst = node.firstChild;
		if (newFirst == null) {
			return node;
		}
		var newLast = node.lastChild;
	}else{
		newFirst = newLast = node;
	}
	var pre = child ? child.previousSibling : parent.lastChild;

	newFirst.previousSibling = pre;
	newLast.nextSibling = child;


	if(pre){
		pre.nextSibling = newFirst;
	}else{
		parent.firstChild = newFirst;
	}
	if(child == null){
		parent.lastChild = newLast;
	}else{
		child.previousSibling = newLast;
	}
	do{
		newFirst.parentNode = parent;
	}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
	_onUpdateChild(parent.ownerDocument||parent, parent);
	//console.log(parent.lastChild.nextSibling == null)
	if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
		node.firstChild = node.lastChild = null;
	}
	return node;
}

/**
 * Appends `newChild` to `parentNode`.
 * If `newChild` is already connected to a `parentNode` it is first removed from it.
 *
 * @see https://github.com/xmldom/xmldom/issues/135
 * @see https://github.com/xmldom/xmldom/issues/145
 * @param {Node} parentNode
 * @param {Node} newChild
 * @returns {Node}
 * @private
 */
function _appendSingleChild (parentNode, newChild) {
	if (newChild.parentNode) {
		newChild.parentNode.removeChild(newChild);
	}
	newChild.parentNode = parentNode;
	newChild.previousSibling = parentNode.lastChild;
	newChild.nextSibling = null;
	if (newChild.previousSibling) {
		newChild.previousSibling.nextSibling = newChild;
	} else {
		parentNode.firstChild = newChild;
	}
	parentNode.lastChild = newChild;
	_onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
	return newChild;
}

Document.prototype = {
	//implementation : null,
	nodeName :  '#document',
	nodeType :  DOCUMENT_NODE,
	/**
	 * The DocumentType node of the document.
	 *
	 * @readonly
	 * @type DocumentType
	 */
	doctype :  null,
	documentElement :  null,
	_inc : 1,

	insertBefore :  function(newChild, refChild){//raises
		if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
			var child = newChild.firstChild;
			while(child){
				var next = child.nextSibling;
				this.insertBefore(child,refChild);
				child = next;
			}
			return newChild;
		}
		_insertBefore(this, newChild, refChild);
		newChild.ownerDocument = this;
		if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
			this.documentElement = newChild;
		}

		return newChild;
	},
	removeChild :  function(oldChild){
		if(this.documentElement == oldChild){
			this.documentElement = null;
		}
		return _removeChild(this,oldChild);
	},
	replaceChild: function (newChild, oldChild) {
		//raises
		_insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
		newChild.ownerDocument = this;
		if (oldChild) {
			this.removeChild(oldChild);
		}
		if (isElementNode(newChild)) {
			this.documentElement = newChild;
		}
	},
	// Introduced in DOM Level 2:
	importNode : function(importedNode,deep){
		return importNode(this,importedNode,deep);
	},
	// Introduced in DOM Level 2:
	getElementById :	function(id){
		var rtv = null;
		_visitNode(this.documentElement,function(node){
			if(node.nodeType == ELEMENT_NODE){
				if(node.getAttribute('id') == id){
					rtv = node;
					return true;
				}
			}
		})
		return rtv;
	},

	/**
	 * The `getElementsByClassName` method of `Document` interface returns an array-like object
	 * of all child elements which have **all** of the given class name(s).
	 *
	 * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
	 *
	 *
	 * Warning: This is a live LiveNodeList.
	 * Changes in the DOM will reflect in the array as the changes occur.
	 * If an element selected by this array no longer qualifies for the selector,
	 * it will automatically be removed. Be aware of this for iteration purposes.
	 *
	 * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
	 * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
	 */
	getElementsByClassName: function(classNames) {
		var classNamesSet = toOrderedSet(classNames)
		return new LiveNodeList(this, function(base) {
			var ls = [];
			if (classNamesSet.length > 0) {
				_visitNode(base.documentElement, function(node) {
					if(node !== base && node.nodeType === ELEMENT_NODE) {
						var nodeClassNames = node.getAttribute('class')
						// can be null if the attribute does not exist
						if (nodeClassNames) {
							// before splitting and iterating just compare them for the most common case
							var matches = classNames === nodeClassNames;
							if (!matches) {
								var nodeClassNamesSet = toOrderedSet(nodeClassNames)
								matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet))
							}
							if(matches) {
								ls.push(node);
							}
						}
					}
				});
			}
			return ls;
		});
	},

	//document factory method:
	createElement :	function(tagName){
		var node = new Element();
		node.ownerDocument = this;
		node.nodeName = tagName;
		node.tagName = tagName;
		node.localName = tagName;
		node.childNodes = new NodeList();
		var attrs	= node.attributes = new NamedNodeMap();
		attrs._ownerElement = node;
		return node;
	},
	createDocumentFragment :	function(){
		var node = new DocumentFragment();
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		return node;
	},
	createTextNode :	function(data){
		var node = new Text();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createComment :	function(data){
		var node = new Comment();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createCDATASection :	function(data){
		var node = new CDATASection();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createProcessingInstruction :	function(target,data){
		var node = new ProcessingInstruction();
		node.ownerDocument = this;
		node.tagName = node.nodeName = node.target = target;
		node.nodeValue = node.data = data;
		return node;
	},
	createAttribute :	function(name){
		var node = new Attr();
		node.ownerDocument	= this;
		node.name = name;
		node.nodeName	= name;
		node.localName = name;
		node.specified = true;
		return node;
	},
	createEntityReference :	function(name){
		var node = new EntityReference();
		node.ownerDocument	= this;
		node.nodeName	= name;
		return node;
	},
	// Introduced in DOM Level 2:
	createElementNS :	function(namespaceURI,qualifiedName){
		var node = new Element();
		var pl = qualifiedName.split(':');
		var attrs	= node.attributes = new NamedNodeMap();
		node.childNodes = new NodeList();
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.tagName = qualifiedName;
		node.namespaceURI = namespaceURI;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		attrs._ownerElement = node;
		return node;
	},
	// Introduced in DOM Level 2:
	createAttributeNS :	function(namespaceURI,qualifiedName){
		var node = new Attr();
		var pl = qualifiedName.split(':');
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.name = qualifiedName;
		node.namespaceURI = namespaceURI;
		node.specified = true;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		return node;
	}
};
_extends(Document,Node);


function Element() {
	this._nsMap = {};
};
Element.prototype = {
	nodeType : ELEMENT_NODE,
	hasAttribute : function(name){
		return this.getAttributeNode(name)!=null;
	},
	getAttribute : function(name){
		var attr = this.getAttributeNode(name);
		return attr && attr.value || '';
	},
	getAttributeNode : function(name){
		return this.attributes.getNamedItem(name);
	},
	setAttribute : function(name, value){
		var attr = this.ownerDocument.createAttribute(name);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	removeAttribute : function(name){
		var attr = this.getAttributeNode(name)
		attr && this.removeAttributeNode(attr);
	},

	//four real opeartion method
	appendChild:function(newChild){
		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
			return this.insertBefore(newChild,null);
		}else{
			return _appendSingleChild(this,newChild);
		}
	},
	setAttributeNode : function(newAttr){
		return this.attributes.setNamedItem(newAttr);
	},
	setAttributeNodeNS : function(newAttr){
		return this.attributes.setNamedItemNS(newAttr);
	},
	removeAttributeNode : function(oldAttr){
		//console.log(this == oldAttr.ownerElement)
		return this.attributes.removeNamedItem(oldAttr.nodeName);
	},
	//get real attribute name,and remove it by removeAttributeNode
	removeAttributeNS : function(namespaceURI, localName){
		var old = this.getAttributeNodeNS(namespaceURI, localName);
		old && this.removeAttributeNode(old);
	},

	hasAttributeNS : function(namespaceURI, localName){
		return this.getAttributeNodeNS(namespaceURI, localName)!=null;
	},
	getAttributeNS : function(namespaceURI, localName){
		var attr = this.getAttributeNodeNS(namespaceURI, localName);
		return attr && attr.value || '';
	},
	setAttributeNS : function(namespaceURI, qualifiedName, value){
		var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	getAttributeNodeNS : function(namespaceURI, localName){
		return this.attributes.getNamedItemNS(namespaceURI, localName);
	},

	getElementsByTagName : function(tagName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
					ls.push(node);
				}
			});
			return ls;
		});
	},
	getElementsByTagNameNS : function(namespaceURI, localName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)){
					ls.push(node);
				}
			});
			return ls;

		});
	}
};
Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


_extends(Element,Node);
function Attr() {
};
Attr.prototype.nodeType = ATTRIBUTE_NODE;
_extends(Attr,Node);


function CharacterData() {
};
CharacterData.prototype = {
	data : '',
	substringData : function(offset, count) {
		return this.data.substring(offset, offset+count);
	},
	appendData: function(text) {
		text = this.data+text;
		this.nodeValue = this.data = text;
		this.length = text.length;
	},
	insertData: function(offset,text) {
		this.replaceData(offset,0,text);

	},
	appendChild:function(newChild){
		throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])
	},
	deleteData: function(offset, count) {
		this.replaceData(offset,count,"");
	},
	replaceData: function(offset, count, text) {
		var start = this.data.substring(0,offset);
		var end = this.data.substring(offset+count);
		text = start + text + end;
		this.nodeValue = this.data = text;
		this.length = text.length;
	}
}
_extends(CharacterData,Node);
function Text() {
};
Text.prototype = {
	nodeName : "#text",
	nodeType : TEXT_NODE,
	splitText : function(offset) {
		var text = this.data;
		var newText = text.substring(offset);
		text = text.substring(0, offset);
		this.data = this.nodeValue = text;
		this.length = text.length;
		var newNode = this.ownerDocument.createTextNode(newText);
		if(this.parentNode){
			this.parentNode.insertBefore(newNode, this.nextSibling);
		}
		return newNode;
	}
}
_extends(Text,CharacterData);
function Comment() {
};
Comment.prototype = {
	nodeName : "#comment",
	nodeType : COMMENT_NODE
}
_extends(Comment,CharacterData);

function CDATASection() {
};
CDATASection.prototype = {
	nodeName : "#cdata-section",
	nodeType : CDATA_SECTION_NODE
}
_extends(CDATASection,CharacterData);


function DocumentType() {
};
DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends(DocumentType,Node);

function Notation() {
};
Notation.prototype.nodeType = NOTATION_NODE;
_extends(Notation,Node);

function Entity() {
};
Entity.prototype.nodeType = ENTITY_NODE;
_extends(Entity,Node);

function EntityReference() {
};
EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends(EntityReference,Node);

function DocumentFragment() {
};
DocumentFragment.prototype.nodeName =	"#document-fragment";
DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
_extends(DocumentFragment,Node);


function ProcessingInstruction() {
}
ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends(ProcessingInstruction,Node);
function XMLSerializer(){}
XMLSerializer.prototype.serializeToString = function(node,isHtml,nodeFilter){
	return nodeSerializeToString.call(node,isHtml,nodeFilter);
}
Node.prototype.toString = nodeSerializeToString;
function nodeSerializeToString(isHtml,nodeFilter){
	var buf = [];
	var refNode = this.nodeType == 9 && this.documentElement || this;
	var prefix = refNode.prefix;
	var uri = refNode.namespaceURI;

	if(uri && prefix == null){
		//console.log(prefix)
		var prefix = refNode.lookupPrefix(uri);
		if(prefix == null){
			//isHTML = true;
			var visibleNamespaces=[
			{namespace:uri,prefix:null}
			//{namespace:uri,prefix:''}
			]
		}
	}
	serializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);
	//console.log('###',this.nodeType,uri,prefix,buf.join(''))
	return buf.join('');
}

function needNamespaceDefine(node, isHTML, visibleNamespaces) {
	var prefix = node.prefix || '';
	var uri = node.namespaceURI;
	// According to [Namespaces in XML 1.0](https://www.w3.org/TR/REC-xml-names/#ns-using) ,
	// and more specifically https://www.w3.org/TR/REC-xml-names/#nsc-NoPrefixUndecl :
	// > In a namespace declaration for a prefix [...], the attribute value MUST NOT be empty.
	// in a similar manner [Namespaces in XML 1.1](https://www.w3.org/TR/xml-names11/#ns-using)
	// and more specifically https://www.w3.org/TR/xml-names11/#nsc-NSDeclared :
	// > [...] Furthermore, the attribute value [...] must not be an empty string.
	// so serializing empty namespace value like xmlns:ds="" would produce an invalid XML document.
	if (!uri) {
		return false;
	}
	if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
		return false;
	}

	var i = visibleNamespaces.length
	while (i--) {
		var ns = visibleNamespaces[i];
		// get namespace prefix
		if (ns.prefix === prefix) {
			return ns.namespace !== uri;
		}
	}
	return true;
}
/**
 * Well-formed constraint: No < in Attribute Values
 * > The replacement text of any entity referred to directly or indirectly
 * > in an attribute value must not contain a <.
 * @see https://www.w3.org/TR/xml11/#CleanAttrVals
 * @see https://www.w3.org/TR/xml11/#NT-AttValue
 *
 * Literal whitespace other than space that appear in attribute values
 * are serialized as their entity references, so they will be preserved.
 * (In contrast to whitespace literals in the input which are normalized to spaces)
 * @see https://www.w3.org/TR/xml11/#AVNormalize
 * @see https://w3c.github.io/DOM-Parsing/#serializing-an-element-s-attributes
 */
function addSerializedAttribute(buf, qualifiedName, value) {
	buf.push(' ', qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"')
}

function serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){
	if (!visibleNamespaces) {
		visibleNamespaces = [];
	}

	if(nodeFilter){
		node = nodeFilter(node);
		if(node){
			if(typeof node == 'string'){
				buf.push(node);
				return;
			}
		}else{
			return;
		}
		//buf.sort.apply(attrs, attributeSorter);
	}

	switch(node.nodeType){
	case ELEMENT_NODE:
		var attrs = node.attributes;
		var len = attrs.length;
		var child = node.firstChild;
		var nodeName = node.tagName;

		isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML

		var prefixedNodeName = nodeName
		if (!isHTML && !node.prefix && node.namespaceURI) {
			var defaultNS
			// lookup current default ns from `xmlns` attribute
			for (var ai = 0; ai < attrs.length; ai++) {
				if (attrs.item(ai).name === 'xmlns') {
					defaultNS = attrs.item(ai).value
					break
				}
			}
			if (!defaultNS) {
				// lookup current default ns in visibleNamespaces
				for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
					var namespace = visibleNamespaces[nsi]
					if (namespace.prefix === '' && namespace.namespace === node.namespaceURI) {
						defaultNS = namespace.namespace
						break
					}
				}
			}
			if (defaultNS !== node.namespaceURI) {
				for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
					var namespace = visibleNamespaces[nsi]
					if (namespace.namespace === node.namespaceURI) {
						if (namespace.prefix) {
							prefixedNodeName = namespace.prefix + ':' + nodeName
						}
						break
					}
				}
			}
		}

		buf.push('<', prefixedNodeName);

		for(var i=0;i<len;i++){
			// add namespaces for attributes
			var attr = attrs.item(i);
			if (attr.prefix == 'xmlns') {
				visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
			}else if(attr.nodeName == 'xmlns'){
				visibleNamespaces.push({ prefix: '', namespace: attr.value });
			}
		}

		for(var i=0;i<len;i++){
			var attr = attrs.item(i);
			if (needNamespaceDefine(attr,isHTML, visibleNamespaces)) {
				var prefix = attr.prefix||'';
				var uri = attr.namespaceURI;
				addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : "xmlns", uri);
				visibleNamespaces.push({ prefix: prefix, namespace:uri });
			}
			serializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces);
		}

		// add namespace for current node
		if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
			var prefix = node.prefix||'';
			var uri = node.namespaceURI;
			addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : "xmlns", uri);
			visibleNamespaces.push({ prefix: prefix, namespace:uri });
		}

		if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
			buf.push('>');
			//if is cdata child node
			if(isHTML && /^script$/i.test(nodeName)){
				while(child){
					if(child.data){
						buf.push(child.data);
					}else{
						serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
					}
					child = child.nextSibling;
				}
			}else
			{
				while(child){
					serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
					child = child.nextSibling;
				}
			}
			buf.push('</',prefixedNodeName,'>');
		}else{
			buf.push('/>');
		}
		// remove added visible namespaces
		//visibleNamespaces.length = startVisibleNamespaces;
		return;
	case DOCUMENT_NODE:
	case DOCUMENT_FRAGMENT_NODE:
		var child = node.firstChild;
		while(child){
			serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
			child = child.nextSibling;
		}
		return;
	case ATTRIBUTE_NODE:
		return addSerializedAttribute(buf, node.name, node.value);
	case TEXT_NODE:
		/**
		 * The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,
		 * except when used as markup delimiters, or within a comment, a processing instruction, or a CDATA section.
		 * If they are needed elsewhere, they must be escaped using either numeric character references or the strings
		 * `&amp;` and `&lt;` respectively.
		 * The right angle bracket (>) may be represented using the string " &gt; ", and must, for compatibility,
		 * be escaped using either `&gt;` or a character reference when it appears in the string `]]>` in content,
		 * when that string is not marking the end of a CDATA section.
		 *
		 * In the content of elements, character data is any string of characters
		 * which does not contain the start-delimiter of any markup
		 * and does not include the CDATA-section-close delimiter, `]]>`.
		 *
		 * @see https://www.w3.org/TR/xml/#NT-CharData
		 * @see https://w3c.github.io/DOM-Parsing/#xml-serializing-a-text-node
		 */
		return buf.push(node.data
			.replace(/[<&>]/g,_xmlEncoder)
		);
	case CDATA_SECTION_NODE:
		return buf.push( '<![CDATA[',node.data,']]>');
	case COMMENT_NODE:
		return buf.push( "<!--",node.data,"-->");
	case DOCUMENT_TYPE_NODE:
		var pubid = node.publicId;
		var sysid = node.systemId;
		buf.push('<!DOCTYPE ',node.name);
		if(pubid){
			buf.push(' PUBLIC ', pubid);
			if (sysid && sysid!='.') {
				buf.push(' ', sysid);
			}
			buf.push('>');
		}else if(sysid && sysid!='.'){
			buf.push(' SYSTEM ', sysid, '>');
		}else{
			var sub = node.internalSubset;
			if(sub){
				buf.push(" [",sub,"]");
			}
			buf.push(">");
		}
		return;
	case PROCESSING_INSTRUCTION_NODE:
		return buf.push( "<?",node.target," ",node.data,"?>");
	case ENTITY_REFERENCE_NODE:
		return buf.push( '&',node.nodeName,';');
	//case ENTITY_NODE:
	//case NOTATION_NODE:
	default:
		buf.push('??',node.nodeName);
	}
}
function importNode(doc,node,deep){
	var node2;
	switch (node.nodeType) {
	case ELEMENT_NODE:
		node2 = node.cloneNode(false);
		node2.ownerDocument = doc;
		//var attrs = node2.attributes;
		//var len = attrs.length;
		//for(var i=0;i<len;i++){
			//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
		//}
	case DOCUMENT_FRAGMENT_NODE:
		break;
	case ATTRIBUTE_NODE:
		deep = true;
		break;
	//case ENTITY_REFERENCE_NODE:
	//case PROCESSING_INSTRUCTION_NODE:
	////case TEXT_NODE:
	//case CDATA_SECTION_NODE:
	//case COMMENT_NODE:
	//	deep = false;
	//	break;
	//case DOCUMENT_NODE:
	//case DOCUMENT_TYPE_NODE:
	//cannot be imported.
	//case ENTITY_NODE:
	//case NOTATION_NODE：
	//can not hit in level3
	//default:throw e;
	}
	if(!node2){
		node2 = node.cloneNode(false);//false
	}
	node2.ownerDocument = doc;
	node2.parentNode = null;
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(importNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}
//
//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
function cloneNode(doc,node,deep){
	var node2 = new node.constructor();
	for (var n in node) {
		if (Object.prototype.hasOwnProperty.call(node, n)) {
			var v = node[n];
			if (typeof v != "object") {
				if (v != node2[n]) {
					node2[n] = v;
				}
			}
		}
	}
	if(node.childNodes){
		node2.childNodes = new NodeList();
	}
	node2.ownerDocument = doc;
	switch (node2.nodeType) {
	case ELEMENT_NODE:
		var attrs	= node.attributes;
		var attrs2	= node2.attributes = new NamedNodeMap();
		var len = attrs.length
		attrs2._ownerElement = node2;
		for(var i=0;i<len;i++){
			node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
		}
		break;;
	case ATTRIBUTE_NODE:
		deep = true;
	}
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(cloneNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}

function __set__(object,key,value){
	object[key] = value
}
//do dynamic
try{
	if(Object.defineProperty){
		Object.defineProperty(LiveNodeList.prototype,'length',{
			get:function(){
				_updateLiveList(this);
				return this.$$length;
			}
		});

		Object.defineProperty(Node.prototype,'textContent',{
			get:function(){
				return getTextContent(this);
			},

			set:function(data){
				switch(this.nodeType){
				case ELEMENT_NODE:
				case DOCUMENT_FRAGMENT_NODE:
					while(this.firstChild){
						this.removeChild(this.firstChild);
					}
					if(data || String(data)){
						this.appendChild(this.ownerDocument.createTextNode(data));
					}
					break;

				default:
					this.data = data;
					this.value = data;
					this.nodeValue = data;
				}
			}
		})

		function getTextContent(node){
			switch(node.nodeType){
			case ELEMENT_NODE:
			case DOCUMENT_FRAGMENT_NODE:
				var buf = [];
				node = node.firstChild;
				while(node){
					if(node.nodeType!==7 && node.nodeType !==8){
						buf.push(getTextContent(node));
					}
					node = node.nextSibling;
				}
				return buf.join('');
			default:
				return node.nodeValue;
			}
		}

		__set__ = function(object,key,value){
			//console.log(value)
			object['$$'+key] = value
		}
	}
}catch(e){//ie8
}

//if(typeof require == 'function'){
	exports.DocumentType = DocumentType;
	exports.DOMException = DOMException;
	exports.DOMImplementation = DOMImplementation;
	exports.Element = Element;
	exports.Node = Node;
	exports.NodeList = NodeList;
	exports.XMLSerializer = XMLSerializer;
//}


/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/entities.js":
/*!*****************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/entities.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var freeze = (__webpack_require__(/*! ./conventions */ "./node_modules/@xmldom/xmldom/lib/conventions.js").freeze);

/**
 * The entities that are predefined in every XML document.
 *
 * @see https://www.w3.org/TR/2006/REC-xml11-20060816/#sec-predefined-ent W3C XML 1.1
 * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent W3C XML 1.0
 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Predefined_entities_in_XML Wikipedia
 */
exports.XML_ENTITIES = freeze({
	amp: '&',
	apos: "'",
	gt: '>',
	lt: '<',
	quot: '"',
});

/**
 * A map of all entities that are detected in an HTML document.
 * They contain all entries from `XML_ENTITIES`.
 *
 * @see XML_ENTITIES
 * @see DOMParser.parseFromString
 * @see DOMImplementation.prototype.createHTMLDocument
 * @see https://html.spec.whatwg.org/#named-character-references WHATWG HTML(5) Spec
 * @see https://html.spec.whatwg.org/entities.json JSON
 * @see https://www.w3.org/TR/xml-entity-names/ W3C XML Entity Names
 * @see https://www.w3.org/TR/html4/sgml/entities.html W3C HTML4/SGML
 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML Wikipedia (HTML)
 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Entities_representing_special_characters_in_XHTML Wikpedia (XHTML)
 */
exports.HTML_ENTITIES = freeze({
	Aacute: '\u00C1',
	aacute: '\u00E1',
	Abreve: '\u0102',
	abreve: '\u0103',
	ac: '\u223E',
	acd: '\u223F',
	acE: '\u223E\u0333',
	Acirc: '\u00C2',
	acirc: '\u00E2',
	acute: '\u00B4',
	Acy: '\u0410',
	acy: '\u0430',
	AElig: '\u00C6',
	aelig: '\u00E6',
	af: '\u2061',
	Afr: '\uD835\uDD04',
	afr: '\uD835\uDD1E',
	Agrave: '\u00C0',
	agrave: '\u00E0',
	alefsym: '\u2135',
	aleph: '\u2135',
	Alpha: '\u0391',
	alpha: '\u03B1',
	Amacr: '\u0100',
	amacr: '\u0101',
	amalg: '\u2A3F',
	AMP: '\u0026',
	amp: '\u0026',
	And: '\u2A53',
	and: '\u2227',
	andand: '\u2A55',
	andd: '\u2A5C',
	andslope: '\u2A58',
	andv: '\u2A5A',
	ang: '\u2220',
	ange: '\u29A4',
	angle: '\u2220',
	angmsd: '\u2221',
	angmsdaa: '\u29A8',
	angmsdab: '\u29A9',
	angmsdac: '\u29AA',
	angmsdad: '\u29AB',
	angmsdae: '\u29AC',
	angmsdaf: '\u29AD',
	angmsdag: '\u29AE',
	angmsdah: '\u29AF',
	angrt: '\u221F',
	angrtvb: '\u22BE',
	angrtvbd: '\u299D',
	angsph: '\u2222',
	angst: '\u00C5',
	angzarr: '\u237C',
	Aogon: '\u0104',
	aogon: '\u0105',
	Aopf: '\uD835\uDD38',
	aopf: '\uD835\uDD52',
	ap: '\u2248',
	apacir: '\u2A6F',
	apE: '\u2A70',
	ape: '\u224A',
	apid: '\u224B',
	apos: '\u0027',
	ApplyFunction: '\u2061',
	approx: '\u2248',
	approxeq: '\u224A',
	Aring: '\u00C5',
	aring: '\u00E5',
	Ascr: '\uD835\uDC9C',
	ascr: '\uD835\uDCB6',
	Assign: '\u2254',
	ast: '\u002A',
	asymp: '\u2248',
	asympeq: '\u224D',
	Atilde: '\u00C3',
	atilde: '\u00E3',
	Auml: '\u00C4',
	auml: '\u00E4',
	awconint: '\u2233',
	awint: '\u2A11',
	backcong: '\u224C',
	backepsilon: '\u03F6',
	backprime: '\u2035',
	backsim: '\u223D',
	backsimeq: '\u22CD',
	Backslash: '\u2216',
	Barv: '\u2AE7',
	barvee: '\u22BD',
	Barwed: '\u2306',
	barwed: '\u2305',
	barwedge: '\u2305',
	bbrk: '\u23B5',
	bbrktbrk: '\u23B6',
	bcong: '\u224C',
	Bcy: '\u0411',
	bcy: '\u0431',
	bdquo: '\u201E',
	becaus: '\u2235',
	Because: '\u2235',
	because: '\u2235',
	bemptyv: '\u29B0',
	bepsi: '\u03F6',
	bernou: '\u212C',
	Bernoullis: '\u212C',
	Beta: '\u0392',
	beta: '\u03B2',
	beth: '\u2136',
	between: '\u226C',
	Bfr: '\uD835\uDD05',
	bfr: '\uD835\uDD1F',
	bigcap: '\u22C2',
	bigcirc: '\u25EF',
	bigcup: '\u22C3',
	bigodot: '\u2A00',
	bigoplus: '\u2A01',
	bigotimes: '\u2A02',
	bigsqcup: '\u2A06',
	bigstar: '\u2605',
	bigtriangledown: '\u25BD',
	bigtriangleup: '\u25B3',
	biguplus: '\u2A04',
	bigvee: '\u22C1',
	bigwedge: '\u22C0',
	bkarow: '\u290D',
	blacklozenge: '\u29EB',
	blacksquare: '\u25AA',
	blacktriangle: '\u25B4',
	blacktriangledown: '\u25BE',
	blacktriangleleft: '\u25C2',
	blacktriangleright: '\u25B8',
	blank: '\u2423',
	blk12: '\u2592',
	blk14: '\u2591',
	blk34: '\u2593',
	block: '\u2588',
	bne: '\u003D\u20E5',
	bnequiv: '\u2261\u20E5',
	bNot: '\u2AED',
	bnot: '\u2310',
	Bopf: '\uD835\uDD39',
	bopf: '\uD835\uDD53',
	bot: '\u22A5',
	bottom: '\u22A5',
	bowtie: '\u22C8',
	boxbox: '\u29C9',
	boxDL: '\u2557',
	boxDl: '\u2556',
	boxdL: '\u2555',
	boxdl: '\u2510',
	boxDR: '\u2554',
	boxDr: '\u2553',
	boxdR: '\u2552',
	boxdr: '\u250C',
	boxH: '\u2550',
	boxh: '\u2500',
	boxHD: '\u2566',
	boxHd: '\u2564',
	boxhD: '\u2565',
	boxhd: '\u252C',
	boxHU: '\u2569',
	boxHu: '\u2567',
	boxhU: '\u2568',
	boxhu: '\u2534',
	boxminus: '\u229F',
	boxplus: '\u229E',
	boxtimes: '\u22A0',
	boxUL: '\u255D',
	boxUl: '\u255C',
	boxuL: '\u255B',
	boxul: '\u2518',
	boxUR: '\u255A',
	boxUr: '\u2559',
	boxuR: '\u2558',
	boxur: '\u2514',
	boxV: '\u2551',
	boxv: '\u2502',
	boxVH: '\u256C',
	boxVh: '\u256B',
	boxvH: '\u256A',
	boxvh: '\u253C',
	boxVL: '\u2563',
	boxVl: '\u2562',
	boxvL: '\u2561',
	boxvl: '\u2524',
	boxVR: '\u2560',
	boxVr: '\u255F',
	boxvR: '\u255E',
	boxvr: '\u251C',
	bprime: '\u2035',
	Breve: '\u02D8',
	breve: '\u02D8',
	brvbar: '\u00A6',
	Bscr: '\u212C',
	bscr: '\uD835\uDCB7',
	bsemi: '\u204F',
	bsim: '\u223D',
	bsime: '\u22CD',
	bsol: '\u005C',
	bsolb: '\u29C5',
	bsolhsub: '\u27C8',
	bull: '\u2022',
	bullet: '\u2022',
	bump: '\u224E',
	bumpE: '\u2AAE',
	bumpe: '\u224F',
	Bumpeq: '\u224E',
	bumpeq: '\u224F',
	Cacute: '\u0106',
	cacute: '\u0107',
	Cap: '\u22D2',
	cap: '\u2229',
	capand: '\u2A44',
	capbrcup: '\u2A49',
	capcap: '\u2A4B',
	capcup: '\u2A47',
	capdot: '\u2A40',
	CapitalDifferentialD: '\u2145',
	caps: '\u2229\uFE00',
	caret: '\u2041',
	caron: '\u02C7',
	Cayleys: '\u212D',
	ccaps: '\u2A4D',
	Ccaron: '\u010C',
	ccaron: '\u010D',
	Ccedil: '\u00C7',
	ccedil: '\u00E7',
	Ccirc: '\u0108',
	ccirc: '\u0109',
	Cconint: '\u2230',
	ccups: '\u2A4C',
	ccupssm: '\u2A50',
	Cdot: '\u010A',
	cdot: '\u010B',
	cedil: '\u00B8',
	Cedilla: '\u00B8',
	cemptyv: '\u29B2',
	cent: '\u00A2',
	CenterDot: '\u00B7',
	centerdot: '\u00B7',
	Cfr: '\u212D',
	cfr: '\uD835\uDD20',
	CHcy: '\u0427',
	chcy: '\u0447',
	check: '\u2713',
	checkmark: '\u2713',
	Chi: '\u03A7',
	chi: '\u03C7',
	cir: '\u25CB',
	circ: '\u02C6',
	circeq: '\u2257',
	circlearrowleft: '\u21BA',
	circlearrowright: '\u21BB',
	circledast: '\u229B',
	circledcirc: '\u229A',
	circleddash: '\u229D',
	CircleDot: '\u2299',
	circledR: '\u00AE',
	circledS: '\u24C8',
	CircleMinus: '\u2296',
	CirclePlus: '\u2295',
	CircleTimes: '\u2297',
	cirE: '\u29C3',
	cire: '\u2257',
	cirfnint: '\u2A10',
	cirmid: '\u2AEF',
	cirscir: '\u29C2',
	ClockwiseContourIntegral: '\u2232',
	CloseCurlyDoubleQuote: '\u201D',
	CloseCurlyQuote: '\u2019',
	clubs: '\u2663',
	clubsuit: '\u2663',
	Colon: '\u2237',
	colon: '\u003A',
	Colone: '\u2A74',
	colone: '\u2254',
	coloneq: '\u2254',
	comma: '\u002C',
	commat: '\u0040',
	comp: '\u2201',
	compfn: '\u2218',
	complement: '\u2201',
	complexes: '\u2102',
	cong: '\u2245',
	congdot: '\u2A6D',
	Congruent: '\u2261',
	Conint: '\u222F',
	conint: '\u222E',
	ContourIntegral: '\u222E',
	Copf: '\u2102',
	copf: '\uD835\uDD54',
	coprod: '\u2210',
	Coproduct: '\u2210',
	COPY: '\u00A9',
	copy: '\u00A9',
	copysr: '\u2117',
	CounterClockwiseContourIntegral: '\u2233',
	crarr: '\u21B5',
	Cross: '\u2A2F',
	cross: '\u2717',
	Cscr: '\uD835\uDC9E',
	cscr: '\uD835\uDCB8',
	csub: '\u2ACF',
	csube: '\u2AD1',
	csup: '\u2AD0',
	csupe: '\u2AD2',
	ctdot: '\u22EF',
	cudarrl: '\u2938',
	cudarrr: '\u2935',
	cuepr: '\u22DE',
	cuesc: '\u22DF',
	cularr: '\u21B6',
	cularrp: '\u293D',
	Cup: '\u22D3',
	cup: '\u222A',
	cupbrcap: '\u2A48',
	CupCap: '\u224D',
	cupcap: '\u2A46',
	cupcup: '\u2A4A',
	cupdot: '\u228D',
	cupor: '\u2A45',
	cups: '\u222A\uFE00',
	curarr: '\u21B7',
	curarrm: '\u293C',
	curlyeqprec: '\u22DE',
	curlyeqsucc: '\u22DF',
	curlyvee: '\u22CE',
	curlywedge: '\u22CF',
	curren: '\u00A4',
	curvearrowleft: '\u21B6',
	curvearrowright: '\u21B7',
	cuvee: '\u22CE',
	cuwed: '\u22CF',
	cwconint: '\u2232',
	cwint: '\u2231',
	cylcty: '\u232D',
	Dagger: '\u2021',
	dagger: '\u2020',
	daleth: '\u2138',
	Darr: '\u21A1',
	dArr: '\u21D3',
	darr: '\u2193',
	dash: '\u2010',
	Dashv: '\u2AE4',
	dashv: '\u22A3',
	dbkarow: '\u290F',
	dblac: '\u02DD',
	Dcaron: '\u010E',
	dcaron: '\u010F',
	Dcy: '\u0414',
	dcy: '\u0434',
	DD: '\u2145',
	dd: '\u2146',
	ddagger: '\u2021',
	ddarr: '\u21CA',
	DDotrahd: '\u2911',
	ddotseq: '\u2A77',
	deg: '\u00B0',
	Del: '\u2207',
	Delta: '\u0394',
	delta: '\u03B4',
	demptyv: '\u29B1',
	dfisht: '\u297F',
	Dfr: '\uD835\uDD07',
	dfr: '\uD835\uDD21',
	dHar: '\u2965',
	dharl: '\u21C3',
	dharr: '\u21C2',
	DiacriticalAcute: '\u00B4',
	DiacriticalDot: '\u02D9',
	DiacriticalDoubleAcute: '\u02DD',
	DiacriticalGrave: '\u0060',
	DiacriticalTilde: '\u02DC',
	diam: '\u22C4',
	Diamond: '\u22C4',
	diamond: '\u22C4',
	diamondsuit: '\u2666',
	diams: '\u2666',
	die: '\u00A8',
	DifferentialD: '\u2146',
	digamma: '\u03DD',
	disin: '\u22F2',
	div: '\u00F7',
	divide: '\u00F7',
	divideontimes: '\u22C7',
	divonx: '\u22C7',
	DJcy: '\u0402',
	djcy: '\u0452',
	dlcorn: '\u231E',
	dlcrop: '\u230D',
	dollar: '\u0024',
	Dopf: '\uD835\uDD3B',
	dopf: '\uD835\uDD55',
	Dot: '\u00A8',
	dot: '\u02D9',
	DotDot: '\u20DC',
	doteq: '\u2250',
	doteqdot: '\u2251',
	DotEqual: '\u2250',
	dotminus: '\u2238',
	dotplus: '\u2214',
	dotsquare: '\u22A1',
	doublebarwedge: '\u2306',
	DoubleContourIntegral: '\u222F',
	DoubleDot: '\u00A8',
	DoubleDownArrow: '\u21D3',
	DoubleLeftArrow: '\u21D0',
	DoubleLeftRightArrow: '\u21D4',
	DoubleLeftTee: '\u2AE4',
	DoubleLongLeftArrow: '\u27F8',
	DoubleLongLeftRightArrow: '\u27FA',
	DoubleLongRightArrow: '\u27F9',
	DoubleRightArrow: '\u21D2',
	DoubleRightTee: '\u22A8',
	DoubleUpArrow: '\u21D1',
	DoubleUpDownArrow: '\u21D5',
	DoubleVerticalBar: '\u2225',
	DownArrow: '\u2193',
	Downarrow: '\u21D3',
	downarrow: '\u2193',
	DownArrowBar: '\u2913',
	DownArrowUpArrow: '\u21F5',
	DownBreve: '\u0311',
	downdownarrows: '\u21CA',
	downharpoonleft: '\u21C3',
	downharpoonright: '\u21C2',
	DownLeftRightVector: '\u2950',
	DownLeftTeeVector: '\u295E',
	DownLeftVector: '\u21BD',
	DownLeftVectorBar: '\u2956',
	DownRightTeeVector: '\u295F',
	DownRightVector: '\u21C1',
	DownRightVectorBar: '\u2957',
	DownTee: '\u22A4',
	DownTeeArrow: '\u21A7',
	drbkarow: '\u2910',
	drcorn: '\u231F',
	drcrop: '\u230C',
	Dscr: '\uD835\uDC9F',
	dscr: '\uD835\uDCB9',
	DScy: '\u0405',
	dscy: '\u0455',
	dsol: '\u29F6',
	Dstrok: '\u0110',
	dstrok: '\u0111',
	dtdot: '\u22F1',
	dtri: '\u25BF',
	dtrif: '\u25BE',
	duarr: '\u21F5',
	duhar: '\u296F',
	dwangle: '\u29A6',
	DZcy: '\u040F',
	dzcy: '\u045F',
	dzigrarr: '\u27FF',
	Eacute: '\u00C9',
	eacute: '\u00E9',
	easter: '\u2A6E',
	Ecaron: '\u011A',
	ecaron: '\u011B',
	ecir: '\u2256',
	Ecirc: '\u00CA',
	ecirc: '\u00EA',
	ecolon: '\u2255',
	Ecy: '\u042D',
	ecy: '\u044D',
	eDDot: '\u2A77',
	Edot: '\u0116',
	eDot: '\u2251',
	edot: '\u0117',
	ee: '\u2147',
	efDot: '\u2252',
	Efr: '\uD835\uDD08',
	efr: '\uD835\uDD22',
	eg: '\u2A9A',
	Egrave: '\u00C8',
	egrave: '\u00E8',
	egs: '\u2A96',
	egsdot: '\u2A98',
	el: '\u2A99',
	Element: '\u2208',
	elinters: '\u23E7',
	ell: '\u2113',
	els: '\u2A95',
	elsdot: '\u2A97',
	Emacr: '\u0112',
	emacr: '\u0113',
	empty: '\u2205',
	emptyset: '\u2205',
	EmptySmallSquare: '\u25FB',
	emptyv: '\u2205',
	EmptyVerySmallSquare: '\u25AB',
	emsp: '\u2003',
	emsp13: '\u2004',
	emsp14: '\u2005',
	ENG: '\u014A',
	eng: '\u014B',
	ensp: '\u2002',
	Eogon: '\u0118',
	eogon: '\u0119',
	Eopf: '\uD835\uDD3C',
	eopf: '\uD835\uDD56',
	epar: '\u22D5',
	eparsl: '\u29E3',
	eplus: '\u2A71',
	epsi: '\u03B5',
	Epsilon: '\u0395',
	epsilon: '\u03B5',
	epsiv: '\u03F5',
	eqcirc: '\u2256',
	eqcolon: '\u2255',
	eqsim: '\u2242',
	eqslantgtr: '\u2A96',
	eqslantless: '\u2A95',
	Equal: '\u2A75',
	equals: '\u003D',
	EqualTilde: '\u2242',
	equest: '\u225F',
	Equilibrium: '\u21CC',
	equiv: '\u2261',
	equivDD: '\u2A78',
	eqvparsl: '\u29E5',
	erarr: '\u2971',
	erDot: '\u2253',
	Escr: '\u2130',
	escr: '\u212F',
	esdot: '\u2250',
	Esim: '\u2A73',
	esim: '\u2242',
	Eta: '\u0397',
	eta: '\u03B7',
	ETH: '\u00D0',
	eth: '\u00F0',
	Euml: '\u00CB',
	euml: '\u00EB',
	euro: '\u20AC',
	excl: '\u0021',
	exist: '\u2203',
	Exists: '\u2203',
	expectation: '\u2130',
	ExponentialE: '\u2147',
	exponentiale: '\u2147',
	fallingdotseq: '\u2252',
	Fcy: '\u0424',
	fcy: '\u0444',
	female: '\u2640',
	ffilig: '\uFB03',
	fflig: '\uFB00',
	ffllig: '\uFB04',
	Ffr: '\uD835\uDD09',
	ffr: '\uD835\uDD23',
	filig: '\uFB01',
	FilledSmallSquare: '\u25FC',
	FilledVerySmallSquare: '\u25AA',
	fjlig: '\u0066\u006A',
	flat: '\u266D',
	fllig: '\uFB02',
	fltns: '\u25B1',
	fnof: '\u0192',
	Fopf: '\uD835\uDD3D',
	fopf: '\uD835\uDD57',
	ForAll: '\u2200',
	forall: '\u2200',
	fork: '\u22D4',
	forkv: '\u2AD9',
	Fouriertrf: '\u2131',
	fpartint: '\u2A0D',
	frac12: '\u00BD',
	frac13: '\u2153',
	frac14: '\u00BC',
	frac15: '\u2155',
	frac16: '\u2159',
	frac18: '\u215B',
	frac23: '\u2154',
	frac25: '\u2156',
	frac34: '\u00BE',
	frac35: '\u2157',
	frac38: '\u215C',
	frac45: '\u2158',
	frac56: '\u215A',
	frac58: '\u215D',
	frac78: '\u215E',
	frasl: '\u2044',
	frown: '\u2322',
	Fscr: '\u2131',
	fscr: '\uD835\uDCBB',
	gacute: '\u01F5',
	Gamma: '\u0393',
	gamma: '\u03B3',
	Gammad: '\u03DC',
	gammad: '\u03DD',
	gap: '\u2A86',
	Gbreve: '\u011E',
	gbreve: '\u011F',
	Gcedil: '\u0122',
	Gcirc: '\u011C',
	gcirc: '\u011D',
	Gcy: '\u0413',
	gcy: '\u0433',
	Gdot: '\u0120',
	gdot: '\u0121',
	gE: '\u2267',
	ge: '\u2265',
	gEl: '\u2A8C',
	gel: '\u22DB',
	geq: '\u2265',
	geqq: '\u2267',
	geqslant: '\u2A7E',
	ges: '\u2A7E',
	gescc: '\u2AA9',
	gesdot: '\u2A80',
	gesdoto: '\u2A82',
	gesdotol: '\u2A84',
	gesl: '\u22DB\uFE00',
	gesles: '\u2A94',
	Gfr: '\uD835\uDD0A',
	gfr: '\uD835\uDD24',
	Gg: '\u22D9',
	gg: '\u226B',
	ggg: '\u22D9',
	gimel: '\u2137',
	GJcy: '\u0403',
	gjcy: '\u0453',
	gl: '\u2277',
	gla: '\u2AA5',
	glE: '\u2A92',
	glj: '\u2AA4',
	gnap: '\u2A8A',
	gnapprox: '\u2A8A',
	gnE: '\u2269',
	gne: '\u2A88',
	gneq: '\u2A88',
	gneqq: '\u2269',
	gnsim: '\u22E7',
	Gopf: '\uD835\uDD3E',
	gopf: '\uD835\uDD58',
	grave: '\u0060',
	GreaterEqual: '\u2265',
	GreaterEqualLess: '\u22DB',
	GreaterFullEqual: '\u2267',
	GreaterGreater: '\u2AA2',
	GreaterLess: '\u2277',
	GreaterSlantEqual: '\u2A7E',
	GreaterTilde: '\u2273',
	Gscr: '\uD835\uDCA2',
	gscr: '\u210A',
	gsim: '\u2273',
	gsime: '\u2A8E',
	gsiml: '\u2A90',
	Gt: '\u226B',
	GT: '\u003E',
	gt: '\u003E',
	gtcc: '\u2AA7',
	gtcir: '\u2A7A',
	gtdot: '\u22D7',
	gtlPar: '\u2995',
	gtquest: '\u2A7C',
	gtrapprox: '\u2A86',
	gtrarr: '\u2978',
	gtrdot: '\u22D7',
	gtreqless: '\u22DB',
	gtreqqless: '\u2A8C',
	gtrless: '\u2277',
	gtrsim: '\u2273',
	gvertneqq: '\u2269\uFE00',
	gvnE: '\u2269\uFE00',
	Hacek: '\u02C7',
	hairsp: '\u200A',
	half: '\u00BD',
	hamilt: '\u210B',
	HARDcy: '\u042A',
	hardcy: '\u044A',
	hArr: '\u21D4',
	harr: '\u2194',
	harrcir: '\u2948',
	harrw: '\u21AD',
	Hat: '\u005E',
	hbar: '\u210F',
	Hcirc: '\u0124',
	hcirc: '\u0125',
	hearts: '\u2665',
	heartsuit: '\u2665',
	hellip: '\u2026',
	hercon: '\u22B9',
	Hfr: '\u210C',
	hfr: '\uD835\uDD25',
	HilbertSpace: '\u210B',
	hksearow: '\u2925',
	hkswarow: '\u2926',
	hoarr: '\u21FF',
	homtht: '\u223B',
	hookleftarrow: '\u21A9',
	hookrightarrow: '\u21AA',
	Hopf: '\u210D',
	hopf: '\uD835\uDD59',
	horbar: '\u2015',
	HorizontalLine: '\u2500',
	Hscr: '\u210B',
	hscr: '\uD835\uDCBD',
	hslash: '\u210F',
	Hstrok: '\u0126',
	hstrok: '\u0127',
	HumpDownHump: '\u224E',
	HumpEqual: '\u224F',
	hybull: '\u2043',
	hyphen: '\u2010',
	Iacute: '\u00CD',
	iacute: '\u00ED',
	ic: '\u2063',
	Icirc: '\u00CE',
	icirc: '\u00EE',
	Icy: '\u0418',
	icy: '\u0438',
	Idot: '\u0130',
	IEcy: '\u0415',
	iecy: '\u0435',
	iexcl: '\u00A1',
	iff: '\u21D4',
	Ifr: '\u2111',
	ifr: '\uD835\uDD26',
	Igrave: '\u00CC',
	igrave: '\u00EC',
	ii: '\u2148',
	iiiint: '\u2A0C',
	iiint: '\u222D',
	iinfin: '\u29DC',
	iiota: '\u2129',
	IJlig: '\u0132',
	ijlig: '\u0133',
	Im: '\u2111',
	Imacr: '\u012A',
	imacr: '\u012B',
	image: '\u2111',
	ImaginaryI: '\u2148',
	imagline: '\u2110',
	imagpart: '\u2111',
	imath: '\u0131',
	imof: '\u22B7',
	imped: '\u01B5',
	Implies: '\u21D2',
	in: '\u2208',
	incare: '\u2105',
	infin: '\u221E',
	infintie: '\u29DD',
	inodot: '\u0131',
	Int: '\u222C',
	int: '\u222B',
	intcal: '\u22BA',
	integers: '\u2124',
	Integral: '\u222B',
	intercal: '\u22BA',
	Intersection: '\u22C2',
	intlarhk: '\u2A17',
	intprod: '\u2A3C',
	InvisibleComma: '\u2063',
	InvisibleTimes: '\u2062',
	IOcy: '\u0401',
	iocy: '\u0451',
	Iogon: '\u012E',
	iogon: '\u012F',
	Iopf: '\uD835\uDD40',
	iopf: '\uD835\uDD5A',
	Iota: '\u0399',
	iota: '\u03B9',
	iprod: '\u2A3C',
	iquest: '\u00BF',
	Iscr: '\u2110',
	iscr: '\uD835\uDCBE',
	isin: '\u2208',
	isindot: '\u22F5',
	isinE: '\u22F9',
	isins: '\u22F4',
	isinsv: '\u22F3',
	isinv: '\u2208',
	it: '\u2062',
	Itilde: '\u0128',
	itilde: '\u0129',
	Iukcy: '\u0406',
	iukcy: '\u0456',
	Iuml: '\u00CF',
	iuml: '\u00EF',
	Jcirc: '\u0134',
	jcirc: '\u0135',
	Jcy: '\u0419',
	jcy: '\u0439',
	Jfr: '\uD835\uDD0D',
	jfr: '\uD835\uDD27',
	jmath: '\u0237',
	Jopf: '\uD835\uDD41',
	jopf: '\uD835\uDD5B',
	Jscr: '\uD835\uDCA5',
	jscr: '\uD835\uDCBF',
	Jsercy: '\u0408',
	jsercy: '\u0458',
	Jukcy: '\u0404',
	jukcy: '\u0454',
	Kappa: '\u039A',
	kappa: '\u03BA',
	kappav: '\u03F0',
	Kcedil: '\u0136',
	kcedil: '\u0137',
	Kcy: '\u041A',
	kcy: '\u043A',
	Kfr: '\uD835\uDD0E',
	kfr: '\uD835\uDD28',
	kgreen: '\u0138',
	KHcy: '\u0425',
	khcy: '\u0445',
	KJcy: '\u040C',
	kjcy: '\u045C',
	Kopf: '\uD835\uDD42',
	kopf: '\uD835\uDD5C',
	Kscr: '\uD835\uDCA6',
	kscr: '\uD835\uDCC0',
	lAarr: '\u21DA',
	Lacute: '\u0139',
	lacute: '\u013A',
	laemptyv: '\u29B4',
	lagran: '\u2112',
	Lambda: '\u039B',
	lambda: '\u03BB',
	Lang: '\u27EA',
	lang: '\u27E8',
	langd: '\u2991',
	langle: '\u27E8',
	lap: '\u2A85',
	Laplacetrf: '\u2112',
	laquo: '\u00AB',
	Larr: '\u219E',
	lArr: '\u21D0',
	larr: '\u2190',
	larrb: '\u21E4',
	larrbfs: '\u291F',
	larrfs: '\u291D',
	larrhk: '\u21A9',
	larrlp: '\u21AB',
	larrpl: '\u2939',
	larrsim: '\u2973',
	larrtl: '\u21A2',
	lat: '\u2AAB',
	lAtail: '\u291B',
	latail: '\u2919',
	late: '\u2AAD',
	lates: '\u2AAD\uFE00',
	lBarr: '\u290E',
	lbarr: '\u290C',
	lbbrk: '\u2772',
	lbrace: '\u007B',
	lbrack: '\u005B',
	lbrke: '\u298B',
	lbrksld: '\u298F',
	lbrkslu: '\u298D',
	Lcaron: '\u013D',
	lcaron: '\u013E',
	Lcedil: '\u013B',
	lcedil: '\u013C',
	lceil: '\u2308',
	lcub: '\u007B',
	Lcy: '\u041B',
	lcy: '\u043B',
	ldca: '\u2936',
	ldquo: '\u201C',
	ldquor: '\u201E',
	ldrdhar: '\u2967',
	ldrushar: '\u294B',
	ldsh: '\u21B2',
	lE: '\u2266',
	le: '\u2264',
	LeftAngleBracket: '\u27E8',
	LeftArrow: '\u2190',
	Leftarrow: '\u21D0',
	leftarrow: '\u2190',
	LeftArrowBar: '\u21E4',
	LeftArrowRightArrow: '\u21C6',
	leftarrowtail: '\u21A2',
	LeftCeiling: '\u2308',
	LeftDoubleBracket: '\u27E6',
	LeftDownTeeVector: '\u2961',
	LeftDownVector: '\u21C3',
	LeftDownVectorBar: '\u2959',
	LeftFloor: '\u230A',
	leftharpoondown: '\u21BD',
	leftharpoonup: '\u21BC',
	leftleftarrows: '\u21C7',
	LeftRightArrow: '\u2194',
	Leftrightarrow: '\u21D4',
	leftrightarrow: '\u2194',
	leftrightarrows: '\u21C6',
	leftrightharpoons: '\u21CB',
	leftrightsquigarrow: '\u21AD',
	LeftRightVector: '\u294E',
	LeftTee: '\u22A3',
	LeftTeeArrow: '\u21A4',
	LeftTeeVector: '\u295A',
	leftthreetimes: '\u22CB',
	LeftTriangle: '\u22B2',
	LeftTriangleBar: '\u29CF',
	LeftTriangleEqual: '\u22B4',
	LeftUpDownVector: '\u2951',
	LeftUpTeeVector: '\u2960',
	LeftUpVector: '\u21BF',
	LeftUpVectorBar: '\u2958',
	LeftVector: '\u21BC',
	LeftVectorBar: '\u2952',
	lEg: '\u2A8B',
	leg: '\u22DA',
	leq: '\u2264',
	leqq: '\u2266',
	leqslant: '\u2A7D',
	les: '\u2A7D',
	lescc: '\u2AA8',
	lesdot: '\u2A7F',
	lesdoto: '\u2A81',
	lesdotor: '\u2A83',
	lesg: '\u22DA\uFE00',
	lesges: '\u2A93',
	lessapprox: '\u2A85',
	lessdot: '\u22D6',
	lesseqgtr: '\u22DA',
	lesseqqgtr: '\u2A8B',
	LessEqualGreater: '\u22DA',
	LessFullEqual: '\u2266',
	LessGreater: '\u2276',
	lessgtr: '\u2276',
	LessLess: '\u2AA1',
	lesssim: '\u2272',
	LessSlantEqual: '\u2A7D',
	LessTilde: '\u2272',
	lfisht: '\u297C',
	lfloor: '\u230A',
	Lfr: '\uD835\uDD0F',
	lfr: '\uD835\uDD29',
	lg: '\u2276',
	lgE: '\u2A91',
	lHar: '\u2962',
	lhard: '\u21BD',
	lharu: '\u21BC',
	lharul: '\u296A',
	lhblk: '\u2584',
	LJcy: '\u0409',
	ljcy: '\u0459',
	Ll: '\u22D8',
	ll: '\u226A',
	llarr: '\u21C7',
	llcorner: '\u231E',
	Lleftarrow: '\u21DA',
	llhard: '\u296B',
	lltri: '\u25FA',
	Lmidot: '\u013F',
	lmidot: '\u0140',
	lmoust: '\u23B0',
	lmoustache: '\u23B0',
	lnap: '\u2A89',
	lnapprox: '\u2A89',
	lnE: '\u2268',
	lne: '\u2A87',
	lneq: '\u2A87',
	lneqq: '\u2268',
	lnsim: '\u22E6',
	loang: '\u27EC',
	loarr: '\u21FD',
	lobrk: '\u27E6',
	LongLeftArrow: '\u27F5',
	Longleftarrow: '\u27F8',
	longleftarrow: '\u27F5',
	LongLeftRightArrow: '\u27F7',
	Longleftrightarrow: '\u27FA',
	longleftrightarrow: '\u27F7',
	longmapsto: '\u27FC',
	LongRightArrow: '\u27F6',
	Longrightarrow: '\u27F9',
	longrightarrow: '\u27F6',
	looparrowleft: '\u21AB',
	looparrowright: '\u21AC',
	lopar: '\u2985',
	Lopf: '\uD835\uDD43',
	lopf: '\uD835\uDD5D',
	loplus: '\u2A2D',
	lotimes: '\u2A34',
	lowast: '\u2217',
	lowbar: '\u005F',
	LowerLeftArrow: '\u2199',
	LowerRightArrow: '\u2198',
	loz: '\u25CA',
	lozenge: '\u25CA',
	lozf: '\u29EB',
	lpar: '\u0028',
	lparlt: '\u2993',
	lrarr: '\u21C6',
	lrcorner: '\u231F',
	lrhar: '\u21CB',
	lrhard: '\u296D',
	lrm: '\u200E',
	lrtri: '\u22BF',
	lsaquo: '\u2039',
	Lscr: '\u2112',
	lscr: '\uD835\uDCC1',
	Lsh: '\u21B0',
	lsh: '\u21B0',
	lsim: '\u2272',
	lsime: '\u2A8D',
	lsimg: '\u2A8F',
	lsqb: '\u005B',
	lsquo: '\u2018',
	lsquor: '\u201A',
	Lstrok: '\u0141',
	lstrok: '\u0142',
	Lt: '\u226A',
	LT: '\u003C',
	lt: '\u003C',
	ltcc: '\u2AA6',
	ltcir: '\u2A79',
	ltdot: '\u22D6',
	lthree: '\u22CB',
	ltimes: '\u22C9',
	ltlarr: '\u2976',
	ltquest: '\u2A7B',
	ltri: '\u25C3',
	ltrie: '\u22B4',
	ltrif: '\u25C2',
	ltrPar: '\u2996',
	lurdshar: '\u294A',
	luruhar: '\u2966',
	lvertneqq: '\u2268\uFE00',
	lvnE: '\u2268\uFE00',
	macr: '\u00AF',
	male: '\u2642',
	malt: '\u2720',
	maltese: '\u2720',
	Map: '\u2905',
	map: '\u21A6',
	mapsto: '\u21A6',
	mapstodown: '\u21A7',
	mapstoleft: '\u21A4',
	mapstoup: '\u21A5',
	marker: '\u25AE',
	mcomma: '\u2A29',
	Mcy: '\u041C',
	mcy: '\u043C',
	mdash: '\u2014',
	mDDot: '\u223A',
	measuredangle: '\u2221',
	MediumSpace: '\u205F',
	Mellintrf: '\u2133',
	Mfr: '\uD835\uDD10',
	mfr: '\uD835\uDD2A',
	mho: '\u2127',
	micro: '\u00B5',
	mid: '\u2223',
	midast: '\u002A',
	midcir: '\u2AF0',
	middot: '\u00B7',
	minus: '\u2212',
	minusb: '\u229F',
	minusd: '\u2238',
	minusdu: '\u2A2A',
	MinusPlus: '\u2213',
	mlcp: '\u2ADB',
	mldr: '\u2026',
	mnplus: '\u2213',
	models: '\u22A7',
	Mopf: '\uD835\uDD44',
	mopf: '\uD835\uDD5E',
	mp: '\u2213',
	Mscr: '\u2133',
	mscr: '\uD835\uDCC2',
	mstpos: '\u223E',
	Mu: '\u039C',
	mu: '\u03BC',
	multimap: '\u22B8',
	mumap: '\u22B8',
	nabla: '\u2207',
	Nacute: '\u0143',
	nacute: '\u0144',
	nang: '\u2220\u20D2',
	nap: '\u2249',
	napE: '\u2A70\u0338',
	napid: '\u224B\u0338',
	napos: '\u0149',
	napprox: '\u2249',
	natur: '\u266E',
	natural: '\u266E',
	naturals: '\u2115',
	nbsp: '\u00A0',
	nbump: '\u224E\u0338',
	nbumpe: '\u224F\u0338',
	ncap: '\u2A43',
	Ncaron: '\u0147',
	ncaron: '\u0148',
	Ncedil: '\u0145',
	ncedil: '\u0146',
	ncong: '\u2247',
	ncongdot: '\u2A6D\u0338',
	ncup: '\u2A42',
	Ncy: '\u041D',
	ncy: '\u043D',
	ndash: '\u2013',
	ne: '\u2260',
	nearhk: '\u2924',
	neArr: '\u21D7',
	nearr: '\u2197',
	nearrow: '\u2197',
	nedot: '\u2250\u0338',
	NegativeMediumSpace: '\u200B',
	NegativeThickSpace: '\u200B',
	NegativeThinSpace: '\u200B',
	NegativeVeryThinSpace: '\u200B',
	nequiv: '\u2262',
	nesear: '\u2928',
	nesim: '\u2242\u0338',
	NestedGreaterGreater: '\u226B',
	NestedLessLess: '\u226A',
	NewLine: '\u000A',
	nexist: '\u2204',
	nexists: '\u2204',
	Nfr: '\uD835\uDD11',
	nfr: '\uD835\uDD2B',
	ngE: '\u2267\u0338',
	nge: '\u2271',
	ngeq: '\u2271',
	ngeqq: '\u2267\u0338',
	ngeqslant: '\u2A7E\u0338',
	nges: '\u2A7E\u0338',
	nGg: '\u22D9\u0338',
	ngsim: '\u2275',
	nGt: '\u226B\u20D2',
	ngt: '\u226F',
	ngtr: '\u226F',
	nGtv: '\u226B\u0338',
	nhArr: '\u21CE',
	nharr: '\u21AE',
	nhpar: '\u2AF2',
	ni: '\u220B',
	nis: '\u22FC',
	nisd: '\u22FA',
	niv: '\u220B',
	NJcy: '\u040A',
	njcy: '\u045A',
	nlArr: '\u21CD',
	nlarr: '\u219A',
	nldr: '\u2025',
	nlE: '\u2266\u0338',
	nle: '\u2270',
	nLeftarrow: '\u21CD',
	nleftarrow: '\u219A',
	nLeftrightarrow: '\u21CE',
	nleftrightarrow: '\u21AE',
	nleq: '\u2270',
	nleqq: '\u2266\u0338',
	nleqslant: '\u2A7D\u0338',
	nles: '\u2A7D\u0338',
	nless: '\u226E',
	nLl: '\u22D8\u0338',
	nlsim: '\u2274',
	nLt: '\u226A\u20D2',
	nlt: '\u226E',
	nltri: '\u22EA',
	nltrie: '\u22EC',
	nLtv: '\u226A\u0338',
	nmid: '\u2224',
	NoBreak: '\u2060',
	NonBreakingSpace: '\u00A0',
	Nopf: '\u2115',
	nopf: '\uD835\uDD5F',
	Not: '\u2AEC',
	not: '\u00AC',
	NotCongruent: '\u2262',
	NotCupCap: '\u226D',
	NotDoubleVerticalBar: '\u2226',
	NotElement: '\u2209',
	NotEqual: '\u2260',
	NotEqualTilde: '\u2242\u0338',
	NotExists: '\u2204',
	NotGreater: '\u226F',
	NotGreaterEqual: '\u2271',
	NotGreaterFullEqual: '\u2267\u0338',
	NotGreaterGreater: '\u226B\u0338',
	NotGreaterLess: '\u2279',
	NotGreaterSlantEqual: '\u2A7E\u0338',
	NotGreaterTilde: '\u2275',
	NotHumpDownHump: '\u224E\u0338',
	NotHumpEqual: '\u224F\u0338',
	notin: '\u2209',
	notindot: '\u22F5\u0338',
	notinE: '\u22F9\u0338',
	notinva: '\u2209',
	notinvb: '\u22F7',
	notinvc: '\u22F6',
	NotLeftTriangle: '\u22EA',
	NotLeftTriangleBar: '\u29CF\u0338',
	NotLeftTriangleEqual: '\u22EC',
	NotLess: '\u226E',
	NotLessEqual: '\u2270',
	NotLessGreater: '\u2278',
	NotLessLess: '\u226A\u0338',
	NotLessSlantEqual: '\u2A7D\u0338',
	NotLessTilde: '\u2274',
	NotNestedGreaterGreater: '\u2AA2\u0338',
	NotNestedLessLess: '\u2AA1\u0338',
	notni: '\u220C',
	notniva: '\u220C',
	notnivb: '\u22FE',
	notnivc: '\u22FD',
	NotPrecedes: '\u2280',
	NotPrecedesEqual: '\u2AAF\u0338',
	NotPrecedesSlantEqual: '\u22E0',
	NotReverseElement: '\u220C',
	NotRightTriangle: '\u22EB',
	NotRightTriangleBar: '\u29D0\u0338',
	NotRightTriangleEqual: '\u22ED',
	NotSquareSubset: '\u228F\u0338',
	NotSquareSubsetEqual: '\u22E2',
	NotSquareSuperset: '\u2290\u0338',
	NotSquareSupersetEqual: '\u22E3',
	NotSubset: '\u2282\u20D2',
	NotSubsetEqual: '\u2288',
	NotSucceeds: '\u2281',
	NotSucceedsEqual: '\u2AB0\u0338',
	NotSucceedsSlantEqual: '\u22E1',
	NotSucceedsTilde: '\u227F\u0338',
	NotSuperset: '\u2283\u20D2',
	NotSupersetEqual: '\u2289',
	NotTilde: '\u2241',
	NotTildeEqual: '\u2244',
	NotTildeFullEqual: '\u2247',
	NotTildeTilde: '\u2249',
	NotVerticalBar: '\u2224',
	npar: '\u2226',
	nparallel: '\u2226',
	nparsl: '\u2AFD\u20E5',
	npart: '\u2202\u0338',
	npolint: '\u2A14',
	npr: '\u2280',
	nprcue: '\u22E0',
	npre: '\u2AAF\u0338',
	nprec: '\u2280',
	npreceq: '\u2AAF\u0338',
	nrArr: '\u21CF',
	nrarr: '\u219B',
	nrarrc: '\u2933\u0338',
	nrarrw: '\u219D\u0338',
	nRightarrow: '\u21CF',
	nrightarrow: '\u219B',
	nrtri: '\u22EB',
	nrtrie: '\u22ED',
	nsc: '\u2281',
	nsccue: '\u22E1',
	nsce: '\u2AB0\u0338',
	Nscr: '\uD835\uDCA9',
	nscr: '\uD835\uDCC3',
	nshortmid: '\u2224',
	nshortparallel: '\u2226',
	nsim: '\u2241',
	nsime: '\u2244',
	nsimeq: '\u2244',
	nsmid: '\u2224',
	nspar: '\u2226',
	nsqsube: '\u22E2',
	nsqsupe: '\u22E3',
	nsub: '\u2284',
	nsubE: '\u2AC5\u0338',
	nsube: '\u2288',
	nsubset: '\u2282\u20D2',
	nsubseteq: '\u2288',
	nsubseteqq: '\u2AC5\u0338',
	nsucc: '\u2281',
	nsucceq: '\u2AB0\u0338',
	nsup: '\u2285',
	nsupE: '\u2AC6\u0338',
	nsupe: '\u2289',
	nsupset: '\u2283\u20D2',
	nsupseteq: '\u2289',
	nsupseteqq: '\u2AC6\u0338',
	ntgl: '\u2279',
	Ntilde: '\u00D1',
	ntilde: '\u00F1',
	ntlg: '\u2278',
	ntriangleleft: '\u22EA',
	ntrianglelefteq: '\u22EC',
	ntriangleright: '\u22EB',
	ntrianglerighteq: '\u22ED',
	Nu: '\u039D',
	nu: '\u03BD',
	num: '\u0023',
	numero: '\u2116',
	numsp: '\u2007',
	nvap: '\u224D\u20D2',
	nVDash: '\u22AF',
	nVdash: '\u22AE',
	nvDash: '\u22AD',
	nvdash: '\u22AC',
	nvge: '\u2265\u20D2',
	nvgt: '\u003E\u20D2',
	nvHarr: '\u2904',
	nvinfin: '\u29DE',
	nvlArr: '\u2902',
	nvle: '\u2264\u20D2',
	nvlt: '\u003C\u20D2',
	nvltrie: '\u22B4\u20D2',
	nvrArr: '\u2903',
	nvrtrie: '\u22B5\u20D2',
	nvsim: '\u223C\u20D2',
	nwarhk: '\u2923',
	nwArr: '\u21D6',
	nwarr: '\u2196',
	nwarrow: '\u2196',
	nwnear: '\u2927',
	Oacute: '\u00D3',
	oacute: '\u00F3',
	oast: '\u229B',
	ocir: '\u229A',
	Ocirc: '\u00D4',
	ocirc: '\u00F4',
	Ocy: '\u041E',
	ocy: '\u043E',
	odash: '\u229D',
	Odblac: '\u0150',
	odblac: '\u0151',
	odiv: '\u2A38',
	odot: '\u2299',
	odsold: '\u29BC',
	OElig: '\u0152',
	oelig: '\u0153',
	ofcir: '\u29BF',
	Ofr: '\uD835\uDD12',
	ofr: '\uD835\uDD2C',
	ogon: '\u02DB',
	Ograve: '\u00D2',
	ograve: '\u00F2',
	ogt: '\u29C1',
	ohbar: '\u29B5',
	ohm: '\u03A9',
	oint: '\u222E',
	olarr: '\u21BA',
	olcir: '\u29BE',
	olcross: '\u29BB',
	oline: '\u203E',
	olt: '\u29C0',
	Omacr: '\u014C',
	omacr: '\u014D',
	Omega: '\u03A9',
	omega: '\u03C9',
	Omicron: '\u039F',
	omicron: '\u03BF',
	omid: '\u29B6',
	ominus: '\u2296',
	Oopf: '\uD835\uDD46',
	oopf: '\uD835\uDD60',
	opar: '\u29B7',
	OpenCurlyDoubleQuote: '\u201C',
	OpenCurlyQuote: '\u2018',
	operp: '\u29B9',
	oplus: '\u2295',
	Or: '\u2A54',
	or: '\u2228',
	orarr: '\u21BB',
	ord: '\u2A5D',
	order: '\u2134',
	orderof: '\u2134',
	ordf: '\u00AA',
	ordm: '\u00BA',
	origof: '\u22B6',
	oror: '\u2A56',
	orslope: '\u2A57',
	orv: '\u2A5B',
	oS: '\u24C8',
	Oscr: '\uD835\uDCAA',
	oscr: '\u2134',
	Oslash: '\u00D8',
	oslash: '\u00F8',
	osol: '\u2298',
	Otilde: '\u00D5',
	otilde: '\u00F5',
	Otimes: '\u2A37',
	otimes: '\u2297',
	otimesas: '\u2A36',
	Ouml: '\u00D6',
	ouml: '\u00F6',
	ovbar: '\u233D',
	OverBar: '\u203E',
	OverBrace: '\u23DE',
	OverBracket: '\u23B4',
	OverParenthesis: '\u23DC',
	par: '\u2225',
	para: '\u00B6',
	parallel: '\u2225',
	parsim: '\u2AF3',
	parsl: '\u2AFD',
	part: '\u2202',
	PartialD: '\u2202',
	Pcy: '\u041F',
	pcy: '\u043F',
	percnt: '\u0025',
	period: '\u002E',
	permil: '\u2030',
	perp: '\u22A5',
	pertenk: '\u2031',
	Pfr: '\uD835\uDD13',
	pfr: '\uD835\uDD2D',
	Phi: '\u03A6',
	phi: '\u03C6',
	phiv: '\u03D5',
	phmmat: '\u2133',
	phone: '\u260E',
	Pi: '\u03A0',
	pi: '\u03C0',
	pitchfork: '\u22D4',
	piv: '\u03D6',
	planck: '\u210F',
	planckh: '\u210E',
	plankv: '\u210F',
	plus: '\u002B',
	plusacir: '\u2A23',
	plusb: '\u229E',
	pluscir: '\u2A22',
	plusdo: '\u2214',
	plusdu: '\u2A25',
	pluse: '\u2A72',
	PlusMinus: '\u00B1',
	plusmn: '\u00B1',
	plussim: '\u2A26',
	plustwo: '\u2A27',
	pm: '\u00B1',
	Poincareplane: '\u210C',
	pointint: '\u2A15',
	Popf: '\u2119',
	popf: '\uD835\uDD61',
	pound: '\u00A3',
	Pr: '\u2ABB',
	pr: '\u227A',
	prap: '\u2AB7',
	prcue: '\u227C',
	prE: '\u2AB3',
	pre: '\u2AAF',
	prec: '\u227A',
	precapprox: '\u2AB7',
	preccurlyeq: '\u227C',
	Precedes: '\u227A',
	PrecedesEqual: '\u2AAF',
	PrecedesSlantEqual: '\u227C',
	PrecedesTilde: '\u227E',
	preceq: '\u2AAF',
	precnapprox: '\u2AB9',
	precneqq: '\u2AB5',
	precnsim: '\u22E8',
	precsim: '\u227E',
	Prime: '\u2033',
	prime: '\u2032',
	primes: '\u2119',
	prnap: '\u2AB9',
	prnE: '\u2AB5',
	prnsim: '\u22E8',
	prod: '\u220F',
	Product: '\u220F',
	profalar: '\u232E',
	profline: '\u2312',
	profsurf: '\u2313',
	prop: '\u221D',
	Proportion: '\u2237',
	Proportional: '\u221D',
	propto: '\u221D',
	prsim: '\u227E',
	prurel: '\u22B0',
	Pscr: '\uD835\uDCAB',
	pscr: '\uD835\uDCC5',
	Psi: '\u03A8',
	psi: '\u03C8',
	puncsp: '\u2008',
	Qfr: '\uD835\uDD14',
	qfr: '\uD835\uDD2E',
	qint: '\u2A0C',
	Qopf: '\u211A',
	qopf: '\uD835\uDD62',
	qprime: '\u2057',
	Qscr: '\uD835\uDCAC',
	qscr: '\uD835\uDCC6',
	quaternions: '\u210D',
	quatint: '\u2A16',
	quest: '\u003F',
	questeq: '\u225F',
	QUOT: '\u0022',
	quot: '\u0022',
	rAarr: '\u21DB',
	race: '\u223D\u0331',
	Racute: '\u0154',
	racute: '\u0155',
	radic: '\u221A',
	raemptyv: '\u29B3',
	Rang: '\u27EB',
	rang: '\u27E9',
	rangd: '\u2992',
	range: '\u29A5',
	rangle: '\u27E9',
	raquo: '\u00BB',
	Rarr: '\u21A0',
	rArr: '\u21D2',
	rarr: '\u2192',
	rarrap: '\u2975',
	rarrb: '\u21E5',
	rarrbfs: '\u2920',
	rarrc: '\u2933',
	rarrfs: '\u291E',
	rarrhk: '\u21AA',
	rarrlp: '\u21AC',
	rarrpl: '\u2945',
	rarrsim: '\u2974',
	Rarrtl: '\u2916',
	rarrtl: '\u21A3',
	rarrw: '\u219D',
	rAtail: '\u291C',
	ratail: '\u291A',
	ratio: '\u2236',
	rationals: '\u211A',
	RBarr: '\u2910',
	rBarr: '\u290F',
	rbarr: '\u290D',
	rbbrk: '\u2773',
	rbrace: '\u007D',
	rbrack: '\u005D',
	rbrke: '\u298C',
	rbrksld: '\u298E',
	rbrkslu: '\u2990',
	Rcaron: '\u0158',
	rcaron: '\u0159',
	Rcedil: '\u0156',
	rcedil: '\u0157',
	rceil: '\u2309',
	rcub: '\u007D',
	Rcy: '\u0420',
	rcy: '\u0440',
	rdca: '\u2937',
	rdldhar: '\u2969',
	rdquo: '\u201D',
	rdquor: '\u201D',
	rdsh: '\u21B3',
	Re: '\u211C',
	real: '\u211C',
	realine: '\u211B',
	realpart: '\u211C',
	reals: '\u211D',
	rect: '\u25AD',
	REG: '\u00AE',
	reg: '\u00AE',
	ReverseElement: '\u220B',
	ReverseEquilibrium: '\u21CB',
	ReverseUpEquilibrium: '\u296F',
	rfisht: '\u297D',
	rfloor: '\u230B',
	Rfr: '\u211C',
	rfr: '\uD835\uDD2F',
	rHar: '\u2964',
	rhard: '\u21C1',
	rharu: '\u21C0',
	rharul: '\u296C',
	Rho: '\u03A1',
	rho: '\u03C1',
	rhov: '\u03F1',
	RightAngleBracket: '\u27E9',
	RightArrow: '\u2192',
	Rightarrow: '\u21D2',
	rightarrow: '\u2192',
	RightArrowBar: '\u21E5',
	RightArrowLeftArrow: '\u21C4',
	rightarrowtail: '\u21A3',
	RightCeiling: '\u2309',
	RightDoubleBracket: '\u27E7',
	RightDownTeeVector: '\u295D',
	RightDownVector: '\u21C2',
	RightDownVectorBar: '\u2955',
	RightFloor: '\u230B',
	rightharpoondown: '\u21C1',
	rightharpoonup: '\u21C0',
	rightleftarrows: '\u21C4',
	rightleftharpoons: '\u21CC',
	rightrightarrows: '\u21C9',
	rightsquigarrow: '\u219D',
	RightTee: '\u22A2',
	RightTeeArrow: '\u21A6',
	RightTeeVector: '\u295B',
	rightthreetimes: '\u22CC',
	RightTriangle: '\u22B3',
	RightTriangleBar: '\u29D0',
	RightTriangleEqual: '\u22B5',
	RightUpDownVector: '\u294F',
	RightUpTeeVector: '\u295C',
	RightUpVector: '\u21BE',
	RightUpVectorBar: '\u2954',
	RightVector: '\u21C0',
	RightVectorBar: '\u2953',
	ring: '\u02DA',
	risingdotseq: '\u2253',
	rlarr: '\u21C4',
	rlhar: '\u21CC',
	rlm: '\u200F',
	rmoust: '\u23B1',
	rmoustache: '\u23B1',
	rnmid: '\u2AEE',
	roang: '\u27ED',
	roarr: '\u21FE',
	robrk: '\u27E7',
	ropar: '\u2986',
	Ropf: '\u211D',
	ropf: '\uD835\uDD63',
	roplus: '\u2A2E',
	rotimes: '\u2A35',
	RoundImplies: '\u2970',
	rpar: '\u0029',
	rpargt: '\u2994',
	rppolint: '\u2A12',
	rrarr: '\u21C9',
	Rrightarrow: '\u21DB',
	rsaquo: '\u203A',
	Rscr: '\u211B',
	rscr: '\uD835\uDCC7',
	Rsh: '\u21B1',
	rsh: '\u21B1',
	rsqb: '\u005D',
	rsquo: '\u2019',
	rsquor: '\u2019',
	rthree: '\u22CC',
	rtimes: '\u22CA',
	rtri: '\u25B9',
	rtrie: '\u22B5',
	rtrif: '\u25B8',
	rtriltri: '\u29CE',
	RuleDelayed: '\u29F4',
	ruluhar: '\u2968',
	rx: '\u211E',
	Sacute: '\u015A',
	sacute: '\u015B',
	sbquo: '\u201A',
	Sc: '\u2ABC',
	sc: '\u227B',
	scap: '\u2AB8',
	Scaron: '\u0160',
	scaron: '\u0161',
	sccue: '\u227D',
	scE: '\u2AB4',
	sce: '\u2AB0',
	Scedil: '\u015E',
	scedil: '\u015F',
	Scirc: '\u015C',
	scirc: '\u015D',
	scnap: '\u2ABA',
	scnE: '\u2AB6',
	scnsim: '\u22E9',
	scpolint: '\u2A13',
	scsim: '\u227F',
	Scy: '\u0421',
	scy: '\u0441',
	sdot: '\u22C5',
	sdotb: '\u22A1',
	sdote: '\u2A66',
	searhk: '\u2925',
	seArr: '\u21D8',
	searr: '\u2198',
	searrow: '\u2198',
	sect: '\u00A7',
	semi: '\u003B',
	seswar: '\u2929',
	setminus: '\u2216',
	setmn: '\u2216',
	sext: '\u2736',
	Sfr: '\uD835\uDD16',
	sfr: '\uD835\uDD30',
	sfrown: '\u2322',
	sharp: '\u266F',
	SHCHcy: '\u0429',
	shchcy: '\u0449',
	SHcy: '\u0428',
	shcy: '\u0448',
	ShortDownArrow: '\u2193',
	ShortLeftArrow: '\u2190',
	shortmid: '\u2223',
	shortparallel: '\u2225',
	ShortRightArrow: '\u2192',
	ShortUpArrow: '\u2191',
	shy: '\u00AD',
	Sigma: '\u03A3',
	sigma: '\u03C3',
	sigmaf: '\u03C2',
	sigmav: '\u03C2',
	sim: '\u223C',
	simdot: '\u2A6A',
	sime: '\u2243',
	simeq: '\u2243',
	simg: '\u2A9E',
	simgE: '\u2AA0',
	siml: '\u2A9D',
	simlE: '\u2A9F',
	simne: '\u2246',
	simplus: '\u2A24',
	simrarr: '\u2972',
	slarr: '\u2190',
	SmallCircle: '\u2218',
	smallsetminus: '\u2216',
	smashp: '\u2A33',
	smeparsl: '\u29E4',
	smid: '\u2223',
	smile: '\u2323',
	smt: '\u2AAA',
	smte: '\u2AAC',
	smtes: '\u2AAC\uFE00',
	SOFTcy: '\u042C',
	softcy: '\u044C',
	sol: '\u002F',
	solb: '\u29C4',
	solbar: '\u233F',
	Sopf: '\uD835\uDD4A',
	sopf: '\uD835\uDD64',
	spades: '\u2660',
	spadesuit: '\u2660',
	spar: '\u2225',
	sqcap: '\u2293',
	sqcaps: '\u2293\uFE00',
	sqcup: '\u2294',
	sqcups: '\u2294\uFE00',
	Sqrt: '\u221A',
	sqsub: '\u228F',
	sqsube: '\u2291',
	sqsubset: '\u228F',
	sqsubseteq: '\u2291',
	sqsup: '\u2290',
	sqsupe: '\u2292',
	sqsupset: '\u2290',
	sqsupseteq: '\u2292',
	squ: '\u25A1',
	Square: '\u25A1',
	square: '\u25A1',
	SquareIntersection: '\u2293',
	SquareSubset: '\u228F',
	SquareSubsetEqual: '\u2291',
	SquareSuperset: '\u2290',
	SquareSupersetEqual: '\u2292',
	SquareUnion: '\u2294',
	squarf: '\u25AA',
	squf: '\u25AA',
	srarr: '\u2192',
	Sscr: '\uD835\uDCAE',
	sscr: '\uD835\uDCC8',
	ssetmn: '\u2216',
	ssmile: '\u2323',
	sstarf: '\u22C6',
	Star: '\u22C6',
	star: '\u2606',
	starf: '\u2605',
	straightepsilon: '\u03F5',
	straightphi: '\u03D5',
	strns: '\u00AF',
	Sub: '\u22D0',
	sub: '\u2282',
	subdot: '\u2ABD',
	subE: '\u2AC5',
	sube: '\u2286',
	subedot: '\u2AC3',
	submult: '\u2AC1',
	subnE: '\u2ACB',
	subne: '\u228A',
	subplus: '\u2ABF',
	subrarr: '\u2979',
	Subset: '\u22D0',
	subset: '\u2282',
	subseteq: '\u2286',
	subseteqq: '\u2AC5',
	SubsetEqual: '\u2286',
	subsetneq: '\u228A',
	subsetneqq: '\u2ACB',
	subsim: '\u2AC7',
	subsub: '\u2AD5',
	subsup: '\u2AD3',
	succ: '\u227B',
	succapprox: '\u2AB8',
	succcurlyeq: '\u227D',
	Succeeds: '\u227B',
	SucceedsEqual: '\u2AB0',
	SucceedsSlantEqual: '\u227D',
	SucceedsTilde: '\u227F',
	succeq: '\u2AB0',
	succnapprox: '\u2ABA',
	succneqq: '\u2AB6',
	succnsim: '\u22E9',
	succsim: '\u227F',
	SuchThat: '\u220B',
	Sum: '\u2211',
	sum: '\u2211',
	sung: '\u266A',
	Sup: '\u22D1',
	sup: '\u2283',
	sup1: '\u00B9',
	sup2: '\u00B2',
	sup3: '\u00B3',
	supdot: '\u2ABE',
	supdsub: '\u2AD8',
	supE: '\u2AC6',
	supe: '\u2287',
	supedot: '\u2AC4',
	Superset: '\u2283',
	SupersetEqual: '\u2287',
	suphsol: '\u27C9',
	suphsub: '\u2AD7',
	suplarr: '\u297B',
	supmult: '\u2AC2',
	supnE: '\u2ACC',
	supne: '\u228B',
	supplus: '\u2AC0',
	Supset: '\u22D1',
	supset: '\u2283',
	supseteq: '\u2287',
	supseteqq: '\u2AC6',
	supsetneq: '\u228B',
	supsetneqq: '\u2ACC',
	supsim: '\u2AC8',
	supsub: '\u2AD4',
	supsup: '\u2AD6',
	swarhk: '\u2926',
	swArr: '\u21D9',
	swarr: '\u2199',
	swarrow: '\u2199',
	swnwar: '\u292A',
	szlig: '\u00DF',
	Tab: '\u0009',
	target: '\u2316',
	Tau: '\u03A4',
	tau: '\u03C4',
	tbrk: '\u23B4',
	Tcaron: '\u0164',
	tcaron: '\u0165',
	Tcedil: '\u0162',
	tcedil: '\u0163',
	Tcy: '\u0422',
	tcy: '\u0442',
	tdot: '\u20DB',
	telrec: '\u2315',
	Tfr: '\uD835\uDD17',
	tfr: '\uD835\uDD31',
	there4: '\u2234',
	Therefore: '\u2234',
	therefore: '\u2234',
	Theta: '\u0398',
	theta: '\u03B8',
	thetasym: '\u03D1',
	thetav: '\u03D1',
	thickapprox: '\u2248',
	thicksim: '\u223C',
	ThickSpace: '\u205F\u200A',
	thinsp: '\u2009',
	ThinSpace: '\u2009',
	thkap: '\u2248',
	thksim: '\u223C',
	THORN: '\u00DE',
	thorn: '\u00FE',
	Tilde: '\u223C',
	tilde: '\u02DC',
	TildeEqual: '\u2243',
	TildeFullEqual: '\u2245',
	TildeTilde: '\u2248',
	times: '\u00D7',
	timesb: '\u22A0',
	timesbar: '\u2A31',
	timesd: '\u2A30',
	tint: '\u222D',
	toea: '\u2928',
	top: '\u22A4',
	topbot: '\u2336',
	topcir: '\u2AF1',
	Topf: '\uD835\uDD4B',
	topf: '\uD835\uDD65',
	topfork: '\u2ADA',
	tosa: '\u2929',
	tprime: '\u2034',
	TRADE: '\u2122',
	trade: '\u2122',
	triangle: '\u25B5',
	triangledown: '\u25BF',
	triangleleft: '\u25C3',
	trianglelefteq: '\u22B4',
	triangleq: '\u225C',
	triangleright: '\u25B9',
	trianglerighteq: '\u22B5',
	tridot: '\u25EC',
	trie: '\u225C',
	triminus: '\u2A3A',
	TripleDot: '\u20DB',
	triplus: '\u2A39',
	trisb: '\u29CD',
	tritime: '\u2A3B',
	trpezium: '\u23E2',
	Tscr: '\uD835\uDCAF',
	tscr: '\uD835\uDCC9',
	TScy: '\u0426',
	tscy: '\u0446',
	TSHcy: '\u040B',
	tshcy: '\u045B',
	Tstrok: '\u0166',
	tstrok: '\u0167',
	twixt: '\u226C',
	twoheadleftarrow: '\u219E',
	twoheadrightarrow: '\u21A0',
	Uacute: '\u00DA',
	uacute: '\u00FA',
	Uarr: '\u219F',
	uArr: '\u21D1',
	uarr: '\u2191',
	Uarrocir: '\u2949',
	Ubrcy: '\u040E',
	ubrcy: '\u045E',
	Ubreve: '\u016C',
	ubreve: '\u016D',
	Ucirc: '\u00DB',
	ucirc: '\u00FB',
	Ucy: '\u0423',
	ucy: '\u0443',
	udarr: '\u21C5',
	Udblac: '\u0170',
	udblac: '\u0171',
	udhar: '\u296E',
	ufisht: '\u297E',
	Ufr: '\uD835\uDD18',
	ufr: '\uD835\uDD32',
	Ugrave: '\u00D9',
	ugrave: '\u00F9',
	uHar: '\u2963',
	uharl: '\u21BF',
	uharr: '\u21BE',
	uhblk: '\u2580',
	ulcorn: '\u231C',
	ulcorner: '\u231C',
	ulcrop: '\u230F',
	ultri: '\u25F8',
	Umacr: '\u016A',
	umacr: '\u016B',
	uml: '\u00A8',
	UnderBar: '\u005F',
	UnderBrace: '\u23DF',
	UnderBracket: '\u23B5',
	UnderParenthesis: '\u23DD',
	Union: '\u22C3',
	UnionPlus: '\u228E',
	Uogon: '\u0172',
	uogon: '\u0173',
	Uopf: '\uD835\uDD4C',
	uopf: '\uD835\uDD66',
	UpArrow: '\u2191',
	Uparrow: '\u21D1',
	uparrow: '\u2191',
	UpArrowBar: '\u2912',
	UpArrowDownArrow: '\u21C5',
	UpDownArrow: '\u2195',
	Updownarrow: '\u21D5',
	updownarrow: '\u2195',
	UpEquilibrium: '\u296E',
	upharpoonleft: '\u21BF',
	upharpoonright: '\u21BE',
	uplus: '\u228E',
	UpperLeftArrow: '\u2196',
	UpperRightArrow: '\u2197',
	Upsi: '\u03D2',
	upsi: '\u03C5',
	upsih: '\u03D2',
	Upsilon: '\u03A5',
	upsilon: '\u03C5',
	UpTee: '\u22A5',
	UpTeeArrow: '\u21A5',
	upuparrows: '\u21C8',
	urcorn: '\u231D',
	urcorner: '\u231D',
	urcrop: '\u230E',
	Uring: '\u016E',
	uring: '\u016F',
	urtri: '\u25F9',
	Uscr: '\uD835\uDCB0',
	uscr: '\uD835\uDCCA',
	utdot: '\u22F0',
	Utilde: '\u0168',
	utilde: '\u0169',
	utri: '\u25B5',
	utrif: '\u25B4',
	uuarr: '\u21C8',
	Uuml: '\u00DC',
	uuml: '\u00FC',
	uwangle: '\u29A7',
	vangrt: '\u299C',
	varepsilon: '\u03F5',
	varkappa: '\u03F0',
	varnothing: '\u2205',
	varphi: '\u03D5',
	varpi: '\u03D6',
	varpropto: '\u221D',
	vArr: '\u21D5',
	varr: '\u2195',
	varrho: '\u03F1',
	varsigma: '\u03C2',
	varsubsetneq: '\u228A\uFE00',
	varsubsetneqq: '\u2ACB\uFE00',
	varsupsetneq: '\u228B\uFE00',
	varsupsetneqq: '\u2ACC\uFE00',
	vartheta: '\u03D1',
	vartriangleleft: '\u22B2',
	vartriangleright: '\u22B3',
	Vbar: '\u2AEB',
	vBar: '\u2AE8',
	vBarv: '\u2AE9',
	Vcy: '\u0412',
	vcy: '\u0432',
	VDash: '\u22AB',
	Vdash: '\u22A9',
	vDash: '\u22A8',
	vdash: '\u22A2',
	Vdashl: '\u2AE6',
	Vee: '\u22C1',
	vee: '\u2228',
	veebar: '\u22BB',
	veeeq: '\u225A',
	vellip: '\u22EE',
	Verbar: '\u2016',
	verbar: '\u007C',
	Vert: '\u2016',
	vert: '\u007C',
	VerticalBar: '\u2223',
	VerticalLine: '\u007C',
	VerticalSeparator: '\u2758',
	VerticalTilde: '\u2240',
	VeryThinSpace: '\u200A',
	Vfr: '\uD835\uDD19',
	vfr: '\uD835\uDD33',
	vltri: '\u22B2',
	vnsub: '\u2282\u20D2',
	vnsup: '\u2283\u20D2',
	Vopf: '\uD835\uDD4D',
	vopf: '\uD835\uDD67',
	vprop: '\u221D',
	vrtri: '\u22B3',
	Vscr: '\uD835\uDCB1',
	vscr: '\uD835\uDCCB',
	vsubnE: '\u2ACB\uFE00',
	vsubne: '\u228A\uFE00',
	vsupnE: '\u2ACC\uFE00',
	vsupne: '\u228B\uFE00',
	Vvdash: '\u22AA',
	vzigzag: '\u299A',
	Wcirc: '\u0174',
	wcirc: '\u0175',
	wedbar: '\u2A5F',
	Wedge: '\u22C0',
	wedge: '\u2227',
	wedgeq: '\u2259',
	weierp: '\u2118',
	Wfr: '\uD835\uDD1A',
	wfr: '\uD835\uDD34',
	Wopf: '\uD835\uDD4E',
	wopf: '\uD835\uDD68',
	wp: '\u2118',
	wr: '\u2240',
	wreath: '\u2240',
	Wscr: '\uD835\uDCB2',
	wscr: '\uD835\uDCCC',
	xcap: '\u22C2',
	xcirc: '\u25EF',
	xcup: '\u22C3',
	xdtri: '\u25BD',
	Xfr: '\uD835\uDD1B',
	xfr: '\uD835\uDD35',
	xhArr: '\u27FA',
	xharr: '\u27F7',
	Xi: '\u039E',
	xi: '\u03BE',
	xlArr: '\u27F8',
	xlarr: '\u27F5',
	xmap: '\u27FC',
	xnis: '\u22FB',
	xodot: '\u2A00',
	Xopf: '\uD835\uDD4F',
	xopf: '\uD835\uDD69',
	xoplus: '\u2A01',
	xotime: '\u2A02',
	xrArr: '\u27F9',
	xrarr: '\u27F6',
	Xscr: '\uD835\uDCB3',
	xscr: '\uD835\uDCCD',
	xsqcup: '\u2A06',
	xuplus: '\u2A04',
	xutri: '\u25B3',
	xvee: '\u22C1',
	xwedge: '\u22C0',
	Yacute: '\u00DD',
	yacute: '\u00FD',
	YAcy: '\u042F',
	yacy: '\u044F',
	Ycirc: '\u0176',
	ycirc: '\u0177',
	Ycy: '\u042B',
	ycy: '\u044B',
	yen: '\u00A5',
	Yfr: '\uD835\uDD1C',
	yfr: '\uD835\uDD36',
	YIcy: '\u0407',
	yicy: '\u0457',
	Yopf: '\uD835\uDD50',
	yopf: '\uD835\uDD6A',
	Yscr: '\uD835\uDCB4',
	yscr: '\uD835\uDCCE',
	YUcy: '\u042E',
	yucy: '\u044E',
	Yuml: '\u0178',
	yuml: '\u00FF',
	Zacute: '\u0179',
	zacute: '\u017A',
	Zcaron: '\u017D',
	zcaron: '\u017E',
	Zcy: '\u0417',
	zcy: '\u0437',
	Zdot: '\u017B',
	zdot: '\u017C',
	zeetrf: '\u2128',
	ZeroWidthSpace: '\u200B',
	Zeta: '\u0396',
	zeta: '\u03B6',
	Zfr: '\u2128',
	zfr: '\uD835\uDD37',
	ZHcy: '\u0416',
	zhcy: '\u0436',
	zigrarr: '\u21DD',
	Zopf: '\u2124',
	zopf: '\uD835\uDD6B',
	Zscr: '\uD835\uDCB5',
	zscr: '\uD835\uDCCF',
	zwj: '\u200D',
	zwnj: '\u200C',
});

/**
 * @deprecated use `HTML_ENTITIES` instead
 * @see HTML_ENTITIES
 */
exports.entityMap = exports.HTML_ENTITIES;


/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var dom = __webpack_require__(/*! ./dom */ "./node_modules/@xmldom/xmldom/lib/dom.js")
exports.DOMImplementation = dom.DOMImplementation
exports.XMLSerializer = dom.XMLSerializer
exports.DOMParser = __webpack_require__(/*! ./dom-parser */ "./node_modules/@xmldom/xmldom/lib/dom-parser.js").DOMParser


/***/ }),

/***/ "./node_modules/@xmldom/xmldom/lib/sax.js":
/*!************************************************!*\
  !*** ./node_modules/@xmldom/xmldom/lib/sax.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var NAMESPACE = (__webpack_require__(/*! ./conventions */ "./node_modules/@xmldom/xmldom/lib/conventions.js").NAMESPACE);

//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
//[5]   	Name	   ::=   	NameStartChar (NameChar)*
var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]///\u10000-\uEFFFF
var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
var S_TAG = 0;//tag name offerring
var S_ATTR = 1;//attr name offerring
var S_ATTR_SPACE=2;//attr name end and space offer
var S_EQ = 3;//=space?
var S_ATTR_NOQUOT_VALUE = 4;//attr value(no quot value only)
var S_ATTR_END = 5;//attr value end and no space(quot end)
var S_TAG_SPACE = 6;//(attr value end || tag end ) && (space offer)
var S_TAG_CLOSE = 7;//closed el<el />

/**
 * Creates an error that will not be caught by XMLReader aka the SAX parser.
 *
 * @param {string} message
 * @param {any?} locator Optional, can provide details about the location in the source
 * @constructor
 */
function ParseError(message, locator) {
	this.message = message
	this.locator = locator
	if(Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
}
ParseError.prototype = new Error();
ParseError.prototype.name = ParseError.name

function XMLReader(){

}

XMLReader.prototype = {
	parse:function(source,defaultNSMap,entityMap){
		var domBuilder = this.domBuilder;
		domBuilder.startDocument();
		_copy(defaultNSMap ,defaultNSMap = {})
		parse(source,defaultNSMap,entityMap,
				domBuilder,this.errorHandler);
		domBuilder.endDocument();
	}
}
function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
	function fixedFromCharCode(code) {
		// String.prototype.fromCharCode does not supports
		// > 2 bytes unicode chars directly
		if (code > 0xffff) {
			code -= 0x10000;
			var surrogate1 = 0xd800 + (code >> 10)
				, surrogate2 = 0xdc00 + (code & 0x3ff);

			return String.fromCharCode(surrogate1, surrogate2);
		} else {
			return String.fromCharCode(code);
		}
	}
	function entityReplacer(a){
		var k = a.slice(1,-1);
		if (Object.hasOwnProperty.call(entityMap, k)) {
			return entityMap[k];
		}else if(k.charAt(0) === '#'){
			return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
		}else{
			errorHandler.error('entity not found:'+a);
			return a;
		}
	}
	function appendText(end){//has some bugs
		if(end>start){
			var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
			locator&&position(start);
			domBuilder.characters(xt,0,end-start);
			start = end
		}
	}
	function position(p,m){
		while(p>=lineEnd && (m = linePattern.exec(source))){
			lineStart = m.index;
			lineEnd = lineStart + m[0].length;
			locator.lineNumber++;
			//console.log('line++:',locator,startPos,endPos)
		}
		locator.columnNumber = p-lineStart+1;
	}
	var lineStart = 0;
	var lineEnd = 0;
	var linePattern = /.*(?:\r\n?|\n)|.*$/g
	var locator = domBuilder.locator;

	var parseStack = [{currentNSMap:defaultNSMapCopy}]
	var closeMap = {};
	var start = 0;
	while(true){
		try{
			var tagStart = source.indexOf('<',start);
			if(tagStart<0){
				if(!source.substr(start).match(/^\s*$/)){
					var doc = domBuilder.doc;
	    			var text = doc.createTextNode(source.substr(start));
	    			doc.appendChild(text);
	    			domBuilder.currentElement = text;
				}
				return;
			}
			if(tagStart>start){
				appendText(tagStart);
			}
			switch(source.charAt(tagStart+1)){
			case '/':
				var end = source.indexOf('>',tagStart+3);
				var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, '');
				var config = parseStack.pop();
				if(end<0){

	        		tagName = source.substring(tagStart+2).replace(/[\s<].*/,'');
	        		errorHandler.error("end tag name: "+tagName+' is not complete:'+config.tagName);
	        		end = tagStart+1+tagName.length;
	        	}else if(tagName.match(/\s</)){
	        		tagName = tagName.replace(/[\s<].*/,'');
	        		errorHandler.error("end tag name: "+tagName+' maybe not complete');
	        		end = tagStart+1+tagName.length;
				}
				var localNSMap = config.localNSMap;
				var endMatch = config.tagName == tagName;
				var endIgnoreCaseMach = endMatch || config.tagName&&config.tagName.toLowerCase() == tagName.toLowerCase()
		        if(endIgnoreCaseMach){
		        	domBuilder.endElement(config.uri,config.localName,tagName);
					if(localNSMap){
						for (var prefix in localNSMap) {
							if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
								domBuilder.endPrefixMapping(prefix);
							}
						}
					}
					if(!endMatch){
		            	errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName ); // No known test case
					}
		        }else{
		        	parseStack.push(config)
		        }

				end++;
				break;
				// end elment
			case '?':// <?...?>
				locator&&position(tagStart);
				end = parseInstruction(source,tagStart,domBuilder);
				break;
			case '!':// <!doctype,<![CDATA,<!--
				locator&&position(tagStart);
				end = parseDCC(source,tagStart,domBuilder,errorHandler);
				break;
			default:
				locator&&position(tagStart);
				var el = new ElementAttributes();
				var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
				//elStartEnd
				var end = parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);
				var len = el.length;


				if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
					el.closed = true;
					if(!entityMap.nbsp){
						errorHandler.warning('unclosed xml attribute');
					}
				}
				if(locator && len){
					var locator2 = copyLocator(locator,{});
					//try{//attribute position fixed
					for(var i = 0;i<len;i++){
						var a = el[i];
						position(a.offset);
						a.locator = copyLocator(locator,{});
					}
					domBuilder.locator = locator2
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
					domBuilder.locator = locator;
				}else{
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
				}

				if (NAMESPACE.isHTML(el.uri) && !el.closed) {
					end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)
				} else {
					end++;
				}
			}
		}catch(e){
			if (e instanceof ParseError) {
				throw e;
			}
			errorHandler.error('element parse error: '+e)
			end = -1;
		}
		if(end>start){
			start = end;
		}else{
			//TODO: 这里有可能sax回退，有位置错误风险
			appendText(Math.max(tagStart,start)+1);
		}
	}
}
function copyLocator(f,t){
	t.lineNumber = f.lineNumber;
	t.columnNumber = f.columnNumber;
	return t;
}

/**
 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
 */
function parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){

	/**
	 * @param {string} qname
	 * @param {string} value
	 * @param {number} startIndex
	 */
	function addAttribute(qname, value, startIndex) {
		if (el.attributeNames.hasOwnProperty(qname)) {
			errorHandler.fatalError('Attribute ' + qname + ' redefined')
		}
		el.addValue(
			qname,
			// @see https://www.w3.org/TR/xml/#AVNormalize
			// since the xmldom sax parser does not "interpret" DTD the following is not implemented:
			// - recursive replacement of (DTD) entity references
			// - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
			value.replace(/[\t\n\r]/g, ' ').replace(/&#?\w+;/g, entityReplacer),
			startIndex
		)
	}
	var attrName;
	var value;
	var p = ++start;
	var s = S_TAG;//status
	while(true){
		var c = source.charAt(p);
		switch(c){
		case '=':
			if(s === S_ATTR){//attrName
				attrName = source.slice(start,p);
				s = S_EQ;
			}else if(s === S_ATTR_SPACE){
				s = S_EQ;
			}else{
				//fatalError: equal must after attrName or space after attrName
				throw new Error('attribute equal must after attrName'); // No known test case
			}
			break;
		case '\'':
		case '"':
			if(s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE
				){//equal
				if(s === S_ATTR){
					errorHandler.warning('attribute value must after "="')
					attrName = source.slice(start,p)
				}
				start = p+1;
				p = source.indexOf(c,start)
				if(p>0){
					value = source.slice(start, p);
					addAttribute(attrName, value, start-1);
					s = S_ATTR_END;
				}else{
					//fatalError: no end quot match
					throw new Error('attribute value no end \''+c+'\' match');
				}
			}else if(s == S_ATTR_NOQUOT_VALUE){
				value = source.slice(start, p);
				addAttribute(attrName, value, start);
				errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
				start = p+1;
				s = S_ATTR_END
			}else{
				//fatalError: no equal before
				throw new Error('attribute value must after "="'); // No known test case
			}
			break;
		case '/':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				s =S_TAG_CLOSE;
				el.closed = true;
			case S_ATTR_NOQUOT_VALUE:
			case S_ATTR:
				break;
				case S_ATTR_SPACE:
					el.closed = true;
				break;
			//case S_EQ:
			default:
				throw new Error("attribute invalid close char('/')") // No known test case
			}
			break;
		case ''://end document
			errorHandler.error('unexpected end of input');
			if(s == S_TAG){
				el.setTagName(source.slice(start,p));
			}
			return p;
		case '>':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				break;//normal
			case S_ATTR_NOQUOT_VALUE://Compatible state
			case S_ATTR:
				value = source.slice(start,p);
				if(value.slice(-1) === '/'){
					el.closed  = true;
					value = value.slice(0,-1)
				}
			case S_ATTR_SPACE:
				if(s === S_ATTR_SPACE){
					value = attrName;
				}
				if(s == S_ATTR_NOQUOT_VALUE){
					errorHandler.warning('attribute "'+value+'" missed quot(")!');
					addAttribute(attrName, value, start)
				}else{
					if(!NAMESPACE.isHTML(currentNSMap['']) || !value.match(/^(?:disabled|checked|selected)$/i)){
						errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')
					}
					addAttribute(value, value, start)
				}
				break;
			case S_EQ:
				throw new Error('attribute value missed!!');
			}
//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
			return p;
		/*xml space '\x20' | #x9 | #xD | #xA; */
		case '\u0080':
			c = ' ';
		default:
			if(c<= ' '){//space
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));//tagName
					s = S_TAG_SPACE;
					break;
				case S_ATTR:
					attrName = source.slice(start,p)
					s = S_ATTR_SPACE;
					break;
				case S_ATTR_NOQUOT_VALUE:
					var value = source.slice(start, p);
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					addAttribute(attrName, value, start)
				case S_ATTR_END:
					s = S_TAG_SPACE;
					break;
				//case S_TAG_SPACE:
				//case S_EQ:
				//case S_ATTR_SPACE:
				//	void();break;
				//case S_TAG_CLOSE:
					//ignore warning
				}
			}else{//not space
//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
				switch(s){
				//case S_TAG:void();break;
				//case S_ATTR:void();break;
				//case S_ATTR_NOQUOT_VALUE:void();break;
				case S_ATTR_SPACE:
					var tagName =  el.tagName;
					if (!NAMESPACE.isHTML(currentNSMap['']) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
						errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead2!!')
					}
					addAttribute(attrName, attrName, start);
					start = p;
					s = S_ATTR;
					break;
				case S_ATTR_END:
					errorHandler.warning('attribute space is required"'+attrName+'"!!')
				case S_TAG_SPACE:
					s = S_ATTR;
					start = p;
					break;
				case S_EQ:
					s = S_ATTR_NOQUOT_VALUE;
					start = p;
					break;
				case S_TAG_CLOSE:
					throw new Error("elements closed character '/' and '>' must be connected to");
				}
			}
		}//end outer switch
		//console.log('p++',p)
		p++;
	}
}
/**
 * @return true if has new namespace define
 */
function appendElement(el,domBuilder,currentNSMap){
	var tagName = el.tagName;
	var localNSMap = null;
	//var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
	var i = el.length;
	while(i--){
		var a = el[i];
		var qName = a.qName;
		var value = a.value;
		var nsp = qName.indexOf(':');
		if(nsp>0){
			var prefix = a.prefix = qName.slice(0,nsp);
			var localName = qName.slice(nsp+1);
			var nsPrefix = prefix === 'xmlns' && localName
		}else{
			localName = qName;
			prefix = null
			nsPrefix = qName === 'xmlns' && ''
		}
		//can not set prefix,because prefix !== ''
		a.localName = localName ;
		//prefix == null for no ns prefix attribute
		if(nsPrefix !== false){//hack!!
			if(localNSMap == null){
				localNSMap = {}
				//console.log(currentNSMap,0)
				_copy(currentNSMap,currentNSMap={})
				//console.log(currentNSMap,1)
			}
			currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
			a.uri = NAMESPACE.XMLNS
			domBuilder.startPrefixMapping(nsPrefix, value)
		}
	}
	var i = el.length;
	while(i--){
		a = el[i];
		var prefix = a.prefix;
		if(prefix){//no prefix attribute has no namespace
			if(prefix === 'xml'){
				a.uri = NAMESPACE.XML;
			}if(prefix !== 'xmlns'){
				a.uri = currentNSMap[prefix || '']

				//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
			}
		}
	}
	var nsp = tagName.indexOf(':');
	if(nsp>0){
		prefix = el.prefix = tagName.slice(0,nsp);
		localName = el.localName = tagName.slice(nsp+1);
	}else{
		prefix = null;//important!!
		localName = el.localName = tagName;
	}
	//no prefix element has default namespace
	var ns = el.uri = currentNSMap[prefix || ''];
	domBuilder.startElement(ns,localName,tagName,el);
	//endPrefixMapping and startPrefixMapping have not any help for dom builder
	//localNSMap = null
	if(el.closed){
		domBuilder.endElement(ns,localName,tagName);
		if(localNSMap){
			for (prefix in localNSMap) {
				if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
					domBuilder.endPrefixMapping(prefix);
				}
			}
		}
	}else{
		el.currentNSMap = currentNSMap;
		el.localNSMap = localNSMap;
		//parseStack.push(el);
		return true;
	}
}
function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
	if(/^(?:script|textarea)$/i.test(tagName)){
		var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
		var text = source.substring(elStartEnd+1,elEndStart);
		if(/[&<]/.test(text)){
			if(/^script$/i.test(tagName)){
				//if(!/\]\]>/.test(text)){
					//lexHandler.startCDATA();
					domBuilder.characters(text,0,text.length);
					//lexHandler.endCDATA();
					return elEndStart;
				//}
			}//}else{//text area
				text = text.replace(/&#?\w+;/g,entityReplacer);
				domBuilder.characters(text,0,text.length);
				return elEndStart;
			//}

		}
	}
	return elStartEnd+1;
}
function fixSelfClosed(source,elStartEnd,tagName,closeMap){
	//if(tagName in closeMap){
	var pos = closeMap[tagName];
	if(pos == null){
		//console.log(tagName)
		pos =  source.lastIndexOf('</'+tagName+'>')
		if(pos<elStartEnd){//忘记闭合
			pos = source.lastIndexOf('</'+tagName)
		}
		closeMap[tagName] =pos
	}
	return pos<elStartEnd;
	//}
}

function _copy (source, target) {
	for (var n in source) {
		if (Object.prototype.hasOwnProperty.call(source, n)) {
			target[n] = source[n];
		}
	}
}

function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
	var next= source.charAt(start+2)
	switch(next){
	case '-':
		if(source.charAt(start + 3) === '-'){
			var end = source.indexOf('-->',start+4);
			//append comment source.substring(4,end)//<!--
			if(end>start){
				domBuilder.comment(source,start+4,end-start-4);
				return end+3;
			}else{
				errorHandler.error("Unclosed comment");
				return -1;
			}
		}else{
			//error
			return -1;
		}
	default:
		if(source.substr(start+3,6) == 'CDATA['){
			var end = source.indexOf(']]>',start+9);
			domBuilder.startCDATA();
			domBuilder.characters(source,start+9,end-start-9);
			domBuilder.endCDATA()
			return end+3;
		}
		//<!DOCTYPE
		//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId)
		var matchs = split(source,start);
		var len = matchs.length;
		if(len>1 && /!doctype/i.test(matchs[0][0])){
			var name = matchs[1][0];
			var pubid = false;
			var sysid = false;
			if(len>3){
				if(/^public$/i.test(matchs[2][0])){
					pubid = matchs[3][0];
					sysid = len>4 && matchs[4][0];
				}else if(/^system$/i.test(matchs[2][0])){
					sysid = matchs[3][0];
				}
			}
			var lastMatch = matchs[len-1]
			domBuilder.startDTD(name, pubid, sysid);
			domBuilder.endDTD();

			return lastMatch.index+lastMatch[0].length
		}
	}
	return -1;
}



function parseInstruction(source,start,domBuilder){
	var end = source.indexOf('?>',start);
	if(end){
		var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
		if(match){
			var len = match[0].length;
			domBuilder.processingInstruction(match[1], match[2]) ;
			return end+2;
		}else{//error
			return -1;
		}
	}
	return -1;
}

function ElementAttributes(){
	this.attributeNames = {}
}
ElementAttributes.prototype = {
	setTagName:function(tagName){
		if(!tagNamePattern.test(tagName)){
			throw new Error('invalid tagName:'+tagName)
		}
		this.tagName = tagName
	},
	addValue:function(qName, value, offset) {
		if(!tagNamePattern.test(qName)){
			throw new Error('invalid attribute:'+qName)
		}
		this.attributeNames[qName] = this.length;
		this[this.length++] = {qName:qName,value:value,offset:offset}
	},
	length:0,
	getLocalName:function(i){return this[i].localName},
	getLocator:function(i){return this[i].locator},
	getQName:function(i){return this[i].qName},
	getURI:function(i){return this[i].uri},
	getValue:function(i){return this[i].value}
//	,getIndex:function(uri, localName)){
//		if(localName){
//
//		}else{
//			var qName = uri
//		}
//	},
//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
//	getType:function(uri,localName){}
//	getType:function(i){},
}



function split(source,start){
	var match;
	var buf = [];
	var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
	reg.lastIndex = start;
	reg.exec(source);//skip <
	while(match = reg.exec(source)){
		buf.push(match);
		if(match[1])return buf;
	}
}

exports.XMLReader = XMLReader;
exports.ParseError = ParseError;


/***/ }),

/***/ "./src/packages/Controls/Control.js":
/*!******************************************!*\
  !*** ./src/packages/Controls/Control.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ol/control/Control */ "ol/control/Control");
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_control_Control__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ControlExtended = /*#__PURE__*/function (_Control) {
  function ControlExtended(options) {
    _classCallCheck(this, ControlExtended);
    return _callSuper(this, ControlExtended, [options]);
  }
  _inherits(ControlExtended, _Control);
  return _createClass(ControlExtended, [{
    key: "setPosition",
    value: function setPosition(pos) {
      var instance = new PositionFactory(this);
      instance.set(pos);
    }
  }]);
}((ol_control_Control__WEBPACK_IMPORTED_MODULE_0___default()));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ControlExtended);

/**
 * gestion des anchors
 */
var ANCHORS = ["top-left", "top-right", "bottom-left", "bottom-right"];

/**
 * Position
 * @private
 * @todo revoir les css des widgets car les panneaux sont en position:absolute
 */
var _PositionFactory_brand = /*#__PURE__*/new WeakSet();
var PositionFactory = /*#__PURE__*/function () {
  /**
   * constructor
   * @param {*} caller - ...
   */
  function PositionFactory(caller) {
    _classCallCheck(this, PositionFactory);
    /**
     * ...
     * @param {*} name  - ...
     * @returns {Boolean} ...
     */
    _classPrivateMethodInitSpec(this, _PositionFactory_brand);
    this.caller = caller;
    _assertClassBrand(_PositionFactory_brand, this, _createContainer).call(this, "top-left");
    _assertClassBrand(_PositionFactory_brand, this, _createContainer).call(this, "top-right");
    _assertClassBrand(_PositionFactory_brand, this, _createContainer).call(this, "bottom-left");
    _assertClassBrand(_PositionFactory_brand, this, _createContainer).call(this, "bottom-right");
    return this;
  }
  return _createClass(PositionFactory, [{
    key: "set",
    value:
    /**
     * ...
     * @param {*} pos - ...
     * @public
     */
    function set(pos) {
      if (!ANCHORS.includes(pos.toLowerCase())) {
        return;
      }
      // positionnement de l'element
      _assertClassBrand(_PositionFactory_brand, this, _setAnchor).call(this, pos);
      document.getElementById("position-container-" + pos).appendChild(this.caller.element);
    }
  }]);
}();
function _existContainer(name) {
  var div = document.getElementById("position-container-" + name);
  if (div) {
    return true;
  }
  return false;
}
/**
 * ...
 * @param {*} name - ...
 * @private
 */
function _createContainer(name) {
  if (_assertClassBrand(_PositionFactory_brand, this, _existContainer).call(this, name)) {
    return;
  }
  // INFO
  // positionner les classes position-container-[left|right|top|bottom]
  // ex. { position:relative; height:50px; width:100%; }
  var div = document.createElement("div");
  div.id = "position-container-" + name;
  div.className = "position-container-" + name;
  var container = this.caller.getMap().getOverlayContainerStopEvent();
  container.appendChild(div);
}
/**
 * ...
 * @param {*} pos - ...
 * @todo
 */
function _setAnchor(pos) {
  var sizeW = function sizeW(pos) {
    var element = document.getElementById("position-container-" + pos);
    var width = element.offsetWidth;
    return width;
  };
  var sizeH = function sizeH(pos) {
    var element = document.getElementById("position-container-" + pos);
    var height = element.offsetHeight;
    return height;
  };
  var clear = function clear(element) {
    element.style.top = "unset";
    element.style.bottom = "unset";
    element.style.left = "unset";
    element.style.right = "unset";
  };

  // on supprime le style de positionnement (top, left...) 
  // car on souhaite une nouvelle position
  clear(this.caller.element);
  this.caller.element.style.position = "unset"; // div.GPwidget

  // on recherche les panneaux (panel) :
  // * panel de formulaire
  // * panel de resultats
  var panels = Array.from(this.caller.element.getElementsByClassName("GPpanel"));
  if (panels.length === 0) {
    return;
  }
  panels.forEach(function (e) {
    clear(e);
  });
  var panel = panels[0];
  // on modifie le positionnement du menu (dialog ou div : panel) 
  // en fonction du bouton
  // ex. bouton : bottom-left, menu : bottom:0px; left:50px
  switch (pos.toLowerCase()) {
    case "top-left":
      panel.style.top = "0px";
      panel.style.left = sizeW(pos) + "px"; // container 50px + padding de 5px
      break;
    case "bottom-left":
      panel.style.bottom = "0px";
      panel.style.left = sizeW(pos) + "px";
      break;
    case "top-right":
      panel.style.top = "0px";
      panel.style.right = sizeW(pos) + "px";
      break;
    case "bottom-right":
      panel.style.bottom = "0px";
      panel.style.right = sizeW(pos) + "px";
      break;
    default:
      break;
  }
}
;

/***/ }),

/***/ "./src/packages/Controls/Editor/Editor.js":
/*!************************************************!*\
  !*** ./src/packages/Controls/Editor/Editor.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CSS_Controls_Editor_GPFeditor_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../CSS/Controls/Editor/GPFeditor.css */ "./src/packages/CSS/Controls/Editor/GPFeditor.css");
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eventbusjs */ "./node_modules/eventbusjs/lib/eventbus.min.js");
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(eventbusjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Utils/Helper */ "./src/packages/Utils/Helper.js");
/* harmony import */ var _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Utils/SelectorID */ "./src/packages/Utils/SelectorID.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
/* harmony import */ var _Style__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Style */ "./src/packages/Controls/Editor/Style.js");
/* harmony import */ var _Themes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Themes */ "./src/packages/Controls/Editor/Themes.js");
/* harmony import */ var _Filter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Filter */ "./src/packages/Controls/Editor/Filter.js");
/* harmony import */ var _Legend__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Legend */ "./src/packages/Controls/Editor/Legend.js");
/* harmony import */ var _Layer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Layer */ "./src/packages/Controls/Editor/Layer.js");
/* harmony import */ var _Group__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Group */ "./src/packages/Controls/Editor/Group.js");
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Event */ "./src/packages/Controls/Editor/Event.js");
/* harmony import */ var _Search__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Search */ "./src/packages/Controls/Editor/Search.js");
/* harmony import */ var _EditorDOM__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./EditorDOM */ "./src/packages/Controls/Editor/EditorDOM.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// import CSS

// import "../../CSS/Controls/Editor/GPFeditorStyle.css";
// import library

// import local












// DOM

var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__["default"].getLogger("editor");

/**
 * @classdesc
 *
 * Editor Styles MapBox...
 *
 * @constructor
 * @alias ol.style.Editor
 * @param {Object} options - options for function call.
 * @fires editor:layer:onclickvisibility
 * @fires editor:layer:onclickclone
 * @fires editor:layer:onclickremove
 * @fires editor:style:oneditjson
 * @fires editor:style:scale:onchangemin
 * @fires editor:style:scale:onchangemax
 * @fires editor:legend:onclickedition
 * @fires editor:legend:onchangevalue
 * @fires editor:filter:oneditjson
 * @fires editor:themes:onclickimage
 * @fires editor:themes:onclicktitle
 * @fires editor:group:oncollapse
 * @fires editor:onloaded
 * @example
 *   var editor = new Editor ({
 *      target : "",
 *      style : "data/styles/layer.json",
 *      themes: {
 *          themesSummary : "",
 *          themes : [{
 *             "thumbnail": "data/images/layer0.png",
 *             "name": "standard0",
 *             "url": "data/styles/layer0.json",
 *             "description": "",
 *             "selected" : true
 *          },{
 *             "thumbnail": "data/images/layer1.png",
 *             "name": "standard1",
 *             "url": "data/styles/layer1.json",
 *             "description": ""
 *          }]
 *      },
 *      scope : this,
 *      events : {
 *          "editor:layer:onclickvisibility" : ...,
 *          "editor:layer:onclickclone" : ...,
 *          "editor:layer:onclickremove" : ...,
 *          "editor:style:oneditjson" : ...,
 *          "editor:style:scale:onchangemin" : ...,
 *          "editor:style:scale:onchangemax" : ...,
 *          "editor:filter:oneditjson" : ...,
 *          "editor:themes:onclickimage" : this._onClickEventImageTheme(),
 *          "editor:themes:onclicktitle" : function(e) {...}
 *      },
 *      tools : {
 *          // afficher/cacher les themes (par defaut) ou utiliser les options
 *          themes : true | false | {
 *              target : "...",
 *              tools : {
 *                  "thumbnails": true,
 *                  "button": { visible : true, type : "checkbox" }
 *              },
 *          },
 *          layers : true | false,     // afficher les couches (layers)
 *          search : true | false,     // TODO : afficher l'outil de recheche de couches
 *          style : true | false,      // afficher les styles (sous menu layers)
 *          filter : true | false,     // afficher les filtres (sous menu layers)
 *          legend : true | false,     // afficher les legendes (layers)
 *          group : true | false,      // grouper les couches, l'option 'sort' doit être activée (layers)
 *          groupAuto : true | false,  // definir la construction automatiques des groupes
 *          sort : true | false,       // trier les couches (layers)
 *          sortBy : "id|class|geom",  // definir le type de tri (layers)
 *          sortOrder : "asc, desc",   // definir l'ordre de tri (layers)
 *          title : true | false       // afficher les titres des rubriques,
 *          collapse : true | false | undefined // afficher et/ou plier les couches ou ne pas afficher l'option,
 *          type : true | false,       // afficher le type de geometrie (layers)
 *          pin : true | false,        // afficher la puce pour chaque couche (layers)
 *          visibility : true | false, // afficher l'icone de visibilité (layers),
 *          icon : {                   // afficher l'icone "oeil" ou "checkbox" (layers),
 *              "image" : true,
 *              "anchor" : "start" // afficher l'icone au debut ou à la fin de la ligne
 *          },
 *          editable : true | false    // active l'edition de la legende (legendes)
 *      }
 *   });
 *   // options par defaut
 *   {
 *      themes : false,
 *      layers : true,
 *      search : false,
 *      style : false,
 *      filter : false,
 *      legend : false,
 *      group : false,
 *      groupAuto : false,
 *      sort : true,
 *      sortBy : "id",
 *      sortOrder : "asc",
 *      title : true,
 *      collapse : undefined,
 *      type : true,
 *      pin : true,
 *      visibility : true,
 *      icon : {
 *          image : true,
 *          anchor : "end"
 *      },
 *      editable : true
 *   }
 *   // Context
 *   editor.setContext("map", map);
 *   editor.setContext("layer", layer);
 *   // create DOM
 *   editor.createElement()
 *     .then(() => {
 *       console.warn(editor.getID());
 *       console.log(this.getContext("map"));
 *       console.log(this.getContext("layer"));
 *     })
 *     .catch(error => {});
 *   // possibility to add listeners with globale variable : eventbus
 *   eventbus.addEventListener("editor:style:scale:onchangemin", function (e) {...});
 */
var Editor = /*#__PURE__*/function () {
  function Editor(options) {
    _classCallCheck(this, Editor);
    logger.trace("[constructor] Editor", options);

    // options
    this.options = options || {
      // TODO default...
    };
    if (!(this instanceof Editor)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this._initialize();
  }

  /**
   * Initialize component
   * (called by constructor)
   *
   * @private
   */
  return _createClass(Editor, [{
    key: "_initialize",
    value: function _initialize() {
      // gestion des options
      if (!this.options.target) {
        logger.info("La 'target' n'est pas renseignée (options.target).");
      }
      if (!this.options.style) {
        logger.error("Le 'style' MapBox n'est pas renseigné (options.style) !");
        return;
      }
      if (this.options.events) {
        this._initEvents();
      } else {
        logger.warn("Les 'handlers' ne sont pas renseignés (options.events) !");
      }
      if (!this.options.themes) {
        logger.info("Les 'themes' MapBox ne sont pas renseignés (options.themes).");
      }

      // options par defaut
      var _toolsDefault = {
        themes: false,
        layers: true,
        search: false,
        style: false,
        filter: false,
        legend: false,
        group: false,
        groupAuto: false,
        sort: true,
        sortBy: "id",
        sortOrder: "asc",
        title: true,
        collapse: undefined,
        type: true,
        pin: true,
        visibility: true,
        icon: {
          image: true,
          anchor: "end"
        },
        editable: true
      };
      if (!this.options.tools) {
        logger.trace("Utilisation des outils MapBox par défaut (options.tools).");
        this.options.tools = _toolsDefault;
      }
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_2__["default"].mergeParams(this.options.tools, _toolsDefault, false);

      // id unique
      this.id = this.options.id || _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_3__["default"].generate();

      // context
      this.context = {};
      // property layers
      this.layers = [];
      // dom container
      this.container = null;
      // dom name
      this.name = {
        target: "GPEditorMapBoxTarget",
        container: "GPEditorMapBoxContainer",
        containerID: "GPEditorMapBoxContainer_ID_",
        containerLayers: "GPEditorMapBoxLayersContainer",
        titleLayers: "GPEditorMapBoxLayersTitle",
        titleLayersID: "GPEditorMapBoxLayersTitle_ID_",
        titleThemes: "GPEditorMapBoxThemesTitle",
        titleThemesID: "GPEditorMapBoxThemesTitle_ID_",
        sep: "GPEditorMapBoxSep"
      };
      // style json
      this.mapbox = {};
      // INFO
      // sprites :
      // {
      //     url : null,
      //     size : {
      //         h : null,
      //         w : null
      //     },
      //     json : {}
      // }
      this.sprites = {};
    }

    /**
    * Initialize events with handlers
    * (called by constructor)
    *
    * List Events :
    *          "editor:layer:visibility"
    *          "editor:layer:clone"
    *          "editor:layer:remove"
    *          "editor:style:edit"
    *          "editor:style:minScale"
    *          "editor:style:maxScale"
    *          "editor:filter:edit"
    *          "editor:themes:image",
    *          "editor:themes:title"
    * @private
    */
  }, {
    key: "_initEvents",
    value: function _initEvents() {
      var ctx = this.options.scope || this;
      var events = this.options.events;
      if (events) {
        for (var event in events) {
          if (events.hasOwnProperty(event)) {
            var handler = events[event];
            // test sur les events disponibles !
            if (handler) {
              if (!eventbusjs__WEBPACK_IMPORTED_MODULE_1___default().hasEventListener(event, handler, ctx)) {
                eventbusjs__WEBPACK_IMPORTED_MODULE_1___default().addEventListener(event, handler, ctx);
              }
            }
          }
        }
      }
    }

    /**
     * Graphical rendering of the component
     * (called by constructor)
     *
     * @example
     *  <div class="GPEditorMapBoxContainer" id="GPEditorMapBoxContainer_ID_0">
     *    <div id="GPEditorMapBoxThemesTitle" class="GPEditorMapBoxThemesTitle">Liste des 'thèmes'</div>
     *    <div class="GPEditorMapBoxThemesContainer">
     *      ...
     *    </div>
     *    <div id="GPEditorMapBoxLayersTitle" class="GPEditorMapBoxLayersTitle">Liste des 'couches'</div>
     *    <div class="GPEditorMapBoxLayersContainer">
     *      <div class="GPEditorMapBoxLayerContainer">
     *          <div id="GPEditorMapBoxLayerTitleContainer-0_1" class="GPEditorMapBoxLayerTitleContainer">
     *              <label class="GPEditorMapBoxLayerImageLabel"></label>
     *              <input id="GPEditorMapBoxLayerTitleInput-0_1" class="GPEditorMapBoxLayerTitleInput" type="checkbox">
     *              <label class="GPEditorMapBoxLayerTitleLabel" for="GPEditorMapBoxLayerTitleInput-0_1" title="states">population_lt_2m</label>
     *          </div>
     *      </div>
     *      <div class="GPEditorMapBoxLayerContainer">...</div>
     *      <div class="GPEditorMapBoxLayerContainer">...</div>
     *    </div>
     *  </div>
     * @private
     */
  }, {
    key: "_initContainer",
    value: function _initContainer() {
      logger.trace(this.mapbox);

      // existance d'un autre container (editeur) ?
      // var _idx = 0;
      // var elements = document.querySelectorAll("div[id^=" + this.name.containerID + "]");
      // for (var j = 0; j < elements.length; j++) {
      //     var element = elements[j];
      //     var num = parseInt(element.id.substring(element.id.lastIndexOf("_") + 1), 10);
      //     if (num > _idx) {
      //         _idx = num;
      //     }
      // }
      // if (elements.length) {
      //     _idx += 1;
      // }
      // container principal de l'editeur
      var div = document.createElement("div");
      div.id = this.name.containerID + this.id;
      div.className = this.name.container;

      // Themes
      var _toolsThemes = this.options.tools.themes;
      if (_toolsThemes && this.options.themes) {
        // title
        if (this.options.tools.title) {
          var titleThemes = document.createElement("div");
          titleThemes.id = this.name.titleThemesID + this.id;
          titleThemes.className = this.name.titleThemes;
          titleThemes.innerHTML = "Liste des 'thèmes'";
          div.appendChild(titleThemes);
        }

        // lien vers les styles
        var themes = new _Themes__WEBPACK_IMPORTED_MODULE_6__["default"]({
          id: this.id,
          target: div,
          tools: _typeof(_toolsThemes) === "object" ? _toolsThemes : {},
          obj: this.options.themes
        });
        themes.add();
      }

      // TODO : Recheche / filtre de couches
      if (this.options.tools.search) {
        var search = new _Search__WEBPACK_IMPORTED_MODULE_12__["default"]({
          id: this.id,
          target: div,
          tools: {},
          obj: this.mapbox.layers // liste des objets layers
        });
        search.add();
      }
      for (var source in this.mapbox.sources) {
        if (this.mapbox.sources.hasOwnProperty(source)) {
          if (this.options.tools.layers) {
            // multisources ? Si oui, on renseigne un titre...
            var multisources = Object.keys(this.mapbox.sources).length > 1 ? 1 : 0;
            if (multisources) {
              var hr = document.createElement("hr");
              hr.className = this.name.sep;
              div.appendChild(hr);
            }
            // title
            if (this.options.tools.title) {
              var titleLayers = document.createElement("div");
              titleLayers.id = this.name.titleLayersID + this.id;
              titleLayers.className = this.name.titleLayers;
              titleLayers.innerHTML = multisources ? "Liste des 'couches' (" + source + ")" : "Liste des 'couches'";
              div.appendChild(titleLayers);
            }
          }

          // gestion de l'ordre avant tri avec la metadata 'order'
          var _layers = this.mapbox.layers.slice(); // clone

          // une fois les layers triés, la metadata:geoportail:order permet
          // de savoir l'emplacement du layers dans le fichier de style.
          _layers.forEach(function (layer, order) {
            // on écarte les layers sans source: ex. "background"
            // if (!layer.source) {
            //     return;
            // }
            // ajout de la metadata d'ordre
            var _metadata = layer["metadata"];
            if (_metadata) {
              _metadata["geoportail:order"] = order;
            } else {
              layer["metadata"] = {
                "geoportail:order": order
              };
            }
          });
          // tri des layers
          if (this.options.tools.sort) {
            var sortBy = this.options.tools.sortBy;
            var sortOrder = this.options.tools.sortOrder;
            var sortFct = function sortFct(a, b) {
              // si on utilise les groupements utilisateurs, ils doivent
              // tous être renseignés sinon..., ça va coincer !
              var result = 0;
              if (a["metadata"] && a["metadata"]["geoportail:group"] && b["metadata"] && b["metadata"]["geoportail:group"]) {
                var cmpA = null;
                var cmpB = null;
                cmpA = a["metadata"]["geoportail:group"];
                cmpB = b["metadata"]["geoportail:group"];
                result = cmpA.localeCompare(cmpB);
              } else {
                switch (sortBy) {
                  case "geom":
                    result = sortOrder === "asc" ? a.type.localeCompare(b.type) || a.id.localeCompare(b.id) : b.type.localeCompare(a.type) || b.id.localeCompare(a.id);
                    break;
                  case "class":
                    result = sortOrder === "asc" ? a["source-layer"].localeCompare(b["source-layer"]) || a.id.localeCompare(b.id) : b["source-layer"].localeCompare(a["source-layer"]) || b.id.localeCompare(a.id);
                    break;
                  case "id":
                  default:
                    // tri sur l'id par defaut
                    result = sortOrder === "asc" ? a.id.localeCompare(b.id) : b.id.localeCompare(a.id);
                    break;
                }
              }
              return result;
            };
            _layers.sort(sortFct);
          }
          logger.trace("Layers : ", _layers);

          // gestion des groupes avec la metadata de groupe
          var groupBy = this.options.tools.sortBy; // le même type de tri que les couches !
          var groupAuto = this.options.tools.groupAuto;
          var _groups = {}; // liste et comptage des layers dans chaque groupes
          _layers.forEach(function (layer) {
            // on écarte les layers sans source: ex. "background"
            // if (!layer.source) {
            //     return;
            // }
            // balise metadata
            var _metadata = layer["metadata"];
            // s'il existe déjà une meta de groupe, on l'utilise...
            // sinon, on la met en place.
            if (_metadata && _metadata["geoportail:group"]) {
              var _groupName = _metadata["geoportail:group"];
              _groups[_groupName] = _groups[_groupName] ? _groups[_groupName] + 1 : 1;
            } else {
              var _field = null;
              switch (groupBy) {
                case "class":
                  _field = layer["source-layer"];
                  break;
                case "geom":
                  _field = layer.type;
                  break;
                case "id":
                default:
                  _field = layer.id;
                  break;
              }
              var _newGroupName = _field;
              if (groupAuto) {
                // separateur
                var _regex = /_|-|:|=/; // TODO à definir via une option !

                // index
                var _idx = _field.search(_regex);
                // y'a t il un separateur ?
                _newGroupName = _idx !== -1 ? _field.substring(0, _idx).trim() : _field;
              }
              // on compte le nombre d'entrée dans un groupe
              _groups[_newGroupName] = _groups[_newGroupName] ? _groups[_newGroupName] + 1 : 1;

              // ajout de la metadata de groupe
              if (_metadata) {
                _metadata["geoportail:group"] = _newGroupName;
              } else {
                layer["metadata"] = {
                  "geoportail:group": _newGroupName
                };
              }
            }
          });
          logger.trace("Groups : ", _groups);

          // container principal des couches
          var divLayers = document.createElement("div");
          divLayers.className = this.name.containerLayers;
          div.appendChild(divLayers);
          var details;
          if (this.options.tools.collapse !== undefined) {
            details = document.createElement("details");
            details.className = "";
            details.open = !this.options.tools.collapse;
            divLayers.appendChild(details);
            var summary = document.createElement("summary");
            summary.className = "";
            summary.innerHTML = "";
            details.appendChild(summary);
          }

          // container courant (cf. groupe) pour l'ajout des elements
          var target = this.options.tools.collapse !== undefined ? details : divLayers;

          // Ex. Layers, Styles, Groups et Filtres
          //  "id": "ocs - vegetation",
          //  "type": "fill",
          //  "source": "pyramide_proto",
          //  "source-layer": "ocs_vegetation_surf",
          //  "metadata" : {
          //      "geoportail:group": "ocs"
          //  },
          //  "layout": {
          //    "visibility": "visible"
          //  },
          //  "filter": ["in","symbo",
          //      "SURFACE_D_EAU",
          //      "BASSIN",
          //      "ZONE_MARINE"
          //  ],
          //  "paint": {
          //    "fill-color": "#2BB3E1"
          //  }
          var index = -1;
          for (var ii = 0; ii < _layers.length; ii++) {
            var data = _layers[ii];
            index++;

            // traitement dans l'ordre des sources
            if (data.source === source) {
              // Groups
              // INFO la gestion des groupes est basée sur la balise metadata::geoportail:group
              // ainsi que sur l'ordre des couches.
              // il n'y a pas de regroupement sans tri des couches !
              if (this.options.tools.group && this.options.tools.sort) {
                var mtd = data.metadata;
                // creation du container de groupe
                // si le tag metadata existe
                if (mtd) {
                  var grp = data.metadata["geoportail:group"];
                  if (grp) {
                    // le groupe doit contenir plus d'un element
                    if (_groups[grp] > 1) {
                      // le groupe est déjà créé, on en veut plus par la suite...
                      _groups[grp] = -1;
                      // creation du groupe
                      var oGroup = new _Group__WEBPACK_IMPORTED_MODULE_10__["default"]({
                        id: this.id,
                        target: this.options.tools.collapse !== undefined ? details : divLayers,
                        title: grp,
                        collapse: true
                      });
                      oGroup.add();
                      // le nouveau container pour les elements suivants
                      target = oGroup.getContainer();
                    } else if (_groups[grp] === 1) {
                      // l'element est seul, donc pas d'ajout dans le
                      // groupe en cours
                      target = this.options.tools.collapse !== undefined ? details : divLayers;
                    } else {
                      // on ajoute l'element dans le groupe courant...
                    }
                  } else {
                    target = this.options.tools.collapse !== undefined ? details : divLayers;
                  }
                } else {
                  target = this.options.tools.collapse !== undefined ? details : divLayers;
                }
              }
              // Layers
              if (this.options.tools.layers) {
                var oLayer = new _Layer__WEBPACK_IMPORTED_MODULE_9__["default"]({
                  id: this.id,
                  target: target,
                  position: index + "_" + this.id,
                  // unique !
                  tools: {
                    visibility: this.options.tools.visibility,
                    icon: this.options.tools.icon,
                    type: this.options.tools.type,
                    pin: this.options.tools.pin
                  },
                  obj: {
                    id: data.id,
                    type: data.type,
                    source: data.source,
                    "source-layer": data["source-layer"]
                  }
                });
                oLayer.add();
                // update visibility layer
                if (data.layout && data.layout.visibility && data.layout.visibility === "none") {
                  oLayer.visibility(false);
                }
                // sauvegarde des layers
                this.layers.push(oLayer);
              }
              // Legende
              if (this.options.tools.legend) {
                // gestion de l'edition de la legende :
                // l'option "editable" est prioritaire sur le tag "editable" du fichier de style !
                var isEditable = this.options.tools.editable;
                if (typeof isEditable === "undefined") {
                  isEditable = data.editable;
                }
                var oLegend = new _Legend__WEBPACK_IMPORTED_MODULE_8__["default"]({
                  id: this.id,
                  target: target,
                  sprites: this.sprites,
                  obj: {
                    id: data.id,
                    source: data.source,
                    title: data.id,
                    editable: typeof isEditable !== "undefined" ? isEditable : false,
                    paint: data.paint,
                    layout: data.layout
                  }
                });
                oLegend.add();
                oLegend.display(false);
                if (oLayer) {
                  oLayer.addLegend(oLegend);
                  oLayer.slotLegend(); // integration de la legende dans le container du layers !
                }
              }
              // Style
              if (this.options.tools.style) {
                var oStyle = new _Style__WEBPACK_IMPORTED_MODULE_5__["default"]({
                  id: this.id,
                  target: target,
                  position: index + "_" + this.id,
                  // unique !,
                  obj: {
                    id: data.id,
                    source: data.source,
                    layout: data.layout,
                    paint: data.paint
                  }
                });
                oStyle.add();
                oStyle.display(false);
                if (oLayer) {
                  oLayer.addStyle(oStyle);
                }
                // update visibility layer
                if (data.layout && data.layout.visibility && data.layout.visibility === "none") {
                  oLayer.visibility(false);
                }
              }
              // Filter
              if (this.options.tools.filter) {
                var oFilter = new _Filter__WEBPACK_IMPORTED_MODULE_7__["default"]({
                  id: this.id,
                  target: target,
                  position: index + "_" + this.id,
                  // unique !,
                  obj: {
                    id: data.id,
                    source: data.source,
                    filter: data.Filter
                  }
                });
                oFilter.add();
                oFilter.display(false);
                if (oLayer) {
                  oLayer.addFilter(oFilter);
                }
              }
            } else {
              // on ecarte un layer car il n'est pas reconnu dans la source
              // on decremente la position du layer
              if (index >= 0) {
                index--;
              }
            }
          }
        }
      }

      // sauvegarde
      this.container = div;

      // container principal
      if (!this.options.target) {
        if (!document.getElementById(this.name.target)) {
          var _target = document.createElement("div");
          _target.id = this.name.target;
          var node = document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0] || document.documentElement;
          node.appendChild(_target);
        }
        this.options.target = document.getElementById(this.name.target);
      }
      if (this.container) {
        this.options.target.appendChild(this.container);
      }
      // dispatch event
      eventbusjs__WEBPACK_IMPORTED_MODULE_1___default().dispatch(_Event__WEBPACK_IMPORTED_MODULE_11__["default"].onloaded, this);
    }

    /**
     * Getting Sprites informations
     * (called by _initialize)
     *
     * @param {String} sprites - url des sprites
     * @returns {Promise} - promise
     * @private
     */
  }, {
    key: "_getSprites",
    value: function _getSprites(sprites) {
      var self = this;

      // on ne doit pas mettre de promise en échec...
      // car on souhaite continuer le traitement même si on n'a pas de sprites !
      // si le protocole est mapbox://
      if (sprites && sprites.startsWith("mapbox://")) {
        return new Promise(function (resolve, reject) {
          logger.error("Protocole mapbox:// non géré !");
          resolve(self);
        });
      }
      // si pas de sprites
      if (!sprites) {
        return new Promise(function (resolve, reject) {
          logger.error("Auncun sprites disponibles !");
          resolve(self);
        });
      }
      var fetchSpritesImage = function fetchSpritesImage() {
        var spritesImage = sprites + ".png";
        return fetch(spritesImage, {
          credentials: "same-origin"
        }).then(function (response) {
          if (response.ok) {
            return response.blob().then(function (blob) {
              self.sprites.url = spritesImage;
              // decode de l'image
              var theImage = new Image();
              theImage.src = spritesImage;
              return theImage.decode().then(function () {
                self.sprites.size = {};
                self.sprites.size.h = theImage.height;
                self.sprites.size.w = theImage.width;
              });
            })["catch"](function (error) {
              logger.warn("fetch image sprites exception :", error);
            });
          } else {
            var err = new Error("HTTP status code: " + response.status);
            throw err;
          }
        })["catch"](function (error) {
          return new Promise(function (resolve, reject) {
            logger.error("fetch image sprites exception :", error);
            reject(error);
          });
        });
      };
      var fetchSpritesJson = function fetchSpritesJson() {
        var spritesJson = sprites + ".json";
        return fetch(spritesJson, {
          credentials: "same-origin"
        }).then(function (response) {
          if (response.ok) {
            return response.json().then(function (json) {
              self.sprites.json = json;
            })["catch"](function (error) {
              logger.warn("fetch json sprites exception :", error);
            });
          } else {
            var err = new Error("HTTP status code: " + response.status);
            throw err;
          }
        })["catch"](function (error) {
          return new Promise(function (resolve, reject) {
            logger.error("fetch json sprites exception :", error);
            reject(error);
          });
        });
      };

      // promise
      return Promise.all([fetchSpritesImage(), fetchSpritesJson()]);
    }

    // ################################################################### //
    // ########################## INTERFACE ############################## //
    // ################################################################### //
    /**
     * Create Editor
     *
     * @returns {Promise} - promise
     */
  }, {
    key: "createElement",
    value: function createElement() {
      var self = this;
      // objet json
      if (_typeof(this.options.style) === "object") {
        this.mapbox = this.options.style;
        // les sprites sont utiles que si on veut une legende !
        if (this.options.tools.legend) {
          return this._getSprites(this.mapbox.sprite).then(function () {
            // init du DOM
            self._initContainer();
            return self;
          })["catch"](function (error) {
            logger.warn("fetch sprites exception :", error);
          });
        } else {
          return new Promise(function (resolve, reject) {
            self._initContainer();
            resolve(self);
          });
        }
      }

      // url
      if (typeof this.options.style === "string") {
        return fetch(this.options.style, {
          credentials: "same-origin"
        }).then(function (response) {
          // sauvegarde du json
          return response.json().then(function (style) {
            self.mapbox = style;
          }).then(function () {
            // les sprites sont utiles que si on veut une legende !
            if (self.options.tools.legend) {
              return self._getSprites(self.mapbox.sprite).then(function () {
                // init du DOM
                self._initContainer();
                return self;
              })["catch"](function (error) {
                logger.warn("fetch sprites exception :", error);
              });
            } else {
              return new Promise(function (resolve, reject) {
                self._initContainer();
                resolve(self);
              });
            }
          })["catch"](function (error) {
            logger.error("json exception :", error);
          });
        })["catch"](function (error) {
          logger.error("fetch exception :", error);
        });
      }
    }

    /**
     * Set display container (DOM)
     *
     * @param {Boolean} display - show/hidden container
     */
  }, {
    key: "display",
    value: function display(_display) {
      this.container.style.display = _display ? "block" : "none";
    }
  }, {
    key: "setContext",
    value: function setContext(key, value) {
      this.context[key] = value;
    }
  }, {
    key: "getContext",
    value: function getContext(key) {
      return this.context[key];
    }

    // ################################################################### //
    // ##################### public methods ############################## //
    // ################################################################### //
    /**
     * Get id editor
     * @returns {Number} id
     */
  }, {
    key: "getID",
    value: function getID() {
      return this.id;
    }

    /**
     * Get container (DOM)
     * @returns {DOMElement} DOM element
     */
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this.container;
    }

    /**
     * Get Style (json)
     * @returns {Object} Style MapBox
     */
  }, {
    key: "getStyle",
    value: function getStyle() {
      return this.mapbox;
    }

    /**
     * Get layer style (json)
     * @param {Number} i - index
     * @returns {Object} Style MapBox of a layers
     */
  }, {
    key: "getStyleLayer",
    value: function getStyleLayer(i) {
      var layer = null;
      var o = this.getLayer(i);
      var id = o.options.obj.id;
      for (var k = 0; k < this.mapbox.layers.length; k++) {
        var l = this.mapbox.layers[k];
        if (l.id === id) {
          layer = l;
          break;
        }
      }
      return layer;
    }

    /**
     * Get layer object from json style
     * @param {Number} i - index into style json
     * @returns {Object} Style MapBox of a layers
     */
  }, {
    key: "getLayerFromStyle",
    value: function getLayerFromStyle(i) {
      var layer = null;
      var l = this.mapbox.layers[i];
      for (var k = 0; k < this.getLayers().length; k++) {
        var o = this.getLayer(k);
        if (l.id === o.options.obj.id) {
          layer = o;
          break;
        }
      }
      return layer;
    }

    /**
     * Get a list of layer object sorted or not (see options.tools.sort)
     * @returns {Array} - List of layer object
     * @see {ol.style.editor.Layer}
     */
  }, {
    key: "getLayers",
    value: function getLayers() {
      return this.layers;
    }

    /**
     * Get the layer object from a list sorted or not (see options.tools.sort)
     * @param {Number} i - index
     * @returns {Object} - layer object
     * @see {ol.style.editor.Layer}
     */
  }, {
    key: "getLayer",
    value: function getLayer(i) {
      return this.layers[i];
    }
  }]);
}();
;

// on récupère les méthodes de la classe DOM
_Utils_Helper__WEBPACK_IMPORTED_MODULE_2__["default"].assign(Editor.prototype, _EditorDOM__WEBPACK_IMPORTED_MODULE_13__["default"]);

// ################################################################### //
// ####################### handlers events to dom #################### //
// ################################################################### //

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Editor);

// Expose Editor as ol.editor.View (for a build bundle)
if (window.ol && window.ol.style) {
  window.ol.style.Editor = Editor;
}

/***/ }),

/***/ "./src/packages/Controls/Editor/EditorDOM.js":
/*!***************************************************!*\
  !*** ./src/packages/Controls/Editor/EditorDOM.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var EditorDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EditorDOM);

/***/ }),

/***/ "./src/packages/Controls/Editor/Event.js":
/*!***********************************************!*\
  !*** ./src/packages/Controls/Editor/Event.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
* managing events
*
* See {@link http://krasimirtsonev.com/blog/article/javascript-managing-events-dispatch-listen}
* See {@link https://github.com/krasimir/EventBus}
*
* @property {Event} "editor:layer:onclickvisibility" - event ...
* @property {Event} "editor:layer:onclickclone" - event ...
* @property {Event} "editor:layer:onclickremove" - event ...
* @property {Event} "editor:style:oneditjson" - event ...
* @property {Event} "editor:style:scale:onchangemin" - event ...
* @property {Event} "editor:style:scale:onchangemax" - event ...
* @property {Event} "editor:legend:onclickedition" - event ...
* @property {Event} "editor:legend:onchangevalue" - event ...
* @property {Event} "editor:filter:oneditjson" - event ...
* @property {Event} "editor:themes:onclickimage" - event ...
* @property {Event} "editor:themes:onclicktitle" - event ...
* @property {Event} "editor:search:onsubmit" - event ...
* @property {Event} "editor:search:onautocomplete" - event ...
* @property {Event} "editor:group:oncollapse" - event ...
* @property {Event} "editor:onloaded" - event ...
*
* @mixin
*
* @example
* // dispatch event
* EventBus.dispatch(EventEditor.layer.visibility, e);
* // listener
* EventBus.addEventListener(EventEditor.layer.visibility, function (e) {...}, this);
*/
var EventEditor = {
  /** evenement sur la fin de chargement de l'editeur */
  onloaded: "editor:onloaded",
  layer: {
    /** evenement sur la visibilité : clic sur le bouton 'oeil' */
    onclickvisibility: "editor:layer:onclickvisibility",
    /** evenement sur la duplication : clic sur le bouton
    (not yet implemented !) */
    onclickclone: "editor:layer:onclickclone",
    /** evenement sur la suppression : clic sur le bouton
    (not yet implemented !) */
    onclickremove: "editor:layer:onclickremove"
  },
  legend: {
    /** evenement sur l'affichage du mode edition */
    onclickedition: "editor:legend:onclickedition",
    /** evenement sur la modification d'une valeur */
    onchangevalue: "editor:legend:onchangevalue"
  },
  group: {
    /**  evenement pour deplier/plier le groupe
    (not yet implemented !) */
    oncollapse: "editor:group:oncollapse"
  },
  style: {
    /** evenement sur l'édition du style
    (not yet implemented !) */
    oneditjson: "editor:style:oneditjson",
    /** evenement sur la modification de l'echelle d'affichage */
    scale: {
      onchangemin: "editor:style:scale:onchangemin",
      onchangemax: "editor:style:scale:onchangemax"
    }
  },
  filter: {
    /** evenement sur l'édition du filtre
    (not yet implemented !) */
    oneditjson: "editor:filter:oneditjson"
  },
  themes: {
    /** evenement sur le clic de l'image */
    onclickimage: "editor:themes:onclickimage",
    /** evenement sur le clic du titre */
    onclicktitle: "editor:themes:onclicktitle"
  },
  search: {
    /** evenement sur la recherche */
    onsubmit: "editor:search:onsubmit",
    onautocomplete: "editor:search:onautocomplete"
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EventEditor);

/***/ }),

/***/ "./src/packages/Controls/Editor/Filter.js":
/*!************************************************!*\
  !*** ./src/packages/Controls/Editor/Filter.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventbusjs */ "./node_modules/eventbusjs/lib/eventbus.min.js");
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventbusjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Event */ "./src/packages/Controls/Editor/Event.js");
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Utils/Helper */ "./src/packages/Utils/Helper.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }




var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_3__["default"].getLogger("editor-filter");

/**
 * @classdesc
 *
 * MapBox filter management
 *
 * @constructor
 * @alias ol.style.editor.Filter
 * @param {Object} options - options for function call.
 * @example
 *   var filter = new Filter ({
 *      target : ...,
 *      position : 1, // identifiant de position (unique !)
 *      tools : {
 *          edition : false
 *      },
 *      title : "Filtres (JSON)",
 *      obj : {
 *          filter : []
 *      }
 *   });
 *  filter.add();
 *  filter.display(true);
 *  filter.getContainer();
 */
var Filter = /*#__PURE__*/function () {
  function Filter(options) {
    _classCallCheck(this, Filter);
    logger.trace("[constructor] Filter", options);

    // options
    this.options = options || {
      // default...
      target: null,
      position: 0,
      tools: null,
      title: null,
      obj: null
    };
    if (!(this instanceof Filter)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this._initialize();
    this._initContainer();
  }

  /**
   * Initialize component
   * (called by constructor)
   *
   * @private
   */
  return _createClass(Filter, [{
    key: "_initialize",
    value: function _initialize() {
      // unique editor id (optional!)
      this.id = this.options.id || null;
      if (!this.options.target) {
        // cf. add()
      }
      if (!this.options.position) {
        this.options.position = 0;
      }
      var _toolsDefault = {
        edition: false
      };
      if (!this.options.tools) {
        this.options.tools = _toolsDefault;
      }
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_2__["default"].mergeParams(this.options.tools, _toolsDefault, false);
      if (!this.options.obj) {
        // choix d'avoir un objet vide pour une edition futur...
        this.options.obj = {
          filter: []
        };
      }
      if (!this.options.title) {
        this.options.title = "JSON Filtres :";
      }
      this.container = null;

      // DOM : className or id
      this.name = {
        target: "GPEditorMapBoxFilterTarget",
        container: "GPEditorMapBoxFilterContainer",
        containerjson: "GPEditorMapBoxFilterJsonContainer",
        jsonlabel: "GPEditorMapBoxFilterTitleJson",
        jsondisplay: "GPEditorMapBoxFilterDisplayJson",
        containertoolsedit: "GPEditorMapBoxFilterToolsEditionContainer"
      };
    }

    /**
     * Graphical rendering of the component
     * (called by constructor)
     *
     * @private
     * @example
     * <div class="GPEditorMapBoxFilterContainer">
     *  <div class ="GPEditorMapBoxFilterJsonontainer">
     *     <label class="GPEditorMapBoxFilterTitleJson">JSON Filtres :</label>
     *     <pre class="GPEditorMapBoxFilterDisplayJson">...</pre>
     *  </div>
     *  <div class ="GPEditorMapBoxStyleToolsEditionContainer"></div>
     * </div>
     */
  }, {
    key: "_initContainer",
    value: function _initContainer() {
      // contexte
      var self = this;
      var _found = false;
      var _filter = JSON.parse(JSON.stringify(this.options.obj)); // on manipule une copie  !

      // FIXME tag filter est obselete !
      // on doit utiliser les expressions dans "paint" ou "layout" !
      if (_filter.filter) {
        _found = true;
        if (_filter.filter.length === 0) {
          logger.info("tag 'filter' is empty !");
        }
      }
      var div = document.createElement("div");
      div.className = this.name.container;
      var json = null;
      if (_found) {
        json = JSON.stringify(_filter.filter, null, 4);
      }
      var divJson = document.createElement("div");
      divJson.className = this.name.containerjson;
      var labelJson = document.createElement("label");
      labelJson.className = this.name.jsonlabel;
      labelJson.innerHTML = this.options.title;
      divJson.appendChild(labelJson);
      var preJson = document.createElement("pre");
      preJson.className = this.name.jsondisplay;
      preJson.innerHTML = json;
      if (preJson.addEventListener) {
        preJson.addEventListener("click", function (e) {
          if (self.options.tools.edition) {
            self.onEditJsonFilterMapBox(e);
          }
        });
      } else if (preJson.attachEvent) {
        preJson.attachEvent("onclick", function (e) {
          if (self.options.tools.edition) {
            self.onEditJsonFilterMapBox(e);
          }
        });
      }
      divJson.appendChild(preJson);
      div.appendChild(divJson);
      if (this.options.tools.edition) {
        var divEdit = document.createElement("div");
        divEdit.className = this.name.containertoolsedit;
        div.appendChild(divEdit);
      }

      // main container
      this.container = div;
    }

    // ################################################################### //
    // ##################### public methods ############################## //
    // ################################################################### //
    /**
     * Add element into target DOM
     * @returns {Object} - Legend instance
     */
  }, {
    key: "add",
    value: function add() {
      if (!this.options.target) {
        if (!document.getElementById(this.name.target)) {
          var div = document.createElement("div");
          div.id = this.name.target;
          var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
          node.appendChild(div);
        }
        this.options.target = document.getElementById(this.name.target);
      }
      if (this.container) {
        this.options.target.appendChild(this.container);
      }
      return this;
    }

    /**
     * Set display container or get
     *
     * @param {Boolean} display - show/hidden container or get status
     * @returns {Boolean} - true/false
     */
  }, {
    key: "display",
    value: function display(_display) {
      logger.trace("display()", _display);
      if (typeof _display !== "undefined") {
        this.container.style.display = _display ? "flex" : "none";
      }
      return this.container.style.display === "flex";
    }

    /**
     * Get container (DOM)
     *
     * @returns {DOMElement} DOM element
     */
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this.container;
    }

    // ################################################################### //
    // ####################### handlers events to dom #################### //
    // ################################################################### //
    /**
     * this method is called by event '' on '' tag form...
     *
     * 'e' contains the option object into 'e.target.data' !
     * 'e' contains the id editor into 'e.target.editorID' !
     *
     * @param {Object} e - HTMLElement
     * @private
     * @fires Filter#editor:style:oneditjson
     */
  }, {
    key: "onEditJsonFilterMapBox",
    value: function onEditJsonFilterMapBox(e) {
      logger.trace("onEditJsonFilterMapBox", e);
      e.editorID = this.id;
      e.data = this.options;
      eventbusjs__WEBPACK_IMPORTED_MODULE_0___default().dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].filter.oneditjson, e);
    }
  }]);
}();
;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Filter);

/***/ }),

/***/ "./src/packages/Controls/Editor/Group.js":
/*!***********************************************!*\
  !*** ./src/packages/Controls/Editor/Group.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventbusjs */ "./node_modules/eventbusjs/lib/eventbus.min.js");
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventbusjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Event */ "./src/packages/Controls/Editor/Event.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }



var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_2__["default"].getLogger("editor-group");

/**
 * @classdesc
 *
 * MapBox group management
 *
 * @constructor
 * @alias ol.style.editor.Group
 * @param {Object} options - options for function call.
 * @example
 *   var group = new Group ({
 *      title : "MyGroup",
 *      collapse : true, // plier/deplier
 *      target : ...
 *   });
 *   group.add();
 *   group.add();
 */
var Group = /*#__PURE__*/function () {
  function Group(options) {
    _classCallCheck(this, Group);
    logger.trace("[constructor] Group", options);

    // options
    this.options = options || {
      // default...
    };
    if (!(this instanceof Group)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this._initialize();
    this._initContainer();
  }

  /**
   * Initialize component
   * (called by constructor)
   *
   * @private
   */
  return _createClass(Group, [{
    key: "_initialize",
    value: function _initialize() {
      // unique editor id (optional!)
      this.id = this.options.id || null;
      if (!this.options.target) {
        // cf. add()
      }
      if (!this.options.title) {
        // cf. summary
        this.options.title = "Détails du groupe...";
      }

      // plier par defaut
      if (typeof this.options.collapse === "undefined") {
        this.options.collapse = true;
      }
      this.container = null;

      // DOM : className or id
      this.name = {
        target: "GPEditorMapBoxGroupTarget",
        container: "GPEditorMapBoxGroupContainer",
        details: "GPEditorMapBoxGroupDetails",
        summary: "GPEditorMapBoxGroupSummary"
      };
    }

    /**
     * Graphical rendering of the component
     * (called by constructor)
     *
     * @private
     * @example
     * <div class="GPEditorMapBoxGroupContainer">...</div>
     */
  }, {
    key: "_initContainer",
    value: function _initContainer() {
      var div = document.createElement("div");
      div.className = this.name.container;

      // FIXME pas compatible IE !
      // https://caniuse.com/#search=details
      // cf. https://css-tricks.com/quick-reminder-that-details-summary-is-the-easiest-way-ever-to-make-an-accordion/
      var details = document.createElement("details");
      details.className = this.name.details;
      details.open = !this.options.collapse;
      div.appendChild(details);
      var summary = document.createElement("summary");
      summary.className = this.name.summary;
      summary.innerHTML = this.options.title;
      details.appendChild(summary);

      // main container
      this.container = div;
    }

    // ################################################################### //
    // ##################### public methods ############################## //
    // ################################################################### //
    /**
     * Add element into target DOM
     */
  }, {
    key: "add",
    value: function add() {
      if (!this.options.target) {
        if (!document.getElementById(this.name.target)) {
          var div = document.createElement("div");
          div.id = this.name.target;
          var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
          node.appendChild(div);
        }
        this.options.target = document.getElementById(this.name.target);
      }
      if (this.container) {
        this.options.target.appendChild(this.container);
      }
    }

    /**
     * Set display container (DOM)
     *
     * @param {Boolean} display - show/hidden container
     */
  }, {
    key: "display",
    value: function display(_display) {
      this.container.style.display = _display ? "flex" : "none";
    }

    /**
     * Get container (DOM)
     *
     * @returns {DOMElement} DOM element
     */
  }, {
    key: "getContainer",
    value: function getContainer() {
      var nodes = this.container.childNodes;
      if (nodes.length) {
        // retourne le noeud "details" !
        return nodes[0];
      }
      // sinon le container principal
      return this.container;
    }

    // ################################################################### //
    // ####################### handlers events to dom #################### //
    // ################################################################### //
    /**
     * this method is called by event '' on '' tag form
     *
     * NOT USED !
     * @param {Object} e - HTMLElement
     * @private
     * @fires Group#editor:group:oncollapse
     */
  }, {
    key: "onCollapseGroupMapBox",
    value: function onCollapseGroupMapBox(e) {
      logger.trace("onCollapseGroupMapBox", e);
      e.editorID = this.id;
      e.data = this.options;
      eventbusjs__WEBPACK_IMPORTED_MODULE_0___default().dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].group.oncollapse, e);
    }
  }]);
}();
;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Group);

/***/ }),

/***/ "./src/packages/Controls/Editor/Layer.js":
/*!***********************************************!*\
  !*** ./src/packages/Controls/Editor/Layer.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventbusjs */ "./node_modules/eventbusjs/lib/eventbus.min.js");
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventbusjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Event */ "./src/packages/Controls/Editor/Event.js");
/* harmony import */ var _Style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Style */ "./src/packages/Controls/Editor/Style.js");
/* harmony import */ var _Legend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Legend */ "./src/packages/Controls/Editor/Legend.js");
/* harmony import */ var _Filter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Filter */ "./src/packages/Controls/Editor/Filter.js");
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../Utils/Helper */ "./src/packages/Utils/Helper.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }







var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_6__["default"].getLogger("editor-layer");

/**
 * @classdesc
 *
 * MapBox filter management
 *
 * @constructor
 * @alias ol.style.editor.Layer
 * @param {Object} options - options for function call.
 * @example
 *   var layers = new Layer ({
 *      target : ...,
 *      position : 1, // identifiant de position (unique !)
 *      tools : {
 *          "visibility" : true, // afficher l'icone de visibilité
 *          "icon" : {
 *              "image" : true, // afficher l'icone "oeil" (defaut) ou une checkbox
 *              "anchor" : "start" | "end"  // afficher l'icone au debut ou à la fin (defaut)
 *          },
 *          "type" : true,       // afficher l'icone du type de geometrie
 *          "pin" : true,        // afficher l'icone de puce
 *          "remove" : false,    // TODO afficher l'icone de suppression
 *          "clone" : false      // TODO afficher l'icone de duplication
 *      },
 *      obj : {
 *          "id": "ocs - vegetation", // MANDATORY
 *          "type": "fill", // OPTIONAL
 *          "source": "pyramide_proto", // OPTIONAL
 *          "source-layer": "ocs_vegetation_surf" // OPTIONAL
 *      }
 *   });
 *  layers.addLegend(oLegend);
 *  layers.slotLegend();
 *  layers.addStyle(oStyle);
 *  layers.addFilter(oFilter);
 *  layers.add();
 *  layers.active(false);
 *  layers.visibility(false);
 *  layers.display(false);
 *  layers.collapse();
 *  EventBus.addEventListener("editor:layer:onclickvisibility", function (e) {
 *     // e.target.data : options !
 *     // e.target.editorID : id or null
 *   }, this);
 */
var Layer = /*#__PURE__*/function () {
  function Layer(options) {
    _classCallCheck(this, Layer);
    logger.trace("[constructor] Layer", options);

    // options
    this.options = options || {};
    if (!(this instanceof Layer)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this._initialize();
    this._initContainer();
  }

  // ################################################################### //
  // ##################### private methods ############################# //
  // ################################################################### //
  /**
   * Initialize component
   * (called by constructor)
   *
   * @private
   */
  return _createClass(Layer, [{
    key: "_initialize",
    value: function _initialize() {
      // unique editor id (optional!)
      this.id = this.options.id || null; // null si le layer n'appartient pas à un editeur !

      if (!this.options.target) {
        // cf. add()
      }
      if (!this.options.position) {
        this.options.position = 0;
      }
      var _toolsDefault = {
        visibility: true,
        icon: {
          image: true,
          anchor: "end"
        },
        type: true,
        pin: true,
        remove: false,
        // TODO
        clone: false // TODO
      };
      if (!this.options.tools) {
        this.options.tools = _toolsDefault;
      }
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_5__["default"].mergeParams(this.options.tools, _toolsDefault, false);
      var _objDefault = {
        id: "",
        type: "",
        // icone sur le type de geometrie
        source: "",
        "source-layer": ""
      };
      if (!this.options.obj) {
        this.options.obj = _objDefault;
      }
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_5__["default"].mergeParams(this.options.obj, _objDefault, false);

      // legende intégrée
      this.bSlotLegend = false;

      // obj
      this.oFilter = null;
      this.oStyle = null;
      this.oLegend = null;

      // dom
      this.container = null;
      this.DomVisibility = null;
      this.DomToggle = null;

      // DOM : className or id
      this.name = {
        target: "GPEditorMapBoxLayerTarget",
        container: "GPEditorMapBoxLayerContainer",
        containerlegend: "GPEditorMapBoxLayerLegendContainer",
        containertitle: "GPEditorMapBoxLayerTitleContainer",
        imagelabelinput: "GPEditorMapBoxLayerImageInput",
        imagelabel: "GPEditorMapBoxLayerImageLabel",
        typeimg: "GPEditorMapBoxLayerTypeImage",
        titleinput: "GPEditorMapBoxLayerTitleInput",
        titlelabel: "GPEditorMapBoxLayerTitleLabel",
        containertools: "GPEditorMapBoxToolsContainer",
        visibilityinput: "GPEditorMapBoxToolsVisibilityInput",
        visibilitylabel: "GPEditorMapBoxToolsVisibilityLabel",
        visibilityinputdisable: "GPEditorMapBoxToolsVisibilityInputDisable",
        visibilitylabeldisable: "GPEditorMapBoxToolsVisibilityLabelDisable"
      };
    }

    /**
     * Graphical rendering of the component
     * (called by constructor)
     *
     * @private
     * @example
     * // >> Titre 1          |OOO| <- menu tools : visibility, clone, remove
     * // >> Titre 2          |OXX| <- affichage configurable (cf. options.tools)
     * // Event : clic sur le titre -> ex. affiche le menu des styles / filtres
     * //       : clic visibility, clone, remove
     * // DOM :
     *      <div class="GPEditorMapBoxLayerContainer">
     *          <div id="GPEditorMapBoxLayerTitleContainer-45" class="GPEditorMapBoxLayerTitleContainer">
     *              <input id="GPEditorMapBoxLayerImageInput-45" class="GPEditorMapBoxLayerImageInput" type="checkbox">
     *              <label class="GPEditorMapBoxLayerImageLabel" for="GPEditorMapBoxLayerImageInput-45"></label>
     *              <input id="GPEditorMapBoxLayerTitleInput-45" class="GPEditorMapBoxLayerTitleInput" type="checkbox">
     *              <label class="GPEditorMapBoxLayerTitleLabel" for="GPEditorMapBoxLayerTitleInput-45" title="...">...</label>
     *          </div>
     *          <div id="GPEditorMapBoxToolsContainer-45" class="GPEditorMapBoxToolsContainer">
     *              <input id="GPEditorMapBoxToolsVisibilityInput-45" type="checkbox" class="GPEditorMapBoxToolsVisibilityInput">
     *              <label for="GPEditorMapBoxToolsVisibilityInput-45" id="GPEditorMapBoxToolsVisibilityLabel-45" class="GPEditorMapBoxToolsVisibilityLabel" title="Afficher/masquer la couche"></label>
     *          </div>
     *      </div>
     */
  }, {
    key: "_initContainer",
    value: function _initContainer() {
      // contexte
      var self = this;
      var obj = this.options.obj;
      var div = document.createElement("div");
      div.className = this.name.container;

      // title
      var divTitle = document.createElement("div");
      divTitle.id = this.name.containertitle + "-" + this.options.position;
      divTitle.className = this.name.containertitle;

      // puce
      if (this.options.tools.pin) {
        // Optionnel !
        // input
        var inputImage = document.createElement("input");
        inputImage.id = this.name.imagelabelinput + "-" + this.options.position;
        inputImage.className = this.name.imagelabelinput;
        inputImage.type = "checkbox";
        divTitle.appendChild(inputImage);
        // puce
        var labelImage = document.createElement("label");
        labelImage.className = this.name.imagelabel;
        labelImage.htmlFor = inputImage.id;
        if (labelImage.addEventListener) {
          labelImage.addEventListener("click", function (e) {
            self.onClickLayerMapBox(e);
          });
        } else if (labelImage.attachEvent) {
          labelImage.attachEvent("onclick", function (e) {
            self.onClickLayerMapBox(e);
          });
        }
        divTitle.appendChild(labelImage);
      }

      // tools :
      // visibility, (remove, clone)
      var _addTools = function _addTools() {
        var divTools = document.createElement("div");
        divTools.id = this.name.containertools + "-" + this.options.position;
        divTools.className = this.name.containertools;

        // visibility
        if (this.options.tools.visibility) {
          var inputTools = document.createElement("input");
          inputTools.id = this.name.visibilityinput + "-" + this.options.position;
          inputTools.className = this.options.tools.icon.image ? this.name.visibilityinput : this.name.visibilityinputdisable;
          inputTools.type = "checkbox";
          inputTools.checked = "checked"; // par défaut, à modifier via visibility(true|false) !

          // event for visibility change
          if (inputTools.addEventListener) {
            inputTools.addEventListener("click", function (e) {
              self.onVisibilityLayerMapBox(e);
            });
          } else if (inputTools.attachEvent) {
            // internet explorer
            inputTools.attachEvent("onclick", function (e) {
              self.onVisibilityLayerMapBox(e);
            });
          }
          divTools.appendChild(inputTools);
          // enregistrement utile pour la méthode : visibility()
          this.DomVisibility = inputTools;
          var labelTools = document.createElement("label");
          labelTools.htmlFor = this.name.visibilityinput + "-" + this.options.position;
          labelTools.id = this.name.visibilitylabel + "-" + this.options.position;
          labelTools.className = this.options.tools.icon.image ? this.name.visibilitylabel : this.name.visibilitylabeldisable;
          labelTools.title = "Afficher/masquer la couche";
          divTools.appendChild(labelTools);
          div.appendChild(divTools);
        }

        // clone
        if (this.options.tools.clone) {
          // TODO...
          logger.warn("Dom for tools clone, it's not yet implemented !");
        }

        // remove
        if (this.options.tools.remove) {
          // TODO...
          logger.warn("Dom for tools remove, it's not yet implemented !");
        }
      };

      // ajout des outils au debut du composant
      if (this.options.tools.icon.anchor === "start") {
        _addTools.apply(this);
      }

      // type
      if (this.options.tools.type && obj.type) {
        // Optionnel !
        var imgType = document.createElement("img");
        imgType.className = this.name.typeimg;
        // FIXME il faudrait faire la difference entre :
        // - icone uniquement : SYMBOL-ICON
        // - texte uniquement : SYMBOL-TEXT
        // - les 2 : SYMBOL
        // Mais il nous faut les styles complets (paint & layout)
        // pour determiner les 3 types !
        switch (obj.type.toUpperCase()) {
          case "SYMBOL-ICON":
            // not used !
            imgType.style["background-position"] = "0px 0";
            break;
          case "SYMBOL-TEXT":
            // not used !
            imgType.style["background-position"] = "-194px 0";
            break;
          case "SYMBOL":
            imgType.style["background-position"] = "-84px 0";
            break;
          case "LINE":
            imgType.style["background-position"] = "-28px 0";
            break;
          case "FILL":
            imgType.style["background-position"] = "-56px 0";
            break;
          case "BACKGROUND":
            imgType.style["background-position"] = "-140px 0";
            break;
          case "CIRCLE":
            imgType.style["background-position"] = "-168px 0";
            break;
          default:
            // type inconnu ou non pris en charge ou par defaut
            imgType.style["background-position"] = "-112px 0";
        }
        divTitle.appendChild(imgType);
      }

      // container legend (empty)
      var divLegend = document.createElement("div");
      divLegend.id = this.name.containerlegend + "-" + this.options.position;
      divLegend.className = this.name.containerlegend;
      divTitle.appendChild(divLegend);

      // input
      var inputTitle = document.createElement("input");
      inputTitle.id = this.name.titleinput + "-" + this.options.position;
      inputTitle.className = this.name.titleinput;
      inputTitle.type = "checkbox";
      divTitle.appendChild(inputTitle);

      // label for
      var labelTitle = document.createElement("label");
      labelTitle.className = this.name.titlelabel;
      labelTitle.htmlFor = inputTitle.id;
      labelTitle.innerHTML = obj["id"] || obj["source-layer"] || obj["source"];
      labelTitle.title = obj["source-layer"] || obj["source"] || obj["id"];
      if (labelTitle.addEventListener) {
        labelTitle.addEventListener("click", function (e) {
          self.onClickLayerMapBox(e);
        });
      } else if (labelTitle.attachEvent) {
        labelTitle.attachEvent("onclick", function (e) {
          self.onClickLayerMapBox(e);
        });
      }
      divTitle.appendChild(labelTitle);
      // enregistrement utile pour la méthode : collapse()
      this.DomToggle = labelTitle;
      div.appendChild(divTitle);

      // ajout des outils au fin du composant
      if (this.options.tools.icon.anchor === "end") {
        _addTools.apply(this);
      }

      // main container
      this.container = div;
    }

    // ################################################################### //
    // ##################### public methods ############################## //
    // ################################################################### //
    /**
     * Add element into target DOM
     * @returns {Object} - Layer instance
     */
  }, {
    key: "add",
    value: function add() {
      logger.trace("add()");
      if (!this.options.target) {
        if (!document.getElementById(this.name.target)) {
          var div = document.createElement("div");
          div.id = this.name.target;
          var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
          node.appendChild(div);
        }
        this.options.target = document.getElementById(this.name.target);
      }
      if (this.container) {
        this.options.target.appendChild(this.container);
      }
      return this;
    }

    /**
     * Add style in the submenu
     *
     * @param {Object} style - style object
     */
  }, {
    key: "addStyle",
    value: function addStyle(style) {
      logger.trace("addStyle()", style);
      if (style && _typeof(style) === "object" && style instanceof _Style__WEBPACK_IMPORTED_MODULE_2__["default"]) {
        this.oStyle = style;
        this.oStyle.display(false); // par defaut !
      }
    }

    /**
     * Add filter in the submenu
     *
     * @param {Object} filter - filter object
     */
  }, {
    key: "addFilter",
    value: function addFilter(filter) {
      logger.trace("addFilter()", filter);
      if (filter && _typeof(filter) === "object" && filter instanceof _Filter__WEBPACK_IMPORTED_MODULE_4__["default"]) {
        this.oFilter = filter;
        this.oFilter.display(false); // par defaut !
      }
    }

    /**
     * Add Legend in the submenu
     *
     * @param {Object} legend - legend object
     */
  }, {
    key: "addLegend",
    value: function addLegend(legend) {
      logger.trace("addLegend()", legend);
      if (legend && _typeof(legend) === "object" && legend instanceof _Legend__WEBPACK_IMPORTED_MODULE_3__["default"]) {
        this.oLegend = legend;
        this.oLegend.display(false); // par defaut !
      }
    }

    /**
     * Integrate Legend to the layer container
     */
  }, {
    key: "slotLegend",
    value: function slotLegend() {
      // cas particulier :
      // on souhaite intégrer une partie de la legende dans le container du layer.
      var legend = this.oLegend;
      if (legend) {
        // FIXME c'est pourri...
        var node = null;
        var nodesLvl1 = this.container.childNodes;
        if (nodesLvl1.length) {
          // selon où se situe l'icone de visibilité : au debut ou à la fin...
          var idx = this.options.tools.icon.anchor === "start" ? 1 : 0;
          var nodesLvl2 = nodesLvl1[idx].childNodes;
          // on recherche le container de la legende
          for (var i = 0; i < nodesLvl2.length; i++) {
            var curnode = nodesLvl2[i];
            if (curnode.id.indexOf(this.name.containerlegend) !== -1) {
              node = curnode;
            }
          }
        }
        if (node) {
          var render = legend.getRenderContainer();
          if (render) {
            node.appendChild(render);
            // legende intégrée
            this.bSlotLegend = true;
          }
        }
      }
    }

    // ################################################################### //
    // ##################### public methods ############################## //
    // ################################################################### //
    /**
     * Set visibility or get
     *
     * @param {Boolean} display - set visibility or undefined to get status
     * @returns {Boolean} - true/false
     */
  }, {
    key: "visibility",
    value: function visibility(display) {
      logger.trace("visibility()", display);
      if (!this.options.tools.visibility) {
        return;
      }
      if (typeof display !== "undefined") {
        this.DomVisibility.checked = display ? "checked" : "";
      }
      return this.DomVisibility.checked;
    }

    /**
    * Collapse a layer panel (event)
    */
  }, {
    key: "collapse",
    value: function collapse() {
      logger.trace("collapse()");
      this.DomToggle.click();
    }

    /**
    * Click on visibility icon (event)
    */
  }, {
    key: "visible",
    value: function visible() {
      logger.trace("visible()");
      if (!this.options.tools.visibility) {
        return;
      }
      this.DomVisibility.click();
    }

    /**
     * Set collapse or get
     *
     * @param {Boolean} display - show/hidden container or get status
     * @returns {Boolean} - true/false
     */
  }, {
    key: "display",
    value: function display(_display) {
      logger.trace("display()", _display);
      var checked = document.getElementById(this.DomToggle.htmlFor).checked;
      if (typeof _display !== "undefined") {
        this.container.style.display = _display ? "inline-flex" : "none";
        if (this.oStyle) {
          this.oStyle.display(_display && checked);
        }
        if (this.oFilter) {
          this.oFilter.display(_display && checked);
        }
        if (this.oLegend) {
          this.oLegend.display(_display && checked);
        }
      }
      return checked;
    }

    /**
     * Set disabled/enabled status or get
     *
     * @param {Boolean} active - disable/enable layer interaction or get status
     * @returns {Boolean} - true/false
     */
  }, {
    key: "active",
    value: function active(_active) {
      logger.trace("active()", _active);
      if (typeof _active !== "undefined") {
        this.container.className = _active ? this.name.container : this.name.container + " disabled";
      }
      return this.container.className === this.name.container;
    }

    /**
     * Get container (DOM)
     *
     * @returns {DOMElement} DOM element
     */
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this.container;
    }

    // ################################################################### //
    // ####################### handlers events to dom #################### //
    // ################################################################### //
    /**
     * this method is called by event '' on '' tag form
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "onClickLayerMapBox",
    value: function onClickLayerMapBox(e) {
      logger.trace("onClickLayerMapBox", e);
      var id = e.target.htmlFor.substring(e.target.htmlFor.indexOf("-"));
      var checked = document.getElementById(e.target.htmlFor).checked;

      // gestion des inputs
      if (e.target.htmlFor === this.name.imagelabelinput + id) {
        document.getElementById(this.name.titleinput + id).checked = !checked;
      }
      if (e.target.htmlFor === this.name.titleinput + id) {
        // si options.pin:false, ce DOM n'existe pas !
        if (document.getElementById(this.name.imagelabelinput + id)) {
          document.getElementById(this.name.imagelabelinput + id).checked = !checked;
        }
      }

      // ouverture du panneau des styles / filtres
      if (this.oStyle) {
        this.oStyle.display(!checked);
      }
      if (this.oFilter) {
        this.oFilter.display(!checked);
      }
      // attention,
      // si la legende est non editable, elle ne se trouve pas dans le sous menu !
      if (this.oLegend && this.oLegend.isEditable()) {
        this.oLegend.display(!checked);
      }
    }

    /**
     * this method is called by event '' on '' tag form...
     *
     * 'e' contains the option object into 'e.target.data' !
     * 'e' contains the id editor into 'e.target.editorID' !
     *
     * @param {Object} e - HTMLElement
     * @private
     * @fires Layer#editor:layer:onclickvisibility
     */
  }, {
    key: "onVisibilityLayerMapBox",
    value: function onVisibilityLayerMapBox(e) {
      logger.trace("onVisibilityLayerMapBox", e);
      e.editorID = this.id;
      e.data = this.options;
      eventbusjs__WEBPACK_IMPORTED_MODULE_0___default().dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].layer.onclickvisibility, e);
    }

    /**
     * this method is called by event '' on '' tag form...
     *
     * 'e' contains the option object into 'e.target.data' !
     * 'e' contains the id editor into 'e.target.editorID' !
     *
     * @param {Object} e - HTMLElement
     * @private
     * @fires Layer#editor:layer:onclickclone
     */
  }, {
    key: "onCloneLayerMapBox",
    value: function onCloneLayerMapBox(e) {
      logger.trace("onCloneLayerMapBox", e);
      e.editorID = this.id;
      e.data = this.options;
      eventbusjs__WEBPACK_IMPORTED_MODULE_0___default().dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].layer.onclickclone, e);
    }

    /**
     * this method is called by event '' on '' tag form...
     *
     * 'e' contains the option object into 'e.target.data' !
     * 'e' contains the id editor into 'e.target.editorID' !
     *
     * @param {Object} e - HTMLElement
     * @private
     * @fires Layer#editor:layer:onclickremove
     */
  }, {
    key: "onRemoveLayerMapBox",
    value: function onRemoveLayerMapBox(e) {
      logger.trace("onRemoveLayerMapBox", e);
      e.editorID = this.id;
      e.data = this.options;
      eventbusjs__WEBPACK_IMPORTED_MODULE_0___default().dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].layer.onclickremove, e);
    }
  }]);
}();
;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Layer);

/***/ }),

/***/ "./src/packages/Controls/Editor/Legend.js":
/*!************************************************!*\
  !*** ./src/packages/Controls/Editor/Legend.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventbusjs */ "./node_modules/eventbusjs/lib/eventbus.min.js");
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventbusjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Event */ "./src/packages/Controls/Editor/Event.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Utils/ColorUtils */ "./src/packages/Utils/ColorUtils.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }




var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_2__["default"].getLogger("editor-legend");

/**
 * @classdesc
 *
 * MapBox Legend management
 *
 * @constructor
 * @alias ol.style.editor.Legend
 * @param {Object} options - options for function call.
 * @param {Object} [options.target = null] - ...
 * @param {Number} [options.position = 0] -  ...
 * @param {Number} [options.id = null] - (internal) ...
 * @param {Object} [options.sprites = null] - ...
 * @param {String} [options.sprites.url] - ...
 * @param {Object} [options.sprites.size] - {h:, w:} ...
 * @param {Object} [options.sprites.json] - ...
 * @param {Object} options.obj - ...
 * @param {String} [options.obj.title] - ...
 * @param {Boolean} [options.obj.editable = true] - ...
 * @param {Object} options.obj.paint - ...
 * @param {Object} options.obj.layout - ...
 * @example
 *   var legend = new Legend ({
 *      target : ...,
 *      position : 1, // identifiant de position (unique !)
 *      sprites : {
 *          url : "http://localhost/sprites.png",
 *          size : { w : 450, h : 550 },
 *          json : {
 *              icon-1 : {x:,y:,height:,width:,pixelRatio:},
 *              icon-2 : {x:,y:,height:,width:,pixelRatio:}
 *          }
 *      },
 *      obj : {
 *          title : "",
 *          editable : true, // tag non standard issue du style json dédié à l'edition
 *          paint : {"fill-color": "#2BB3E1"},
 *          layout : {visibility:"none"}
 *      }
 *   });
 *  legend.add();
 *  legend.display(true);
 *  legend.isEditable();
 *  legend.getRenderContainer();
 *  legend.getToolsContainer();
 *  legend.getContainer();
 */
var Legend = /*#__PURE__*/function () {
  function Legend(options) {
    _classCallCheck(this, Legend);
    logger.trace("[constructor] Legend", options);

    // options
    this.options = options || {
      // default...
      target: null,
      position: 0,
      sprites: null,
      obj: null
    };
    if (!(this instanceof Legend)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this._initialize();
    this._initContainer();
  }

  // ################################################################### //
  // ########################## init methods ########################### //
  // ################################################################### //
  /**
   * Initialize component
   * (called by constructor)
   *
   * @private
   */
  return _createClass(Legend, [{
    key: "_initialize",
    value: function _initialize() {
      // unique editor id (optional!)
      this.id = this.options.id || null;
      if (!this.options.target) {
        // cf. add()
      }

      // permet d'avoir un identifiant de position dans la liste des layers
      if (!this.options.position) {
        this.options.position = 0;
      }
      if (!this.options.obj) {
        // choix d'avoir un objet vide pour une edition...
        this.options.obj = {
          title: "vide...",
          editable: true,
          paint: {
            "fill-color": "#FFFFFF"
          }
        };
      }

      // la legende est elle editable ?
      // le tag 'editable' est à placer dans le fichier de style (dans le layer)...
      var _editable = this.options.obj.editable;
      this.editable = typeof _editable !== "undefined" ? _editable : false;

      // liste des caractéristiques de la legende par defaut
      this.legendRender = {
        type: "fill",
        values: {
          width: 1,
          stroke: "#FFFFFF",
          color: "#000000",
          opacity: 1
        }
      };

      // DOM : pointer
      this.container = null;
      this.rendercontainer = null;
      this.toolscontainer = null;

      // DOM : className or id
      this.name = {
        target: "GPEditorMapBoxLegendTarget",
        container: "GPEditorMapBoxLegendContainer",
        containerlegendrender: "GPEditorMapBoxLegendRenderContainer",
        legendrender: "GPEditorMapBoxLegendRender",
        legendeditable: "GPEditorMapBoxLegendEditable",
        legendtitle: "GPEditorMapBoxLegendTitle",
        containerlegendtools: "GPEditorMapBoxLegendToolsContainer"
      };

      // DOM : Label menu Edition
      this.labels = {
        "line-color": "Couleur du trait",
        "line-width": "Epaisseur du trait",
        "line-opacity": "Opacité du trait",
        "fill-color": "Couleur de remplissage",
        "fill-opacity": "Opacité du remplissage"
      };
    }

    /**
     * Graphical rendering of the component
     * (called by constructor)
     *
     * @private
     * @example
     * <div class="GPEditorMapBoxLegendContainer">
     *  <div class="GPEditorMapBoxLegendRenderContainer">
     *      <div class="GPEditorMapBoxLegendRender GPEditorMapBoxLegendEditable legend-circle" style="..."></div>
     *      <span class="GPEditorMapBoxLegendTitle">test circle editable...</span>
     *  </div>
     *  <div class="GPEditorMapBoxLegendToolsContainer">...</div>
     * </div>
     */
  }, {
    key: "_initContainer",
    value: function _initContainer() {
      var _obj = this.options.obj;
      var div = document.createElement("div");
      div.className = this.name.container;

      // INFO
      // on recherche les informations dans le tag 'paint' en priorité, mais pour
      // les icones ou textes, les informations peuvent se trouver aussi dans le tag 'layout'...
      // on fusionnne paint et layout par facilité
      var style = Object.assign({}, _obj.paint, _obj.layout);

      // liste des properties mapbox
      // ex. fill-color
      var keys = Object.keys(style);
      if (keys.length === 0) {
        logger.info("tag 'paint' or 'layout' is empty !");
        return;
      }

      // FIXME
      // - gestion de type plus complexe : texte avec/sans symbole ou symbole !
      // - pour les textes ou icones, les info peuvent être aussi dans le tag 'layout' !
      var params = {};
      var bFound = false;
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        // recherche du type
        // ex. fill
        if (/fill-/.test(key) || /line-/.test(key) || /circle-/.test(key) || /background-/.test(key) || /text-/.test(key) || /icon-/.test(key)) {
          // style geré & trouvé
          bFound = true;
          var title = _obj.title || "";

          // INFO
          // le type texte ou icone est difficile à trouver car les 2 types cohabitent,
          // on le gère en symbole...
          var type = key.split("-")[0];
          if (type === "text" || type === "icon") {
            type = "symbol";
          }
          this.legendRender = this._getProperties(type, style);
          params = {
            edit: this.editable,
            title: title,
            type: this.legendRender.type,
            values: this.legendRender.values
          };
          div.appendChild(this._createElementIconLegend(params));

          // on stoppe la recherche
          break;
        }
      }

      // legende avec un style indeterminé ou non géré !?
      if (!bFound) {
        // on prend la legende par defaut
        params = {
          edit: this.editable,
          title: "",
          type: this.legendRender.type,
          values: this.legendRender.values
        };
        div.appendChild(this._createElementIconLegend(params));
        logger.warn("legend type unknown, default legend used...");
      }

      // ajout mode edition graphique de la legende
      this.toolscontainer = this._createElementEditionLegend(params);
      div.appendChild(this.toolscontainer);

      // main container
      this.container = div;
    }

    // ################################################################### //
    // ##################### private methods ############################# //
    // ################################################################### //
    /**
    * Get properties supported
    *
    * @param {Object} type - fill, line, circle, text, icon...
    * @param {Object} values - raw values from the JSON file
    * @returns {Object} - { type : (fill | line | circle | symbol), values : valuesSupported }
    *
    * @private
    * @example
    *
    * // TODO
    * // symbol with text (1) / symbol without text (2) / text (3)
    * // "layout":{
    * //      "icon-image":"{maki}-11",          <!--- IT'S A SYMBOL (1) (2)-->
    * //      "text-font":[
    * //           "Open Sans Semibold",
    * //           "Arial Unicode MS Bold"
    * //       ],
    * //       "text-field":"{name_en}",         <!--- IT'S A TEXT (1) (3)-->
    * //       "text-max-width":9,
    * //       "text-padding":2,
    * //       "text-offset":[
    * //            0,
    * //            0.6
    * //       ],
    * //       "text-anchor":"top",
    * //       "text-size":12
    * // },
    * // "paint":{
    * //     "text-color":"#666",
    * //     "text-halo-color":"#ffffff",
    * //     "text-halo-width":1,
    * //     "text-halo-blur":0.5
    * // },
    *
    */
  }, {
    key: "_getProperties",
    value: function _getProperties(type, values) {
      // cas particulier du symbole complexe
      // il existe plusieurs types pour un symbole :
      // - text
      // - icon
      // - icon with text
      if (type === "symbol") {
        var isTextValue = values["text-field"];
        var isIconValue = values["icon-image"];
        type = isTextValue && isIconValue ? "icon" : isTextValue ? "text" : isIconValue ? "icon" : "unknow";
        if (type === "unknow") {
          logger.warn("type unknow !?");
          return;
        }
      }
      var valuesSupported = {};
      for (var key in values) {
        if (Object.hasOwnProperty.call(values, key)) {
          var val = values[key];
          if (Legend.PROPERTIES[type].includes(key)) {
            var prop = key.replace(type, "").slice(1);
            var value = this._getValue(val);
            if (value) {
              // cas particulier des sprites
              if (prop === "pattern" || prop === "image") {
                if (!this.options.sprites || !this.options.sprites.json || !this.options.sprites.json[value]) {
                  var k = type + ":" + prop;
                  logger.warn("sprites mandatory for key ", k);
                  break;
                }
              }
              valuesSupported[prop] = value;
            }
          } else {
            logger.warn("property not supported : ", key);
          }
        }
      }
      return {
        type: type,
        values: valuesSupported
      };
    }

    /**
    * Render thumbnail (SVG)
    *
    * @param {Object} type - fill, line, circle, text, ...
    * @param {Object} values - {"color":..., "width":..., "stroke":...., "opacity":...}
    * @returns {Boolean} true/false
    *
    * @private
    * @example
    * (...)
    */
  }, {
    key: "_renderThumbnail",
    value: function _renderThumbnail(type, values) {
      // div de rendu de la legende
      var div = this.rendercontainer;
      if (!div) {
        return false;
      }

      // SVG
      var svg = null;
      // facteur grossissement (x10) pour le trait
      var factor = 3;

      // valeur par defaut
      if (!values.color) {
        values.color = "#FFFFFF";
      }
      // en fonction du type, on y ajoute le style
      switch (type) {
        case "text":
          var styleText = "font-size: 5em;font-weight: bold;";
          svg = "url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 100 100'><text x='50' y='50' fill='%color%' fill-opacity='%opacity%'  text-anchor='middle' dominant-baseline='central' style='%style%'> T </text></svg>\")";
          div.style["background"] = svg.replace("%color%", values.color.indexOf("rgb") === 0 ? values.color : _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].hexToRgba(values.color, 1)).replace("%opacity%", values.opacity || 1).replace("%style%", styleText);
          break;
        case "icon":
          if (values.image) {
            // FIXME on reste dans le paradigme d'utilisation du SVG...,
            // mais probleme de ratio de l'image !?
            svg = "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' width='27px' height='27px' x='0' y='0' viewBox='%x% %y% %w% %h%'><image width='%W%px' height='%H%px' href='%URL%'/></svg>".replace("%x%", this.options.sprites.json[values.image].x).replace("%y%", this.options.sprites.json[values.image].y).replace(/%w%/g, this.options.sprites.json[values.image].width).replace(/%h%/g, this.options.sprites.json[values.image].height).replace("%W%", this.options.sprites.size.w).replace("%H%", this.options.sprites.size.h).replace("%URL%", this.options.sprites.url);
            div.innerHTML = svg;
          } else {
            var styleTextIcon = "fill: transparent;stroke-width: 10;";
            svg = "url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 100 100'><path d='M 50,20 80,82.5 20,82.5 z' stroke='%color%' style='%style%'/></svg>\")";
            div.style["background"] = svg.replace("%color%", values.color.indexOf("rgb") === 0 ? values.color : _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].hexToRgba(values.color, 1)).replace("%style%", styleTextIcon);
          }
          break;
        case "line":
          var lstrockedasharray = Array.isArray(values["dasharray"]) ? values["dasharray"].join(" ") : 0;
          svg = "url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 100 100'><line x1='0' y1='100' x2='100' y2='0' stroke='%color%' stroke-width='%stroke-width%' stroke-opacity='%stroke-opacity%' stroke-dasharray='%stroke-dasharray%' /></svg>\")";
          // svg = "url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 100 100'><path d='M0 99 L99 0 L100 1 L1 100' stroke='%color%' stroke-width='%width%' stroke-opacity='%opacity%' stroke-dasharray='%dasharray%' /></svg>\")";
          div.style["background"] = svg.replace("%color%", values.color.indexOf("rgb") === 0 ? values.color : _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].hexToRgba(values.color, 1)).replace("%stroke-opacity%", values.opacity || 1).replace("%stroke-dasharray%", lstrockedasharray).replace("%stroke-width%", (values.width || 0) * factor);
          break;
        case "circle":
          var cstrockcolor = values["stroke-color"] || "#FFFFFF";
          svg = "url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 100 100'><circle cx='50' cy='50' r='40' stroke='%stroke-color%' stroke-width='%stroke-width%' stroke-opacity='%strock-opacity%' fill='%color%' fill-opacity='%opacity%' /></svg>\")";
          div.style["background"] = svg.replace("%color%", values.color.indexOf("rgb") === 0 ? values.color : _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].hexToRgba(values.color, 1)).replace("%opacity%", values.opacity || 1).replace("%stroke-color%", cstrockcolor.indexOf("rgb") === 0 ? cstrockcolor : _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].hexToRgba(cstrockcolor, 1)).replace("%stroke-opacity%", values["stroke-opacity"] || 1).replace("%stroke-width%", (values["stroke-width"] || 0) * factor);
          break;
        case "background":
        case "fill":
          if (values.pattern) {
            svg = "<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' width='27px' height='27px' x='0' y='0' viewBox='%x% %y% %w% %h%'><image width='%W%px' height='%H%px' href='%URL%'/></svg>".replace("%x%", this.options.sprites.json[values.pattern].x).replace("%y%", this.options.sprites.json[values.pattern].y).replace(/%w%/g, this.options.sprites.json[values.pattern].width).replace(/%h%/g, this.options.sprites.json[values.pattern].height).replace("%W%", this.options.sprites.size.w).replace("%H%", this.options.sprites.size.h).replace("%URL%", this.options.sprites.url);
            div.innerHTML = svg;
          } else {
            var fstrokecolor = values["outline-color"] || "#FFFFFF";
            svg = "url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 100 100'><rect x='0' y='0' width='100' height='100' rx='5' ry='5' stroke='%stroke-color%' stroke-width='3' fill='%color%' fill-opacity='%opacity%' /></svg>\")";
            div.style["background"] = svg.replace("%color%", values.color.indexOf("rgb") === 0 ? values.color : _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].hexToRgba(values.color, 1)).replace("%opacity%", values.opacity || 1).replace("%stroke-color%", fstrokecolor.indexOf("rgb") === 0 ? fstrokecolor : _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].hexToRgba(fstrokecolor, 1));
          }
          break;
        default:
          logger.warn("type not found, no thumbnail...");
          return false;
      }
      return true;
    }

    /**
     * Get value
     *
     * @param {*} value - value of a property (ex. "#2BB3E1")
     * @returns {*} return a verified value (ex. color": "#2BB3E1")
     *
     * @private
     * @example
     * // type simple for fill, line or circle type with string :
     * // "paint": {
     * //     "fill-color": "#2BB3E1"
     * // }
     *
     * // type simple for fill, line or circle type with array :
     * // "paint": {
     * //     "line-dasharray": [2,10]
     * // }
     *
     * // TODO type complexe : not yet implemented !
     * // "paint": {
     * //     "fill-color": [
     * //          "match",
     * //          ["get","symbo"],
     * //          "ZONE_BOISEE","#A7DA81",
     * //          "ZONE_MANGROVE","#7E8AB5",
     * //          "#A7DA81"
     * //      ]
     * // }
     *
     * // other type complexe :
     * // "paint": {
     * //     "fill-color": {
     * //        "base": 1,
     * //        "stops": [
     * //        [
     * //          15.5,
     * //         "#f2eae2"
     * //        ],
     * //        [
     * //          16,
     * //          "#dfdbd7"
     * //        ]
     * //        ]
     * //     }
     * // }
     */
  }, {
    key: "_getValue",
    value: function _getValue(value) {
      var result = null;
      if (typeof value === "string") {
        result = value;
      } else if (typeof value === "number") {
        result = value;
      } else if (Array.isArray(value)) {
        // cas d'un tableau de valeurs numériques : [1,2,3]
        var isNumber = true;
        value.forEach(function (v) {
          if (typeof v !== "number") {
            isNumber = false;
          }
        });
        if (isNumber) {
          result = value;
        }
      } else if (_typeof(value) === "object") {
        result = null;
        if ("stops" in value) {
          // on realise un ordre inversé sur les zooms
          value.stops.sort(function (a, b) {
            var numA = a[0];
            var numB = b[0];
            if (numA > numB) {
              return -1;
            }
            if (numA < numB) {
              return 1;
            }
            return 0;
          });
          // et, on prend le plus petit zoom
          var lastStopsValue = value.stops.slice(-1);
          result = lastStopsValue[0][1];
        }
      } else {
        logger.warn("value not supported !");
      }
      return result;
    }

    // ################################################################### //
    // ######################### DOM methods ############################# //
    // ################################################################### //
    /**
    * Create a Graphical Legend Icon
    *
    * @param {Object} params - param
    * @param {String} params.title - title
    * @param {String} params.type - fill, line, circle, text, icon, ...
    * @param {String} params.values - {"color": "#2BB3E1", "width": 10, "opacity": 0.5, "stroke": "#2BB3E1"}
    * @param {Boolean} params.edit - editable with a colorPicker for only line, fill and circle legend !
    * @returns {DOMElement} DOM element
    *
    * @private
    * @example
    *   <div class="GPEditorMapBoxLegendRenderContainer">
    *       <div class="GPEditorMapBoxLegendRender GPEditorMapBoxLegendEditable legend-fill"
    *           style="background: url(&quot;data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' preserveAspectRatio='none' viewBox='0 0 100 100'><rect x='0' y='0' width='100' height='100' rx='5' ry='5' fill='rgba(255, 255, 255, 1)' fill-opacity='1' /></svg>&quot;);">
    *       </div>
    *       <span class="GPEditorMapBoxLegendTitle">vide...</span>
    * </div>
    */
  }, {
    key: "_createElementIconLegend",
    value: function _createElementIconLegend(params) {
      // contexte
      var self = this;
      var container = document.createElement("div");
      container.className = this.name.containerlegendrender;
      var div = this.rendercontainer = document.createElement("div");
      div.className = this.name.legendrender;
      if (params.edit) {
        div.className += " ";
        div.className += this.name.legendeditable;
        if (div.addEventListener) {
          div.addEventListener("click", function (e) {
            self.onEditionLegendMapBox(e);
          });
        } else if (div.attachEvent) {
          div.attachEvent("onclick", function (e) {
            self.onEditionLegendMapBox(e);
          });
        }
      }

      // type de legende
      var type = params.type;

      // TODO className
      // div.className += " legend-not-implemented";
      // ajout du style sur la div de rendu
      if (this._renderThumbnail(type, params.values)) {
        // className possibles :
        // " legend-text"
        // " legend-icon"
        // " legend-background"
        // " legend-line"
        // " legend-line-not-editable"
        // " legend-circle"
        // " legend-circle-not-editable"
        // " legend-fill"
        // " legend-fill-not-editable"
        div.className += params.edit ? " legend-" + type : " legend-" + type + "-not-editable";
      } else {
        div.className += " legend-unknow";
      }
      container.appendChild(div);
      var span = document.createElement("span");
      span.className = this.name.legendtitle;
      span.innerHTML = params.title || "";
      container.appendChild(span);
      return container;
    }

    /**
    * Create a Graphical Legend Edition
    *
    * @param {Object} params - param
    * @param {String} params.type - fill, line, (TODO : circle, icon or text)
    * @param {String} params.values - {"fill-color": "#2BB3E1"}
    * @param {Boolean} params.edit - editable with a colorPicker for only line and fill legend !
    * @returns {DOMElement} DOM element
    *
    * @private
    * @example
    *   <div class="GPEditorMapBoxLegendToolsContainer">
    *       <div class="legend-styling-div">
    *           <label for="stroke-color">Couleur du trait</label>
    *           <input class="legend-styling" id="stroke-color" title="" type="color">
    *       </div>
    *       <div class="legend-styling-div">
    *           <label for="stroke-width">Epaisseur du trait</label>
    *           <input class="legend-styling" id="stroke-width" title="" type="range" min="0" max="10" step="1" value="1">
    *       </div>
    *       <div class="legend-styling-div">
    *           <label for="stroke-opacity">Opacité du trait</label>
    *           <input class="legend-styling" id="stroke-opacity" title="" type="range" min="0" max="1" step="0.1" value="1">
    *       </div>
    *       <div class="legend-styling-div">
    *           <label for="fill-color">Couleur de remplissage</label>
    *        <input class="legend-styling" id="fill-color" title="" type="color">
    *       </div>
    *       <div class="legend-styling-div">
    *           <label for="fill-opacity">Opacité du remplissage</label>
    *           <input class="legend-styling" id="fill-opacity" title="" type="range" min="0" max="1" step="0.1" value="1">
    *       </div>
    *   </div>
    */
  }, {
    key: "_createElementEditionLegend",
    value: function _createElementEditionLegend(params) {
      // contexte
      var self = this;
      var container = document.createElement("div");
      container.className = this.name.containerlegendtools;

      // uniquement les elements editables !
      if (!params.edit) {
        return container;
      }

      // on ne traite que l'edition du mode 'traits' ou 'surfaciques'
      // mode 'line'
      switch (params.type) {
        case "line":
          createLineColor.call(self);
          createLineWidth.call(self);
          createLineOpacity.call(self);
          break;
        case "background":
        case "fill":
          createFillColor.call(self);
          createFillOpacity.call(self);
          break;
        default:
          break;
      }

      // couleur du trait
      function createLineColor() {
        var linecolor = document.createElement("div");
        linecolor.className = "legend-styling-div";
        var lLineColor = document.createElement("label");
        lLineColor.className = "legend-line";
        lLineColor.htmlFor = this.id ? "line-color-" + this.id : "line-color";
        lLineColor.innerHTML = this.labels["line-color"];
        var inputLineColor = document.createElement("input");
        inputLineColor.className = "legend-styling";
        inputLineColor.id = this.id ? "line-color-" + this.id : "line-color";
        inputLineColor.title = "Selectionner une couleur de trait";
        inputLineColor.type = "color";
        inputLineColor.value = params.values.color;
        inputLineColor.setAttribute("data-id", "line-color");
        if (inputLineColor.addEventListener) {
          inputLineColor.addEventListener("change", function (e) {
            self._renderThumbnail(params.type, Object.assign(params.values, {
              color: e.target.value
            }));
            self.onChangeValueLegendMapBox(e);
          });
        } else if (inputLineColor.attachEvent) {
          inputLineColor.attachEvent("onchange", function (e) {
            self._renderThumbnail(params.type, Object.assign(params.values, {
              color: e.target.value
            }));
            self.onChangeValueLegendMapBox(e);
          });
        }
        linecolor.appendChild(lLineColor);
        linecolor.appendChild(inputLineColor);
        container.appendChild(linecolor);
      }

      // epaisseur du trait
      function createLineWidth() {
        var linewidth = document.createElement("div");
        linewidth.className = "legend-styling-div";
        var lLineWidth = document.createElement("label");
        lLineWidth.className = "legend-line";
        lLineWidth.htmlFor = this.id ? "line-width-" + this.id : "line-width";
        lLineWidth.innerHTML = this.labels["line-width"];
        var inputLineWidth = document.createElement("input");
        inputLineWidth.className = "legend-styling";
        inputLineWidth.id = this.id ? "line-width-" + this.id : "line-width";
        inputLineWidth.title = params.values.width;
        inputLineWidth.type = "range";
        inputLineWidth.min = "0";
        inputLineWidth.max = "10";
        inputLineWidth.step = "1";
        inputLineWidth.defaultValue = params.values.width;
        inputLineWidth.setAttribute("data-id", "line-width");
        if (inputLineWidth.addEventListener) {
          inputLineWidth.addEventListener("change", function (e) {
            logger.trace(e);
            e.target.title = e.target.value;
            self._renderThumbnail(params.type, Object.assign(params.values, {
              width: e.target.value
            }));
            self.onChangeValueLegendMapBox(e);
          });
        } else if (inputLineWidth.attachEvent) {
          inputLineWidth.attachEvent("onchange", function (e) {
            logger.trace(e);
            e.target.title = e.target.value;
            self._renderThumbnail(params.type, Object.assign(params.values, {
              width: e.target.value
            }));
            self.onChangeValueLegendMapBox(e);
          });
        }
        linewidth.appendChild(lLineWidth);
        linewidth.appendChild(inputLineWidth);
        container.appendChild(linewidth);
      }

      // opacité du trait
      function createLineOpacity() {
        var lineopacity = document.createElement("div");
        lineopacity.className = "legend-styling-div";
        var lLineOpacity = document.createElement("label");
        lLineOpacity.className = "legend-line";
        lLineOpacity.htmlFor = this.id ? "line-opacity-" + this.id : "line-opacity";
        lLineOpacity.innerHTML = this.labels["line-opacity"];
        var inputLineOpacity = document.createElement("input");
        inputLineOpacity.className = "legend-styling";
        inputLineOpacity.id = this.id ? "line-opacity-" + this.id : "line-opacity";
        inputLineOpacity.title = params.values.opacity;
        inputLineOpacity.type = "range";
        inputLineOpacity.min = "0";
        inputLineOpacity.max = "1";
        inputLineOpacity.step = "0.1";
        inputLineOpacity.defaultValue = params.values.opacity;
        inputLineOpacity.setAttribute("data-id", "line-opacity");
        if (inputLineOpacity.addEventListener) {
          inputLineOpacity.addEventListener("change", function (e) {
            logger.trace(e);
            e.target.title = e.target.value;
            self._renderThumbnail(params.type, Object.assign(params.values, {
              opacity: e.target.value
            }));
            self.onChangeValueLegendMapBox(e);
          });
        } else if (inputLineOpacity.attachEvent) {
          inputLineOpacity.attachEvent("onchange", function (e) {
            logger.trace(e);
            e.target.title = e.target.value;
            self._renderThumbnail(params.type, Object.assign(params.values, {
              opacity: e.target.value
            }));
            self.onChangeValueLegendMapBox(e);
          });
        }
        lineopacity.appendChild(lLineOpacity);
        lineopacity.appendChild(inputLineOpacity);
        container.appendChild(lineopacity);
      }

      // couleur de remplissage
      function createFillColor() {
        var fillcolor = document.createElement("div");
        fillcolor.className = "legend-styling-div";
        var lFillColor = document.createElement("label");
        lFillColor.className = "legend-fill";
        lFillColor.htmlFor = this.id ? "fill-color-" + this.id : "fill-color";
        lFillColor.innerHTML = this.labels["fill-color"];
        var inputFillColor = document.createElement("input");
        inputFillColor.className = "legend-styling";
        inputFillColor.id = this.id ? "fill-color-" + this.id : "fill-color";
        inputFillColor.title = "Selectionner une couleur de remplissage";
        inputFillColor.type = "color";
        inputFillColor.value = params.values.color;
        inputFillColor.setAttribute("data-id", "fill-color");
        if (inputFillColor.addEventListener) {
          inputFillColor.addEventListener("change", function (e) {
            self._renderThumbnail(params.type, Object.assign(params.values, {
              color: e.target.value
            }));
            self.onChangeValueLegendMapBox(e);
          });
        } else if (inputFillColor.attachEvent) {
          inputFillColor.attachEvent("onchange", function (e) {
            self._renderThumbnail(params.type, Object.assign(params.values, {
              color: e.target.value
            }));
            self.onChangeValueLegendMapBox(e);
          });
        }
        fillcolor.appendChild(lFillColor);
        fillcolor.appendChild(inputFillColor);
        container.appendChild(fillcolor);
      }

      // opacité du remplissage
      function createFillOpacity() {
        var fillopacity = document.createElement("div");
        fillopacity.className = "legend-styling-div";
        var lFillOpacity = document.createElement("label");
        lFillOpacity.className = "legend-fill";
        lFillOpacity.htmlFor = this.id ? "fill-opacity-" + this.id : "fill-opacity";
        lFillOpacity.innerHTML = this.labels["fill-opacity"];
        var inputFillOpacity = document.createElement("input");
        inputFillOpacity.className = "legend-styling";
        inputFillOpacity.id = this.id ? "fill-opacity-" + this.id : "fill-opacity";
        inputFillOpacity.title = params.values.opacity;
        inputFillOpacity.type = "range";
        inputFillOpacity.min = "0";
        inputFillOpacity.max = "1";
        inputFillOpacity.step = "0.1";
        inputFillOpacity.defaultValue = params.values.opacity;
        inputFillOpacity.setAttribute("data-id", "fill-opacity");
        if (inputFillOpacity.addEventListener) {
          inputFillOpacity.addEventListener("change", function (e) {
            e.target.title = e.target.value;
            self._renderThumbnail(params.type, Object.assign(params.values, {
              opacity: e.target.value
            }));
            self.onChangeValueLegendMapBox(e);
          });
        } else if (inputFillOpacity.attachEvent) {
          inputFillOpacity.attachEvent("onchange", function (e) {
            e.target.title = e.target.value;
            self._renderThumbnail(params.type, Object.assign(params.values, {
              opacity: e.target.value
            }));
            self.onChangeValueLegendMapBox(e);
          });
        }
        fillopacity.appendChild(lFillOpacity);
        fillopacity.appendChild(inputFillOpacity);
        container.appendChild(fillopacity);
      }
      return container;
    }

    // ################################################################### //
    // ##################### public methods ############################## //
    // ################################################################### //
    /**
     * Add element into target DOM
     *
     * @returns {Object} - Legend instance
     */
  }, {
    key: "add",
    value: function add() {
      if (!this.options.target) {
        if (!document.getElementById(this.name.target)) {
          var div = document.createElement("div");
          div.id = this.name.target;
          var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
          node.appendChild(div);
        }
        this.options.target = document.getElementById(this.name.target);
      }
      if (this.container) {
        this.options.target.appendChild(this.container);
      }
      return this;
    }

    /**
     * Set display container or get
     *
     * @param {Boolean} display - show/hidden container or get status
     * @returns {Boolean} - true/false
     */
  }, {
    key: "display",
    value: function display(_display) {
      logger.trace("display()", _display);
      if (typeof _display !== "undefined") {
        this.container.style.display = _display ? "flex" : "none";
      }
      return this.container.style.display === "flex";
    }

    /**
     * Is editable
     *
     * @returns {Boolean} - true/false
     */
  }, {
    key: "isEditable",
    value: function isEditable() {
      return this.editable;
    }

    /**
     * Get container Legend Render (DOM)
     *
     * @returns {DOMElement} DOM element
     * @see Layer.prototype.slotLegend()
     * @example
     *  <div class="GPEditorMapBoxLegendRender legend-(line|fill|background|text|icon|circle|unknow)" style="..."></div>
     */
  }, {
    key: "getRenderContainer",
    value: function getRenderContainer() {
      return this.rendercontainer;
    }

    /**
     * Get container Legend Tools (DOM)
     *
     * @returns {DOMElement} DOM element
     * @see Layer.prototype.slotLegend()
     * @example
     *  <div class="GPEditorMapBoxLegendToolsContainer">...</div>
     */
  }, {
    key: "getToolsContainer",
    value: function getToolsContainer() {
      return this.toolscontainer;
    }

    /**
     * Get container (DOM)
     *
     * @returns {DOMElement} DOM element
     */
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this.container;
    }

    // ################################################################### //
    // ####################### handlers events to dom #################### //
    // ################################################################### //
    /**
     * this method is called by event '' on '' tag form...
     *
     * 'e' contains the option object into 'e.target.data' !
     * 'e' contains the id editor into 'e.target.editorID' !
     *
     * @param {Object} e - HTMLElement
     * @private
     * @fires Legend#editor:legend:onclickedition
     */
  }, {
    key: "onEditionLegendMapBox",
    value: function onEditionLegendMapBox(e) {
      logger.trace("onEditionLegendMapBox", e);
      e.editorID = this.id;
      e.data = this.options;
      eventbusjs__WEBPACK_IMPORTED_MODULE_0___default().dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].legend.onclickedition, e);
    }

    /**
     * this method is called by event '' on '' tag form...
     *
     * 'e' contains the option object into 'e.target.data' !
     * 'e' contains the id editor into 'e.target.editorID' !
     *
     * @param {Object} e - HTMLElement
     * @private
     * @fires Legend#editor:legend:onchangevalue
     */
  }, {
    key: "onChangeValueLegendMapBox",
    value: function onChangeValueLegendMapBox(e) {
      logger.trace("onChangeValueLegendMapBox", e);
      e.editorID = this.id;
      e.data = this.options;
      eventbusjs__WEBPACK_IMPORTED_MODULE_0___default().dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].legend.onchangevalue, e);
    }
  }]);
}();
;

// ################################################################### //
// ########################## CONSTANTES ############################# //
// ################################################################### //

/**
 * List of supported properties
 */
Legend.PROPERTIES = {
  line: ["line-color", "line-dasharray", "line-opacity", "line-width"],
  fill: ["fill-color", "fill-opacity", "fill-outline-color", "fill-pattern"],
  background: ["background-color", "background-opacity", "background-pattern"],
  circle: ["circle-color", "circle-opacity", "circle-stroke-color", "circle-stroke-opacity", "circle-stroke-width"],
  icon: ["icon-color", "icon-image", "icon-opacity", "__icon-size"],
  text: ["__text-anchor", "text-color", "text-field", "__text-font", "__text-opacity", "__text-size"]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Legend);

/***/ }),

/***/ "./src/packages/Controls/Editor/Search.js":
/*!************************************************!*\
  !*** ./src/packages/Controls/Editor/Search.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventbusjs */ "./node_modules/eventbusjs/lib/eventbus.min.js");
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventbusjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Event */ "./src/packages/Controls/Editor/Event.js");
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Utils/Helper */ "./src/packages/Utils/Helper.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }




var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_3__["default"].getLogger("editor-search");

/**
 * @classdesc
 *
 * TODO MapBox search management
 *
 * @constructor
 * @alias ol.style.editor.Search
 * @param {Object} options - options for function call.
 * @todo
 * @example
 *   var Search = new Search ({
 *      target : ...,
 *      tools : {
 *          // ...
 *      }
 *      title : "Filtres de recherche :",
 *      obj : {}
 *   });
 *  Search.add();
 *  Search.display(true);
 *  Search.getContainer();
 */
var Search = /*#__PURE__*/function () {
  function Search(options) {
    _classCallCheck(this, Search);
    logger.trace("[constructor] Search", options);

    // options
    this.options = options || {
      // default...
      target: null,
      tools: null,
      title: null,
      obj: null
    };
    if (!(this instanceof Search)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this._initialize();
    this._initContainer();
  }

  /**
   * Initialize component
   * (called by constructor)
   *
   * @private
   */
  return _createClass(Search, [{
    key: "_initialize",
    value: function _initialize() {
      // unique editor id (optional!)
      this.id = this.options.id || null;
      if (!this.options.target) {
        // cf. add()
      }
      var _toolsDefault = {};
      if (!this.options.tools) {
        this.options.tools = _toolsDefault;
      }
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_2__["default"].mergeParams(this.options.tools, _toolsDefault, false);
      if (!this.options.obj) {
        // choix d'avoir un objet vide pour une edition futur...
        this.options.obj = {};
      }
      if (!this.options.title) {
        this.options.title = "Recherche de couches :";
      }
      this.container = null;

      // DOM : className or id
      this.name = {
        target: "GPEditorMapBoxSearchTarget",
        container: "GPEditorMapBoxSearchContainer"
        // TODO ...
      };
    }

    /**
     * Graphical rendering of the component
     * (called by constructor)
     *
     * @private
     * @example
     * <div class="GPEditorMapBoxSearchContainer">
     *  // ...
     * </div>
     */
  }, {
    key: "_initContainer",
    value: function _initContainer() {
      // contexte
      // var self = this;
      var _search = JSON.parse(JSON.stringify(this.options.obj)); // on manipule une copie  !

      if (_search.layers) {
        if (_search.layers.length === 0) {
          logger.info("tag 'layers' is empty !");
        }
      }
      var div = document.createElement("div");
      div.className = this.name.container;

      // TODO...
      // outil de recherche des couches mapbox.
      // 2 modes de recherches : exact ou par autocompletion
      // affichage des resultats directement dans la liste des couches
      // la recherche porte sur les champs suiavnts (options):
      // * id (par defaut)
      // * source-layer (par defaut)
      // * type (ex. Symbol)
      // * field (ex. HOPITAL_PONC) > recherche dans le champs filtre
      // main container
      this.container = div;
    }

    // ################################################################### //
    // ##################### public methods ############################## //
    // ################################################################### //
    /**
     * Add element into target DOM
     * @returns {Object} - Search instance
     */
  }, {
    key: "add",
    value: function add() {
      if (!this.options.target) {
        if (!document.getElementById(this.name.target)) {
          var div = document.createElement("div");
          div.id = this.name.target;
          var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
          node.appendChild(div);
        }
        this.options.target = document.getElementById(this.name.target);
      }
      if (this.container) {
        this.options.target.appendChild(this.container);
      }
      return this;
    }

    /**
     * Set display container or get
     *
     * @param {Boolean} display - show/hidden container or get status
     * @returns {Boolean} - true/false
     */
  }, {
    key: "display",
    value: function display(_display) {
      logger.trace("display()", _display);
      if (typeof _display !== "undefined") {
        this.container.style.display = _display ? "flex" : "none";
      }
      return this.container.style.display === "flex";
    }

    /**
     * Get container (DOM)
     *
     * @returns {DOMElement} DOM element
     */
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this.container;
    }

    // ################################################################### //
    // ####################### handlers events to dom #################### //
    // ################################################################### //
    /**
     * this method is called by event '' on '' tag form...
     *
     * 'e' contains the option object into 'e.target.data' !
     * 'e' contains the id editor into 'e.target.editorID' !
     *
     * @param {Object} e - HTMLElement
     * @private
     * @fires Search#editor:search:onsubmit
     */
  }, {
    key: "onSubmitSearchLayersMapBox",
    value: function onSubmitSearchLayersMapBox(e) {
      logger.trace("onSubmitSearchLayersMapBox", e);
      e.editorID = this.id;
      e.data = this.options;
      eventbusjs__WEBPACK_IMPORTED_MODULE_0___default().dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].search.onsubmit, e);
    }

    /**
     * this method is called by event '' on '' tag form...
     *
     * 'e' contains the option object into 'e.target.data' !
     * 'e' contains the id editor into 'e.target.editorID' !
     *
     * @param {Object} e - HTMLElement
     * @private
     * @fires Search#editor:search:onautocomplete
     */
  }, {
    key: "onAutocompleteSearchLayersMapBox",
    value: function onAutocompleteSearchLayersMapBox(e) {
      logger.trace("onAutocompleteSearchLayersMapBox", e);
      e.editorID = this.id;
      e.data = this.options;
      eventbusjs__WEBPACK_IMPORTED_MODULE_0___default().dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].search.onautocomplete, e);
    }
  }]);
}();
;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Search);

/***/ }),

/***/ "./src/packages/Controls/Editor/Style.js":
/*!***********************************************!*\
  !*** ./src/packages/Controls/Editor/Style.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventbusjs */ "./node_modules/eventbusjs/lib/eventbus.min.js");
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventbusjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Event */ "./src/packages/Controls/Editor/Event.js");
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Utils/Helper */ "./src/packages/Utils/Helper.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }




var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_3__["default"].getLogger("editor-style");

/**
 * @classdesc
 *
 * MapBox styles management
 *
 * @constructor
 * @alias ol.style.editor.Style
 * @param {Object} options - options for function call.
 * @example
 *   var style = new Style ({
 *      target : ...,
 *      position : 1, // identifiant de position (unique !)
 *      tools : {
 *          edition : false,
 *          scale : true
 *      },
 *      title : "Styles (JSON)",
 *      obj : {
 *          paint : {},
 *          layout : {}
 *      }
 *   });
 *  style.add();
 *  style.display(true);
 *  style.getContainer();
 */
var Style = /*#__PURE__*/function () {
  function Style(options) {
    _classCallCheck(this, Style);
    logger.trace("[constructor] Style", options);

    // options
    this.options = options || {
      // default...
      target: null,
      position: 0,
      tools: null,
      title: null,
      obj: null
    };
    if (!(this instanceof Style)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this._initialize();
    this._initContainer();
  }

  /**
   * Initialize component
   * (called by constructor)
   *
   * @private
   */
  return _createClass(Style, [{
    key: "_initialize",
    value: function _initialize() {
      // unique editor id (optional!)
      this.id = this.options.id || null;
      if (!this.options.target) {
        // cf. add()
      }
      if (!this.options.position) {
        this.options.position = 0;
      }
      var _toolsDefault = {
        scale: true,
        edition: false
      };
      if (!this.options.tools) {
        this.options.tools = _toolsDefault;
      }
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_2__["default"].mergeParams(this.options.tools, _toolsDefault, false);
      if (!this.options.obj) {
        // choix d'avoir un objet vide pour une edition futur...
        this.options.obj = {
          paint: {},
          layout: {}
        };
      }
      if (!this.options.title) {
        this.options.title = "JSON Styles :";
      }
      this.container = null;

      // DOM : className or id
      this.name = {
        target: "GPEditorMapBoxStyleTarget",
        container: "GPEditorMapBoxStyleContainer",
        containerjson: "GPEditorMapBoxStyleJsonContainer",
        jsonlabel: "GPEditorMapBoxStyleJsonTitle",
        jsondisplay: "GPEditorMapBoxStyleJsonDisplay",
        containertoolsscale: "GPEditorMapBoxStyleToolsScaleContainer",
        scaletitle: "GPEditorMapBoxStyleScaleTitle",
        containertoolsminscale: "GPEditorMapBoxStyleToolsScaleMinContainer",
        scalelabelmin: "GPEditorMapBoxStyleScaleLabelMin",
        scaleinputmin: "GPEditorMapBoxStyleScaleInputMin",
        containertoolsmaxscale: "GPEditorMapBoxStyleToolsScaleMaxContainer",
        scalelabelmax: "GPEditorMapBoxStyleScaleLabelMax",
        scaleinputmax: "GPEditorMapBoxStyleScaleInputMax",
        containertoolsedit: "GPEditorMapBoxStyleToolsEditionContainer"
      };
    }

    /**
     * Graphical rendering of the component
     * ie. this.container
     * (called by constructor)
     *
     * @private
     * @example
     * <div class="GPEditorMapBoxStyleContainer">
     *   <div class ="GPEditorMapBoxStyleJsonContainer">
     *      <label class="GPEditorMapBoxStyleJsonTitle">JSON Styles :</label>
     *      <pre class="GPEditorMapBoxStyleJsonDisplay">...</pre>
     *   </div>
     *   <div class ="GPEditorMapBoxStyleToolsScaleContainer"></div>
     *   <div class ="GPEditorMapBoxStyleToolsEditionContainer"></div>
     * </div>
     */
  }, {
    key: "_initContainer",
    value: function _initContainer() {
      // contexte
      var self = this;
      var _found = false;
      var _obj = JSON.parse(JSON.stringify(this.options.obj)); // on manipule une copie  !
      var _style = {};

      // styles into tag 'paint' ?
      if (_obj.paint) {
        _found = true;
        _style.paint = _obj.paint;
        if (Object.keys(_obj.paint).length === 0) {
          logger.info("tag 'paint' is empty !");
        }
      }

      // if not, search into tag 'layout' !
      if (_obj.layout) {
        _found = true;
        _style.layout = _obj.layout;
        // FIXME delete visibility from display ?
        if (_obj.layout.visibility) {
          delete _style.visibility;
        }
        if (Object.keys(_obj.layout).length === 0) {
          logger.info("tag 'layout' is empty !");
        }
      }
      var div = document.createElement("div");
      div.className = this.name.container;
      var json = null;
      if (_found) {
        var strJson = JSON.stringify(_style, null, 4);
        json = this._syntaxHighlight(strJson);
      }
      var divJson = document.createElement("div");
      divJson.className = this.name.containerjson;
      var label = document.createElement("label");
      label.className = this.name.jsonlabel;
      label.innerHTML = this.options.title;
      divJson.appendChild(label);
      var pre = document.createElement("pre");
      pre.className = this.name.jsondisplay;
      pre.innerHTML = json;
      if (pre.addEventListener) {
        pre.addEventListener("click", function (e) {
          if (self.options.tools.edition) {
            self.onEditJsonStyleMapBox(e);
          }
        });
      } else if (pre.attachEvent) {
        pre.attachEvent("onclick", function (e) {
          if (self.options.tools.edition) {
            self.onEditJsonStyleMapBox(e);
          }
        });
      }
      divJson.appendChild(pre);
      div.appendChild(divJson);

      // scale
      if (this.options.tools.scale) {
        div.appendChild(this._createElementToolsScale({
          min: _style.layout ? _style.layout.minzoom : 0,
          max: _style.layout ? _style.layout.maxzoom : 21
        }));
      }

      // TODO menu d'edition
      if (this.options.tools.edition) {
        div.appendChild(this._createElementToolsEdition());
      }

      // main container
      this.container = div;
    }

    /**
     * Graphical rendering of the scale tools
     *
     * @param {Object} scale - {min,max} or 0|21
     * @returns {DOMElement} DOM element
     *
     * @private
     * @example
     *   <div class ="GPEditorMapBoxStyleToolsScaleContainer"></div>
     */
  }, {
    key: "_createElementToolsScale",
    value: function _createElementToolsScale(scale) {
      logger.trace("_createElementToolsScale");
      var self = this;
      var obj = this.options.obj;
      var divToolsScale = document.createElement("div");
      divToolsScale.className = this.name.containertoolsscale;

      // FIXME Titre ?
      // var label = document.createElement("label");
      // label.className = this.name.scaletitle;
      // label.innerHTML = "Scale :";
      // divToolsScale.appendChild(label);
      var divMin = document.createElement("div");
      divMin.className = this.name.containertoolsminscale;
      var labelMin = document.createElement("label");
      labelMin.className = this.name.scalelabelmin;
      labelMin.innerHTML = "min :";
      divMin.appendChild(labelMin);
      var inputMin = document.createElement("input");
      inputMin.className = this.name.scaleinputmin;
      inputMin.type = "range";
      inputMin.value = scale.min || 0;
      inputMin.title = scale.min || 0;
      inputMin.disabled = false;
      inputMin.min = 0;
      inputMin.max = 21;
      inputMin.data = obj; // on lie le DOM et la couche, utile lors d'evenement !
      if (inputMin.addEventListener) {
        inputMin.addEventListener("change", function (e) {
          self.onChangeStyleScaleMinMapBox(e);
        });
      } else if (inputMin.appendChild) {
        inputMin.appendChild("onchange", function (e) {
          self.onChangeStyleScaleMinMapBox(e);
        });
      }
      divMin.appendChild(inputMin);
      divToolsScale.appendChild(divMin);
      var divMax = document.createElement("div");
      divMax.className = this.name.containertoolsmaxscale;
      var labelMax = document.createElement("label");
      labelMax.className = this.name.scalelabelmax;
      labelMax.innerHTML = "max :";
      divMax.appendChild(labelMax);
      var inputMax = document.createElement("input");
      inputMax.className = this.name.scaleinputmin;
      inputMax.type = "range";
      inputMax.value = scale.max || 21;
      inputMax.title = scale.max || 21;
      inputMax.disabled = false;
      inputMax.min = 0;
      inputMax.max = 21;
      inputMax.data = obj; // on lie le DOM et la couche, utile lors d'evenement !
      if (inputMax.addEventListener) {
        inputMax.addEventListener("change", function (e) {
          self.onChangeStyleScaleMaxMapBox(e);
        });
      } else if (inputMax.appendChild) {
        inputMax.appendChild("onchange", function (e) {
          self.onChangeStyleScaleMaxMapBox(e);
        });
      }
      divMax.appendChild(inputMax);
      divToolsScale.appendChild(divMax);
      return divToolsScale;
    }

    /**
     * Graphical rendering of the edition tools
     *
     * @returns {DOMElement} DOM element
     *
     * @private
     * @example
     *   <div class ="GPEditorMapBoxStyleToolsScaleContainer"></div>
     */
  }, {
    key: "_createElementToolsEdition",
    value: function _createElementToolsEdition() {
      logger.warn("_createElementToolsEdition, it's not yet implemented !");
      var divToolsEdit = document.createElement("div");
      divToolsEdit.className = this.name.containertoolsedit;
      return divToolsEdit;
    }

    // ################################################################### //
    // ##################### private methods ############################# //
    // ################################################################### //
    /**
     * Transform a JSON into a DOM with a syntax in color
     *
     * @private
     * @param {Object} json - json.
     * @returns {DOMElement} dom element
     */
  }, {
    key: "_syntaxHighlight",
    value: function _syntaxHighlight(json) {
      json = json.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)/g, function (match) {
        var cls = "gp-json-number";
        if (/^"/.test(match)) {
          if (/:$/.test(match)) {
            cls = "gp-json-key";
          } else {
            cls = "gp-json-string";
          }
        } else if (/true|false/.test(match)) {
          cls = "gp-json-boolean";
        } else if (/null/.test(match)) {
          cls = "gp-json-null";
        }
        return "<span class='" + cls + "'>" + match + "</span>";
      });
    }

    // ################################################################### //
    // ##################### public methods ############################## //
    // ################################################################### //
    /**
     * Add element into target DOM
     * @returns {Object} - Legend instance
     */
  }, {
    key: "add",
    value: function add() {
      if (!this.options.target) {
        if (!document.getElementById(this.name.target)) {
          var div = document.createElement("div");
          div.id = this.name.target;
          var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
          node.appendChild(div);
        }
        this.options.target = document.getElementById(this.name.target);
      }
      if (this.container) {
        this.options.target.appendChild(this.container);
      }
      return this;
    }

    /**
     * Set display container or get
     *
     * @param {Boolean} display - show/hidden container or get status
     * @returns {Boolean} - true/false
     */
  }, {
    key: "display",
    value: function display(_display) {
      logger.trace("display()", _display);
      if (typeof _display !== "undefined") {
        this.container.style.display = _display ? "flex" : "none";
      }
      return this.container.style.display === "flex";
    }

    /**
     * Get container (DOM)
     *
     * @returns {DOMElement} DOM element
     */
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this.container;
    }

    // ################################################################### //
    // ####################### handlers events to dom #################### //
    // ################################################################### //
    /**
     * this method is called by event '' on '' tag form...
     *
     * 'e' contains the option object into 'e.target.data' !
     * 'e' contains the id editor into 'e.target.editorID' !
     *
     * @param {Object} e - HTMLElement
     * @private
     * @fires Style#editor:style:oneditjson
     */
  }, {
    key: "onEditJsonStyleMapBox",
    value: function onEditJsonStyleMapBox(e) {
      logger.trace("onEditJsonStyleMapBox", e);
      e.editorID = this.id;
      e.data = this.options;
      eventbusjs__WEBPACK_IMPORTED_MODULE_0___default().dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].style.oneditjson, e);
    }

    /**
     * this method is called by event '' on '' tag form...
     *
     * 'e' contains the option object into 'e.target.data' !
     * 'e' contains the id editor into 'e.target.editorID' !
     *
     * @param {Object} e - HTMLElement
     * @private
     * @fires Style#editor:style:scale:onchangemin
     */
  }, {
    key: "onChangeStyleScaleMinMapBox",
    value: function onChangeStyleScaleMinMapBox(e) {
      logger.trace("onChangeStyleScaleMinMapBox", e);
      e.editorID = this.id;
      e.data = this.options;
      eventbusjs__WEBPACK_IMPORTED_MODULE_0___default().dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].style.scale.onchangemin, e);
    }

    /**
     * this method is called by event '' on '' tag form...
     *
     * 'e' contains the option object into 'e.target.data' !
     * 'e' contains the id editor into 'e.target.editorID' !
     *
     * @param {Object} e - HTMLElement
     * @private
     * @fires Style#editor:style:scale:onchangemax
     */
  }, {
    key: "onChangeStyleScaleMaxMapBox",
    value: function onChangeStyleScaleMaxMapBox(e) {
      logger.trace("onChangeStyleScaleMaxMapBox", e);
      e.editorID = this.id;
      e.data = this.options;
      eventbusjs__WEBPACK_IMPORTED_MODULE_0___default().dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].style.scale.onchangemax, e);
    }
  }]);
}();
;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Style);

/***/ }),

/***/ "./src/packages/Controls/Editor/Themes.js":
/*!************************************************!*\
  !*** ./src/packages/Controls/Editor/Themes.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventbusjs */ "./node_modules/eventbusjs/lib/eventbus.min.js");
/* harmony import */ var eventbusjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventbusjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Event */ "./src/packages/Controls/Editor/Event.js");
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Utils/Helper */ "./src/packages/Utils/Helper.js");
/* harmony import */ var _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Utils/SelectorID */ "./src/packages/Utils/SelectorID.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }





var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__["default"].getLogger("editor-themes");

/**
 * @classdesc
 *
 * Mapbox Themes management
 *
 * @constructor
 * @alias ol.style.editor.Theme
 * @param {Object} options - options for function call.
 * @example
 *   var theme = new Themes ({
 *        "target": "",
 *        "tools": {
 *          "thumbnails": true,
 *          "button" : {
 *              "visible" : true,
 *              "type" : "radio" (par defaut) | "checkbox"
 *          }
 *        },
 *        "obj": {
 *          "themesSummary": "", // Titre du composant (non graphique !)
 *          "themes": [{
 *             "thumbnail": "data/images/layer0.png",
 *             "name": "standard0",
 *             "url": "data/styles/layer0.json",
 *             "description": "",
 *             "selected" : true
 *          },{
 *             "thumbnail": "data/images/layer1.png",
 *             "name": "standard1",
 *             "url": "data/styles/layer1.json",
 *             "description": ""
 *          }]
 *        }
 *   });
 *  theme.add();
 *  theme.display(true);
 *  theme.getContainer();
 */
var Themes = /*#__PURE__*/function () {
  function Themes(options) {
    _classCallCheck(this, Themes);
    logger.trace("[constructor] Themes", options);

    // options
    this.options = options || {
      // TODO default...
    };
    if (!(this instanceof Themes)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    this._initialize();
    this._initContainer();
  }

  /**
   * Initialize component
   * (called by constructor)
   *
   * @private
   */
  return _createClass(Themes, [{
    key: "_initialize",
    value: function _initialize() {
      // unique editor id (optional!)
      this.id = this.options.id || null;
      if (!this.options.target) {
        // cf. add()
      }
      var _toolsDefault = {
        thumbnails: true,
        button: {
          visible: true,
          type: "radio"
        }
      };
      if (!this.options.tools || Object.keys(this.options.tools).length === 0) {
        this.options.tools = _toolsDefault;
      }
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_2__["default"].mergeParams(this.options.tools, _toolsDefault, false);
      if (typeof this.options.obj === "undefined" || this.options.obj === null || !this.options.obj) {
        // vide par defaut ?
        this.options.obj = {
          themesSummary: "",
          themes: []
        };
      }
      this.container = null;

      // DOM : className or id
      this.name = {
        target: "GPEditorMapBoxThemeTarget",
        container: "GPEditorMapBoxThemesContainer",
        containertheme: "GPEditorMapBoxThemeContainer",
        containerthemeID: "GPEditorMapBoxThemeContainer_ID_",
        input: "GPEditorMapBoxThemeInput",
        inputID: "GPEditorMapBoxThemeInput_ID_",
        label: "GPEditorMapBoxThemeTitle",
        labelID: "GPEditorMapBoxThemeTitle_ID_",
        image: "GPEditorMapBoxThemeImage",
        imageID: "GPEditorMapBoxThemeImage_ID_",
        message: "GPEditorMapBoxThemeMessage"
      };
    }

    /**
     * Graphical rendering of the component
     * (called by constructor)
     *
     * @private
     * @example
     *  <div class="GPEditorMapBoxThemesContainer">
     *      <div id="GPEditorMapBoxThemeContainer-1" class="GPEditorMapBoxThemeContainer">
     *          <input type="radio" id="GPEditorMapBoxThemeInput-1" class="GPEditorMapBoxThemeInput" name="1552920176933">
     *          <img class="GPEditorMapBoxThemeImage" src="http://image1.png" alt="Description1"></img>
     *          <label for="GPEditorMapBoxThemeInput-1" class="GPEditorMapBoxThemeTitle">Titre1</label>
     *      </div>
     *      <div id="GPEditorMapBoxThemeContainer-2" class="GPEditorMapBoxThemeContainer">
     *          <input type="radio" id="GPEditorMapBoxThemeInput-2" class="GPEditorMapBoxThemeInput" name="1552920176934">
     *          <img class="GPEditorMapBoxThemeImage" src="http://image2.png" alt="Description2"></img>
     *          <label for="GPEditorMapBoxThemeInput-2" class="GPEditorMapBoxThemeTitle">Titre2</label>
     *      </div>
     * </div>
     */
  }, {
    key: "_initContainer",
    value: function _initContainer() {
      // contexte
      var self = this;
      var obj = this.options.obj;
      var id = this.id || _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_3__["default"].generate();

      // div principale
      var div = document.createElement("div");
      div.className = this.name.container;
      div.title = obj.themesSummary || "";
      var _lstThemes = obj.themes;
      if (_lstThemes) {
        for (var i = 0; i < _lstThemes.length; i++) {
          var _theme = _lstThemes[i];

          // div pour chaque theme
          var divTheme = document.createElement("div");
          divTheme.id = this.name.containerthemeID + i + "_" + id;
          divTheme.className = this.name.containertheme;
          divTheme.tabIndex = i;

          // url du style est obligatoire !
          var _url = _theme.url;
          // style selectionné par defaut (uniquement en mode radio-button !?)
          var _selected = _theme.selected || false;
          if (_url) {
            // bouton
            var button = this.options.tools.button;
            if (button.visible) {
              var _type = button.type === "checkbox" ? "checkbox" : "radio";
              var _button = document.createElement("input");
              _button.type = _type;
              _button.id = this.name.inputID + i + "_" + id;
              _button.className = this.name.input;
              _button.name = id;
              _button.checked = _selected;
              _button.data = _url; // on lie le DOM et la couche, utile lors d'evenement !
              if (_button.addEventListener) {
                _button.addEventListener("click", function (e) {
                  self.onClickThemeTitleMapBox(e);
                });
              } else if (_button.attachEvent) {
                _button.attachEvent("onclick", function (e) {
                  self.onClickThemeTitleMapBox(e);
                });
              }
              divTheme.appendChild(_button);
            }
            // vignette
            if (this.options.tools.thumbnails) {
              if (_theme.thumbnail) {
                var _img = document.createElement("img");
                _img.id = this.name.imageID + i + "_" + id;
                _img.className = this.name.image;
                _img.src = _theme.thumbnail;
                _img.alt = _theme.thumbnail;
                _img.title = _theme.description || ""; // une description au survol de l'image ou titre...
                _img.data = _url; // on lie le DOM et la couche, utile lors d'evenement !
                if (_img.addEventListener) {
                  _img.addEventListener("click", function (e) {
                    self.onClickThemeImageMapBox(e);
                    // maj du radio button
                    var nodes = e.target.parentElement.childNodes;
                    if (nodes) {
                      var node = nodes[0];
                      if (node.tagName.toLowerCase() === "input") {
                        node.checked = !node.checked;
                      }
                    }
                  });
                } else if (_img.attachEvent) {
                  _img.attachEvent("onclick", function (e) {
                    self.onClickThemeImageMapBox(e);
                    var nodes = e.target.parentElement.childNodes;
                    if (nodes) {
                      var node = nodes[0];
                      if (node.tagName.toLowerCase() === "input") {
                        node.checked = !node.checked;
                      }
                    }
                  });
                }
                divTheme.appendChild(_img);
              }
            }
            // label
            if (_theme.name) {
              var _label = document.createElement("label");
              _label.id = this.name.labelID + i + "_" + id;
              if (this.options.tools.button.visible) {
                _label.htmlFor = _button.id;
              }
              _label.className = this.name.label;
              _label.innerHTML = _theme.name;
              _label.title = _theme.description || ""; // une description au survol de l'image ou titre...
              _label.data = _url; // on lie le DOM et la couche, utile lors d'evenement !
              if (!this.options.tools.button.visible) {
                if (_label.addEventListener) {
                  _label.addEventListener("click", function (e) {
                    self.onClickThemeTitleMapBox(e);
                  });
                } else if (_label.attachEvent) {
                  _label.attachEvent("onclick", function (e) {
                    self.onClickThemeTitleMapBox(e);
                  });
                }
              }
              divTheme.appendChild(_label);
            }
          } else {
            var _msg = document.createElement("label");
            _msg.className = this.name.message;
            _msg.innerHTML = "Thème non disponible...";
            divTheme.appendChild(_msg);
          }
          div.appendChild(divTheme);
        }
      }
      this.container = div;
    }

    // ################################################################### //
    // ##################### public methods ############################## //
    // ################################################################### //
    /**
     * Add element into target DOM
     * @returns {Object} - Legend instance
     */
  }, {
    key: "add",
    value: function add() {
      if (!this.options.target) {
        if (!document.getElementById(this.name.target)) {
          var div = document.createElement("div");
          div.id = this.name.target;
          var node = document.documentElement || document.getElementsByTagName("body")[0] || document.getElementsByTagName("head")[0];
          node.appendChild(div);
        }
        this.options.target = document.getElementById(this.name.target);
      }
      if (this.container) {
        this.options.target.appendChild(this.container);
      }
      return this;
    }

    /**
     * Set display container or get
     *
     * @param {Boolean} display - show/hidden container or get status
     * @returns {Boolean} - true/false
     */
  }, {
    key: "display",
    value: function display(_display) {
      logger.trace("display()", _display);
      if (typeof _display !== "undefined") {
        this.container.style.display = _display ? "flex" : "none";
      }
      return this.container.style.display === "flex";
    }

    /**
     * Get container (DOM)
     *
     * @returns {DOMElement} DOM element
     */
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this.container;
    }

    // ################################################################### //
    // ####################### handlers events to dom #################### //
    // ################################################################### //
    /**
     * this method is called by event '' on '' tag form
     *
     * @param {Object} e - HTMLElement
     * @private
     * @fires Themes#editor:themes:image
     */
  }, {
    key: "onClickThemeImageMapBox",
    value: function onClickThemeImageMapBox(e) {
      logger.trace("onClickThemeImageMapBox", e);
      e.editorID = this.id;
      e.data = this.options;
      if (this.options.tools.button.type === "checkbox") {
        // GPEditorMapBoxThemeInput_ID_0_1571317605868
        var targetIDX = e.target.previousSibling.id.substring(e.target.previousSibling.id.lastIndexOf("_") + 1);
        var _inputs = document.getElementsByClassName(this.name.input);
        for (var i = 0; i < _inputs.length; i++) {
          var el = _inputs[i];
          if (el.id === e.target.previousSibling.id) {
            continue;
          }
          var elIDX = el.id.substring(el.id.lastIndexOf("_") + 1);
          if (elIDX !== targetIDX) {
            continue;
          }
          el.checked = false;
        }
      }
      eventbusjs__WEBPACK_IMPORTED_MODULE_0___default().dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].themes.onclickimage, e);
    }

    /**
     * this method is called by event '' on '' tag form
     *
     * @param {Object} e - HTMLElement
     * @private
     * @fires Themes#editor:themes:title
     */
  }, {
    key: "onClickThemeTitleMapBox",
    value: function onClickThemeTitleMapBox(e) {
      logger.trace("onClickThemeTitleMapBox", e);
      e.editorID = this.id;
      e.data = this.options;
      if (this.options.tools.button.type === "checkbox") {
        // GPEditorMapBoxThemeInput_ID_0_1571317605868
        var targetIDX = e.target.id.substring(e.target.id.lastIndexOf("_") + 1);
        var _inputs = document.getElementsByClassName(this.name.input);
        for (var i = 0; i < _inputs.length; i++) {
          var el = _inputs[i];
          if (el.id === e.target.id) {
            continue;
          }
          var elIDX = el.id.substring(el.id.lastIndexOf("_") + 1);
          if (elIDX !== targetIDX) {
            continue;
          }
          el.checked = false;
        }
      }
      eventbusjs__WEBPACK_IMPORTED_MODULE_0___default().dispatch(_Event__WEBPACK_IMPORTED_MODULE_1__["default"].themes.onclicktitle, e);
    }
  }]);
}();
;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Themes);

/***/ }),

/***/ "./src/packages/Controls/ElevationPath/ElevationPath.js":
/*!**************************************************************!*\
  !*** ./src/packages/Controls/ElevationPath/ElevationPath.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CSS_Controls_ElevationPath_GPFelevationPath_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../CSS/Controls/ElevationPath/GPFelevationPath.css */ "./src/packages/CSS/Controls/ElevationPath/GPFelevationPath.css");
/* harmony import */ var _Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Control */ "./src/packages/Controls/Control.js");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ol/style */ "ol/style");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_style__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ol/geom */ "ol/geom");
/* harmony import */ var ol_geom__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_geom__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ol/interaction */ "ol/interaction");
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_interaction__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ol/proj */ "ol/proj");
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ol_proj__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var ol_sphere__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ol/sphere */ "ol/sphere");
/* harmony import */ var ol_sphere__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ol_sphere__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var ol_Feature__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ol/Feature */ "ol/Feature");
/* harmony import */ var ol_Feature__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(ol_Feature__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ol/layer/Vector */ "ol/layer/Vector");
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(ol_layer_Vector__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ol/source/Vector */ "ol/source/Vector");
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(ol_source_Vector__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var geoportal_access_lib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! geoportal-access-lib */ "./node_modules/geoportal-access-lib/src/Gp.js");
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../Utils/Helper */ "./src/packages/Utils/Helper.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../Utils/SelectorID */ "./src/packages/Utils/SelectorID.js");
/* harmony import */ var _Utils_Markers__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../Utils/Markers */ "./src/packages/Controls/Utils/Markers.js");
/* harmony import */ var _Utils_Interactions__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../Utils/Interactions */ "./src/packages/Controls/Utils/Interactions.js");
/* harmony import */ var _ToolBoxMeasure_MeasureToolBox__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../ToolBoxMeasure/MeasureToolBox */ "./src/packages/Controls/ToolBoxMeasure/MeasureToolBox.js");
/* harmony import */ var _Measures_Measures__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../Measures/Measures */ "./src/packages/Controls/Measures/Measures.js");
/* harmony import */ var _LayerSwitcher_LayerSwitcher__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../LayerSwitcher/LayerSwitcher */ "./src/packages/Controls/LayerSwitcher/LayerSwitcher.js");
/* harmony import */ var _Export_Export__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../Export/Export */ "./src/packages/Controls/Export/Export.js");
/* harmony import */ var _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../Formats/GeoJSON */ "./src/packages/Formats/GeoJSON.js");
/* harmony import */ var _ElevationPathDOM__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./ElevationPathDOM */ "./src/packages/Controls/ElevationPath/ElevationPathDOM.js");
/* harmony import */ var _ProfileElevationPathDOM__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./ProfileElevationPathDOM */ "./src/packages/Controls/ElevationPath/ProfileElevationPathDOM.js");
var _ElevationPath;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/** globals AmCharts, d3 */
// import CSS

// import "../../CSS/Controls/ElevationPath/GPFelevationPathStyle.css";
// import OpenLayers
// import Control from "ol/control/Control";









// import geoportal library access

// import local




// import local with ol dependencies






// DOM


var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_12__["default"].getLogger("elevationpath");

/**
 * @classdesc
 *
 * Elevation Path Control. Allows users to draw a path on a Openlayers map see the elevation profile computed with geoportal elevation path web service along that path.
 *
 * @constructor
 * @alias ol.control.ElevationPath
 * @type {ol.control.ElevationPath}
 * @extends ol.control.Control
 * @param {Object} options - options for function call.
 * @param {String} [options.apiKey] - API key for services call (isocurve and autocomplete services). The key "calcul" is used by default.
 * @param {Boolean} [options.active = false] - specify if control should be actived at startup. Default is false.
 * @param {Boolean} [options.ssl = true] - use of ssl or not (default true, service requested using https protocol)
 * @param {Boolean|Object} [options.export = false] - Specify if button "Export" is displayed. For the use of the options of the "Export" control, see {@link ol.control.Export}
 * @param {Object} [options.elevationOptions = {}] - elevation path service options. See {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~getAltitude Gp.Services.getAltitude()} for available options
 * @param {Object} [options.layerDescription = {}] - Layer informations to be displayed in LayerSwitcher widget (only if a LayerSwitcher is also added to the map)
 * @param {String} [options.layerDescription.title = "Profil altimétrique"] - Layer title to be displayed in LayerSwitcher
 * @param {String} [options.layerDescription.description = "Mon profil altimétrique"] - Layer description to be displayed in LayerSwitcher
 * @param {Object} [options.stylesOptions] - styles management
 * @param {Object} [options.stylesOptions.marker = {}] - styles management of marker displayed on map when the user follows the elevation path. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Image-ImageStyle.html ol.style.Image} subclass object
 * @param {Object} [options.stylesOptions.draw = {}] - styles used when drawing. Specified with following properties.
 * @param {Object} [options.stylesOptions.draw.pointer = {}] - Style for mouse pointer when drawing the line. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Image-ImageStyle.html ol.style.Image} subclass object.
 * @param {Object} [options.stylesOptions.draw.start = {}] - Line Style when drawing. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Stroke-Stroke.html ol.style.Stroke} object.
 * @param {Object} [options.stylesOptions.draw.finish = {}] - Line Style when finished drawing. Specified with an {@link https://openlayers.org/en/latest/apidoc/module-ol_style_Stroke-Stroke.html ol.style.Stroke} object.
 * @param {Object} [options.displayProfileOptions = {}] - profile options.
 * @param {Boolean} [options.displayProfileOptions.totalDistance = true] - display the total distance of the path
 * @param {Boolean} [options.displayProfileOptions.greaterSlope = true] - display the greater slope into the graph
 * @param {Boolean} [options.displayProfileOptions.meanSlope = true] -  display the mean slope into the graph
 * @param {Boolean} [options.displayProfileOptions.ascendingElevation = true] -  display the ascending elevation into the graph
 * @param {Boolean} [options.displayProfileOptions.descendingElevation = true] -  display the descending elevation into the graph
 * @param {Boolean} [options.displayProfileOptions.currentSlope = true] -  display current slope value on profile mouseover
 * @param {Function} [options.displayProfileOptions.apply] - function to display profile if you want to cutomise it. By default, ([DISPLAY_PROFILE_BY_DEFAULT()](./ol.control.ElevationPath.html#.DISPLAY_PROFILE_BY_DEFAULT)) is used. Helper functions to use with D3 ([DISPLAY_PROFILE_LIB_D3()](./ol.control.ElevationPath.html#.DISPLAY_PROFILE_LIB_D3)) or AmCharts ([DISPLAY_PROFILE_LIB_AMCHARTS()](./ol.control.ElevationPath.html#.DISPLAY_PROFILE_LIB_AMCHARTS)) frameworks are also provided. You may also provide your own function.
 * @param {Object} [options.displayProfileOptions.target] - DOM container to use to display the profile.
 * @fires elevationpath:drawstart
 * @fires elevationpath:drawend
 * @fires elevationpath:compute
 * @fires export:compute
 * @example
 *
 * var measure = new ol.control.ElevationPath({
 *    export : false,
 *    stylesOptions : {
 *     draw : {
 *       finish : new ol.style.Stroke({
 *            color : "rgba(0, 0, 0, 0.5)",
 *            width : 2
 *       })
 *     },
 *    }
 *    displayProfileOptions : {
 *       apply : ol.control.ElevationPath.DISPLAY_PROFILE_RAW,
 *    }
 * });
 *
 * // if you want to pluggued the control Export with options :
 * var measure = new ol.control.ElevationPath({
 *    export : {
 *      name : "export",
 *      format : "geojson",
 *      title : "Exporter",
 *      menu : false
 *    }
 * });
 *
 * Exemples :
 * - displayProfileOptions.apply : null
 * - displayProfileOptions.apply : function (elevations, container, context) {  // do some stuff... }
 * - displayProfileOptions.apply : ol.control.ElevationPath.DISPLAY_PROFILE_{LIB_AMCHARTS | LIB_D3 | RAW}
 *
 */
var ElevationPath = (_ElevationPath = /*#__PURE__*/function (_Control) {
  /**
   * See {@link ol.control.ElevationPath}
   * @module ElevationPath
   * @alias module:~controls/ElevationPath
   * @param {*} options - options
   * @example
   * import ElevationPath from "gpf-ext-ol/controls/ElevationPath"
   * ou 
   * import { ElevationPath } from "gpf-ext-ol"
   */
  function ElevationPath(options) {
    var _this;
    _classCallCheck(this, ElevationPath);
    logger.trace("ElevationPath()");

    /**
     * options
     * @private
     */
    options = options || {};

    // call ol.control.Control constructor
    _this = _callSuper(this, ElevationPath, [{
      element: options.element,
      target: options.target,
      render: options.render
    }]);
    if (!(_this instanceof ElevationPath)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }

    /**
     * Nom de la classe (heritage)
     * @private
     */
    _this.CLASSNAME = "ElevationPath";

    // uuid
    _this._uid = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_13__["default"].generate();

    // container : HTMLElement
    _this._showContainer = null;
    _this._pictoButton = null;
    _this._panelContainer = null;
    _this._profileContainer = null;
    _this._waitingContainer = null;
    _this._infoContainer = null;

    // timer sur la fenetre d'informations des données
    _this._timerHdlr = null;

    // objet de type "ol.style"
    _this._drawStyleStart = null;
    _this._drawStyleFinish = null;
    _this._markerStyle = null;

    // graph
    _this._profile = null;

    // data elevations
    _this._data = {};

    /* objet de type
        "ol.source.Vector",
        "ol.layer.Vector",
        "ol.interaction.Draw"
    */
    _this._measureSource = null;
    _this._measureVector = null;
    _this._measureDraw = null;

    // objet de type ol.feature, saisie en cours
    _this._lastSketch = null;
    _this._currentSketch = null;

    // objet de type ol.feature, marker
    _this._marker = null;

    // initialisation du composant
    _this._initialize(options);

    // creation du DOM container
    _this._container = _this._initializeContainer();

    // ajout du container
    _this.element ? _this.element.appendChild(_this._container) : _this.element = _this._container;
    return _possibleConstructorReturn(_this, _this);
  }

  /**
  * Styles applied by default if stylesOptions property is not set.
  */
  _inherits(ElevationPath, _Control);
  return _createClass(ElevationPath, [{
    key: "setMap",
    value:
    // ################################################################### //
    // ##################### public methods ############################## //
    // ################################################################### //

    /**
     * Attach control to map. Overloaded ol.control.Control.setMap() method.
     *
     * @param {ol.Map} map - Map.
     */
    function setMap(map) {
      logger.trace("ElevationPath::setMap");
      if (map) {
        // activation des interactions de dessin selon la valeur de
        // l'option active
        if (this.options.active) {
          // on n'affiche pas la fenetre de profile s'il n'existe pas...
          if (this._profile === null) {
            this._panelContainer.style.display = "none";
            // this._panelContainer.style.visibility = "hidden";
          }
          this._initMeasureInteraction(map);
          this._addMeasureInteraction(map);
        }

        // ajout du composant dans une toolbox
        if (!this.options.target && !this.options.position) {
          _ToolBoxMeasure_MeasureToolBox__WEBPACK_IMPORTED_MODULE_16__["default"].add(map, this);
        }

        // ajout d'un bouton d'export
        if (this.options["export"]) {
          var opts = _Utils_Helper__WEBPACK_IMPORTED_MODULE_11__["default"].assign({
            control: this
          }, this.options["export"]);
          this["export"] = new _Export_Export__WEBPACK_IMPORTED_MODULE_19__["default"](opts);
          this["export"].render();
          var self = this;
          this["export"].on("export:compute", function (e) {
            self.dispatchEvent({
              type: "export:compute",
              content: e.content
            });
          });
        }
      }

      // on appelle la méthode setMap originale d'OpenLayers
      _get(_getPrototypeOf(ElevationPath.prototype), "setMap", this).call(this, map);

      // position
      if (this.options.position) {
        this.setPosition(this.options.position);
      }
    }
  }, {
    key: "getActive",
    value:
    /**
     * Returns true if widget is actived (drawing),
     * false otherwise
     *
     * @returns {Boolean} active - true or false
     */
    function getActive() {
      logger.trace("ElevationPath::getActive");
      return this.options.active;
    }

    /**
     * Actived widget drawing or not
     *
     * @param {Boolean} active - true / false
     */
  }, {
    key: "setActive",
    value: function setActive(active) {
      logger.trace("ElevationPath::setActive");
      this.options.active = active;
    }

    /**
     * Get elevation data
     *
     * @returns {Object} data - elevations
     * @example
     * {
     *        type // "elevationpath"
     *        greaterSlope // pente max
     *        meanSlope  // pente moyenne
     *        distancePlus // distance cumulée positive
     *        distanceMinus // distance cumulée négative
     *        ascendingElevation // dénivelé cumulée positive
     *        descendingElevation // dénivelé cumulée négative
     *        altMin // altitude min
     *        altMax // altitude max
     *        distance // distance totale
     *        unit // unité des mesures de distance
     *        points // elevations
     *   }
     */
  }, {
    key: "getData",
    value: function getData() {
      return _Utils_Helper__WEBPACK_IMPORTED_MODULE_11__["default"].assign({
        type: "elevationpath"
      }, this._data);
    }

    /**
     * Set profile data
     *
     * @param {*} data - elevations
     * @example
     * {
     *        greaterSlope // pente max
     *        meanSlope  // pente moyenne
     *        distancePlus // distance cumulée positive
     *        distanceMinus // distance cumulée négative
     *        ascendingElevation // dénivelé cumulée positive
     *        descendingElevation // dénivelé cumulée négative
     *        altMin // altitude min
     *        altMax // altitude max
     *        distance // distance totale
     *        unit // unité des mesures de distance
     *        points // elevations
     * }
     */
  }, {
    key: "setData",
    value: function setData(data) {
      this._data = data;
    }

    /**
     * Get container
     *
     * @returns {DOMElement} container
     */
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this._container;
    }

    /**
     * Get layer
     *
     * @returns {ol.layer.Vector} layer
     */
  }, {
    key: "getLayer",
    value: function getLayer() {
      return this._measureVector;
    }

    /**
     * Set layer
     *
     * @param {Object} layer - ol.layer.Vector profil layer
     */
  }, {
    key: "setLayer",
    value: function setLayer(layer) {
      if (!layer) {
        this._measureVector = null;
        return;
      }
      if (!(layer instanceof (ol_layer_Vector__WEBPACK_IMPORTED_MODULE_8___default()))) {
        logger.log("no valid layer given for hosting drawn features.");
        return;
      }

      // application des styles
      layer.setStyle(this._drawStyleFinish);
      // sauvegarde
      this._measureVector = layer;
      this._measureSource = layer.getSource();
    }

    /**
     * Get vector layer
     *
     * @returns {String} geojson - GeoJSON format layer
     */
  }, {
    key: "getGeoJSON",
    value: function getGeoJSON() {
      var features = this._measureVector.getSource().getFeatures();
      var Format = new _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_20__["default"]({
        defaultStyle: this._drawStyleFinish
      });
      // INFO
      // par defaut, webmercator ou "EPSG:3857"
      var geojson = Format.writeFeatures(features, {
        dataProjection: "EPSG:4326",
        featureProjection: "EPSG:3857"
      });
      return geojson;
    }

    /**
     * Get default style
     *
     * @returns {ol.style} style
     */
  }, {
    key: "getStyle",
    value: function getStyle() {
      return this._drawStyleFinish;
    }

    /**
     * clean
     * @param {Boolean} remove - remove layer
     */
  }, {
    key: "clean",
    value: function clean(remove) {
      logger.trace("ElevationPath::clean");
      var map = this.getMap();

      // fenetre du profil
      this._panelContainer.style.display = "none";
      // this._panelContainer.style.visibility = "hidden";

      // picto
      this._pictoButton.setAttribute("aria-pressed", false);

      // this._removeMeasure();
      this._removeProfile();
      this._removeMeasureInteraction(map, typeof remove !== "undefined" ? remove : false);
      this.setLayer();
    }

    /**
     * This method is public.
     * It allows to init the control.
     * @fixme
     */
  }, {
    key: "init",
    value: function init() {
      // FIXME
      // le panneau du profil ne peut pas afficher un profil si il est caché
      // car le profil est calculé en fonction de la taille du panneau (clientHeight / clientWidth),
      // et ces valeurs sont à 0 !?
      this._pictoButton.setAttribute("aria-pressed", true);
      this._panelContainer.style.display = "block";
      this._displayProfile(this._data);
      this._waitingContainer.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
    }

    // ################################################################### //
    // ##################### init component ############################## //
    // ################################################################### //

    /**
     * Initialize control (called by constructor)
     *
     * @param {Object} options - options
     *
     * @private
     */
  }, {
    key: "_initialize",
    value: function _initialize(options) {
      logger.trace("ElevationPath::_initialize : ", options);

      // liste des options
      this.options = {
        target: null,
        render: null,
        active: false,
        apiKey: null,
        "export": false,
        elevationOptions: {
          outputFormat: "json"
        },
        layerDescription: {
          title: "Profil altimétrique",
          description: "Mon profil altimétrique"
        },
        displayProfileOptions: {
          totalDistance: true,
          greaterSlope: true,
          meanSlope: true,
          ascendingElevation: true,
          descendingElevation: true,
          currentSlope: true,
          apply: null,
          target: null
        },
        stylesOptions: {
          profile: null,
          draw: null,
          marker: null
        }
      };

      // merge with user options
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_11__["default"].mergeParams(this.options, options);
      this.options.target = options.target || null;
      // this.options.render = options.render || null;

      // cle API sur le service
      this.options.apiKey = options.apiKey;

      // gestion de l'affichage du profil
      var _profile = options.displayProfileOptions || {};

      // bouton export
      this["export"] = null;

      // gestion de la fonction du profil
      var displayFunction = _profile.apply;
      this.options.displayProfileOptions.apply = typeof displayFunction === "function" ? displayFunction : ElevationPath.DISPLAY_PROFILE_BY_DEFAULT;

      // gestion du container du profil
      var displayContainer = _profile.target;
      this.options.displayProfileOptions.target = typeof displayContainer !== "undefined" ? displayContainer : null;

      // gestion des styles
      var _styles = options.stylesOptions || {};

      // FIXME ???
      // gestion du style du profil
      // var profileStyle = _styles.profile;
      // this.options.stylesOptions.profile = ( typeof profileStyle === "undefined" || Object.keys(profileStyle).length === 0 ) ?
      //     ElevationPath.DEFAULT_STYLES.PROFILE : profileStyle;
      // this._createStylingProfile();

      // gestion des styles du tracé
      this.options.stylesOptions.draw = _styles.draw || {};
      this._createStylingDraw();

      // gestion des styles du marker
      this.options.stylesOptions.marker = _styles.marker || {};
      this._createStylingMarker();
    }

    /**
     * initialize component container (DOM)
     *
     * @returns {DOMElement} DOM element
     *
     * @private
     */
  }, {
    key: "_initializeContainer",
    value: function _initializeContainer() {
      logger.trace("ElevationPath::_initializeContainer : ", this._uid);

      // create main container
      var container = this._createMainContainerElement();
      var picto = this._pictoButton = this._createShowElevationPathPictoElement();
      container.appendChild(picto);

      // mode "active"
      if (this.options.active) {
        this._pictoButton.click();
      }

      // panneau
      var panel = this._panelContainer = this._createElevationPathPanelElement();
      var panelDiv = this._createElevationPathPanelDivElement();
      panel.appendChild(panelDiv);

      // header
      var header = this._createElevationPathPanelHeaderElement();
      panelDiv.appendChild(header);

      // profile
      var profile = this._profileContainer = this._createElevationPathPanelProfilElement();
      panelDiv.appendChild(profile);

      // waiting
      var waiting = this._waitingContainer = this._createElevationPathWaitingElement();
      panelDiv.appendChild(waiting);

      // info
      var info = this._infoContainer = this._createElevationPathInformationsElement();
      panelDiv.appendChild(info);
      if (this.options.displayProfileOptions.target === null) {
        container.appendChild(panel);
      }
      return container;
    }

    // ################################################################### //
    // ###################### init styles ################################ //
    // ################################################################### //

    /**
     * create style marker object : "ol.style"
     *
     * @private
     */
  }, {
    key: "_createStylingMarker",
    value: function _createStylingMarker() {
      logger.trace("ElevationPath::_createStylingMarker ");
      var marker = ElevationPath.DEFAULT_STYLES.MARKER;
      logger.trace("style marker", marker);

      // si marker n'est pas un objet ol.style.Image, on applique le
      // style par défaut.
      if (this.options.stylesOptions.marker instanceof ol_style__WEBPACK_IMPORTED_MODULE_2__.Image) {
        marker = this.options.stylesOptions.marker;
      }
      this._markerStyle = new ol_style__WEBPACK_IMPORTED_MODULE_2__.Style({
        image: marker
      });
    }

    /**
     * create style draw object : "ol.style"
     *
     * @private
     */
  }, {
    key: "_createStylingDraw",
    value: function _createStylingDraw() {
      logger.trace("ElevationPath::_createStylingDraw");

      // on interprete les params pour y creer un objet ol.Style
      var styles = this.options.stylesOptions.draw;

      // style de depart
      logger.trace("style start", styles.start);

      // Creation à partir des styles par défaut
      var startStyleOpts = {
        image: _Measures_Measures__WEBPACK_IMPORTED_MODULE_17__["default"].DEFAULT_POINTER_STYLE,
        stroke: _Measures_Measures__WEBPACK_IMPORTED_MODULE_17__["default"].DEFAULT_DRAW_START_STYLE.getStroke()
      };
      // ecrasement à partir des propriétés renseignées
      if (styles.hasOwnProperty("pointer") && styles.pointer instanceof ol_style__WEBPACK_IMPORTED_MODULE_2__.Image) {
        startStyleOpts.image = styles.pointer;
      }
      if (styles.hasOwnProperty("start") && styles.start instanceof ol_style__WEBPACK_IMPORTED_MODULE_2__.Stroke) {
        startStyleOpts.stroke = styles.start;
      }
      this._drawStyleStart = new ol_style__WEBPACK_IMPORTED_MODULE_2__.Style(startStyleOpts);

      // style de fin
      logger.trace("style finish", styles.finish);
      var finishStyleOpts = {
        stroke: _Measures_Measures__WEBPACK_IMPORTED_MODULE_17__["default"].DEFAULT_DRAW_FINISH_STYLE.getStroke()
      };
      // ecrasement à partir des propriétés renseignées
      if (styles.hasOwnProperty("finish") && styles.finish instanceof ol_style__WEBPACK_IMPORTED_MODULE_2__.Stroke) {
        finishStyleOpts.stroke = styles.finish;
      }
      this._drawStyleFinish = new ol_style__WEBPACK_IMPORTED_MODULE_2__.Style(finishStyleOpts);
    }

    /**
     * create style graph
     * FIXME : à revoir car ne sert que pour AmCharts !?
     *
     * @private
     */
  }, {
    key: "_createStylingProfile",
    value: function _createStylingProfile() {
      logger.trace("ElevationPath::_createStylingProfile");
      var userStyles = this.options.stylesOptions.profile;
      logger.trace("style profile", userStyles);
      var defaultStyle = ElevationPath.DEFAULT_STYLES.PROFILE;
      Object.keys(defaultStyle).forEach(function (key) {
        if (!userStyles.hasOwnProperty(key)) {
          // si le style user n'existe pas, on ajoute celui par defaut
          userStyles[key] = defaultStyle[key];
        } else {
          var _defaultStyle = defaultStyle[key];
          if (_typeof(_defaultStyle) === "object") {
            // on merge avec un objet,
            // les styles user ecrasent ceux par defaut...
            _Utils_Helper__WEBPACK_IMPORTED_MODULE_11__["default"].mergeParams(_defaultStyle, userStyles[key]);
            userStyles[key] = _defaultStyle;
          }
        }
      });
    }

    // ################################################################### //
    // ################### Map interactions management ################### //
    // ################################################################### //

    /**
     * this method is called by this.onShowElevationPathClick,
     * and initialize a vector layer, if widget is active.
     *
     * @param {ol.Map} map - Map
     * @private
     */
  }, {
    key: "_initMeasureInteraction",
    value: function _initMeasureInteraction(map) {
      var _this2 = this;
      logger.trace("ElevationPath::_initMeasureInteraction()");

      // var map = this.getMap();
      if (!map) {
        return;
      }
      this._measureSource = new (ol_source_Vector__WEBPACK_IMPORTED_MODULE_9___default())();
      this._measureVector = new (ol_layer_Vector__WEBPACK_IMPORTED_MODULE_8___default())({
        source: this._measureSource,
        style: this._drawStyleFinish
      });

      // on rajoute le champ gpResultLayerId permettant d'identifier une couche crée par le composant.
      this._measureVector.gpResultLayerId = "measure:profil";
      map.addLayer(this._measureVector);

      // Si un layer switcher est présent dans la carte, on lui affecte des informations pour cette couche
      map.getControls().forEach(function (control) {
        if (control instanceof _LayerSwitcher_LayerSwitcher__WEBPACK_IMPORTED_MODULE_18__["default"]) {
          // un layer switcher est présent dans la carte
          var layerId = _this2._measureVector.gpLayerId;
          // on n'ajoute des informations que s'il n'y en a pas déjà (si le titre est le numéro par défaut)
          if (control._layers[layerId].title === layerId) {
            control.addLayer(_this2._measureVector, {
              title: _this2.options.layerDescription.title,
              description: _this2.options.layerDescription.description
            });
          }
        }
      });
    }

    /**
     * this method is called by this.onShowElevationPathClick,
     * and add draw interaction to map, if widget is not active.
     *
     * @param {ol.Map} map - Map
     * @private
     */
  }, {
    key: "_addMeasureInteraction",
    value: function _addMeasureInteraction(map) {
      var _this3 = this;
      logger.trace("ElevationPath::_addMeasureInteraction()");

      // var map = this.getMap();
      if (!map) {
        return;
      }

      // Creates and adds the interaction
      this._measureDraw = new ol_interaction__WEBPACK_IMPORTED_MODULE_4__.Draw({
        source: this._measureSource,
        type: "LineString",
        style: this._drawStyleStart,
        stopClick: true
      });
      this._measureDraw.setProperties({
        name: "ElevationPath",
        source: this
      });
      map.addInteraction(this._measureDraw);

      // Event start
      this._measureDraw.on("drawstart", function (evt) {
        logger.trace("drawstart", evt);

        // delete marker current
        if (_this3._marker !== null) {
          _this3._measureSource.removeFeature(_this3._marker);
          _this3._marker = null;
        }

        // set new feature and remove last feature
        if (_this3._lastSketch !== null) {
          _this3._measureSource.removeFeature(_this3._lastSketch);
          _this3._lastSketch = null;
        }
        _this3._currentSketch = evt.feature;

        // and, all features
        var _features = _this3._measureSource.getFeatures();
        for (var i = 0; i < _features.length; i++) {
          _this3._measureSource.removeFeature(_features[i]);
        }
        /**
        * event triggered at the start of drawing input
        * @event elevationpath:drawstart
        */
        _this3.dispatchEvent("elevationpath:drawstart");
      });

      // Event end
      this._measureDraw.on("drawend", function (evt) {
        logger.trace("drawend", evt);
        /**
        * event triggered at the end of drawing input
        * @event elevationpath:drawend
        */
        _this3.dispatchEvent("elevationpath:drawend");

        // set feature
        _this3._lastSketch = _this3._currentSketch;

        // Si il n'y a pas de surcharge utilisateur de la fonction de recuperation des
        // resultats, on realise l'affichage du panneau
        if (typeof _this3.options.elevationOptions.onSuccess === "undefined" && _this3.options.displayProfileOptions.target === null) {
          _this3._panelContainer.style.display = "block";
          // self._panelContainer.style.visibility = "visible";
        }

        // set an alti request and display results
        _this3._measureDraw.setActive(false);
        _this3._requestService();
      });
    }

    /**
     * this method is called by this.onShowElevationPathClick,
     * and removes draw interaction from map (if exists)
     * And removes layer too...
     *
     * @param {ol.Map} map - Map
     * @param {Boolean} remove - Remove layer
     * @private
     */
  }, {
    key: "_removeMeasureInteraction",
    value: function _removeMeasureInteraction(map, remove) {
      logger.trace("ElevationPath::_removeMeasureInteraction()");

      // var map = this.getMap();
      if (!map) {
        return;
      }
      if (remove) {
        if (this._measureVector) {
          map.removeLayer(this._measureVector);
          this._measureVector = null;
        }
      }
      if (this._measureDraw) {
        map.removeInteraction(this._measureDraw);
        this._measureDraw = null;
      }
    }

    // ################################################################### //
    // ############################ Alti request ######################### //
    // ################################################################### //

    /**
     * transforme geometry feature to position coordinate (service)
     *
     * @returns {Object[]} geometry
     *
     * @private
     */
  }, {
    key: "_getGeometry",
    value: function _getGeometry() {
      // INFO
      // on transmet toujours des coordonnées au service en EPSG:4326

      if (this._currentSketch === null) {
        logger.warn("Current Feature undefined !?");
        return;
      }
      var geometry = [];
      var map = this.getMap();
      var projSrc = map.getView().getProjection();
      var projDest = "EPSG:4326";
      var coordinates = this._currentSketch.getGeometry().getCoordinates();
      for (var i = 0; i < coordinates.length; i++) {
        var xy = coordinates[i];
        var ll = xy;
        // on transmet au service des coordonnées en EPSG:4326
        if (projSrc !== projDest) {
          ll = (0,ol_proj__WEBPACK_IMPORTED_MODULE_5__.transform)(xy, projSrc, projDest);
        }
        geometry.push({
          lon: Math.round(ll[0] * 1e8) / 1e8,
          lat: Math.round(ll[1] * 1e8) / 1e8
        });
      }
      return geometry;
    }

    /**
     * get geometry feature length
     *
     * @returns {Integer} length
     *
     * @private
     */
  }, {
    key: "_getLength",
    value: function _getLength() {
      if (this._currentSketch === null) {
        logger.warn("Current Feature undefined !?");
        return;
      }
      var length = 0;
      var map = this.getMap();
      var projSrc = map.getView().getProjection();
      var projDest = "EPSG:4326";
      var coordinates = this._currentSketch.getGeometry().getCoordinates();
      for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
        var c1 = (0,ol_proj__WEBPACK_IMPORTED_MODULE_5__.transform)(coordinates[i], projSrc, projDest);
        var c2 = (0,ol_proj__WEBPACK_IMPORTED_MODULE_5__.transform)(coordinates[i + 1], projSrc, projDest);
        c1[0] = Math.round(c1[0] * 1e8) / 1e8;
        c1[1] = Math.round(c1[1] * 1e8) / 1e8;
        c2[0] = Math.round(c2[0] * 1e8) / 1e8;
        c2[1] = Math.round(c2[1] * 1e8) / 1e8;
        length += (0,ol_sphere__WEBPACK_IMPORTED_MODULE_6__.getDistance)(c1, c2);
      }
      return length;
    }

    /**
     * get geometry feature point coords in EPSG:4326 [lon, lat]
     *
     * @returns {Array} point coords in EPSG:4326 [lon, lat]
     *
     * @private
     */
  }, {
    key: "_getSketchCoords",
    value: function _getSketchCoords() {
      if (this._currentSketch === null) {
        logger.warn("Current Feature undefined !?");
        return;
      }
      var map = this.getMap();
      var projSrc = map.getView().getProjection();
      var projDest = "EPSG:4326";
      var pointCoords = [];
      var coordinates = this._currentSketch.getGeometry().getCoordinates();
      for (var i = 0; i < coordinates.length; i++) {
        var c1 = (0,ol_proj__WEBPACK_IMPORTED_MODULE_5__.transform)(coordinates[i], projSrc, projDest);
        c1[0] = Math.round(c1[0] * 1e8) / 1e8;
        c1[1] = Math.round(c1[1] * 1e8) / 1e8;
        pointCoords.push(c1);
      }
      return pointCoords;
    }

    /**
     * this method is called at the end of the path,
     * it generates and sends alti request, then displays results
     *
     * @private
     */
  }, {
    key: "_requestService",
    value: function _requestService() {
      logger.trace("ElevationPath::_requestService");

      // les coordonnées sont obligatoires
      var geometry = this._getGeometry();
      logger.trace("geometry", geometry);
      if (!geometry) {
        logger.warn("missing geometry !?");
        return;
      }

      // on construit les options pour la requête
      var options = {};

      // on surcharge avec les options de l'utilisateur
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_11__["default"].mergeParams(options, this.options.elevationOptions);

      // au cas où ...
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_11__["default"].mergeParams(options, {
        apiKey: options.apiKey || this.options.apiKey
      });

      // si l'utilisateur a spécifié le paramètre ssl au niveau du control, on s'en sert
      // true par défaut (https)
      if (typeof options.ssl !== "boolean") {
        if (typeof this.options.ssl === "boolean") {
          options.ssl = this.options.ssl;
        } else {
          options.ssl = true;
        }
      }
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_11__["default"].mergeParams(options, {
        ssl: options.ssl
      });

      // les callbacks
      var self = this;

      // gestion des callback
      var bOnFailure = !!(this.options.elevationOptions.onFailure !== null && typeof this.options.elevationOptions.onFailure === "function"); // cast variable to boolean
      var bOnSuccess = !!(this.options.elevationOptions.onSuccess !== null && typeof this.options.elevationOptions.onSuccess === "function");

      // callback _requestServiceOnSuccess
      var _requestServiceOnSuccess = function _requestServiceOnSuccess(result) {
        logger.trace(result);
        if (result) {
          self._panelContainer.style.display = "block";
          // self._panelContainer.style.visibility = "visible";
          if (self._data) {
            self._data = {};
          }
          self._data = self._computeElevationMeasure(result.elevations);
          self._displayProfile(self._data);
          self._waitingContainer.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
          self._waiting = false;
          self._measureDraw.setActive(true);
        }
        if (bOnSuccess) {
          self.options.elevationOptions.onSuccess.call(self, self.getData());
        }
      };

      // callback _requestServiceOnFailure
      var _requestServiceOnFailure = function _requestServiceOnFailure(error) {
        // on ferme le panneau en cas d'erreur !
        self._panelContainer.style.display = "none";
        // self._panelContainer.style.visibility = "hidden";
        logger.error(error.message);
        self._waitingContainer.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
        self._waiting = false;
        self._measureDraw.setActive(true);
        if (bOnFailure) {
          self.options.elevationOptions.onFailure.call(self, error);
        }
      };
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_11__["default"].mergeParams(options, {
        onSuccess: _requestServiceOnSuccess,
        onFailure: _requestServiceOnFailure
      });

      // le sampling est soit defini par l'utilisateur (opts),
      // ou soit calculé dynamiquement...
      var sampling = options.sampling;
      if (!sampling) {
        // computing sampling
        var _sampling;
        var _length = this._getLength();
        logger.trace("length", _length);
        var p = Math.max(50, Math.floor(_length) / 5); // en mètre sur un pas moyen de 5m !
        if (p > 200) {
          _sampling = 200;
        } else {
          _sampling = Math.floor(p);
        }
        var pointNumber = this._getSketchCoords().length;
        if (pointNumber > 100) {
          _sampling = 0;
        }
      }
      if (_sampling > 0) {
        _Utils_Helper__WEBPACK_IMPORTED_MODULE_11__["default"].mergeParams(options, {
          sampling: _sampling
        });
      }

      // et enfin, la geometrie
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_11__["default"].mergeParams(options, {
        positions: geometry
      });
      logger.trace("options du service", options);

      // mise en place de la patience
      this._waitingContainer.className = "GPwaitingContainer GPwaitingContainerVisible gpf-waiting gpf-waiting--visible";

      // Request altitude service
      geoportal_access_lib__WEBPACK_IMPORTED_MODULE_10__["default"].Services.getAltitude(options);
    }

    // ################################################################### //
    // ########################## Profil display ######################### //
    // ################################################################### //

    /**
     * this method computes results elevations (Z and distance)
     *
     * @param {Array} elevations - array of elevation
     * @return {Array} elevations
     * @private
     */
  }, {
    key: "_computeElevationMeasure",
    value: function _computeElevationMeasure(elevations) {
      logger.trace("ElevationPath::_computeElevationMeasure", elevations);
      var _data = elevations;
      var _unit = "m";
      var _sketchPoints = this._getSketchCoords();
      if (!_sketchPoints) {
        return;
      }
      // section actuelle du sketch sur laquelle on est
      var _currentSection = 0;
      // longueur cumulée des sections précédentes
      var _previousSectionsLength = 0;
      var _nextSectionBegining = _sketchPoints[1];

      // Calcul de la distance au départ pour chaque point + arrondi des lat/lon
      _data[0].dist = 0;
      _data[0].slope = 0;
      _data[0].lat = Math.round(_data[0].lat * 10000) / 10000;
      _data[0].lon = Math.round(_data[0].lon * 10000) / 10000;
      var _distanceMinus = 0;
      var _distancePlus = 0;
      var _ascendingElevation = 0;
      var _descendingElevation = 0;
      var _distance = 0;
      var _slopes = 0;
      var distances = [];
      for (var i = 1; i < _data.length; i++) {
        var a = [_data[i].lon, _data[i].lat];
        var distanceToStart = _previousSectionsLength + (0,ol_sphere__WEBPACK_IMPORTED_MODULE_6__.getDistance)(a, _sketchPoints[_currentSection]);
        var dist = distanceToStart - _distance;

        // Changement de section
        if (a[0] === _nextSectionBegining[0] && a[1] === _nextSectionBegining[1]) {
          _currentSection++;
          _previousSectionsLength = distanceToStart;
          // Pas de next section si on est sur le dernier point
          if (i !== _data.length - 1) {
            _nextSectionBegining = _sketchPoints[_currentSection + 1];
          }
        }
        var za = _data[i].z;
        var zb = _data[i - 1].z;
        if (za < 0) {
          za = 0;
        }
        if (zb < 0) {
          zb = 0;
        }
        var slope = za - zb;
        if (slope < 0) {
          _distanceMinus += dist;
          _descendingElevation += slope;
        } else if (slope > 0) {
          _distancePlus += dist;
          _ascendingElevation += slope;
        }
        _distance = distanceToStart;
        _data[i].dist = distanceToStart;
        distances.push(distanceToStart);
        _slopes += slope ? Math.abs(Math.round(slope / dist * 100)) : 0;
        _data[i].slope = slope ? Math.abs(Math.round(slope / dist * 100)) : 0;

        // EVOL ?
        // cf. gradiant
        // http://www.color-hex.com/color/00b798
        var value = _data[i].slope;
        if (value > 15 && value < 30) {
          _data[i].color = "#005b4c";
        } else if (value > 30 && value < 45) {
          _data[i].color = "#00362d";
        } else if (value > 45) {
          _data[i].color = "#00120f";
        } else {
          _data[i].color = "#00B798";
        }
        _data[i].lat = Math.round(_data[i].lat * 10000) / 10000;
        _data[i].lon = Math.round(_data[i].lon * 10000) / 10000;
      }

      // check distance totale
      logger.trace("List Distances", distances);

      // Correction des altitudes aberrantes + arrondi des calculs de distance + ...
      var _altMin = _data[0].z;
      var _altMax = _data[0].z;
      var _greaterSlope = _data[0].slope;
      for (var ji = 0; ji < _data.length; ji++) {
        var d = _data[ji];
        if (d.z < -100) {
          d.z = 0;
        }
        if (d.z > _altMax) {
          _altMax = d.z;
        }
        if (d.z < _altMin) {
          _altMin = d.z;
        }
        if (d.slope > _greaterSlope) {
          _greaterSlope = d.slope;
        }
      }
      return {
        greaterSlope: _greaterSlope,
        // pente max
        meanSlope: Math.round(_slopes / _data.length),
        // pente moyenne
        distancePlus: _distancePlus,
        // distance cumulée positive
        distanceMinus: _distanceMinus,
        // distance cumulée négative
        ascendingElevation: _ascendingElevation,
        // dénivelé cumulée positive
        descendingElevation: _descendingElevation,
        // dénivelé cumulée négative
        altMin: _altMin.toLocaleString(),
        // altitude min TODO: inutile ?
        altMax: _altMax.toLocaleString(),
        // altitude max TODO: inutile ?
        distance: this._getLength(),
        // distance totale
        unit: _unit,
        // unité des mesures de distance
        points: _data
      };
    }

    /**
     * this method is called after service request (in case of success)
     * and display results
     *
     * @param {Array} elevations - array of elevation
     * @private
     */
  }, {
    key: "_displayProfile",
    value: function _displayProfile(elevations) {
      logger.trace("ElevationPath::_displayProfile", elevations);
      this._updateInfoContainer();

      // container
      var container = this.options.displayProfileOptions.target;
      if (container) {
        container.appendChild(this._panelContainer);
      }
      container = this._profileContainer;

      // TODO contexte ?
      var context = this;

      // fonction
      var displayFunction = this.options.displayProfileOptions.apply;

      // execution...
      displayFunction.call(this, elevations, container, context);
      var opts = this.options.displayProfileOptions;
      var element = document.getElementById("GPelevationPathPanelInfo-" + this._uid);
      if (element) {
        if (opts.totalDistance || opts.greaterSlope || opts.meanSlope || opts.ascendingElevation || opts.descendingElevation) {
          // on affiche les informations
          element.style.display = "block";
        }
      }

      /**
       * event triggered when the compute is finished
       *
       * @event elevationpath:compute
       * @typedef {Object}
       * @property {Object} type - event
       * @property {Object} target - instance ElevationPath
       * @example
       * ElevationPath.on("elevationpath:compute", function (e) {
       *   console.log(e.target.getData());
       * })
       */
      this.dispatchEvent({
        type: "elevationpath:compute"
      });
    }

    /**
     * update info container
     *
     * @private
     */
  }, {
    key: "_updateInfoContainer",
    value: function _updateInfoContainer() {
      logger.trace("ElevationPath::_updateInfoContainer");

      // options d'affichage
      var totalDistance = this.options.displayProfileOptions.totalDistance;
      var meanSlope = this.options.displayProfileOptions.meanSlope;
      var greaterSlope = this.options.displayProfileOptions.greaterSlope;
      var ascendingElevation = this.options.displayProfileOptions.ascendingElevation;
      var descendingElevation = this.options.displayProfileOptions.descendingElevation;

      // clean
      var div = this._infoContainer;
      if (div.childElementCount) {
        while (div.firstChild) {
          div.removeChild(div.firstChild);
        }
      }

      // creation des infomations
      if (totalDistance) {
        this._addElevationPathInformationsItem("Distance totale : " + Math.round(this._data.distance).toLocaleString() + " m");
      }
      if (ascendingElevation) {
        this._addElevationPathInformationsItem("Dénivelé positif : " + this._data.ascendingElevation.toLocaleString() + " m");
      }
      if (descendingElevation) {
        this._addElevationPathInformationsItem("Dénivelé négatif : " + this._data.descendingElevation.toLocaleString() + " m");
      }
      if (meanSlope) {
        this._addElevationPathInformationsItem("Pente moyenne : " + this._data.meanSlope.toLocaleString() + " %");
      }
      if (greaterSlope) {
        this._addElevationPathInformationsItem("Plus forte pente : " + this._data.greaterSlope.toLocaleString() + " %");
      }
    }

    /**
     * Remove measure
     * @private
     */
  }, {
    key: "_removeMeasure",
    value: function _removeMeasure() {
      // sketch
      this._lastSketch = null;
      this._currentSketch = null;
      if (this._measureSource) {
        // marker
        if (this._marker) {
          this._measureSource.removeFeature(this._marker);
          this._marker = null;
        }

        // all other features
        var _features = this._measureSource.getFeatures();
        for (var i = 0; i < _features.length; i++) {
          this._measureSource.removeFeature(_features[i]);
        }
      }
    }

    /**
     * Remove profile
     * @private
     */
  }, {
    key: "_removeProfile",
    value: function _removeProfile() {
      // graph
      this._profile = null;

      // on vide le container
      if (this._profileContainer) {
        while (this._profileContainer.firstChild) {
          this._profileContainer.removeChild(this._profileContainer.firstChild);
        }
      }
    }

    // ################################################################### //
    // ####################### handlers events to dom #################### //
    // ################################################################### //

    /**
     * this method is called by event 'click' on '' picto
     * and enable or disable the entry of the path
     *
     * @param {Object} e - event
     * @private
     */
  }, {
    key: "onShowElevationPathClick",
    value: function onShowElevationPathClick(e) {
      var map = this.getMap();
      _Utils_Interactions__WEBPACK_IMPORTED_MODULE_15__["default"].unset(map, {
        current: "ElevationPath"
      });

      // Activation/Desactivation des interactions de dessins
      var opened = this._pictoButton.ariaPressed;
      if (opened === "true") {
        // on n'affiche pas la fenetre de profile s'il n'existe pas...
        if (this._profile === null) {
          this._panelContainer.style.display = "none";
          // this._panelContainer.style.visibility = "hidden";
        }
        this._initMeasureInteraction(map);
        this._addMeasureInteraction(map);
      } else {
        this._panelContainer.style.display = "none";
        // HACK
        // il est possible de faire passer une instruction via le DOM et les dataset :
        // * data-remove-measure : true|false
        // * data-remove-layer : true|false
        if (e && e.target.dataset && e.target.dataset.removeMeasure) {
          if (e.target.dataset.removeMeasure === "true") {
            this._removeMeasure();
          } else {
            // sketch
            this._lastSketch = null;
            this._currentSketch = null;
          }
        } else {
          this._removeMeasure();
        }
        this._removeProfile();
        if (e && e.target.dataset && e.target.dataset.removeLayer) {
          this._removeMeasureInteraction(map, e.target.dataset.removeLayer === "true");
        } else {
          this._removeMeasureInteraction(map, true);
        }
      }
    }

    /**
     * this method is called by event 'click' on '' picto
     * (cf. this.),
     * and display the panel info
     *
     * @private
     */
  }, {
    key: "onOpenElevationPathInfoClick",
    value: function onOpenElevationPathInfoClick() {
      var div = this._infoContainer;

      // show des informations !
      if (div.className === "GPelementVisible gpf-visible") {
        clearTimeout(this._timerHdlr);
        div.className = "GPelementHidden gpf-hidden";
      } else {
        div.className = "GPelevationPathInformationsContainerVisible";
      }

      // hidden des informations !
      this._timerHdlr = setTimeout(function () {
        div.className = "GPelementHidden gpf-hidden";
      }, 4000);
    }
  }], [{
    key: "__removeProfileMarker",
    value:
    /**
     * suppression du marker
     *
     * @param {Object} context - context
     *
     * @private
     */
    function __removeProfileMarker(context) {
      var self = context;
      // suppression de l'ancien marker
      if (self._marker) {
        self._measureSource.removeFeature(self._marker);
        self._marker = null;
      }
    }
  }, {
    key: "__createProfileMarker",
    value:
    /**
     * suppression du marker
     *
     * @param {Object} context - context
     * @param {Object} d - d
     *
     * @private
     */
    function __createProfileMarker(context, d) {
      var self = context;
      // suppression de l'ancien marker
      if (self._marker) {
        self._measureSource.removeFeature(self._marker);
        self._marker = null;
      }
      var map = self.getMap();
      var proj = map.getView().getProjection();
      var _coordinate = (0,ol_proj__WEBPACK_IMPORTED_MODULE_5__.transform)([d.lon, d.lat], "EPSG:4326", proj);
      var _coordinateProj = self._measureSource.getFeatures()[0].getGeometry().getClosestPoint(_coordinate);
      var _geometry = new ol_geom__WEBPACK_IMPORTED_MODULE_3__.Point(_coordinateProj);
      self._marker = new (ol_Feature__WEBPACK_IMPORTED_MODULE_7___default())({
        geometry: _geometry
      });
      logger.trace(_geometry);

      // style
      self._marker.setStyle(self._markerStyle);

      // ajout du marker sur la map
      self._measureSource.addFeature(self._marker);
    }

    /**
     * mise à jour du marker
     *
     * @param {Object} context - context
     * @param {Object} d - data
     *
     * @private
     */
  }, {
    key: "__updateProfileMarker",
    value: function __updateProfileMarker(context, d) {
      var self = context;
      ElevationPath.__removeProfileMarker(self);
      ElevationPath.__createProfileMarker(self, d);
    }

    /**
     * TODO : customisation possible d'une opération sur le profil
     *
     * @param {Object} context - context
     * @param {Object} d - data
     *
     * @private
     */
  }, {
    key: "__customRawProfileOperation",
    value: function __customRawProfileOperation(context, d) {
      logger.log("__customRawProfileOperation");
      var self = context;
      var _pts = d.points;
      var _proj = self.getMap().getView().getProjection();
      for (var i = 0; i < _pts.length; i++) {
        var obj = _pts[i];
        var _coordinate = (0,ol_proj__WEBPACK_IMPORTED_MODULE_5__.transform)([obj.lon, obj.lat], "EPSG:4326", _proj);
        var _geometry = new ol_geom__WEBPACK_IMPORTED_MODULE_3__.Point(_coordinate);
        self._marker = new (ol_Feature__WEBPACK_IMPORTED_MODULE_7___default())({
          geometry: _geometry
        });
        logger.trace(_geometry);

        // TODO style en options ?
        var styles = ElevationPath.DEFAULT_STYLES.RESULTS;
        var _image = new ol_style__WEBPACK_IMPORTED_MODULE_2__.Circle({
          radius: styles.imageRadius,
          stroke: new ol_style__WEBPACK_IMPORTED_MODULE_2__.Stroke({
            color: styles.imageStrokeColor,
            width: styles.imageStrokeWidth
          }),
          fill: new ol_style__WEBPACK_IMPORTED_MODULE_2__.Fill({
            color: styles.imageFillColor
          })
        });
        self._marker.setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_2__.Style({
          image: _image
        }));

        // ajout du marker sur la map
        self._measureSource.addFeature(self._marker);
      }
    }

    /**
     * TODO : customisation possible d'une opération sur le profil
     * Ex. Methode appélée dans le DOM : ProfileElevationPathDOM
     *
     * @param {Object} context - context
     * @param {Object} e - event
     * @private
     */
  }, {
    key: "__customRawProfileMouseOverEvent",
    value: function __customRawProfileMouseOverEvent(context, e) {
      logger.log("__customRawProfileMouseOverEvent", context, e);
    }

    /**
     * display Profile using Amcharts framework. This method needs AmCharts libraries to be loaded.
     *
     * @param {Object} data - collection elevations
     * @param {HTMLElement} container - container
     * @param {Object} context - this control object
     */
  }, {
    key: "DISPLAY_PROFILE_LIB_AMCHARTS",
    value: function DISPLAY_PROFILE_LIB_AMCHARTS(data, container, context) {
      logger.trace("ElevationPath.DISPLAY_PROFILE_LIB_AMCHARTS");

      // Calcul du profile
      if (typeof AmCharts === "undefined") {
        logger.log("Lib. AmCharts is not loaded !");
        return;
      }
      var profile = _ProfileElevationPathDOM__WEBPACK_IMPORTED_MODULE_22__["default"].displayProfileLibAmCharts(data, container, context, ElevationPath);
      // on sauvegarde le profil du container dans l'objet
      if (profile) {
        this._profile = profile;
      }
    }

    /**
     * display Profile using D3 javascript framework. This method needs D3 libraries to be loaded.
     *
     * @param {Object} data - elevations values for profile
     * @param {HTMLElement} container - html container where to display profile
     * @param {Object} context - this control object
     */
  }, {
    key: "DISPLAY_PROFILE_LIB_D3",
    value: function DISPLAY_PROFILE_LIB_D3(data, container, context) {
      logger.trace("ElevationPath.DISPLAY_PROFILE_LIB_D3");

      // Calcul du profile
      if (typeof d3 === "undefined") {
        logger.log("Lib. D3 is not loaded !");
        return;
      }
      var profile = _ProfileElevationPathDOM__WEBPACK_IMPORTED_MODULE_22__["default"].displayProfileLibD3(data, container, context, ElevationPath);
      // on sauvegarde le profil du container dans l'objet
      if (profile) {
        this._profile = profile;
      }
    }

    /**
     * display Profile without graphical rendering (raw service response)
     *
     * @param {Object} data - elevations values for profile
     * @param {HTMLElement} container - html container where to display profile
     * @param {Object} context - this control object
     */
  }, {
    key: "DISPLAY_PROFILE_RAW",
    value: function DISPLAY_PROFILE_RAW(data, container, context) {
      logger.trace("ElevationPath.DISPLAY_PROFILE_RAW");
      var profile = _ProfileElevationPathDOM__WEBPACK_IMPORTED_MODULE_22__["default"].displayProfileRaw(data, container, context, ElevationPath);
      // on sauvegarde le profil du container dans l'objet
      if (profile) {
        this._profile = profile;
      }
    }
  }, {
    key: "DISPLAY_PROFILE_BY_DEFAULT",
    value:
    /**
     * Display Profile function used by default : no additonal framework needed.
     *
     * @param {Object} data - elevations values for profile
     * @param {HTMLElement} container - html container where to display profile
     * @param {Object} context - this control object
     */
    function DISPLAY_PROFILE_BY_DEFAULT(data, container, context) {
      logger.trace("ElevationPath.DISPLAY_PROFILE_BY_DEFAULT");
      var profile = _ProfileElevationPathDOM__WEBPACK_IMPORTED_MODULE_22__["default"].displayProfileByDefault(data, container, context, ElevationPath);
      // on sauvegarde le profil du container dans l'objet
      if (profile) {
        this._profile = profile;
      }
    }
  }]);
}(_Control__WEBPACK_IMPORTED_MODULE_1__["default"]), _defineProperty(_ElevationPath, "DEFAULT_STYLES", {
  // styling drawing by default
  // see => Measures.DEFAULTS_STYLES
  // stying marker to the profile by default
  MARKER: new ol_style__WEBPACK_IMPORTED_MODULE_2__.Icon({
    src: _Utils_Markers__WEBPACK_IMPORTED_MODULE_14__["default"]["lightOrange"],
    // image avec un mauvais ratio size 51/38 pixels
    // src : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAsCAYAAAAATWqyAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABTtJREFUeNq8WGtsFUUU/rb3gtdCAykFG9AUDTQUKimhxUewEusrJYoBo4FfEgoqotHERH6oP9TGmJhIrIlWAf9hjAaEiME2pgFfVVpFii8sWqIQLLSx3EJLW7p+Z2Z2b2l7d/b23vZLTmZ2duacb2fmnDk7DlKA67rXs1hJKacsohRQppjXFygnKT9TDlH2O47zFzIFGnco91EOuqnjoBnr2Ow4FhIlLN6m3DykFTh3BGj/Doj/CfSe082xPCDnBmDWTUBeyXDVjZTHOUNHUiZCEs+weI0ySTV0/w0c2wa07gIungn+vOx8YN46oPhpYOp1Xms/5TmSeSMUERKImFnYqBoGuPRNL5LEW8BgX2rrmjWZZLYApS8BUW8r4T0zO5eTEjFr+S6lSjV0HgPqVwNdf6S30abNB+7aDeQWey3bKZtIxvU5DxvyrE/izJfAvuXpkxCIDtElOjWqjK2RM8LZWMbiG0oEnUc5kB7a14WMYvI04H56du5ieZKluZWz8r0/IyQh5TuKRH8cqFuTeRIC0Sm6xYbYok1j21+ahyhLVO3wC8D5VowbRLfY0FhibOulIavDLEoRZyD8sJDeMWBXKG5ZsIobsdDsg+OMq3u1m1u9KQo8zP45EqjRxOUpk6i50IRl4FuGjpZtwUoiMYa314GFj/EzIsN8n8v+C1e4kfvwcm+wnhsZY27xQ8oiWZpKrWRQB6tAElfxpKnjsCdGklDzG9HvpI/0DYLYEpsalVnmAAM6fgR62oMHl70C5N9mn3rpI32DILbEpkZ5ljlFgbPNFtebzij5VPhNKX1lTBASNtXSzPZ3cxCuvVOH7FTCu4yxeZDGbCES0z5+PniQ3uGpwTYmYTOWCPGTpgYP6u9OnYhtzBCbQkSH0NiM4EEdP6VOxDYmYbNLiJxQ1elFwYPaG3XQCn3QHddjgpCweUKI6K2bvzw4YROf//rJob6fZl/H2FRoFiINfqo3qyzYwD8MVIeYLw32J+8j76SP9A2C2BKbGg1CZL+EF/W4YKP9a3/fCeyhkrY9DOOXEu1SlzZ5J31sSNjqURm/OfQkY9qgvkYOvXhbuH0g505Oga7HT9rPF9+t5+pDL0ulwzt46FV5ROax+JUSRRtP0LoHMK64+xNg7iqVEVOKSKRVxRGpsKhRnaRD4SPjR0J0axKCGmP7ilQxm4X8d8xXmfvHJZlPkCR3WfODl9FLMlxCIhevSJ5Nwzo1XdKxYpe3hpmB6BKdmoS43VqPxIgsni+aWOg8biZ3f+nLmSMiuvKWek/P01az7QdLyNVT7lC/l59WAKcb0iMxhzpW1nvmvpDtSiKD1l9OkpnDgv8UyMWFU9wvTP8vdY6NhJwnD1JVtso2OiiLSeL0iJUbNfg6zikVVwRTyOn2HWOfjfLtHgnBhtFIJCViyNDZUatdmnGlaFPqJIoe1WM1aqlz71ivJbLNobgAA9zgu7nZ/vstHAk5WVdzaPRqmGC5lER6kjpV4OWJdq+1kkshSk4VH9izcy/bV66qSPQZV+0J9G7rTY6+XNmqHmYwyJVV24kse1X31dhKHdasygkzy+a64oC4nWr47F4e858nSbLv4V/KAe9JKpVDrx/SImLIXMOiRUKdujESl+49O8xVZxpXzVc/C/I/RxL/hgq8YYkYhev9q6kVO4d9B+sr3vdICNaHJTHWW8Ya/87wqy2uWwstUk/gTYw3aCRGOarMDfS67kfFWqSuIe9imAjQEC272nJHixYNaSvGRIIGN49ywbsZEw1zI11N6TZSHeaGORn+F2AAJtRIMx4t+hUAAAAASUVORK5CYII=",
    anchor: [0.5, 1],
    snapToPixel: true
  }),
  // styling service results points by default
  RESULTS: {
    // INFO orienté maintenance !
    imageRadius: 5,
    imageFillColor: "rgba(128, 128, 128, 0.2)",
    imageStrokeColor: "rgba(0, 0, 0, 0.7)",
    imageStrokeWidth: 2
  }
  // FIXME ???
  // PROFILE : {
  //     type : "serial",
  //     pathToImages : "http://cdn.amcharts.com/lib/3/images/",
  //     categoryField : "dist",
  //     autoMarginOffset : 0,
  //     marginRight : 10,
  //     marginTop : 10,
  //     startDuration : 0,
  //     color : "#5E5E5E",
  //     fontSize : 10,
  //     theme : "light",
  //     thousandsSeparator : "",
  //     categoryAxis : {
  //         color : "#5E5E5E",
  //         gridPosition : "start",
  //         minHorizontalGap : 40,
  //         tickPosition : "start",
  //         title : "Distance (km)",
  //         titleColor : "#5E5E5E",
  //         startOnAxis : true
  //     },
  //     chartCursor : {
  //         animationDuration : 0,
  //         bulletsEnabled : true,
  //         bulletSize : 10,
  //         categoryBalloonEnabled : false,
  //         cursorColor : "#F90",
  //         graphBulletAlpha : 1,
  //         graphBulletSize : 1,
  //         zoomable : false
  //     },
  //     trendLines : [],
  //     graphs : [
  //         {
  //             balloonColor : "#CCCCCC",
  //             balloonText : "<span class='altiPathValue'>[[title]] : [[value]]m</span><br/><span class='altiPathCoords'>(lat: [[lat]] / lon:[[lon]])</span>",
  //             bullet : "round",
  //             bulletAlpha : 0,
  //             bulletBorderColor : "#FFF",
  //             bulletBorderThickness : 2,currentSlope
  //             bulletColor : "#F90",
  //             bulletSize : 6,
  //             hidden : false,
  //             id : "AmGraph-1",
  //             fillAlphas : 0.4,
  //             fillColors : "#C77A04",
  //             lineAlpha : 1,
  //             lineColor : "#C77A04",
  //             lineThickness : 1,
  //             title : "Altitude",
  //             valueField : "z"
  //         }
  //     ],
  //     guides : [],
  //     valueAxes : [
  //         {
  //             id : "ValueAxis-1",
  //             minVerticalGap : 20,
  //             title : "Altitude (m)"
  //         }
  //     ],
  //     allLabels : [],
  //     balloon : {
  //         borderColor : "#CCCCCC",
  //         borderThickness : 1,
  //         fillColor : "#FFFFFF",
  //         showBullet : true
  //     },
  //     titles : []
  // }
}), _ElevationPath);

// on récupère les méthodes de la classe commune ElevationPath
Object.assign(ElevationPath.prototype, _ElevationPathDOM__WEBPACK_IMPORTED_MODULE_21__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ElevationPath);

// Expose ElevationPath as ol.control.ElevationPath (for a build bundle)
if (window.ol && window.ol.control) {
  window.ol.control.ElevationPath = ElevationPath;
}

/***/ }),

/***/ "./src/packages/Controls/ElevationPath/ElevationPathDOM.js":
/*!*****************************************************************!*\
  !*** ./src/packages/Controls/ElevationPath/ElevationPathDOM.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ElevationPathDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   *
   * @returns {DOMElement} DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GPelevationPath");
    container.className = "GPwidget gpf-widget gpf-widget-button";
    return container;
  },
  // ################################################################### //
  // ################# Methods to display Main Panel ################### //
  // ################################################################### //

  /**
   * Show control
   * see event !
   *
   * @returns {DOMElement} DOM element
   */
  _createShowElevationPathPictoElement: function _createShowElevationPathPictoElement() {
    // contexte d'execution
    var context = this;
    var button = document.createElement("button");
    button.id = this._addUID("GPshowElevationPathPicto");
    button.className = "GPshowOpen GPshowAdvancedToolPicto gpf-btn gpf-btn-icon gpf-btn-icon-elevation fr-btn";
    button.title = "Calculer un profil";
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);

    // gestionnaire d'evenement :
    // on ouvre le menu de saisie de saisie
    // L'ouverture/Fermeture permet de faire le menage
    // (reinitialisation)
    if (button.addEventListener) {
      button.addEventListener("click", function (e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowElevationPathClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function (e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowElevationPathClick(e);
      });
    }
    return button;
  },
  // ################################################################### //
  // ######################### Methods to Panel ######################## //
  // ################################################################### //

  /**
   * Create Container Panel
   *
   * FIXME
   * don't call this._createElevationPathPanelHeaderElement
   * don't call this._createElevationPathPanelProfilElement
   *
   * @returns {DOMElement} DOM element
   */
  _createElevationPathPanelElement: function _createElevationPathPanelElement() {
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GPelevationPathPanel");
    dialog.className = "GPpanel gpf-panel fr-modal";

    // dialog.appendChild(this._createElevationPathPanelHeaderElement());
    // dialog.appendChild(this._createElevationPathPanelProfilElement());

    return dialog;
  },
  _createElevationPathPanelDivElement: function _createElevationPathPanelDivElement() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    return div;
  },
  /**
   * Create Header Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createElevationPathPanelHeaderElement: function _createElevationPathPanelHeaderElement() {
    var self = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header fr-modal__header";
    var divInfo = document.createElement("button");
    divInfo.id = this._addUID("GPelevationPathPanelInfo");
    divInfo.className = "GPpanelInfo gpf-btn gpf-btn-icon-info fr-btn fr-btn--secondary";
    divInfo.title = "Informations";
    // add event on click
    if (divInfo.addEventListener) {
      divInfo.addEventListener("click", function () {
        self.onOpenElevationPathInfoClick();
      });
    } else if (divInfo.attachEvent) {
      // internet explorer
      divInfo.attachEvent("onclick", function () {
        self.onOpenElevationPathInfoClick();
      });
    }
    container.appendChild(divInfo);
    var divTitle = document.createElement("div");
    divTitle.className = "GPpanelTitle gpf-panel__title fr-modal__title";
    divTitle.innerHTML = "Profil Altimétrique";
    container.appendChild(divTitle);
    var buttonReduce = document.createElement("button");
    buttonReduce.id = this._addUID("GPelevationPathPanelReduce");
    buttonReduce.className = "GPpanelReduce gpf-btn gpf-btn-icon-reduce fr-btn fr-btn--secondary";
    buttonReduce.title = "Masquer le panneau";
    if (buttonReduce.addEventListener) {
      buttonReduce.addEventListener("click", function (e) {
        if (typeof self.onReduceElevationPathPanelClick === "function") {
          self.onReduceElevationPathPanelClick();
        }
      }, false);
    } else if (buttonReduce.attachEvent) {
      buttonReduce.attachEvent("onclick", function (e) {
        if (typeof self.onReduceElevationPathPanelClick === "function") {
          self.onReduceElevationPathPanelClick();
        }
      });
    }
    container.appendChild(buttonReduce);
    var buttonClose = document.createElement("button");
    buttonClose.id = this._addUID("GPelevationPathPanelClose");
    buttonClose.className = "GPpanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--secondary fr-m-1w";
    buttonClose.title = "Fermer le panneau";

    // Link panel close / visibility checkbox
    if (buttonClose.addEventListener) {
      buttonClose.addEventListener("click", function () {
        document.getElementById(self._addUID("GPshowElevationPathPicto")).click();
      }, false);
    } else if (buttonClose.attachEvent) {
      buttonClose.attachEvent("onclick", function () {
        document.getElementById(self._addUID("GPshowElevationPathPicto")).click();
      });
    }
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible"; // afficher en dsfr
    span.innerText = "Fermer";
    buttonClose.appendChild(span);
    container.appendChild(buttonClose);
    return container;
  },
  /**
   * Create Form
   * see evenement !
   *
   * @returns {DOMElement} DOM element
   */
  _createElevationPathPanelProfilElement: function _createElevationPathPanelProfilElement() {
    var div = document.createElement("div");
    div.id = "GPelevationPathProfil";
    return div;
  },
  /**
   * Create Waiting Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createElevationPathWaitingElement: function _createElevationPathWaitingElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPelevationPathCalcWaitingContainer");
    div.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
    var p = document.createElement("p");
    p.className = "GPwaitingContainerInfo gpf-waiting_info";
    p.innerHTML = "Recherche en cours...";
    div.appendChild(p);
    return div;
  },
  /**
   * Create information Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createElevationPathInformationsElement: function _createElevationPathInformationsElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPelevationPathInformationsContainer");
    div.className = "GPelementHidden gpf-hidden";
    var p = document.createElement("p");
    p.className = "GPelevationPathInformations";
    p.innerHTML = "Aucune information...";
    div.appendChild(p);
    return div;
  },
  /**
   * Add a information into Panel
   *
   * @param {String} value - value of item
   * @returns {DOMElement} DOM element
   */
  _addElevationPathInformationsItem: function _addElevationPathInformationsItem(value) {
    var div = document.getElementById(this._addUID("GPelevationPathInformationsContainer"));
    if (div) {
      var p = document.createElement("p");
      p.className = "GPelevationPathInformations";
      p.innerHTML = value;
      div.appendChild(p);
    }
    return div;
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ElevationPathDOM);

/***/ }),

/***/ "./src/packages/Controls/ElevationPath/ProfileElevationPathDOM.js":
/*!************************************************************************!*\
  !*** ./src/packages/Controls/ElevationPath/ProfileElevationPathDOM.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* globals AmCharts, d3 */
var ProfileElevationPathDOM = {
  /**
   * Gets a css property from an element
   *
   * @private
   * @param {HTMLElement} element The element to get the property from
   * @param {String} property The css property
   * @returns {String} The value of the property
   *
   * @see https://stackoverflow.com/questions/7444451/how-to-get-the-actual-rendered-font-when-its-not-defined-in-css
   */
  _getCssProperty: function _getCssProperty(element, property) {
    return window.getComputedStyle(element, null).getPropertyValue(property);
  },
  /**
   * Uses canvas.measureText to compute and return the width of the given text of given font in pixels.
   *
   * @private
   * @param {String} text The text to be rendered.
   * @param {HTMLElement} container The container of the text
   * @param {String} font The font of the container if known, format: 'weight size familiy'
   * @returns {Number} The width of the text
   *
   * @see https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript/21015393#21015393
   */
  _getTextWidth: function _getTextWidth(text, container) {
    var font = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    // re-use canvas object for better performance
    var canvas = /** ts-syntax */this.canvas || (this.canvas = document.createElement("canvas"));
    var context = canvas.getContext("2d");
    if (font === null) {
      context.font = "".concat(this._getCssProperty(container, "font-weight"), " ").concat(this._getCssProperty(container, "font-size"), " ").concat(this._getCssProperty(container, "font-family"));
    } else {
      context.font = font;
    }
    var metrics = context.measureText(text);
    return metrics.width;
  },
  /**
   * Converts a data point z to svg y coord
   *
   * @private
   * @param {Object} z The z to convert.
   * @param {Number} pathHeight The height of the path in the svg container in px
   * @param {Number} minGraphZ Min z of the graph
   * @param {Number} pxPerMZ Number of pixels per meter for the z (y) axis
   * @returns {Number} The y svg coordinate of the point
   *
   */
  _dataZToSvgY: function _dataZToSvgY(z, pathHeight, minGraphZ, pxPerMZ) {
    return pathHeight - (z - minGraphZ) * pxPerMZ - 0.5;
  },
  /**
   * Converts a data point dist value to svg x coord
   *
   * @private
   * @param {Number} dist The dist to convert
   * @param {Number} svgWidth The witdth of the svg container in px
   * @param {Number} pathWidth The witdth of the path in the svg container in px
   * @param {Number} pxPerMX Number of pixels per meter for the x axis
   * @returns {Array} The x svg coordinate of the point
   *
   */
  _dataDistToSvgX: function _dataDistToSvgX(dist, svgWidth, pathWidth, pxPerMX) {
    return svgWidth - pathWidth + dist * pxPerMX;
  },
  /**
   * Converts a svg x coord to dist value
   *
   * @private
   * @param {Number} svgX The dist to convert
   * @param {Number} svgWidth The witdth of the svg container in px
   * @param {Number} pathWidth The witdth of the path in the svg container in px
   * @param {Number} pxPerMX Number of pixels per meter for the x axis
   * @returns {Array} The dist value
   *
   */
  _svgXToDataDist: function _svgXToDataDist(svgX, svgWidth, pathWidth, pxPerMX) {
    return (svgX + pathWidth - svgWidth) / pxPerMX;
  },
  /**
   * Returns the index of value if it were inserted in sorted (by dist) array of data points.
   *
   * @private
   * @param {Array} array Sorted array of data points (with dist property)
   * @param {Number} value Value to test the index of.
   * @returns {Number} The index the value would have.
   *
   */
  _arrayBisect: function _arrayBisect(array, value) {
    var idx;
    if (array.length === 0) {
      return 0;
    }
    for (idx = 0; idx < array.length; idx++) {
      if (value < array[idx].dist) {
        return idx;
      }
    }
    return idx - 1;
  },
  /**
   * Display Profile function used by default : no additonal framework needed.
   *
   * @public
   * @param {Object} data - elevations values for profile
   * @param {HTMLElement} container - html container where to display profile
   * @param {Object} context - this control object
   * @param {Object} className - calling class (ie ElevationPath)
   * @returns {DOMElement} profil container
   */
  displayProfileByDefault: function displayProfileByDefault(data, container, context, className) {
    var self = context;
    if (!container) {
      return;
    }
    if (!data) {
      return;
    }

    // on nettoie toujours...
    while (container.firstChild) {
      container.removeChild(container.firstChild);
    }
    var margin = {
      top: 25,
      right: 15,
      bottom: 10,
      left: 10
    };
    var _displayProfileOptions = self.options.displayProfileOptions;
    var _points = data.points;
    var sortedElev = JSON.parse(JSON.stringify(_points));
    sortedElev.sort(function (e1, e2) {
      return e1.z - e2.z;
    });
    var minZ = sortedElev[0].z;
    var maxZ = sortedElev[sortedElev.length - 1].z;
    var dist = data.distance;
    var distUnit = "m";
    var widgetDiv = document.createElement("div");
    widgetDiv.id = "profileElevationByDefault";
    container.appendChild(widgetDiv);

    // Détermination des tailles en pixels des éléments du widget
    var clientWidth = window.getComputedStyle(container).getPropertyValue("width").replace(/px/, "");
    var clientHeight = window.getComputedStyle(container).getPropertyValue("height").replace(/px/, "");
    var widgetHeigth = clientHeight - margin.top - margin.bottom;
    var widgetWidth = clientWidth - margin.left - margin.right;
    // const widgetHeigth = container.clientHeight - margin.top - margin.bottom;
    // const widgetWidth = container.clientWidth - margin.left - margin.right;

    var zLabelWidth = 17;
    var zGradWidth = this._getTextWidth(Math.round(maxZ).toLocaleString() + ",88", container, "400 10 Verdana");
    var xLabelHeight = 17;
    var xGradHeight = 15;
    var minZguideHeigth = 15;
    var minXguideWidth = this._getTextWidth(Math.round(dist).toLocaleString() + ",5", container);
    var minNumXGuides = 1;
    var pathHeight = widgetHeigth - xLabelHeight - xGradHeight;
    var pathWidth = widgetWidth - zLabelWidth - zGradWidth;
    var elevationSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    elevationSvg.id = "profileElevationByDefaultSvg";
    elevationSvg.setAttribute("style", "display: block; margin: auto; overflow: visible; position: absolute; left: 10px;");
    elevationSvg.setAttribute("viewBox", "0 0 ".concat(clientWidth, " ").concat(clientHeight));
    elevationSvg.setAttribute("width", "100%");
    elevationSvg.setAttribute("height", "100%");

    // Détermination des guides en ordonnée :
    var maxNumZguides = Math.floor(pathHeight / minZguideHeigth);
    var gradZ;
    // Traitement du cas altitude max = altitude min
    if (maxZ === minZ) {
      gradZ = 0.1;
    } else {
      gradZ = Math.pow(10, Math.ceil(Math.log((maxZ - minZ) / maxNumZguides) / Math.log(10))) / 2;
    }
    var minGraphZ = Math.floor(minZ / gradZ) * gradZ;
    var maxGraphZ = Math.ceil(maxZ / gradZ) * gradZ;
    // cas où le path atteint pile les graduations extremes : ajout d'une gradiation
    if (maxGraphZ === maxZ) {
      maxGraphZ += gradZ;
    }
    // cas où gradZ < 1 : nombres flottants capricieux...
    minGraphZ = Math.round(minGraphZ * 100) / 100;
    maxGraphZ = Math.round(maxGraphZ * 100) / 100;
    var numZguides = Math.round((maxGraphZ - minGraphZ) / gradZ);

    // Si plus de guides que le max, on passe à une graduation de 10**x en 10**x (et non 10**x / 2)
    if (numZguides + 1 > maxNumZguides) {
      gradZ = Math.pow(10, Math.ceil(Math.log((maxZ - minZ) / maxNumZguides) / Math.log(10)));
      minGraphZ = Math.floor(minZ / gradZ) * gradZ;
      maxGraphZ = Math.ceil(maxZ / gradZ) * gradZ;
      // cas où le path atteint pile les graduations extremes : ajout d'une gradiation
      if (maxGraphZ === maxZ) {
        maxGraphZ += gradZ;
      }
      // cas où gradZ < 1 : nombres flottants capricieux...
      minGraphZ = Math.round(minGraphZ * 100) / 100;
      maxGraphZ = Math.round(maxGraphZ * 100) / 100;
      numZguides = Math.floor((maxGraphZ - minGraphZ) / gradZ);
    }
    numZguides = Math.max(Math.round(numZguides), 1);
    var axisZ = document.createElementNS("http://www.w3.org/2000/svg", "g");
    axisZ.setAttribute("class", "profile-z-vertical");
    var guidesZ = document.createElementNS("http://www.w3.org/2000/svg", "g");
    var gradZyOffsetPx = pathHeight / numZguides;
    var pxPerMZ;
    // Traitement du cas altitude max = altitude min
    if (maxZ === minZ) {
      pxPerMZ = pathHeight / 0.2;
    } else {
      pxPerMZ = pathHeight / (maxGraphZ - minGraphZ);
    }
    var gradZtext;
    var yTextTranslation;
    var yStrokeTranslation;
    var gradZstroke;
    var gradZpath;
    var gradZgrad;
    // Ajout des graduations au graphique
    for (var i = 0; i <= numZguides; i++) {
      gradZtext = document.createElementNS("http://www.w3.org/2000/svg", "text");
      gradZtext.setAttribute("class", "profile-z-graduation");
      gradZtext.setAttribute("font-family", "Verdana");
      gradZtext.setAttribute("font-size", "10px");
      gradZtext.setAttribute("fill", "#5E5E5E");
      // Cas où gradZ < 1 : nombres flottants capricieux...
      // Le Math.round est pour éviter des ennuis du genre 3 * 0.1 = 0.300000000000004
      gradZtext.textContent = (Math.round(100 * (minGraphZ + i * gradZ)) / 100).toLocaleString();
      yTextTranslation = pathHeight - i * gradZyOffsetPx;
      gradZtext.setAttribute("transform", "translate(".concat(zLabelWidth + zGradWidth - 8, ", ").concat(yTextTranslation + 5, ")"));
      gradZtext.setAttribute("text-anchor", "end");
      axisZ.appendChild(gradZtext);
      yStrokeTranslation = Math.round(yTextTranslation) - 0.5;
      gradZstroke = document.createElementNS("http://www.w3.org/2000/svg", "g");
      gradZpath = document.createElementNS("http://www.w3.org/2000/svg", "path");
      gradZpath.setAttribute("cs", "100,100");
      gradZpath.setAttribute("stroke-width", "1");
      if (i !== 0) {
        gradZpath.setAttribute("stroke-opacity", "0.2");
      } else {
        gradZpath.setAttribute("stroke-opacity", "1");
      }
      gradZpath.setAttribute("stroke", "#000000");
      gradZpath.setAttribute("fill", "none");
      gradZpath.setAttribute("d", "M".concat(zLabelWidth + zGradWidth, ",").concat(yStrokeTranslation, " L").concat(pathWidth + zLabelWidth + zGradWidth, ",").concat(yStrokeTranslation));
      gradZgrad = document.createElementNS("http://www.w3.org/2000/svg", "path");
      gradZgrad.setAttribute("cs", "100,100");
      gradZgrad.setAttribute("stroke-width", "1");
      gradZgrad.setAttribute("stroke-opacity", "1");
      gradZgrad.setAttribute("stroke", "#000000");
      gradZgrad.setAttribute("fill", "none");
      gradZgrad.setAttribute("d", "M".concat(zLabelWidth + zGradWidth, ",").concat(yStrokeTranslation, " L").concat(zLabelWidth + zGradWidth + 5, ",").concat(yStrokeTranslation));
      gradZgrad.setAttribute("transform", "translate(-5, 0)");
      gradZstroke.appendChild(gradZgrad);
      gradZstroke.appendChild(gradZpath);
      guidesZ.appendChild(gradZstroke);
    }
    var axisZLegend = document.createElementNS("http://www.w3.org/2000/svg", "text");
    axisZLegend.setAttribute("class", "profile-z-legend");
    axisZLegend.setAttribute("font-family", "Verdana");
    axisZLegend.setAttribute("font-size", "11px");
    axisZLegend.setAttribute("fill", "#5E5E5E");
    axisZLegend.textContent = "Altitude (m)";
    axisZLegend.setAttribute("transform", "translate(".concat(zLabelWidth - 8, ", ").concat(Math.round(pathHeight / 2), ") rotate(-90)"));
    axisZLegend.setAttribute("text-anchor", "middle");
    axisZ.appendChild(axisZLegend);
    elevationSvg.appendChild(axisZ);
    elevationSvg.appendChild(guidesZ);

    // Détermination des guides en abscisse :
    // Passage éventuel en km
    if (dist > 2000) {
      dist /= 1000;
      distUnit = "km";
    }
    var maxNumXguides = Math.floor(pathWidth / minXguideWidth);
    var gradX = Math.pow(10, Math.ceil(Math.log(dist / maxNumXguides) / Math.log(10))) / 2;
    var maxGraphX = dist;

    // Si plus de guides que le max, on passe à une graduation de 10**x en 10**x (et non 10**x / 2)
    var numXguides = Math.floor(maxGraphX / gradX);
    if (numXguides > maxNumXguides) {
      gradX = Math.pow(10, Math.ceil(Math.log(dist / maxNumXguides) / Math.log(10)));
      numXguides = Math.floor(maxGraphX / gradX);
    } else if (numXguides < minNumXGuides) {
      gradX = Math.pow(10, Math.ceil(Math.log(dist / maxNumXguides) / Math.log(10)) - 1);
      numXguides = Math.floor(maxGraphX / gradX);
    }
    numXguides = Math.max(numXguides, 1);
    var lastGradX = gradX * numXguides;
    var axisX = document.createElementNS("http://www.w3.org/2000/svg", "g");
    axisX.setAttribute("class", "profile-x-vertical");
    var guidesX = document.createElementNS("http://www.w3.org/2000/svg", "g");

    // Décalage des graduations pour que la dernière corresponde à la distance max
    var pxPerMX = pathWidth / maxGraphX;
    var xOffset = (maxGraphX - lastGradX) * pxPerMX;
    var gradXxOffsetPx = Math.round((pathWidth - xOffset) / numXguides);
    var gradXtext;
    var xTextTranslation;
    var xStrokeTranslation;
    var gradXstroke;
    var gradXpath;
    var gradXgrad;
    // Ajout des graduations au graphique
    for (var _i = 0; _i <= numXguides + 1; _i++) {
      gradXtext = document.createElementNS("http://www.w3.org/2000/svg", "text");
      gradXtext.setAttribute("class", "profile-x-graduation");
      gradXtext.setAttribute("font-family", "Verdana");
      gradXtext.setAttribute("font-size", "10px");
      gradXtext.setAttribute("fill", "#5E5E5E");

      // Exclusion du cas de la dernière graduation : correspond à la distance max : pas de texte
      if (_i !== numXguides + 1) {
        // Cas où gradX < 1 : nombres flottants capricieux...
        gradXtext.textContent = (Math.round(100 * _i * gradX) / 100).toLocaleString();
      }
      xTextTranslation = zLabelWidth + zGradWidth + _i * gradXxOffsetPx;
      // Cas de la dernière graduation : correspond à la distance max
      if (_i === numXguides + 1) {
        xTextTranslation = zLabelWidth + zGradWidth + pathWidth;
      }
      gradXtext.setAttribute("transform", "translate(".concat(xTextTranslation, ", ").concat(pathHeight + xGradHeight + 5, ")"));
      gradXtext.setAttribute("text-anchor", "middle");
      axisX.appendChild(gradXtext);
      xStrokeTranslation = xTextTranslation - 0.5;
      gradXstroke = document.createElementNS("http://www.w3.org/2000/svg", "g");
      gradXpath = document.createElementNS("http://www.w3.org/2000/svg", "path");
      gradXpath.setAttribute("cs", "100,100");
      gradXpath.setAttribute("stroke-width", "1");
      if (_i !== 0) {
        gradXpath.setAttribute("stroke-opacity", "0.2");
      } else {
        gradXpath.setAttribute("stroke-opacity", "1");
      }
      gradXpath.setAttribute("stroke", "#000000");
      gradXpath.setAttribute("fill", "none");
      gradXpath.setAttribute("d", "M".concat(xStrokeTranslation, ",").concat(pathHeight, " L").concat(xStrokeTranslation, ",0"));
      gradXgrad = document.createElementNS("http://www.w3.org/2000/svg", "path");
      gradXgrad.setAttribute("cs", "100,100");
      gradXgrad.setAttribute("stroke-width", "1");
      gradXgrad.setAttribute("stroke-opacity", "1");
      gradXgrad.setAttribute("stroke", "#000000");
      gradXgrad.setAttribute("fill", "none");
      gradXgrad.setAttribute("d", "M".concat(xStrokeTranslation, ",").concat(pathHeight, " L").concat(xStrokeTranslation, ",").concat(pathHeight - 5));
      gradXgrad.setAttribute("transform", "translate(0, 5)");
      gradXstroke.appendChild(gradXgrad);
      gradXstroke.appendChild(gradXpath);
      guidesX.appendChild(gradXstroke);
    }
    var axisXLegend = document.createElementNS("http://www.w3.org/2000/svg", "text");
    axisXLegend.setAttribute("class", "profile-x-legend");
    axisXLegend.setAttribute("font-family", "Verdana");
    axisXLegend.setAttribute("font-size", "11px");
    axisXLegend.setAttribute("fill", "#5E5E5E");
    axisXLegend.textContent = "Distance (".concat(distUnit, ")");
    axisXLegend.setAttribute("transform", "translate(".concat(zLabelWidth + zGradWidth + pathWidth / 2, ", ").concat(pathHeight + xGradHeight + xLabelHeight + 3, ")"));
    axisXLegend.setAttribute("text-anchor", "middle");
    axisX.appendChild(axisXLegend);
    elevationSvg.appendChild(axisX);
    elevationSvg.appendChild(guidesX);
    var elevationPathG = document.createElementNS("http://www.w3.org/2000/svg", "g");
    var factor = 1;
    if (distUnit === "km") {
      factor = 1000;
    }
    var pointX = this._dataDistToSvgX(_points[0].dist / factor, widgetWidth, pathWidth, pxPerMX);
    var pointY = this._dataZToSvgY(_points[0].z, pathHeight, minGraphZ, pxPerMZ);
    var pathD = "M".concat(pointX, ",").concat(pointY);
    for (var _i2 = 1; _i2 < _points.length; _i2++) {
      pointX = this._dataDistToSvgX(_points[_i2].dist / factor, widgetWidth, pathWidth, pxPerMX);
      pointY = this._dataZToSvgY(_points[_i2].z, pathHeight, minGraphZ, pxPerMZ);
      pathD += " L".concat(pointX, ",").concat(pointY);
    }
    var pathPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
    pathPath.setAttribute("cs", "100,100");
    pathPath.setAttribute("stroke-width", "1");
    pathPath.setAttribute("stroke-opacity", "1");
    pathPath.setAttribute("stroke", "#0B6BA7");
    pathPath.setAttribute("fill", "none");
    pathPath.setAttribute("d", pathD);

    // Fermeture du path pour le fill
    pathD += " L".concat(pointX, ",").concat(pathHeight);
    pathD += " L".concat(widgetWidth - pathWidth, ",").concat(pathHeight);
    var pathFill = document.createElementNS("http://www.w3.org/2000/svg", "path");
    pathFill.setAttribute("cs", "100,100");
    pathFill.setAttribute("stroke-width", "1");
    pathFill.setAttribute("stroke-opacity", "0");
    pathFill.setAttribute("stroke", "#000000");
    pathFill.setAttribute("fill", "#00B798");
    pathFill.setAttribute("fill-opacity", "0.4");
    pathFill.setAttribute("d", pathD);
    elevationPathG.appendChild(pathPath);
    elevationPathG.appendChild(pathFill);
    elevationSvg.appendChild(elevationPathG);

    // Mise en place de l'écouteur d'évènement : pour l'affichage dynamique
    var dynamicsG = document.createElementNS("http://www.w3.org/2000/svg", "g");
    // Pour écouter la position de la souris
    var pathRectangle = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    pathRectangle.setAttribute("width", pathWidth);
    pathRectangle.setAttribute("height", pathHeight);
    pathRectangle.setAttribute("transform", "translate(".concat(widgetWidth - pathWidth, ",0)"));
    pathRectangle.setAttribute("visibility", "hidden");
    pathRectangle.setAttribute("pointer-events", "all");
    var sortedDist = JSON.parse(JSON.stringify(_points));
    sortedDist.sort(function (e1, e2) {
      return e1.dist - e2.dist;
    });
    var focusLineX = document.createElementNS("http://www.w3.org/2000/svg", "line");
    focusLineX.setAttribute("id", "focusLineX");
    focusLineX.setAttribute("class", "focusLine-default");
    focusLineX.setAttribute("fill", "none");
    focusLineX.setAttribute("stroke", "#F90");
    focusLineX.setAttribute("stroke-width", "0.5px");
    focusLineX.setAttribute("visibility", "hidden");
    var focusLineY = document.createElementNS("http://www.w3.org/2000/svg", "line");
    focusLineY.setAttribute("id", "focusLineY");
    focusLineY.setAttribute("class", "focusLine-default");
    focusLineY.setAttribute("fill", "none");
    focusLineY.setAttribute("stroke", "#F90");
    focusLineY.setAttribute("stroke-width", "0.5px");
    focusLineY.setAttribute("visibility", "hidden");
    var focusCircle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
    focusCircle.setAttribute("id", "focusCircle");
    focusCircle.setAttribute("r", 4);
    focusCircle.setAttribute("class", "circle-default focusCircle-default");
    focusCircle.setAttribute("fill", "#F90");
    focusCircle.setAttribute("visibility", "hidden");
    dynamicsG.appendChild(focusCircle);
    dynamicsG.appendChild(focusLineX);
    dynamicsG.appendChild(focusLineY);

    // Tooltip
    var tooltipDiv = document.createElementNS("http://www.w3.org/2000/svg", "text");
    var altiSpan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    var slopeSpan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    var coordsSpan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    tooltipDiv.setAttribute("style", "text-align:center; max-width:220px; font-size:10px; color:#000000; font-family:Verdana; z-index:50;");
    tooltipDiv.style.pointerEvents = "none";
    tooltipDiv.style.position = "fixed";
    // tooltipDiv.classList.add("tooltipInit");
    // IE...
    tooltipDiv.setAttribute("class", "tooltipInit");
    tooltipDiv.setAttribute("text-anchor", "middle");
    widgetDiv.appendChild(tooltipDiv);
    altiSpan.setAttribute("class", "altiPathValue");
    altiSpan.setAttribute("x", "0");
    altiSpan.setAttribute("dy", "-.7em");
    slopeSpan.setAttribute("class", "altiPathValue");
    slopeSpan.setAttribute("x", "0");
    slopeSpan.setAttribute("dy", "1em");
    coordsSpan.setAttribute("class", "altiPathCoords");
    coordsSpan.setAttribute("x", "0");
    coordsSpan.setAttribute("dy", "1em");
    tooltipDiv.appendChild(altiSpan);
    if (_displayProfileOptions.currentSlope) {
      tooltipDiv.appendChild(slopeSpan);
    }
    tooltipDiv.appendChild(coordsSpan);
    var tooltipG = document.createElementNS("http://www.w3.org/2000/svg", "g");
    dynamicsG.appendChild(tooltipG);
    var tooltipBubble = document.createElementNS("http://www.w3.org/2000/svg", "path");
    tooltipBubble.setAttribute("cs", "100,100");
    tooltipBubble.setAttribute("fill", "#FFFFFF");
    tooltipBubble.setAttribute("stroke", "#CCCCCC");
    tooltipBubble.setAttribute("fill-opacity", "0.8");
    tooltipBubble.setAttribute("stroke-width", "1");
    tooltipBubble.setAttribute("stroke-opacity", "1");
    var tooltipBubbleShadow = document.createElementNS("http://www.w3.org/2000/svg", "path");
    tooltipBubbleShadow.setAttribute("cs", "100,100");
    tooltipBubbleShadow.setAttribute("fill", "#FFFFFF");
    tooltipBubbleShadow.setAttribute("stroke", "#000000");
    tooltipBubbleShadow.setAttribute("fill-opacity", "0");
    tooltipBubbleShadow.setAttribute("stroke-width", "1");
    tooltipBubbleShadow.setAttribute("stroke-opacity", "0.4");
    tooltipBubbleShadow.setAttribute("transform", "translate(1,1)");
    tooltipG.appendChild(tooltipBubbleShadow);
    tooltipG.appendChild(tooltipBubble);
    tooltipG.appendChild(tooltipDiv);

    // tooltipG.classList.add("tooltipInit");
    // IE... deprecated
    tooltipG.setAttribute("class", "tooltipInit");
    tooltipG.style.pointerEvents = "none";
    function onMouseOver() {
      focusLineX.setAttribute("visibility", "visible");
      focusLineY.setAttribute("visibility", "visible");
      focusCircle.setAttribute("visibility", "visible");
      className.__createProfileMarker(self, _points[0]);

      // tooltips
      // tooltipDiv.classList.remove("tooltipInit");
      // tooltipG.classList.remove("tooltipInit");
      // tooltipDiv.classList.remove("tooltipFadeOut");
      // tooltipG.classList.remove("tooltipFadeOut");
      // tooltipDiv.classList.add("tooltipFadeIn");
      // tooltipG.classList.add("tooltipFadeIn");
      // IE... deprecated
      tooltipDiv.setAttribute("class", "tooltipFadeIn");
      tooltipG.setAttribute("class", "tooltipFadeIn");
    }
    function onMouseOut() {
      focusLineX.setAttribute("visibility", "hidden");
      focusLineY.setAttribute("visibility", "hidden");
      focusCircle.setAttribute("visibility", "hidden");
      className.__removeProfileMarker(self);
      // tooltips
      // tooltipDiv.classList.remove("tooltipFadeIn");
      // tooltipG.classList.remove("tooltipFadeIn");
      // tooltipDiv.classList.add("tooltipFadeOut");
      // tooltipG.classList.add("tooltipFadeOut");
      // IE... deprecated
      tooltipDiv.setAttribute("class", "tooltipFadeOut");
      tooltipG.setAttribute("class", "tooltipFadeOut");
    }
    function onMouseMove(e) {
      var mousePoint = elevationSvg.createSVGPoint();
      mousePoint.x = e.clientX;
      mousePoint.y = e.clientY;
      var svgMousePoint = mousePoint.matrixTransform(elevationSvg.getScreenCTM().inverse());
      var mouseDist = this._svgXToDataDist(svgMousePoint.x, widgetWidth, pathWidth, pxPerMX) * factor;

      // Math.max pour éviter de sortir de l'array
      var distIndex = Math.max(1, this._arrayBisect(sortedDist, mouseDist));
      var d0 = _points[distIndex - 1];
      var d1 = _points[distIndex];
      var d = d0;
      if (mouseDist - d0.dist > d1.dist - mouseDist) {
        d = d1;
      }
      var focusX = this._dataDistToSvgX(d.dist / factor, widgetWidth, pathWidth, pxPerMX);
      var focusY = this._dataZToSvgY(d.z, pathHeight, minGraphZ, pxPerMZ);

      // Mise à jour des éléments graphiques
      focusCircle.setAttribute("cx", focusX);
      focusCircle.setAttribute("cy", focusY);
      focusLineX.setAttribute("x1", focusX);
      focusLineX.setAttribute("y1", pathHeight);
      focusLineX.setAttribute("x2", focusX);
      focusLineX.setAttribute("y2", 0);
      focusLineY.setAttribute("x1", zLabelWidth + zGradWidth);
      focusLineY.setAttribute("y1", focusY);
      focusLineY.setAttribute("x2", pathWidth + zLabelWidth + zGradWidth);
      focusLineY.setAttribute("y2", focusY);
      className.__updateProfileMarker(self, d);

      // Mise à jour du tooltip
      var altiSpanTxt = "Altitude : ".concat(d.z.toLocaleString(), " m");
      var slopeSpanTxt = "Pente : ".concat(d.slope, " %");
      var coordsSpanTxt = "(lat : ".concat(d.lat.toLocaleString(), " / lon : ").concat(d.lon.toLocaleString(), ")");
      altiSpan.innerHTML = altiSpanTxt;
      slopeSpan.innerHTML = slopeSpanTxt;
      coordsSpan.innerHTML = coordsSpanTxt;
      var tooltipTextWidth = Math.max(this._getTextWidth(coordsSpanTxt, coordsSpan), this._getTextWidth(altiSpanTxt, altiSpan));
      var toolTipBubbleD;
      if (d.dist > dist * factor / 2) {
        toolTipBubbleD = "M -0.5 -0.5 l -6 6 l 0 16 l -".concat(tooltipTextWidth + 10, " 0 l 0 -44 l ").concat(tooltipTextWidth + 10, " 0 l 0 16 l 6 6");
        tooltipDiv.setAttribute("transform", "translate(".concat(-(tooltipTextWidth / 2 + 12), ",0)")); // IE11 !
      } else if (d.dist <= dist * factor / 2) {
        toolTipBubbleD = "M -0.5 -0.5 l 6 6 l 0 16 l ".concat(tooltipTextWidth + 10, " 0 l 0 -44 l -").concat(tooltipTextWidth + 10, " 0 l 0 16 l -6 6");
        // Largeur de la fleche de la bulle du tooltip
        tooltipDiv.setAttribute("transform", "translate(".concat(tooltipTextWidth / 2 + 12, ",0)")); // IE11 !
      }
      tooltipBubble.setAttribute("d", toolTipBubbleD);
      tooltipBubbleShadow.setAttribute("d", toolTipBubbleD);
      tooltipG.setAttribute("transform", "translate(".concat(focusX, ",").concat(focusY, ")")); // IE11 !
      tooltipG.style.transform = "translate(".concat(focusX, "px,").concat(focusY, "px)");
    }
    pathRectangle.addEventListener("pointerover", onMouseOver);
    pathRectangle.addEventListener("pointerout", onMouseOut);
    pathRectangle.addEventListener("pointermove", onMouseMove.bind(this));
    dynamicsG.appendChild(pathRectangle);
    elevationSvg.appendChild(dynamicsG);
    widgetDiv.appendChild(elevationSvg);
    return container;
  },
  /**
   * Display Profile without graphical rendering (raw service response)
   *
   * @public
   * @param {Object} data - elevations values for profile
   * @param {HTMLElement} container - html container where to display profile
   * @param {Object} context - this control object
   * @param {Object} className - calling class (ie ElevationPath)
   * @returns {DOMElement} profil container
   */
  displayProfileRaw: function displayProfileRaw(data, container, context, className) {
    if (!container) {
      return;
    }

    // on nettoie toujours...
    while (container.firstChild) {
      container.removeChild(container.firstChild);
    }
    var _points = data && data.points ? data.points : {};
    var div = document.createElement("textarea");
    div.id = "profilElevationResults";
    div.rows = 10;
    div.cols = 50;
    div.style.width = "100%";
    div.innerHTML = JSON.stringify(_points, undefined, 4);
    div.addEventListener("mouseover", function (e) {
      className.__customRawProfileMouseOverEvent(context, e);
    });

    // TODO
    // for (var i = 0; i < _points.length; i++) {
    //     var point = _points[i];
    //     var divC  = document.createElement("code");
    //     divC.id = "point_" + i;
    //     divC.innerHTML = JSON.stringify(point, undefined, 4);
    //     div.appendChild(divC);
    //     divC.addEventListener("mouseover", function (e) {
    //          className.__customRawProfileMouseOverEvent(context, e);
    //     });
    // }

    container.appendChild(div);
    return container;
  },
  /**
   * Display Profile using D3 javascript framework. This method needs D3 libraries to be loaded.
   *
   * @public
   * @param {Object} data - elevations values for profile
   * @param {HTMLElement} container - html container where to display profile
   * @param {Object} context - this control object
   * @param {Object} className - calling class (ie ElevationPath)
   * @returns {DOMElement} profil container
   */
  displayProfileLibD3: function displayProfileLibD3(data, container, context, className) {
    var self = context;
    if (!container) {
      return;
    }
    if (!data) {
      return;
    }

    // on nettoie toujours...
    while (container.firstChild) {
      container.removeChild(container.firstChild);
    }
    var _points = data.points;
    if (data.distance > 2000) {
      data.unit = "km";
      for (var i = 0; i < _points.length; i++) {
        _points[i].dist /= 1000;
      }
    }
    var _displayProfileOptions = self.options.displayProfileOptions;
    var margin = {
      top: 20,
      right: 20,
      bottom: 30,
      left: 40
    };
    var widgetWidth = window.getComputedStyle(container).getPropertyValue("width");
    var widgetHeigth = window.getComputedStyle(container).getPropertyValue("height");
    var width = widgetWidth.replace(/px/, "") - margin.left - margin.right;
    var height = widgetHeigth.replace(/px/, "") - margin.top - margin.bottom;
    var x = d3.scale.linear().range([0, width]);
    var y = d3.scale.linear().range([height, 0]);
    var xAxis = d3.svg.axis().scale(x).orient("bottom").ticks(5);
    var yAxis = d3.svg.axis().scale(y).orient("left").ticks(5);
    var line = d3.svg.line().interpolate("basis").x(function (d) {
      return x(d.dist);
    }).y(function (d) {
      return y(d.z);
    });
    var area = d3.svg.area().interpolate("basis").x(function (d) {
      return x(d.dist);
    }).y0(height).y1(function (d) {
      return y(d.z);
    });
    var svg = d3.select(container).append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    var xDomain = d3.extent(_points, function (d) {
      return d.dist;
    });
    x.domain(xDomain);
    var yDomain = [0, d3.max(_points, function (d) {
      return d.z;
    })];
    y.domain(yDomain);
    svg.append("path").datum(_points).attr("class", "area-d3").attr("d", area);
    svg.append("g").attr("class", "x axis-d3").attr("transform", "translate(0," + height + ")").call(xAxis).append("text").attr("y", -15).attr("dy", ".71em").attr("x", width).text("Distance (" + data.unit + ")");
    svg.append("g").attr("class", "y axis-d3").call(yAxis).append("text").attr("transform", "rotate(-90)").attr("y", 6).attr("dy", ".71em").text("Altitude (m)");
    svg.append("g").attr("class", "grid-d3 vertical").attr("transform", "translate(0," + height + ")").call(xAxis.orient("bottom").tickSize(-height, 0, 0).tickFormat(""));
    svg.append("g").attr("class", "grid-d3 horizontal").call(yAxis.orient("left").tickSize(-width, 0, 0).tickFormat(""));
    svg.append("path").datum(_points).attr("class", "line-d3").attr("d", line);
    svg.selectAll("circle").data(_points).enter().append("circle").attr("cx", function (d) {
      return x(d.dist);
    }).attr("cy", function (d) {
      return y(d.z);
    }).attr("r", 0).attr("class", "circle-d3");
    var focus = svg.append("g").style("display", "none");
    focus.append("line").attr("id", "focusLineX").attr("class", "focusLine-d3");
    focus.append("line").attr("id", "focusLineY").attr("class", "focusLine-d3");
    focus.append("circle").attr("id", "focusCircle").attr("r", 4).attr("class", "circle-d3 focusCircle-d3");
    var div = d3.select(container).append("div").attr("class", "tooltip-d3").style("opacity", 0);
    var bisectDist = d3.bisector(function (d) {
      return d.dist;
    }).left;
    svg.append("rect").attr("class", "overlay-d3").attr("width", width).attr("height", height).on("mouseover", function () {
      focus.style("display", null);
      className.__createProfileMarker(self, _points[0]);
    }).on("mouseout", function () {
      focus.style("display", "none");
      className.__removeProfileMarker(self);

      // tooltips
      div.transition().duration(500).style("opacity", 0);
    }).on("mousemove", function () {
      var m = d3.mouse(this);
      var distance = x.invert(m[0]);
      // Math.max pour éviter de sortir de l'array
      var i = Math.max(1, bisectDist(_points, distance));
      var d0 = _points[i - 1];
      var d1 = _points[i];
      var d = distance - d0[0] > d1[0] - distance ? d1 : d0;
      var xc = x(d.dist);
      var yc = y(d.z);
      focus.select("#focusCircle").attr("cx", xc).attr("cy", yc);
      focus.select("#focusLineX").attr("x1", xc).attr("y1", y(yDomain[0])).attr("x2", xc).attr("y2", y(yDomain[1]));
      focus.select("#focusLineY").attr("x1", x(xDomain[0])).attr("y1", yc).attr("x2", x(xDomain[1])).attr("y2", yc);
      className.__updateProfileMarker(self, d);

      // tooltips
      div.transition().duration(200).style("opacity", 0.9);
      var _message = "";
      _message += " Altitude : " + d.z + " m";
      if (_displayProfileOptions.currentSlope) {
        _message += "<br/> Pente : " + d.slope + " %";
      }
      _message += "<br/> (Lat : " + d.lat + "/ Lon : " + d.lon + ")";
      div.html(_message).style("left", d3.event.pageX + "px").style("top", d3.event.pageY - 28 + "px");
    });

    // return d3.selectAll("rect.overlay")[0][0];
    return svg;
  },
  /**
   * Display Profile using Amcharts framework. This method needs AmCharts libraries to be loaded.
   *
   * @public
   * @param {Object} data - elevations values for profile
   * @param {HTMLElement} container - html container where to display profile
   * @param {Object} context - this control object
   * @param {Object} className - calling class (ie ElevationPath)
   * @returns {DOMElement} profil container
   */
  displayProfileLibAmCharts: function displayProfileLibAmCharts(data, container, context, className) {
    var self = context;
    if (!container) {
      return;
    }
    if (!data) {
      return;
    }
    var _points = data.points;
    var ballonText = "<span class='altiPathValue'>[[title]] : [[value]]m</span><br/>";
    var currentSlope = self.options.displayProfileOptions.currentSlope;
    if (currentSlope) {
      ballonText += "<span class='altiPathValue'>Pente : [[slope]] %</span><br/>";
    }
    ballonText += "<span class='altiPathCoords'>(Lat: [[lat]] / Lon:[[lon]])</span>";
    AmCharts.addInitHandler(function () {});
    if (data.distance > 2000) {
      data.unit = "km";
      for (var i = 0; i < _points.length; i++) {
        _points[i].dist /= 1000;
      }
    }
    for (var _i3 = 0; _i3 < _points.length; _i3++) {
      var dist = _points[_i3].dist;
      var coeffArrond = 100;
      if (dist > 100) {
        coeffArrond = 1;
      } else if (dist > 10) {
        coeffArrond = 10;
      }

      // Correction arrondi distance totale
      dist = Math.round(dist * coeffArrond) / coeffArrond;
      _points[_i3].dist = dist;
    }
    var settings = {
      type: "serial",
      pathToImages: "http://cdn.amcharts.com/lib/3/images/",
      categoryField: "dist",
      autoMarginOffset: 0,
      marginRight: 10,
      marginTop: 10,
      startDuration: 0,
      color: "#5E5E5E",
      fontSize: 8,
      theme: "light",
      thousandsSeparator: "",
      numberFormatter: {
        precision: -1,
        decimalSeparator: ",",
        thousandsSeparator: " "
      },
      categoryAxis: {
        color: "#5E5E5E",
        gridPosition: "start",
        minHorizontalGap: 40,
        tickPosition: "start",
        title: "Distance (" + data.unit + ")",
        titleColor: "#5E5E5E",
        labelOffset: 0,
        startOnAxis: true
      },
      chartCursor: {
        animationDuration: 0,
        bulletsEnabled: true,
        bulletSize: 10,
        categoryBalloonEnabled: false,
        cursorColor: "#F90",
        graphBulletAlpha: 1,
        graphBulletSize: 1,
        zoomable: false
      },
      trendLines: [],
      graphs: [{
        balloonColor: "#CCCCCC",
        balloonText: ballonText,
        bullet: "round",
        bulletAlpha: 0,
        bulletBorderColor: "#FFF",
        bulletBorderThickness: 2,
        bulletColor: "#F90",
        bulletSize: 6,
        hidden: false,
        id: "AmGraph-1",
        fillAlphas: 0.4,
        fillColors: "#C77A04",
        lineAlpha: 1,
        lineColor: "#C77A04",
        lineThickness: 1,
        title: "Altitude",
        valueField: "z"
      }],
      guides: [],
      valueAxes: [{
        id: "ValueAxis-1",
        minVerticalGap: 20,
        title: "Altitude (m)"
      }],
      balloon: {
        borderColor: "#CCCCCC",
        borderThickness: 1,
        fillColor: "#FFFFFF",
        showBullet: true
      },
      titles: [],
      allLabels: [],
      dataProvider: _points
    };
    var _containerProfile = AmCharts.makeChart(container, settings);
    _containerProfile.addListener("changed", function (e) {
      var obj = e.chart.dataProvider[e.index];
      className.__updateProfileMarker(self, obj);
    });
    return _containerProfile;
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ProfileElevationPathDOM);

/***/ }),

/***/ "./src/packages/Controls/Export/Export.js":
/*!************************************************!*\
  !*** ./src/packages/Controls/Export/Export.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CSS_Controls_Export_GPFexport_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../CSS/Controls/Export/GPFexport.css */ "./src/packages/CSS/Controls/Export/GPFexport.css");
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ol/control/Control */ "ol/control/Control");
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_control_Control__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Utils/SelectorID */ "./src/packages/Utils/SelectorID.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
/* harmony import */ var _Formats_KML__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Formats/KML */ "./src/packages/Formats/KML.js");
/* harmony import */ var _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../Formats/GeoJSON */ "./src/packages/Formats/GeoJSON.js");
/* harmony import */ var _Formats_GPX__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../Formats/GPX */ "./src/packages/Formats/GPX.js");
/* harmony import */ var _ExportDOM__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ExportDOM */ "./src/packages/Controls/Export/ExportDOM.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
// import CSS

// import "../../CSS/Controls/Export/GPFexportStyle.css";

// import OpenLayers


// import local



// import local with ol dependencies




// DOM

var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_3__["default"].getLogger("export");

/**
 * @classdesc
 *
 * Export button
 *
 * @constructor
 * @alias ol.control.Export
 * @param {Object} options - options for function call.
 * @param {String} [options.format = "geojson"] - geojson / kml / gpx
 * @param {String} [options.name = "export"] - export name
 * @param {String} [options.title = "Exporter"] - button name
 * @param {Boolean} [options.menu = false] - displays the format choice menu
 * @param {Function} [options.onExport] - callback
 * @param {DOMElement} [options.target] - target
 * @param {Object} options.control - instance of control
 * @fires export:compute
 * @example
 * // pluggued widget Export into control Isocurve
 * var iso = new ol.control.Isocurve();
 * map.addControl(iso);
 *
 * // method : call render()
 * var export = new ButtonExport();
 * export.setControl(iso);
 * export.setTarget(<!-- DOMElement -->);
 * export.setName("export");
 * export.setFormat("geojson");
 * export.setTitle("Exporter");
 * export.setMenu(false);
 * export.render(); // <-- direct call to render function !
 * export.on("export:compute", (data) => { console.log(data); });
 *
 * // method : call map.addControl()
 * var export = new ButtonExport();
 * export.setControl(iso);
 * export.setTarget(<!-- DOMElement -->);
 * export.setName("export");
 * export.setFormat("geojson");
 * export.setTitle("Exporter");
 * export.setMenu(false);
 * export.on("export:compute", (data) => { console.log(data); });
 * map.addControl(export); // <-- using the OpenLayers mechanism, don't call to render function !
 *
 * // use control options instead of setters
 * var export = new ButtonExport({
 *   control : iso,
 *   target : <!-- DOMElement -->,
 *   name : "export",
 *   format : "geojson",
 *   title : "Exporter",
 *   menu : false
 * });
 * map.addControl(export);
 *
 * // method with passing option into the control Isocurve
 * var iso = new ol.control.Isocurve({ export : true });
 * // with control options :
 * var iso = new ol.control.Isocurve({ export : {
 *   name : "export",
 *   format : "geojson",
 *   title : "Exporter",
 *   menu : false
 * }});
 */
var ButtonExport = /*#__PURE__*/function (_Control) {
  /**
   * See {@link ol.control.Export}
   * @module ButtonExport
   * @alias module:~controls/ButtonExport
   * @param {Object} [options] - options
   * @example
   * import ButtonExport from "gpf-ext-ol/controls/ButtonExport"
   * ou 
   * import { ButtonExport } from "gpf-ext-ol"
   */
  function ButtonExport(options) {
    var _this;
    _classCallCheck(this, ButtonExport);
    options = options || {
      control: null,
      target: null,
      format: "geojson",
      name: "export",
      title: "Exporter",
      menu: false,
      onExport: null
    };
    logger.trace("[constructor] Export", options);
    _this = _callSuper(this, ButtonExport, [{
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    }]);
    if (!(_this instanceof ButtonExport)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }

    /**
     * Response to the export of the route calculation
     * (only for jsdoc)
     *
     * @example
     * // GeoJSON format
     * {
     *   "type":"FeatureCollection",
     *   "features":[...],
     *   "geoportail:compute":{
     *     "points":[ [2.588024210134887, 48.84192678293002 ] ],
     *     "transport":"Voiture",
     *     "exclusions":[...],
     *     "computation":"fastest",
     *     "results":{ <!-- Service --> }
     * }
     *
     * @see {@link https://ignf.github.io/geoportal-access-lib/latest/jsdoc/Gp.Services.RouteResponse.html|Service}
     */
    // eslint-disable-next-line no-undef
    _this.EXPORT_ROUTE = {};

    /**
     * Response to the export of the isochron calculation
     * (only for jsdoc)
     *
     * @example
     * // GeoJSON format
     * {
     *    "type":"FeatureCollection",
     *    "features":[...],
     *    "geoportail:compute":{
     *       "transport":"Pieton",
     *       "computation":"time",
     *       "exclusions":[
     *
     *       ],
     *       "direction":"departure",
     *       "point":[ 2.587835382718464, 48.84192678293002 ],
     *       "results":{
     *          "message":"",
     *          "id":"",
     *          "location":{
     *             "x":"2.587835382718464",
     *             "y":"48.84192678293002"
     *          },
     *          "srs":"EPSG:4326",
     *          "geometry":{
     *             "type":"Polygon",
     *             "coordinates":[[...]]
     *          },
     *         "time":180,
     *         "distance":""
     *      }
     *    }
     * }
     *
     * @see {@link https://ignf.github.io/geoportal-access-lib/latest/jsdoc/Gp.Services.IsoCurveResponse.html|Service}
     */
    // eslint-disable-next-line no-undef
    _this.EXPORT_ISOCHRON = {};

    /**
     * Response to the export of the profile calculation
     * (only for jsdoc)
     *
     * @example
     * // GeoJSON format
     * {
     *  "type":"FeatureCollection",
     *   "features":[...],
     *   "geoportail:compute":{
     *      "greaterSlope":76,
     *      "meanSlope":7,
     *      "distancePlus":84,
     *      "distanceMinus":48,
     *      "ascendingElevation":5,
     *      "descendingElevation":-4,
     *      "altMin":"92,04",
     *      "altMax":"96,71",
     *      "distance":163,
     *      "unit":"m",
     *      "points":[
     *        {
     *            "z":95.68,
     *            "lon":2.5874,
     *            "lat":48.8419,
     *            "acc":2.5,
     *            "dist":0,
     *            "slope":0
     *         }
     *      ]
     *   }
     * }
     *
     * @see {@link https://ignf.github.io/geoportal-access-lib/latest/jsdoc/Gp.Services.AltiResponse.html|Service}
     */
    // eslint-disable-next-line no-undef
    _this.EXPORT_PROFILE = {};

    // id unique
    _this.uid = options.id || _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_2__["default"].generate();

    // export
    _this.extension = null;
    _this.mimeType = null;

    // dom
    _this.container = null;
    _this.button = null;
    _this.menu = null;
    _this.icon = "\u2630 ";
    _this.menuClassHidden = "GPelementHidden gpf-hidden";
    _this.initOptions(options);
    _this.initContainer();
    return _this;
  }

  // ################################################################### //
  // ##################### public methods ############################## //
  // ################################################################### //

  /**
   * Render DOM
   *
   * @public
   */
  _inherits(ButtonExport, _Control);
  return _createClass(ButtonExport, [{
    key: "render",
    value: function render() {
      // container principal
      if (!this.options.target) {
        if (this.options.control) {
          // insertion du composant dans le panneau du controle
          var container = this.options.control.getContainer();
          // ex. GP(iso|route)Panel-
          this.options.target = container.lastChild;
        }
      }
      if (this.container) {
        this.options.target.appendChild(this.container);
      }
    }

    // ################################################################### //
    // #################### privates methods ############################# //
    // ################################################################### //

    /**
     * Initialize options
     * (called by constructor)
     *
     * @param {Object} options - options
     * @private
     */
  }, {
    key: "initOptions",
    value: function initOptions(options) {
      // options
      this.options = options;
      if (this.options.control) {
        // ...
      }
      if (this.options.target) {
        // ...
      }
      var format = this.options.format;
      format ? this.setFormat(format) : this.setFormat("");
      if (!this.options.name) {
        this.setName("export");
      }
      if (!this.options.title) {
        this.setTitle("Exporter");
      }
      if (this.options.menu === undefined) {
        this.setMenu(false);
      }
    }

    /**
     * Initialize container
     * (called by constructor)
     *
     * @private
     * @todo menu des options
     */
  }, {
    key: "initContainer",
    value: function initContainer() {
      var _this2 = this;
      // TODO
      // menu des options de l'export :
      // * [ nom ]
      // * format
      // https://www.w3schools.com/howto/howto_css_dropdown.asp
      // https://www.w3schools.com/howto/howto_css_custom_checkbox.asp

      // afficher l'icone du menu
      var title = this.options.title;
      if (this.options.menu) {
        title = this.icon + this.options.title;
      }
      var div = document.createElement("div");
      div.id = this._addUID("GPexportContainer");
      div.className = "GPexportMenuContainer";

      // bouton Exporter
      // utiliser les templates literals avec la substitution ${...}
      var button = this.stringToHTML("\n            <input type=\"button\"\n                id=\"".concat(this._addUID("GPexportButton"), "\" \n                class=\"GPsubmit gpf-btn gpf-btn-icon-submit  fr-btn\"\n                value=\"").concat(title, "\">\n        "));

      // add event click button
      this.button = button.firstChild;
      if (this.button) {
        this.button.addEventListener("click", function (e) {
          return _this2.onClickButtonExport(e);
        });
      }
      div.appendChild(button.firstChild);

      // menu des options
      // utiliser les templates literals avec la substitution ${...}
      var menu = this.stringToHTML("\n            <div class=\"GPexportMenuContent ".concat(this.menuClassHidden, "\">\n                <label class=\"container\">GeoJSON\n                    <input type=\"radio\" \n                        id=\"GPmenuFormatGeojson-").concat(this.uid, "\"\n                        name=\"format\" \n                        value=\"geojson\">\n                    <span class=\"checkmark\"></span>\n                </label>\n                <label class=\"container\">KML\n                    <input type=\"radio\" \n                        id=\"GPmenuFormatKml-").concat(this.uid, "\"\n                        name=\"format\" \n                        value=\"kml\">\n                    <span class=\"checkmark\"></span>\n                </label>\n                <label class=\"container\">GPX\n                    <input type=\"radio\" \n                        id=\"GPmenuFormatGpx-").concat(this.uid, "\"\n                        name=\"format\" \n                        value=\"gpx\">\n                    <span class=\"checkmark\"></span>\n                </label>\n            </div>\n        "));
      this.menu = menu.firstChild;
      if (this.menu) {
        if (this.options.menu) {
          var className = this.menu.className;
          this.menu.className = className.replace(this.menuClassHidden, "");
        }
        var radios = this.menu.querySelectorAll("input[type=radio][name=\"format\"]");
        radios.forEach(function (radio) {
          // radio checked par defaut
          if (radio.id.toUpperCase().includes(_this2.options.format.toUpperCase())) {
            radio.checked = true;
          }
          // ecouteur pour changer de format
          radio.addEventListener("change", function (e) {
            _this2.setFormat(e.target.value);
          });
        });
      }
      div.appendChild(menu.firstChild);
      this.container = div;
    }

    /**
     * ...
     *
     * @param {String} str - ...
     * @returns {DOMElement} - ...
     * @private
     */
  }, {
    key: "stringToHTML",
    value: function stringToHTML(str) {
      var support = function support() {
        if (!window.DOMParser) {
          return false;
        }
        var parser = new DOMParser();
        try {
          parser.parseFromString("x", "text/html");
        } catch (err) {
          return false;
        }
        return true;
      };

      // If DOMParser is supported, use it
      if (support()) {
        var parser = new DOMParser();
        var doc = parser.parseFromString(str, "text/html");
        return doc.body;
      }

      // Otherwise, fallback to old-school method
      var dom = document.createElement("div");
      dom.innerHTML = str;
      return dom;
    }

    /**
     * ...
     * @returns {Boolean} - ...
     * @private
     */
  }, {
    key: "isPluggableControl",
    value: function isPluggableControl() {
      // tester toutes les méthodes des widgets pluggable
      // la méthode getData() n'est pas obligatoire car certains widgets
      // n'ont pas de configuration.
      if (this.options.control && typeof this.options.control.getContainer === "function" && typeof this.options.control.getLayer === "function") {
        return true;
      }
      return false;
    }

    /**
     * ...
     * @param {Object} layer - ...
     * @param {Object} [data] - ...
     * @param {Object} [style] - ...
     * @returns {String} - ...
     * @private
     */
  }, {
    key: "exportFeatures",
    value: function exportFeatures(layer, data, style) {
      var _this3 = this;
      var result = null;
      if (!layer) {
        logger.warn("Impossible to export : no layer is hosting features.");
        return result;
      }
      if (!layer.getSource() || !layer.getSource().getFeatures() || !layer.getSource().getFeatures().length) {
        logger.warn("Impossible to export : no features found.");
        return result;
      }

      // INFO
      // les styles sont bien transmis pour l'outil de dessin
      // mais, ce n'est pas toujours le cas pour certains widgets !?
      // donc, on y ajoute les styles par defaut...
      layer.getSource().getFeatures().forEach(function (feature) {
        var style = feature.getStyle();
        if (!style && typeof _this3.options.control.getStyle === "function") {
          feature.setStyle(_this3.options.control.getStyle());
        }
      });

      // ajouter les metadonnées de calcul et de configuration
      var options = {
        defaultStyle: style
      };
      if (data) {
        // properties ajoutées à la racine :
        // ex. "geoportail:compute" : {}
        options.extensions = {
          "geoportail:compute": data
        };
      }
      var ClassName = null;
      switch (this.options.format.toUpperCase()) {
        case "KML":
          options.writeStyles = true;
          options.showPointNames = true;
          ClassName = new _Formats_KML__WEBPACK_IMPORTED_MODULE_4__["default"](options);
          break;
        case "GPX":
          ClassName = new _Formats_GPX__WEBPACK_IMPORTED_MODULE_6__["default"](options);
          break;
        case "GEOJSON":
          ClassName = new _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_5__["default"](options);
          break;
        default:
          break;
      }
      if (!ClassName) {
        logger.warn("Impossible to export : format unknown !?");
        return result;
      }
      var featProj = layer.getSource().getProjection();

      // INFO
      // on determine la projection de la carte
      // si le composant a été ajouté sur la carte via le mécanisme d'OpenLayer...
      var map = this.getMap();
      if (map) {
        featProj = featProj || map.getView().getProjection();
      }
      var features = layer.getSource().getFeatures();

      // INFO
      // par defaut, webmercator ou "EPSG:3857"
      result = ClassName.writeFeatures(features, {
        dataProjection: "EPSG:4326",
        featureProjection: featProj || "EPSG:3857"
      });
      return result;
    }
    // ################################################################### //
    // ######################## event dom ################################ //
    // ################################################################### //

    /**
     * ...
     * @param {*} e - Click
     */
  }, {
    key: "onClickButtonExport",
    value: function onClickButtonExport(e) {
      if (!this.isPluggableControl()) {
        logger.warn("Componant not pluggable with the control !");
        return;
      }
      var layer = this.options.control.getLayer();
      var data = this.options.control.getData !== undefined ? this.options.control.getData() : {};
      var style = this.options.control.getStyle !== undefined ? this.options.control.getStyle() : {};
      var content = this.exportFeatures(layer, data, style);
      if (!content || content === "null") {
        return;
      }

      /**
       * event triggered when the export is finished
       *
       * @event export:compute
       * @typedef {Object}
       * @property {Object} type - event
       * @property {Object} target - instance Export
       * @property {String} content - export data
       * @example
       * Export.on("export:compute", function (e) {
       *   console.log(e.target);
       * })
       */
      this.dispatchEvent({
        type: "export:compute",
        content: content
      });

      // INFO
      // la callback annule le download du fichier.
      if (this.options.onExport && typeof this.options.onExport === "function") {
        this.options.onExport(content);
        return;
      }
      var link = document.createElement("a");
      // determiner le bon charset !
      var charset = "utf-8";
      link.setAttribute("href", "data:" + this.mimeType + ";charset=" + charset + "," + encodeURIComponent(content));
      link.setAttribute("download", this.options.name + this.extension);
      if (document.createEvent) {
        var event = document.createEvent("MouseEvents");
        event.initEvent("click", true, true);
        link.dispatchEvent(event);
      } else {
        link.click();
      }
    }

    // ################################################################### //
    // ##################### public setters ############################## //
    // ################################################################### //
    /**
     * ...
     * @param {Object} control - ...
     * @public
     */
  }, {
    key: "setControl",
    value: function setControl(control) {
      this.options.control = control;
    }

    /**
     * ...
     * @param {DOMElement} target - ...
     * @public
     */
  }, {
    key: "setTarget",
    value: function setTarget(target) {
      this.options.target = target;
    }

    /**
     * ...
     * @param {String} format - ...
     * @public
     */
  }, {
    key: "setFormat",
    value: function setFormat(format) {
      this.options.format = format.toUpperCase();
      switch (this.options.format) {
        case "KML":
          this.extension = ".kml";
          this.mimeType = "application/vnd.google-earth.kml+xml";
          break;
        case "GPX":
          this.extension = ".gpx";
          this.mimeType = "application/gpx+xml";
          break;
        case "GEOJSON":
          this.extension = ".geojson";
          this.mimeType = "application/geo+json";
          break;
        default:
          // redefine format by default !
          this.options.format = "GEOJSON";
          this.extension = ".geojson";
          this.mimeType = "application/geo+json";
          break;
      }
    }

    /**
     * ...
     * @param {String} name - ...
     * @public
     */
  }, {
    key: "setName",
    value: function setName(name) {
      this.options.name = name;
    }

    /**
     * ...
     * @param {String} title - ...
     * @public
     */
  }, {
    key: "setTitle",
    value: function setTitle(title) {
      this.options.title = title;
      if (this.button) {
        // afficher l'icone du menu / titre
        this.button.value = this.options.menu ? this.icon + title : title;
      }
    }

    /**
     * ...
     * @param {Boolean} active - ...
     * @public
     */
  }, {
    key: "setMenu",
    value: function setMenu(active) {
      var _this4 = this;
      this.options.menu = active;
      if (this.button) {
        // afficher l'icone du menu / titre
        this.button.value = this.options.menu ? this.icon + this.options.title : this.options.title;
      }
      if (this.menu && this.options.menu) {
        // afficher le menu
        var className = this.menu.className;
        this.menu.className = className.replace(this.menuClassHidden, "");
        // format par defaut
        var radios = this.menu.querySelectorAll("input[type=radio][name=\"format\"]");
        radios.forEach(function (radio) {
          // radio checked par defaut
          if (radio.id.toUpperCase().includes(_this4.options.format.toUpperCase())) {
            radio.checked = true;
          }
        });
      }
    }
  }]);
}((ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default()));
;

// on récupère les méthodes de la classe DOM
Object.assign(ButtonExport.prototype, _ExportDOM__WEBPACK_IMPORTED_MODULE_7__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ButtonExport);

// Expose Export as ol.control.Export (for a build bundle)
if (window.ol && window.ol.control) {
  window.ol.control.Export = ButtonExport;
}

/***/ }),

/***/ "./src/packages/Controls/Export/ExportDOM.js":
/*!***************************************************!*\
  !*** ./src/packages/Controls/Export/ExportDOM.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ExportDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this.uid ? id + "-" + this.uid : id;
    return uid;
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ExportDOM);

/***/ }),

/***/ "./src/packages/Controls/Isocurve/Isocurve.js":
/*!****************************************************!*\
  !*** ./src/packages/Controls/Isocurve/Isocurve.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CSS_Controls_Isochron_GPFisochron_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../CSS/Controls/Isochron/GPFisochron.css */ "./src/packages/CSS/Controls/Isochron/GPFisochron.css");
/* harmony import */ var _Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Control */ "./src/packages/Controls/Control.js");
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ol/Observable */ "ol/Observable");
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_Observable__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ol/layer/Vector */ "ol/layer/Vector");
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_layer_Vector__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ol/source/Vector */ "ol/source/Vector");
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_source_Vector__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ol/style */ "ol/style");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ol_style__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var geoportal_access_lib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! geoportal-access-lib */ "./node_modules/geoportal-access-lib/src/Gp.js");
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../Utils/Helper */ "./src/packages/Utils/Helper.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../Utils/SelectorID */ "./src/packages/Utils/SelectorID.js");
/* harmony import */ var _Utils_Markers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Utils/Markers */ "./src/packages/Controls/Utils/Markers.js");
/* harmony import */ var _Utils_Draggable__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../Utils/Draggable */ "./src/packages/Utils/Draggable.js");
/* harmony import */ var _Utils_Interactions__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../Utils/Interactions */ "./src/packages/Controls/Utils/Interactions.js");
/* harmony import */ var _LayerSwitcher_LayerSwitcher__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../LayerSwitcher/LayerSwitcher */ "./src/packages/Controls/LayerSwitcher/LayerSwitcher.js");
/* harmony import */ var _LocationSelector_LocationSelector__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../LocationSelector/LocationSelector */ "./src/packages/Controls/LocationSelector/LocationSelector.js");
/* harmony import */ var _Export_Export__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../Export/Export */ "./src/packages/Controls/Export/Export.js");
/* harmony import */ var _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../Formats/GeoJSON */ "./src/packages/Formats/GeoJSON.js");
/* harmony import */ var _IsocurveDOM__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./IsocurveDOM */ "./src/packages/Controls/Isocurve/IsocurveDOM.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
// import CSS

// import "../../CSS/Controls/Isochron/GPFisochronStyle.css";
// import OpenLayers
// import Control from "ol/control/Control";




// import GeoJSON from "ol/format/GeoJSON";

// import geoportal library access

// import local






// import local with ol dependencies





// DOM

var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_8__["default"].getLogger("isocurve");

/**
 * @classdesc
 *
 * Isocurve Control.
 *
 * @constructor
 * @alias ol.control.Isocurve
 * @type {ol.control.Isocurve}
 * @extends {ol.control.Control}
 * @param {Object} options - Isocurve control options
 * @param {String}   [options.apiKey] - API key for services call (isocurve and autocomplete services). The key "calcul" is used by default.
 * @param {Boolean} [options.ssl = true] - use of ssl or not (default true, service requested using https protocol)
 * @param {Boolean} [options.collapsed = true] - Specify if widget has to be collapsed (true) or not (false) on map loading. Default is true.
 * @param {Boolean} [options.draggable = false] - Specify if widget is draggable
 * @param {Boolean|Object} [options.export = false] - Specify if button "Export" is displayed. For the use of the options of the "Export" control, see {@link ol.control.Export}
 * @param {Object}  [options.exclusions = {"toll" : false, "tunnel" : false, "bridge" : false}] - list of exclusions with status (true = checked). By default : no exclusions checked.
 * @param {Array}   [options.graphs = ["Voiture", "Pieton"]] - list of graph resources to be used for isocurve calculation, by default : ["Voiture", "Pieton"]. Possible values are "Voiture" and "Pieton". The first element is selected.
 * @param {Array}   [options.methods = ["time", "distance"]] - list of methods, by default : ["time", "distance"]. Possible values are "time" and "distance". The first element is selected by default.
 * @param {Array}   [options.directions = ["departure", "arrival"]] - list of directions to be displayed, by default : ["departure", "arrival"]. The first element is selected by default. Possible values are "departure" and "arrival".
 *      Directions enable to specify if input location point will be used as a departure point ("departure") or as an arrival point ("arrival")
 * @param {Object} [options.isocurveOptions = {}] - isocurve service options. see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~isoCurve Gp.Services.isoCurve()} to know all isocurve options.
 * @param {Object} [options.autocompleteOptions = {}] - autocomplete service options. see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~autoComplete Gp.Services.autoComplete()} to know all autocomplete options
 * @param {Object} [options.markerOpts] - options to use your own marker. Default is a lightOrange marker.
 * @param {String} [options.markerOpts.url] - marker base64 encoded url (ex "data:image/png;base64,...""). Mandatory for a custom marker
 * @param {Array} [options.markerOpts.offset] - Offsets in pixels used when positioning the overlay. The first element in the array is the horizontal offset. A positive value shifts the overlay right. The second element in the array is the vertical offset. A positive value shifts the overlay down. Default is [0, 0]. (see http://openlayers.org/en/latest/apidoc/ol.Overlay.html)
 * @param {Object} [options.layerDescription = {}] - Layer informations to be displayed in LayerSwitcher widget (only if a LayerSwitcher is also added to the map)
 * @param {String} [options.layerDescription.title = "Isochrone/Isodistance"] - Layer title to be displayed in LayerSwitcher
 * @param {String} [options.layerDescription.description = "isochrone/isodistance basé sur un graphe"] - Layer description to be displayed in LayerSwitcher
 * @fires isocurve:drawstart
 * @fires isocurve:drawend
 * @fires isocurve:compute
 * @fires export:compute
 * @example
 *  var iso = ol.control.Isocurve({
 *      "collapsed" : false,
 *      "draggable" : true,
 *      "export"    : false,
 *      "methods" : ["time", "distance"],
 *      "exclusions" : {
 *         "toll" : true,
 *         "bridge" : false,
 *         "tunnel" : true
 *      },
 *      "graphs" : ["Pieton", "Voiture"],
 *      "markerOpts" : {
 *          "url" : "...",
 *          "offset" : [0,0]
 *      }
 *      "isocurveOptions" : {},
 *      "autocompleteOptions" : {}
 *  });
 *
 *  // if you want to pluggued the control Export with options :
 *  var iso = new ol.control.Isocurve({
 *    export : {
 *      name : "export",
 *      format : "geojson",
 *      title : "Exporter",
 *      menu : false
 *    }
 *  });
 */
var Isocurve = /*#__PURE__*/function (_Control) {
  /**
   * See {@link ol.control.Isocurve}
   * @module Isocurve
   * @alias module:~controls/Isocurve
   * @param {*} options - options
   * @example
   * import Isocurve from from "gpf-ext-ol/controls/Isocurve"
   * ou 
   * import { Isocurve } from "gpf-ext-ol"
   */
  function Isocurve(options) {
    var _this;
    _classCallCheck(this, Isocurve);
    options = options || {};

    // call ol.control.Control constructor
    _this = _callSuper(this, Isocurve, [{
      element: options.element,
      target: options.target,
      render: options.render
    }]);
    if (!(_this instanceof Isocurve)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }

    // initialisation du composant
    _this.initialize(options);

    // // Widget main DOM container
    _this._container = _this._createMainContainerElement();

    // ajout du container
    _this.element ? _this.element.appendChild(_this._container) : _this.element = _this._container;
    return _possibleConstructorReturn(_this, _this);
  }

  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {ol.Map} map - Map.
   */
  _inherits(Isocurve, _Control);
  return _createClass(Isocurve, [{
    key: "setMap",
    value: function setMap(map) {
      if (map) {
        // enrichissement du DOM du container lors de l'ajout à la carte
        this._container = this._initContainer(map);

        // ajout d'un bouton d'export
        if (this.options["export"]) {
          var opts = _Utils_Helper__WEBPACK_IMPORTED_MODULE_7__["default"].assign({
            control: this
          }, this.options["export"]);
          this["export"] = new _Export_Export__WEBPACK_IMPORTED_MODULE_15__["default"](opts);
          this["export"].render();
          var self = this;
          this["export"].on("export:compute", function (e) {
            self.dispatchEvent({
              type: "export:compute",
              content: e.content
            });
          });
        }

        // mode "draggable"
        if (this.draggable) {
          _Utils_Draggable__WEBPACK_IMPORTED_MODULE_11__["default"].dragElement(this._IsoPanelContainer, this._IsoPanelHeaderContainer, this.options.position ? null : map.getTargetElement());
        }

        // mode "collapsed"
        if (!this.collapsed) {
          this._pictoIsoButton.setAttribute("aria-pressed", true);
        }
      }

      // on appelle la méthode setMap originale d'OpenLayers
      _get(_getPrototypeOf(Isocurve.prototype), "setMap", this).call(this, map);

      // position
      if (this.options.position) {
        this.setPosition(this.options.position);
      }
    }

    // ################################################################### //
    // ##################### public methods ############################## //
    // ################################################################### //

    /**
     * Returns true if widget is collapsed (minimized), false otherwise
     *
     * @returns {Boolean} collapsed - true if widget is collapsed
     */
  }, {
    key: "getCollapsed",
    value: function getCollapsed() {
      return this.collapsed;
    }

    /**
     * Collapse or display widget main container
     *
     * @param {Boolean} collapsed - True to collapse widget, False to display it
     */
  }, {
    key: "setCollapsed",
    value: function setCollapsed(collapsed) {
      if (collapsed === undefined) {
        logger.log("[ERROR] Isocurve:setCollapsed - missing collapsed parameter");
        return;
      }
      if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
        return;
      }
      if (collapsed) {
        document.getElementById("GPisochronPanelClose-" + this._uid).click();
      } else {
        this._pictoIsoButton.click();
      }
      this.collapsed = collapsed;
    }

    /**
     * Get vector layer where Isocurve geometry is drawn
     *
     * @returns {Object} layer - ol.layer.Vector isocurve layer
     */
  }, {
    key: "getLayer",
    value: function getLayer() {
      return this._geojsonLayer;
    }

    /**
     * Set vector layer where Isocurve geometry is drawn
     *
     * @param {Object} layer - ol.layer.Vector isocurve layer
     */
  }, {
    key: "setLayer",
    value: function setLayer(layer) {
      if (!layer) {
        this._geojsonLayer = null;
        return;
      }
      if (!(layer instanceof (ol_layer_Vector__WEBPACK_IMPORTED_MODULE_3___default()))) {
        logger.log("no valid layer given for hosting drawn features.");
        return;
      }

      // application des styles
      layer.setStyle(this._defaultFeatureStyle);

      // sauvegarde
      this._geojsonLayer = layer;
    }

    /**
     * Get vector layer
     *
     * @returns {String} geojson - GeoJSON format layer
     */
  }, {
    key: "getGeoJSON",
    value: function getGeoJSON() {
      return JSON.stringify(this._geojsonObject);
    }

    /**
     * Set vector layer
     *
     * @param {String} geojson - GeoJSON format layer
     */
  }, {
    key: "setGeoJSON",
    value: function setGeoJSON(geojson) {
      try {
        this._geojsonObject = JSON.parse(geojson);
      } catch (e) {
        logger.log("no valid geojson given :" + e.message);
      }
    }

    /**
     * Get isocurve data
     *
     * @returns {Object} data - process results
     */
  }, {
    key: "getData",
    value: function getData() {
      var data = {
        type: "isocurve",
        transport: this._currentTransport,
        computation: this._currentComputation,
        exclusions: this._currentExclusions,
        direction: this._currentDirection,
        point: this._originPoint.getCoordinate(),
        // lon/lat wgs84
        results: {}
      };
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_7__["default"].assign(data.results, this._currentIsoResults);
      return data;
    }

    /**
     * Set isocurve data
     *
     * @param {Object} data - control informations
     * @param {String} data.transport - transport type
     * @param {String} data.computation - computation type
     * @param {Array} data.exclusions - list of exclusions
     * @param {String} data.direction - direction type
     * @param {Array} data.point - [lon, lat]
     * @param {Object} data.results - service response
     */
  }, {
    key: "setData",
    value: function setData(data) {
      this._currentTransport = data.transport;
      this._currentComputation = data.computation;
      this._currentExclusions = data.exclusions;
      this._currentDirection = data.direction;
      // INFO
      // > this._originPoint.clear();
      // l'utilisation de cette méthode declenche des evenements qui retirent la couche en cours !
      // (cf. _createIsoPanelFormPointElement),
      var inputPointer = document.getElementById("GPlocationOriginPointer_" + 1 + "-" + this._uid);
      inputPointer.checked = true;
      var inputCoords = document.getElementById("GPlocationOriginCoords_" + 1 + "-" + this._uid);
      inputCoords.value = "";
      this._originPoint.setCoordinate(data.point, "EPSG:4326");
      this._currentIsoResults = data.results;
    }

    /**
     * Get container
     *
     * @returns {DOMElement} container
     */
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this._container;
    }

    /**
     * Get default style
     *
     * @returns {ol.style} style
     */
  }, {
    key: "getStyle",
    value: function getStyle() {
      return this._defaultFeatureStyle;
    }

    /**
     * This method is public.
     * It allows to control the execution of a traitment.
     *
     * @param {Array} position - position in the projection map [ x, y ]
     * @param {Object} value - distance in km or hours-minutes
     * @param {Object} options - options = {...}
     */
  }, {
    key: "compute",
    value: function compute(position, value, options) {
      this._clear();
      var opened = this._pictoIsoButton.ariaPressed;
      if (!(opened === "true")) {
        this._pictoIsoButton.click();
      }
      var map = this.getMap();
      if (!map) {
        return;
      }

      // Les options par defauts
      var settings = {
        direction: "departure",
        method: "time",
        transport: "Voiture",
        exclusions: []
      };

      // On recupere les options
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_7__["default"].assign(settings, options);
      this._originPoint.setCoordinate(position);
      var coordinate = this._originPoint.getCoordinate();
      var input = document.getElementById("GPlocationOrigin_" + 1 + "-" + this._uid);
      input.value = coordinate[0].toFixed(4) + " / " + coordinate[1].toFixed(4);
      this._currentTransport = settings.transport;
      if (settings.transport === "Voiture") {
        document.getElementById("GPisochronTransportCar-" + this._uid).checked = true;
      } else {
        document.getElementById("GPisochronTransportPedestrian-" + this._uid).checked = true;
      }
      this._currentExclusions = settings.exclusions;
      this._currentComputation = settings.method;
      if (settings.method === "time") {
        var time = value.split(".");
        this._currentTimeHour = time[0] || 0;
        document.getElementById("GPisochronValueChronInput1-" + this._uid).value = this._currentTimeHour;
        this._currentTimeMinute = time[1] || 0;
        document.getElementById("GPisochronValueChronInput2-" + this._uid).value = this._currentTimeMinute;
        document.getElementById("GPisochronChoiceAltChron-" + this._uid).click();
      } else {
        this._currentDistance = value;
        document.getElementById("GPisochronValueDistInput-" + this._uid).value = this._currentDistance;
        document.getElementById("GPisochronChoiceAltDist-" + this._uid).click();
      }
      this._currentDirection = settings.direction;
      settings.direction === "departure" ? document.getElementById("GPisochronDirectionSelect-" + this._uid).selectedIndex = 0 : document.getElementById("GPisochronDirectionSelect-" + this._uid).selectedIndex = 1;
      this.onIsoComputationSubmit();
    }

    /**
     * This method is public.
     * It allows to init the control.
     */
  }, {
    key: "init",
    value: function init() {
      // point
      var coordinate = this._originPoint.getCoordinate();
      var input = document.getElementById("GPlocationOrigin_" + 1 + "-" + this._uid);
      input.value = coordinate[1].toFixed(4) + " / " + coordinate[0].toFixed(4);

      // transport
      if (this._currentTransport === "Voiture") {
        document.getElementById("GPisochronTransportCar-" + this._uid).checked = true;
      } else {
        document.getElementById("GPisochronTransportPedestrian-" + this._uid).checked = true;
      }

      // method
      if (this._currentComputation === "time") {
        var minutes = this._currentIsoResults.time / 60;
        this._currentTimeHour = Math.floor(minutes / 60);
        document.getElementById("GPisochronValueChronInput1-" + this._uid).value = this._currentTimeHour;
        this._currentTimeMinute = Math.round((minutes / 60 - this._currentTimeHour) * 60);
        document.getElementById("GPisochronValueChronInput2-" + this._uid).value = this._currentTimeMinute;
        document.getElementById("GPisochronChoiceAltChron-" + this._uid).click();
      } else {
        this._currentDistance = this._currentIsoResults.distance / 1000;
        document.getElementById("GPisochronValueDistInput-" + this._uid).value = this._currentDistance;
        document.getElementById("GPisochronChoiceAltDist-" + this._uid).click();
      }

      // direction
      this._currentDirection === "departure" ? document.getElementById("GPisochronDirectionSelect-" + this._uid).selectedIndex = 0 : document.getElementById("GPisochronDirectionSelect-" + this._uid).selectedIndex = 1;
    }

    /**
     * Clean UI : reinit control
     */
  }, {
    key: "clean",
    value: function clean() {
      this._clearIsoInputs();
      // INFO
      // le comportement est surchargé, ceci supprime la couche !?
      // cf. _createIsoPanelFormPointElement()
      this._originPoint.clearResults();
      document.getElementById("GPlocationPoint_1-" + this._uid).style.cssText = "";
      document.getElementById("GPlocationOriginCoords_1-" + this._uid).value = "";
      document.getElementById("GPlocationOrigin_1-" + this._uid).value = "";
      document.getElementById("GPlocationPoint_1-" + this._uid).style.cssText = "";
      document.getElementById("GPlocationOriginPointer_1-" + this._uid).checked = false;
      document.getElementById("GPlocationOrigin_1-" + this._uid).className = "GPlocationOriginVisible gpf-visible";
      document.getElementById("GPlocationOriginCoords_1-" + this._uid).className = "GPlocationOriginHidden gpf-hidden";
      this._currentIsoResults = null;
      this.setLayer();
    }

    // ################################################################### //
    // ##################### init component ############################## //
    // ################################################################### //

    /**
     * Initialize Isocurve control (called by Isocurve constructor)
     *
     * @param {Object} options - constructor options
     * @private
     */
  }, {
    key: "initialize",
    value: function initialize(options) {
      this._checkInputOptions(options);

      // set default options
      this.options = {
        collapsed: true,
        draggable: false,
        "export": false,
        methods: ["time", "distance"],
        graphs: ["Voiture", "Pieton"],
        exclusions: {
          toll: false,
          tunnel: false,
          bridge: false
        },
        directions: ["departure", "arrival"],
        markerOpts: {
          url: _Utils_Markers__WEBPACK_IMPORTED_MODULE_10__["default"]["lightOrange"],
          offset: _Utils_Markers__WEBPACK_IMPORTED_MODULE_10__["default"].defaultOffset
        },
        isocurveOptions: {},
        autocompleteOptions: {},
        layerDescription: {
          title: "Isochrone/Isodistance",
          description: "isochrone/isodistance basé sur un graphe"
        }
      };

      // merge with user options
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_7__["default"].assign(this.options, options);

      /** {Boolean} specify if isocurve control is collapsed (true) or not (false) */
      this.collapsed = this.options.collapsed;

      /** {Boolean} specify if isocurve control is draggable (true) or not (false) */
      this.draggable = this.options.draggable;

      // identifiant du contrôle : utile pour suffixer les identifiants CSS (pour gérer le cas où il y en a plusieurs dans la même page)
      this._uid = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_9__["default"].generate();

      // Options du service paramétrables via l'interface (graph, method, exclusions)
      // Mode de transport selectionné : 'Voiture' ou 'Pieton'
      this._currentTransport = null;
      this._initTransport();
      // Mode de calcul selectionné : 'time' (isochron) ou 'distance' (isodistance)
      this._currentComputation = null;
      this._initComputation();
      // Exclusions selectionnées : Tunnel, Toll et Bridge
      this._currentExclusions = [];
      this._initExclusions();
      // sens de parcours : "departure" ou "arrival"
      this._currentDirection = null;
      this._initDirection();

      // point de saisie
      this._originPoint = null;

      // containers principaux
      this._pictoIsoButton = null;
      this._waitingContainer = null;
      this._formContainer = null;
      this._IsoPanelContainer = null;
      this._IsoPanelHeaderContainer = null;

      // les résultats du calcul
      this._currentIsoResults = null;

      // la géométrie
      this._geojsonLayer = null;
      this._geojsonObject = null;

      // bouton export
      this["export"] = null;

      // si un calcul est en cours ou non
      this._waiting = false;
      // timer pour cacher la patience après un certain temps
      this._timer = null;

      // styles pour les sélections des features
      this._defaultFeatureStyle = new ol_style__WEBPACK_IMPORTED_MODULE_5__.Style({
        fill: new ol_style__WEBPACK_IMPORTED_MODULE_5__.Fill({
          color: "rgba(0, 183, 152, 0.7)"
        }),
        stroke: new ol_style__WEBPACK_IMPORTED_MODULE_5__.Stroke({
          color: "rgba(0, 183, 152, 0)",
          width: 1
        })
      });

      // liste des ressources avec droits par service
      // Ex. {
      //   "Isocurve" : {
      //       key : "ger4g456re45er456t4er5ge5",
      //       resources : ["Pieton", "Voiture"]
      //   }
      // }
      this._resources = {};

      // listener key for event click on map
      this.listenerKey = null;
    }

    /**
     * this method is called by this.initialize()
     *
     * @param {Object} options - options
     *
     * @private
     */
  }, {
    key: "_checkInputOptions",
    value: function _checkInputOptions(options) {
      // vérification des options
      // on ne permet pas de n'afficher aucun mode de calcul ou aucun mode de transport ?
      var i;

      // modes de calcul
      if (options.methods) {
        if (Array.isArray(options.methods)) {
          // on ne permet pas de passer un tableau vide : on spécifie au moins une méthode
          if (options.methods.length === 0) {
            options.methods = null;
          } else {
            for (i = 0; i < options.methods.length; i++) {
              if (typeof options.methods[i] !== "string") {
                logger.log("[ol.control.Isocurve] ERROR : parameter 'methods' elements should be of type 'string'");
              }
            }
          }
        } else {
          logger.warn("'methods' parameter should be an array");
          options.methods = null;
        }
      }

      // mode de transport
      if (options.graphs) {
        if (Array.isArray(options.graphs)) {
          // on ne permet pas de passer un tableau vide : on spécifie au moins un graph
          if (options.graphs.length === 0) {
            options.graphs = null;
          } else {
            for (i = 0; i < options.graphs.length; i++) {
              if (typeof options.graphs[i] !== "string") {
                logger.log("[ol.control.Isocurve] ERROR : parameter 'graphs' elements should be of type 'string'");
              } else {
                if (options.graphs[i].toLowerCase() === "pieton") {
                  options.graphs[i] = "Pieton";
                }
                if (options.graphs[i].toLowerCase() === "voiture") {
                  options.graphs[i] = "Voiture";
                }
              }
            }
          }
        } else {
          logger.warn("'graphs' parameter should be an array");
          options.graphs = null;
        }
      }

      // sens du parcours
      if (options.directions) {
        if (Array.isArray(options.directions)) {
          // on ne permet pas de passer un tableau vide : on spécifie au moins une direction
          if (options.directions.length === 0) {
            options.directions = null;
          } else {
            for (i = 0; i < options.directions.length; i++) {
              if (typeof options.directions[i] !== "string") {
                logger.log("[ol.control.Isocurve] ERROR : parameter 'directions' elements should be of type 'string'");
              }
            }
          }
        } else {
          logger.warn("'directions' parameter should be an array");
          options.directions = null;
        }
      }

      // collapsed
      if (options.collapsed === "true") {
        options.collapsed = true;
      }
      if (options.collapsed === "false") {
        options.collapsed = false;
      }
    }

    /**
     * this method is called by this.initialize() and initialize transport mode
     * ("Voiture" ou "Pieton")
     *
     * @private
     */
  }, {
    key: "_initTransport",
    value: function _initTransport() {
      // Mode de transport selectionné
      this._currentTransport = "Voiture"; // par defaut

      // par defaut
      var transports = this.options.graphs;
      if (!transports || transports.length === 0) {
        this.options.graphs = ["Voiture", "Pieton"];
      }

      // option
      if (Array.isArray(transports) && transports.length) {
        // FIXME pb si le 1er graphe n'est pas une ressource connue !
        if (transports[0] === "Voiture" || transports[0] === "Pieton") {
          this._currentTransport = transports[0];
        }
      }

      // si l'utilisateur a spécifié un graph dans le service, on surcharge les options du widget
      var serviceOptions = this.options.isocurveOptions;
      if (serviceOptions.graph) {
        this._currentTransport = serviceOptions.graph;
      }
    }

    /**
     * this method is called by this.initialize() and initialize computation mode
     * (time or distance)
     *
     * @private
     */
  }, {
    key: "_initComputation",
    value: function _initComputation() {
      // Mode de calcul selectionné
      this._currentComputation = "time"; // par defaut

      // par defaut
      var methods = this.options.methods;
      if (!methods || methods.length === 0) {
        this.options.methods = ["time", "distance"];
      }

      // option
      if (Array.isArray(methods) && methods.length) {
        // FIXME pb si le 1er graphe n'est pas une ressource connue !
        if (methods[0] === "time" || methods[0] === "distance") {
          this._currentComputation = methods[0];
        }
      }

      // si l'utilisateur a spécifié une méthode dans le service, on surcharge les options du widget
      var serviceOptions = this.options.isocurveOptions;
      if (serviceOptions.method) {
        this._currentComputation = serviceOptions.method;
      }
      if (serviceOptions.time) {
        this._currentComputation = "time";
      }
      if (serviceOptions.distance) {
        this._currentComputation = "distance";
      }
    }

    /**
     * this method is called by this.initialize() and initialize direction mode
     * (departure or arrival)
     *
     * @private
     */
  }, {
    key: "_initDirection",
    value: function _initDirection() {
      // Mode de calcul selectionné
      this._currentDirection = "departure"; // par defaut

      // par defaut
      var directions = this.options.directions;
      if (!directions || directions.length === 0) {
        this.options.directions = ["departure", "arrival"];
      }

      // option
      if (Array.isArray(directions) && directions.length) {
        // FIXME pb si le 1er graphe n'est pas une ressource connue !
        if (directions[0] === "departure" || directions[0] === "arrival") {
          this._currentDirection = directions[0];
        }
      }

      // si l'utilisateur a spécifié une méthode dans le service, on surcharge les options du widget
      var serviceOptions = this.options.isocurveOptions;
      if (!serviceOptions.reverse) {
        this._currentDirection = "departure";
      }
      if (serviceOptions.reverse === true) {
        this._currentDirection = "arrival";
        this.options.directions = ["arrival", "departure"];
      }
    }

    /**
     * this method is called by this.initialize() and initialize exclusions
     *
     * @private
     */
  }, {
    key: "_initExclusions",
    value: function _initExclusions() {
      // Exclusions selectionnées : Tunnel, Toll et Bridge
      this._currentExclusions = []; // par defaut

      // par defaut
      var exclusion = this.options.exclusions;
      if (!exclusion || _typeof(exclusion) === "object" && Object.keys(exclusion).length === 0) {
        this.options.exclusions = {
          toll: false,
          tunnel: false,
          bridge: false
        };
      }

      // option
      if (exclusion && _typeof(exclusion) === "object" && Object.keys(exclusion).length) {
        for (var k in exclusion) {
          if (exclusion.hasOwnProperty(k)) {
            if (exclusion.k) {
              this._currentExclusions.push(k);
            }
          }
        }
      }

      // si l'utilisateur a spécifié des exclusions dans le service, on surcharge les options du widget
      var serviceOptions = this.options.isocurveOptions;
      if (Array.isArray(serviceOptions.exclusions)) {
        this._currentExclusions = serviceOptions.exclusions;
      }
    }

    // ################################################################### //
    // ######################## DOM initialize ########################### //
    // ################################################################### //

    /**
     * initialize component container (DOM)
     *
     * @param {Object} map - the map
     *
     * @returns {DOMElement} DOM element
     *
     * @private
     */
  }, {
    key: "_initContainer",
    value: function _initContainer(map) {
      var _this2 = this;
      // get main container
      var container = this._container;
      var picto = this._pictoIsoButton = this._createShowIsoPictoElement();
      container.appendChild(picto);

      // panneau
      var panel = this._IsoPanelContainer = this._createIsoPanelElement();
      var panelDiv = this._createIsoPanelDivElement();
      panel.appendChild(panelDiv);

      // header
      var header = this._IsoPanelHeaderContainer = this._createIsoPanelHeaderElement();
      panelDiv.appendChild(header);

      // form
      var form = this._formContainer = this._createIsoPanelFormElement();

      // form: input de saisie de la localisation (fonction de Isocurve, voir ci-dessous)
      var point = this._createIsoPanelFormPointElement(map);
      form.appendChild(point);
      var isoChronChecked = false;
      var isoDistChecked = false;
      var typeChoice = this._createIsoPanelFormTypeChoiceElement();
      for (var i = 0; i < this.options.methods.length; i++) {
        if (this.options.methods[i] === "time") {
          isoChronChecked = i === 0;
          typeChoice.appendChild(this._createIsoPanelFormTypeChoiceChronElement(isoChronChecked));
        }
        if (this.options.methods[i] === "distance") {
          isoDistChecked = i === 0;
          typeChoice.appendChild(this._createIsoPanelFormTypeChoiceDistElement(isoDistChecked));
        }
      }
      form.appendChild(typeChoice);

      // form: menu du choix des valeurs
      form.appendChild(this._createIsoPanelFormValueIsochronElement(isoChronChecked));
      form.appendChild(this._createIsoPanelFormValueIsodistanceElement(isoDistChecked));

      // form: menu du choix du transport et du sens du parcours
      var modeChoice = this._createIsoPanelFormModeChoiceElement();
      modeChoice.appendChild(this._createIsoPanelFormModeChoiceTransportElement(this.options.graphs));
      // FIXME : doit on passer le paramètre defaultDirection ?
      modeChoice.appendChild(this._createIsoPanelFormModeChoiceDirectionElement(this.options.directions));
      form.appendChild(modeChoice);

      // form: menu des exclusions
      if (this.options.exclusions && _typeof(this.options.exclusions) === "object" && Object.keys(this.options.exclusions).length !== 0) {
        form.appendChild(this._createShowIsoExclusionsPictoElement());
        var exclusion = this._createIsoPanelFormExclusionsElement();
        exclusion.appendChild(this._createIsoPanelFormExclusionOptionsElement(this.options.exclusions));
        form.appendChild(exclusion);
      }

      // footer
      var footer = this._createIsoPanelFooterElement();
      form.appendChild(footer);
      var buttonReset = this._createIsoFormResetElement();
      footer.appendChild(buttonReset);

      // form: bouton du calcul
      var buttonSubmit = this._submitContainer = this._createIsoSubmitFormElement();
      footer.appendChild(buttonSubmit);
      panelDiv.appendChild(form);

      // waiting
      var waiting = this._waitingContainer = this._createIsoWaitingElement();
      panel.appendChild(waiting);
      container.appendChild(panel);

      // hide autocomplete suggested locations on container click
      if (container.addEventListener) {
        container.addEventListener("click", function (e) {
          return _this2._hideIsoSuggestedLocations(e);
        });
      }
      return container;
    }

    /**
     * Create start point
     *
     * @param {Object} map - the map
     *
     * @returns {Object} DOM element
     * @private
     */
  }, {
    key: "_createIsoPanelFormPointElement",
    value: function _createIsoPanelFormPointElement(map) {
      this._originPoint = new _LocationSelector_LocationSelector__WEBPACK_IMPORTED_MODULE_14__["default"]({
        apiKey: this.options.apiKey || null,
        tag: {
          id: 1,
          groupId: this._uid,
          markerOpts: this.options.markerOpts,
          label: "Départ",
          display: true
        },
        autocompleteOptions: this.options.autocompleteOptions || null
      });
      this._originPoint.setMap(map);
      // a la sélection d'un nouveau point, on réinitialise aussi le tracé
      var self = this;
      // click sur le pointer
      document.getElementById("GPlocationOriginPointerImg_1-" + this._uid).onclick = function () {
        self._clearGeojsonLayer();
        var map = self.getMap();
        if (self._originPoint._inputShowPointerContainer.checked) {
          // au click sur l'input pour pointer sur la carte: on minimise le formulaire
          self._formContainer.className = "GPisochronFormMini gpf-panel__content fr-modal__content";
          // et au clic sur la carte, on réaffichera le formulaire "normal"
          this.listenerKey = map.on("click", function () {
            self._formContainer.className = "gpf-panel__content fr-modal__content";
            self.dispatchEvent("isocurve:drawend");
          });
        } else {
          // si on déselectionne le pointer, on rétablit le formulaire en mode normal
          self._formContainer.className = "gpf-panel__content fr-modal__content";
          // et on enlève l'écouteur d'évènement sur la carte
          // map.un("click", () => { self._formContainer.className = ""; });
          (0,ol_Observable__WEBPACK_IMPORTED_MODULE_2__.unByKey)(this.listenerKey);
        }
        /**
        * event triggered at the start of drawing input
        *
        * @event isocurve:drawstart
        */
        self.dispatchEvent("isocurve:drawstart");
      };
      // click sur le label
      document.getElementById("GPlocationOriginLabel_1-" + this._uid).onclick = function () {
        self._clearGeojsonLayer();
        self._formContainer.className = "gpf-panel__content fr-modal__content";
        // on désactive l'écouteur d'événements sur la carte (pour ne pas placer un marker au clic)
        map.un("click", function () {
          self._formContainer.className = "gpf-panel__content fr-modal__content";
        });
        self.dispatchEvent("isocurve:drawend");
      };
      // click sur la zone de saisie
      document.getElementById("GPlocationOrigin_1-" + this._uid).onclick = function () {
        self._clearGeojsonLayer();
        /**
        * event triggered at the end of drawing input
        *
        * @event isocurve:drawend
        */
        self.dispatchEvent("isocurve:drawend");
      };
      return this._originPoint._container;
    }

    // ################################################################### //
    // ####################### handlers events to dom #################### //
    // ################################################################### //

    /**
     * this method is called by event 'submit' on 'GPisochronForm' tag form
     * (cf. this._createIsoPanelFormElement),
     * and call isocurve service to display results
     *
     * @private
     */
  }, {
    key: "onIsoComputationSubmit",
    value: function onIsoComputationSubmit() {
      // si on n'a pas de valeur récupérée pour notre point origine, on ne fait rien
      if (!this._originPoint || !this._originPoint.getCoordinate || !this._originPoint.getCoordinate()) {
        logger.log("[Isocurve] Missing position parameter to submit isocurve request");
        return;
      }

      // récupération de l'origine
      var positionCoordinates = this._originPoint.getCoordinate();
      var position = {
        x: positionCoordinates[0],
        y: positionCoordinates[1]
      };
      logger.log("origin : ", position);

      // récupération du temps ou de la distance
      var time;
      var distance;
      if (this._currentComputation.toLowerCase() === "time") {
        var timeHourInput = document.getElementById("GPisochronValueChronInput1-" + this._uid);
        var hours = parseInt(timeHourInput.value, 10);
        if (isNaN && isNaN(hours)) {
          hours = 0;
        }
        var timeMinutesInput = document.getElementById("GPisochronValueChronInput2-" + this._uid);
        var minutes = parseInt(timeMinutesInput.value, 10);
        if (isNaN && isNaN(minutes)) {
          minutes = 0;
        }
        // durée exprimée en secondes
        time = hours * 3600 + minutes * 60;
        logger.log("time : " + time);
      }
      if (this._currentComputation.toLowerCase() === "distance") {
        var distInput = document.getElementById("GPisochronValueDistInput-" + this._uid);
        // distance exprimée en mètres
        distance = parseFloat(distInput.value) * 1000;
        logger.log("distance : " + distance);
      }

      // si on n'a pas de valeur de calcul renseignée, on ne lance pas la requête.
      if (!time && !distance) {
        logger.log("[Isocurve] Missing time or distance parameter to submit isocurve request");
        return;
      }

      // on recupere les éventuelles options du service passées par l'utilisateur
      var options = this.options.isocurveOptions || {};

      // gestion du protocole et du timeout
      // le timeout est indispensable sur le protocole JSONP.
      var _protocol = options.protocol || "XHR";
      var _timeout = options.timeOut || 0;
      if (_protocol === "JSONP" && _timeout === 0) {
        // FIXME le timeout est obligatoire pour ce type de protocole...
        _timeout = 15000;
      }

      // gestion des callback
      var bOnFailure = !!(options.onFailure !== null && typeof options.onFailure === "function"); // cast variable to boolean
      var bOnSuccess = !!(options.onSuccess !== null && typeof options.onSuccess === "function");

      // on met en place l'affichage des resultats dans la fenetre de resultats.
      var context = this;
      var isoRequestOptions = {
        position: position,
        graph: options.graph || this._currentTransport,
        exclusions: options.exclusions || this._currentExclusions,
        method: options.method || this._currentComputation,
        smoothing: options.smoothing || true,
        timeOut: _timeout,
        protocol: _protocol,
        resource: options.resource,
        // callback onSuccess
        onSuccess: function onSuccess(results) {
          logger.log(results);
          if (results) {
            context._drawIsoResults(results);
          }
          if (bOnSuccess) {
            options.onSuccess.call(context, results);
          }
        },
        // callback onFailure
        onFailure: function onFailure(error) {
          // FIXME mise à jour du controle mais le service ne repond pas en 200 !?
          context._hideWaitingContainer();
          logger.log(error.message);
          if (bOnFailure) {
            options.onFailure.call(context, error);
          }
        }
      };
      if (this._currentDirection.toLowerCase() === "arrival" || options.reverse) {
        isoRequestOptions.reverse = true;
      }
      if (time) {
        isoRequestOptions.time = time;
      }
      if (distance) {
        isoRequestOptions.distance = distance;
      }
      this._requestIsoCurve(isoRequestOptions);
    }

    /**
     * this method is called by event 'click' on 'GPshowIsochronPicto' picto
     * (cf. this._createShowIsoPictoElement),
     * and clear inputs and previous isocurve drawings
     *
     * @private
     */
  }, {
    key: "onShowIsoPanelClick",
    value: function onShowIsoPanelClick() {
      var map = this.getMap();
      // on supprime toutes les interactions
      _Utils_Interactions__WEBPACK_IMPORTED_MODULE_12__["default"].unset(map);
      var opened = this._pictoIsoButton.ariaPressed;
      this.collapsed = !(opened === "true");
      // on génère nous même l'evenement OpenLayers de changement de propriété
      // (utiliser ol.control.Isocurve.on("change:collapsed", function ) pour s'abonner à cet évènement)
      this.dispatchEvent("change:collapsed");
    }

    /**
     * this method is called by event 'change' on 'GPisochronChoiceAltDist' or 'GPisochronChoiceAltChron'
     * input (cf. this._createIsoPanelFormTypeChoiceElement),
     * and updates current computation mode
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "onIsoTypeChoiceChange",
    value: function onIsoTypeChoiceChange(e) {
      var value = e.target.value;
      if (!value) {
        return;
      }
      if (value === "isodistance") {
        this._currentComputation = "distance";
      }
      if (value === "isochron") {
        this._currentComputation = "time";
      }
    }

    /**
     * this method is called by event 'click' on 'GPisochronTransportPedestrian' or 'GPisochronTransportCar'
     * input (cf. this._createIsoPanelFormModeChoiceTransportElement),
     * and updates current transport mode
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "onIsoModeTransportChange",
    value: function onIsoModeTransportChange(e) {
      var value = e.target.value;
      if (!value) {
        return;
      }
      this._currentTransport = value;
    }

    /**
     * this method is called by event 'change' on 'GPisochronDirectionSelect' select
     * (cf. this._createIsoPanelFormModeChoiceDirectionElement),
     * and updates current direction mode
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "onIsoModeDirectionChange",
    value: function onIsoModeDirectionChange(e) {
      var value = e.target.value;
      if (!value) {
        return;
      }
      if (value.toLowerCase() === "arrival") {
        this._originPoint._buttonLabel.innerHTML = "Arrivée";
      } else {
        this._originPoint._buttonLabel.innerHTML = "Départ";
      }
      this._currentDirection = value;
    }

    /**
     * this method is called by event 'change' on 'GPIsoExclusionsToll'
     * or 'GPIsoeExclusionsTunnel' or 'GPIsoExclusionsBridge' tag input
     * (cf. this._createIsoPanelFormExclusionOptionsElement).
     * this value is saved as a parameter for the service isocurve.
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "onIsoExclusionsChange",
    value: function onIsoExclusionsChange(e) {
      var value = e.target.value;
      var checked = e.target.checked;
      if (!value) {
        return;
      }
      var bFound = false;
      var iFound = null;
      for (var i = 0; i < this._currentExclusions.length; i++) {
        if (deepEqual(this._currentExclusions[i], value.toLowerCase())) {
          iFound = i;
          bFound = true;
        }
      }
      // on l'ajoute si la valeur n'existe pas et est selectionnée
      if (!bFound && !checked) {
        this._currentExclusions.push(value.toLowerCase());
      }
      // on la retire si la valeur existe et est deselectionnée
      if (bFound && checked) {
        this._currentExclusions[iFound] = null;
      }
    }

    /**
     * this method is called by event 'click' on 'GPisoReset'
     * tag label (cf. this._createIsoFormResetElement),
     * and it cleans all isochron input options and results.
     *
     * @private
     */
  }, {
    key: "onIsoResetClick",
    value: function onIsoResetClick() {
      // clear
      this._clear();
    }

    /**
     * ...
     * @private
     */
  }, {
    key: "onShowIsoSettingsClick",
    value: function onShowIsoSettingsClick() {}

    // ################################################################### //
    // ######################## isocurve calculation ##################### //
    // ################################################################### //

    /**
     * this method is called by this.onIsoComputationSubmit
     * and executes a request to the service.
     *
     * @param {Object} options - isocurve service request options
     * @private
     */
  }, {
    key: "_requestIsoCurve",
    value: function _requestIsoCurve(options) {
      // on ne fait pas de requête si on n'a pas renseigné de parametres !
      if (!options || _typeof(options) === "object" && Object.keys(options).length === 0) {
        return;
      }
      // on ne fait pas de requête si on n'a pas de point d'origine
      if (!options.position) {
        return;
      }

      // si l'utilisateur a spécifié le paramètre ssl au niveau du control, on s'en sert
      // true par défaut (https)
      if (typeof options.ssl !== "boolean") {
        if (typeof this.options.ssl === "boolean") {
          options.ssl = this.options.ssl;
        } else {
          options.ssl = true;
        }
      }
      logger.log(options);

      // on efface une éventuelle précédente couche
      this._clearGeojsonLayer();

      // mise en place de la patience
      this._displayWaitingContainer();

      // appel du service de calcul d'isochrones
      geoportal_access_lib__WEBPACK_IMPORTED_MODULE_6__["default"].Services.isoCurve(options);
    }

    /**
     * this method is called by this.onIsoComputationSubmit (in case of success)
     * and draw isocurve results geometry on map
     *
     * @param {Object} results - isocurve response results
     * @private
     */
  }, {
    key: "_drawIsoResults",
    value: function _drawIsoResults(results) {
      var _this3 = this;
      // sauvegarde de l'etat des resultats
      this._currentIsoResults = results;
      // cache la patience
      this._hideWaitingContainer();
      if (!results.geometry) {
        return;
      }
      var map = this.getMap();

      // 1. création de l'objet geoJSON
      this._geojsonObject = {
        type: "FeatureCollection",
        crs: {
          type: "name",
          properties: {
            name: "EPSG:4326"
          }
        },
        features: [{
          type: "Feature",
          crs: {
            type: "name",
            properties: {
              name: "EPSG:4326"
            }
          },
          geometry: results.geometry
        }]
      };
      this._geojsonObject.features.push({
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: this._originPoint.getCoordinate()
        },
        properties: {
          description: "Point d'origine",
          "marker-symbol": this.options.markerOpts.url
        }
      });
      var geojsonformat = new _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_16__["default"]({
        defaultDataProjection: "EPSG:4326",
        defaultStyle: this._defaultFeatureStyle
      });
      var mapProj = map.getView().getProjection().getCode();
      var features = geojsonformat.readFeatures(this._geojsonObject, {
        dataProjection: "EPSG:4326",
        featureProjection: mapProj
      });

      // 2. ajout de la géométrie comme nouvelle couche vecteur à la carte
      this._geojsonLayer = new (ol_layer_Vector__WEBPACK_IMPORTED_MODULE_3___default())({
        source: new (ol_source_Vector__WEBPACK_IMPORTED_MODULE_4___default())({
          features: features
        }),
        style: this._defaultFeatureStyle,
        opacity: 0.9
      });
      // ajout d'un identifiant à la couche
      var graph;
      if (this._currentTransport === "Pieton") {
        graph = "piéton";
        this._geojsonLayer.gpResultLayerId = "Pieton$GEOPORTAIL:GPP:Isocurve";
      } else {
        graph = "voiture";
        this._geojsonLayer.gpResultLayerId = "Voiture$GEOPORTAIL:GPP:Isocurve";
      }
      // ajout à la carte
      map.addLayer(this._geojsonLayer);

      /**
       * event triggered when the compute is finished
       *
       * @event isocurve:compute
       * @typedef {Object}
       * @property {Object} type - event
       * @property {Object} target - instance Isocurve
       * @example
       * Isocurve.on("isocurve:compute", function (e) {
       *   console.log(e.target.getData());
       * })
       */
      this.dispatchEvent({
        type: "isocurve:compute"
      });

      // 3. Zoom sur l'emprise de la geometry
      if (features[0] && features[0].getGeometry() && features[0].getGeometry().getExtent()) {
        var extent = features[0].getGeometry().getExtent();
        map.getView().fit(extent, map.getSize());
      }

      // 5. Si un layer switcher est présent dans la carte, on lui affecte des informations pour cette couche
      var method = this._currentComputation === "time" ? "Isochrone" : "Isodistance";
      map.getControls().forEach(function (control) {
        if (control instanceof _LayerSwitcher_LayerSwitcher__WEBPACK_IMPORTED_MODULE_13__["default"]) {
          // un layer switcher est présent dans la carte
          var layerId = _this3._geojsonLayer.gpLayerId;
          // on n'ajoute des informations que s'il n'y en a pas déjà (si le titre est le numéro par défaut)
          if (control._layers[layerId].title === layerId) {
            control.addLayer(_this3._geojsonLayer, {
              title: _this3.options.layerDescription.title + " (" + method + "/" + graph + ")",
              description: _this3.options.layerDescription.description
            });
          }
        }
      });
    }

    // ################################################################### //
    // ############################# Clean ############################### //
    // ################################################################### //

    /**
     * this method is called by this.onShowIsoPanelClick()
     * and it clears all elements (reinit).
     *
     * @private
     */
  }, {
    key: "_clear",
    value: function _clear() {
      // clear inputs
      this._clearIsoInputs();

      // clear origin point (and marker)
      this._originPoint.clear();

      // remove geometry layer
      this._clearGeojsonLayer();

      // clear results
      this._currentIsoResults = null;
    }

    /**
     * this method is called by this._clear()
     * and it clears all input elements (dist and time)
     *
     * @private
     */
  }, {
    key: "_clearIsoInputs",
    value: function _clearIsoInputs() {
      // 1. clear inputs
      // clear time inputs (if exists) :
      // hours
      var timeHourInput = document.getElementById("GPisochronValueChronInput1-" + this._uid);
      if (timeHourInput) {
        timeHourInput.value = "0";
      }
      // minutes
      var timeMinutesInput = document.getElementById("GPisochronValueChronInput2-" + this._uid);
      if (timeMinutesInput) {
        timeMinutesInput.value = "0";
      }
      // clear distance input (if exists)
      var distInput = document.getElementById("GPisochronValueDistInput-" + this._uid);
      if (distInput) {
        distInput.value = "0";
      }

      // 2. reinit options to default
      this._initTransport();
      this._initComputation();
      this._initDirection();
      this._initExclusions();

      // 3. set transport mode to default
      var transportdiv;
      if (this._currentTransport === "Pieton") {
        transportdiv = document.getElementById("GPisochronTransportPedestrian-" + this._uid);
        if (transportdiv) {
          transportdiv.checked = "true";
        }
      } else {
        transportdiv = document.getElementById("GPisochronTransportCar-" + this._uid);
        if (transportdiv) {
          transportdiv.checked = "true";
        }
      }

      // 4. set computation mode to default (distance or time)
      var computationdiv;
      if (this._currentComputation.toLowerCase() === "distance") {
        computationdiv = document.getElementById("GPisochronChoiceAltDist-" + this._uid);
        if (computationdiv) {
          computationdiv.checked = "true";
        }
        if (document.getElementById("GPisochronValueDist-" + this._uid)) {
          document.getElementById("GPisochronValueDist-" + this._uid).className = "GPflexInput gpf-flex";
        }
        if (document.getElementById("GPisochronValueChron-" + this._uid)) {
          document.getElementById("GPisochronValueChron-" + this._uid).className = "GPelementHidden gpf-hidden";
        }
      } else {
        computationdiv = document.getElementById("GPisochronChoiceAltChron-" + this._uid);
        if (computationdiv) {
          computationdiv.checked = "true";
        }
        if (document.getElementById("GPisochronValueChron-" + this._uid)) {
          document.getElementById("GPisochronValueChron-" + this._uid).className = "GPflexInput gpf-flex";
        }
        if (document.getElementById("GPisochronValueDist-" + this._uid)) {
          document.getElementById("GPisochronValueDist-" + this._uid).className = "GPelementHidden gpf-hidden";
        }
      }

      // 5. set direction mode to default (arrival or departure)
      var directionSelect = document.getElementById("GPisochronDirectionSelect-" + this._uid);
      if (directionSelect) {
        directionSelect.value = this._currentDirection;
      }
      if (this._currentDirection === "arrival") {
        this._originPoint._buttonLabel.innerHTML = "Arrivée";
      } else {
        this._originPoint._buttonLabel.innerHTML = "Départ";
      }

      // 6. set exclusions to default
      var tollInput = document.getElementById("GPisoExclusionsToll-" + this._uid);
      if (tollInput) {
        if (this._currentExclusions.indexOf("toll") !== -1) {
          tollInput.checked = false;
        } else {
          tollInput.checked = true;
        }
      }
      var tunnelInput = document.getElementById("GPisoExclusionsTunnel-" + this._uid);
      if (tunnelInput) {
        if (this._currentExclusions.indexOf("tunnel") !== -1) {
          tunnelInput.checked = false;
        } else {
          tunnelInput.checked = true;
        }
      }
      var bridgeInput = document.getElementById("GPisoExclusionsBridge-" + this._uid);
      if (bridgeInput) {
        if (this._currentExclusions.indexOf("bridge") !== -1) {
          bridgeInput.checked = false;
        } else {
          bridgeInput.checked = true;
        }
      }
    }

    /**
     * this method is called by this.onIsoComputationSubmit (in case of failure)
     * and it clears all geometries
     *
     * @private
     */
  }, {
    key: "_clearGeojsonLayer",
    value: function _clearGeojsonLayer() {
      var map = this.getMap();
      // remove layer
      if (this._geojsonLayer) {
        map.removeLayer(this._geojsonLayer);
        this._geojsonLayer = null;
      }
      // remove geojson object
      this._geojsonObject = null;
    }

    /**
     * this method is called by event 'click' on control main container
     * and hide suggested Locations (unless target is an autocomplete input)
     *
     * @param {Object} e - event
     *
     * @private
     */
  }, {
    key: "_hideIsoSuggestedLocations",
    value: function _hideIsoSuggestedLocations(e) {
      // si on clique sur l'input de saisie du point d'origine
      if (e.target && e.target.id && e.target.id.indexOf("GPlocationOrigin_") !== -1) {} else {
        // si on clique ailleurs dans le DOM du control, on cache tous les résultats d'autocomplétion
        this._originPoint._hideSuggestedLocation();
      }
    }

    /**
     * this method displays waiting container and sets a timeout
     *
     * @private
     */
  }, {
    key: "_displayWaitingContainer",
    value: function _displayWaitingContainer() {
      this._waitingContainer.className = "GPwaitingContainer GPwaitingContainerVisible gpf-waiting gpf-waiting--visible";
      this._waiting = true;

      // mise en place d'un timeout pour réinitialiser le panel (cacher la patience)
      // si on est toujours en attente (si la requête est bloquée par exemple)
      var opts = this.options.isocurveOptions;
      if (opts && opts.timeOut) {
        if (this._timer) {
          clearTimeout(this._timer);
          this._timer = null;
        }
        var context = this;
        this._timer = setTimeout(function () {
          if (context._waiting === true) {
            context._hideWaitingContainer();
          } else {
            if (context._timer) {
              clearTimeout(context._timer);
            }
          }
        }, 16000);
      }
    }

    /**
     * this method hides waiting container and clears timeout
     *
     * @private
     */
  }, {
    key: "_hideWaitingContainer",
    value: function _hideWaitingContainer() {
      if (this._waiting) {
        this._waitingContainer.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
        this._waiting = false;
        var opts = this.options.isocurveOptions;
        if (opts && opts.timeOut) {
          clearTimeout(this._timer);
          this._timer = null;
        }
      }
    }
  }]);
}(_Control__WEBPACK_IMPORTED_MODULE_1__["default"]);

// on récupère les méthodes de la classe commune MousePosition
Object.assign(Isocurve.prototype, _IsocurveDOM__WEBPACK_IMPORTED_MODULE_17__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Isocurve);

// Expose Isocurve as ol.control.Isocurve (for a build bundle)
if (window.ol && window.ol.control) {
  window.ol.control.Isocurve = Isocurve;
}
var deepEqual = function deepEqual(x, y) {
  if (x === y) {
    return true;
  } else if (_typeof(x) === "object" && x != null && _typeof(y) === "object" && y != null) {
    if (Object.keys(x).length !== Object.keys(y).length) {
      return false;
    }
    for (var prop in x) {
      if (y.hasOwnProperty(prop)) {
        if (!deepEqual(x[prop], y[prop])) {
          return false;
        }
      } else {
        return false;
      }
    }
    return true;
  } else {
    return false;
  }
};

/***/ }),

/***/ "./src/packages/Controls/Isocurve/IsocurveDOM.js":
/*!*******************************************************!*\
  !*** ./src/packages/Controls/Isocurve/IsocurveDOM.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var IsoDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   *
   * @returns {DOMElement} DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GPisochron");
    container.className = "GPwidget gpf-widget gpf-widget-button";
    return container;
  },
  // ################################################################### //
  // ################# Methods to display Main Panel ################### //
  // ################################################################### //

  /**
   * Show iso control
   * see event !
   *
   * @returns {DOMElement} DOM element
   */
  _createShowIsoPictoElement: function _createShowIsoPictoElement() {
    // contexte d'execution
    var context = this;
    var button = document.createElement("button");
    button.id = this._addUID("GPshowIsochronPicto");
    button.className = "GPshowOpen GPshowAdvancedToolPicto GPshowIsochronPicto gpf-btn gpf-btn-icon gpf-btn-icon-isocurve fr-btn";
    button.title = "Calculer une isochrone";
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);

    // gestionnaire d'evenement :
    // on ouvre le menu de saisie du calcul d'isochrone
    // L'ouverture/Fermeture permet de faire le menage
    // (reinitialisation)
    if (button.addEventListener) {
      button.addEventListener("click", function (e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowIsoPanelClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function (e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowIsoPanelClick(e);
      });
    }
    return button;
  },
  // ################################################################### //
  // ################## Methods to display Inputs Panel ################ //
  // ################################################################### //

  /**
   * Create Container Panel
   *
   * FIXME
   * don't call this._createIsoPanelHeaderElement
   * don't call this._createIsoPanelFormElement
   *
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelElement: function _createIsoPanelElement() {
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GPisochronPanel");
    dialog.className = "GPpanel gpf-panel fr-modal";

    // dialog.appendChild(this._createIsoPanelHeaderElement());
    // dialog.appendChild(this._createIsoPanelFormElement());

    return dialog;
  },
  _createIsoPanelDivElement: function _createIsoPanelDivElement() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    return div;
  },
  /**
   * Create Header Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelHeaderElement: function _createIsoPanelHeaderElement() {
    var self = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header fr-modal__header";
    var div = document.createElement("div");
    div.className = "GPpanelTitle gpf-panel__title fr-modal__title fr-m-1w";
    div.innerHTML = "Calcul d'isochrone";
    container.appendChild(div);

    // on desactive l'impl. reduction de la fenetre
    // var divReduce  = document.createElement("div");
    // divReduce.id = this._addUID("GPisochronPanelReduce");
    // divReduce.className = "GPpanelReduce";
    // divReduce.title = "Masquer le panneau";
    //
    // if (divReduce.addEventListener) {
    //     divReduce.addEventListener("click", function () {
    //         if ( typeof self.onReduceIsoPanelClick === "function") {
    //             document.getElementById(self._addUID("GPshowIsochron")).checked = false;
    //             self.onReduceIsoPanelClick();
    //         }
    //     }, false);
    // } else if (divReduce.attachEvent) {
    //     divReduce.attachEvent("onclick", function () {
    //         if ( typeof self.onReduceIsoPanelClick === "function") {
    //             document.getElementById(self._addUID("GPshowIsochron")).checked = false;
    //             self.onReduceIsoPanelClick();
    //         }
    //     });
    // }
    // container.appendChild(divReduce);

    var divClose = document.createElement("button");
    divClose.id = this._addUID("GPisochronPanelClose");
    divClose.className = "GPpanelClose GPisochronPanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--secondary fr-m-1w";
    divClose.title = "Fermer le panneau";

    // Link panel close / visibility checkbox
    if (divClose.addEventListener) {
      divClose.addEventListener("click", function () {
        document.getElementById(self._addUID("GPshowIsochronPicto")).click();
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function () {
        document.getElementById(self._addUID("GPshowIsochronPicto")).click();
      });
    }
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible"; // afficher en dsfr
    span.innerText = "Fermer";
    divClose.appendChild(span);
    container.appendChild(divClose);
    return container;
  },
  /**
   * Create Form
   * see evenement !
   *
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormElement: function _createIsoPanelFormElement() {
    // contexte d'execution
    var self = this;
    var form = document.createElement("form");
    form.id = this._addUID("GPisochronForm");
    form.className = "GPform gpf-panel__content fr-modal__content";
    form.addEventListener("submit", function (e) {
      e.preventDefault();
      self.onIsoComputationSubmit(e);
      return false;
    });
    return form;
  },
  /**
   * Create Waiting Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createIsoWaitingElement: function _createIsoWaitingElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPisochronCalcWaitingContainer");
    div.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
    var p = document.createElement("p");
    p.className = "GPwaitingContainerInfo gpf-waiting_info";
    p.innerHTML = "Recherche en cours...";
    div.appendChild(p);
    return div;
  },
  /**
   * Create Footer Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFooterElement: function _createIsoPanelFooterElement() {
    var container = document.createElement("div");
    container.className = "GPpanelFooter gpf-panel__footer fr-modal__footer";
    return container;
  },
  // ################################################################### //
  // ############# Methods to the type choice into form ################ //
  // ################################################################### //

  /**
   * Create Container to type choice
   *
   * FIXME
   * don't call this._createIsoPanelFormTypeChoiceChronElement
   * don't call this._createIsoPanelFormTypeChoiceDistElement
   *
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormTypeChoiceElement: function _createIsoPanelFormTypeChoiceElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPisochronChoice");
    div.className = "fr-mt-4w";

    // div.appendChild(this._createIsoPanelFormTypeChoiceChronElement());
    // div.appendChild(this._createIsoPanelFormTypeChoiceDistElement());

    return div;
  },
  /**
   * Create Type choice Chron
   * see event !
   * FIXME event not useful
   * @param {Boolean} checked - checked
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormTypeChoiceChronElement: function _createIsoPanelFormTypeChoiceChronElement(checked) {
    var self = this;
    var div = document.createElement("div");
    div.className = "GPisochronChoiceAlt gpf-flex gpf-flex-isocurve gpf-radio-group fr-radio-group";
    var input = document.createElement("input");
    input.id = this._addUID("GPisochronChoiceAltChron");
    input.name = "GPisochronChoiceMode";
    input.type = "radio";
    input.checked = !!checked;
    if (input.addEventListener) {
      input.addEventListener("change", function (e) {
        document.getElementById(self._addUID("GPisochronValueChron")).className = "GPflexInput gpf-flex fr-mt-1w";
        document.getElementById(self._addUID("GPisochronValueDist")).className = "GPelementHidden gpf-hidden";
        self.onIsoTypeChoiceChange(e);
      }, false);
    } else if (input.attachEvent) {
      input.attachEvent("onchange", function () {
        document.getElementById(self._addUID("GPisochronValueChron")).className = "GPflexInput gpf-flex fr-mt-1w";
        document.getElementById(self._addUID("GPisochronValueDist")).className = "GPelementHidden gpf-hidden";
        self.onIsoTypeChoiceChange();
      });
    }
    // info: Internet explorer support
    input.value = "isochron";
    div.appendChild(input);
    var label = document.createElement("label");
    label.className = "GPisochronChoiceAltImg gpf-label fr-label";
    label.htmlFor = this._addUID("GPisochronChoiceAltChron");
    label.innerHTML = "isochrone";
    label.title = "isochrone";
    div.appendChild(label);
    var span = document.createElement("span");
    span.id = this._addUID("GPisochronChoiceAltChronTxt");
    span.className = "gpf-hidden";
    span.innerHTML = "isochrone";
    if (span.addEventListener) {
      span.addEventListener("click", function () {
        document.getElementById(self._addUID("GPisochronChoiceAltChron")).click();
      }, false);
    } else if (span.attachEvent) {
      span.attachEvent("onclick", function () {
        document.getElementById(self._addUID("GPisochronChoiceAltChron")).click();
      });
    }
    div.appendChild(span);
    return div;
  },
  /**
   * Create Type choice Dist
   * see event !
   * FIXME event not useful
   * @param {Boolean} checked - checked
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormTypeChoiceDistElement: function _createIsoPanelFormTypeChoiceDistElement(checked) {
    var self = this;
    var div = document.createElement("div");
    div.className = "GPisochronChoiceAlt gpf-flex gpf-flex-isocurve gpf-radio-group fr-radio-group";
    var input = document.createElement("input");
    input.id = this._addUID("GPisochronChoiceAltDist");
    input.name = "GPisochronChoiceMode";
    input.type = "radio";
    input.checked = !!checked;
    if (input.addEventListener) {
      input.addEventListener("change", function (e) {
        document.getElementById(self._addUID("GPisochronValueDist")).className = "GPflexInput gpf-flex fr-mt-1w";
        document.getElementById(self._addUID("GPisochronValueChron")).className = "GPelementHidden gpf-hidden";
        self.onIsoTypeChoiceChange(e);
      }, false);
    } else if (input.attachEvent) {
      input.attachEvent("onchange", function () {
        document.getElementById(self._addUID("GPisochronValueDist")).className = "GPflexInput gpf-flex fr-mt-1w";
        document.getElementById(self._addUID("GPisochronValueChron")).className = "GPelementHidden gpf-hidden";
        self.onIsoTypeChoiceChange();
      });
    }
    // info: Internet explorer support
    input.value = "isodistance";
    div.appendChild(input);
    var label = document.createElement("label");
    label.className = "GPisochronChoiceAltImg gpf-label fr-label";
    label.htmlFor = this._addUID("GPisochronChoiceAltDist");
    label.innerHTML = "isodistance";
    label.title = "isodistance";
    div.appendChild(label);
    var span = document.createElement("span");
    span.id = this._addUID("GPisochronChoiceAltDistTxt");
    span.className = "gpf-hidden";
    span.innerHTML = "isodistance";
    if (span.addEventListener) {
      span.addEventListener("click", function () {
        document.getElementById(self._addUID("GPisochronChoiceAltDist")).click();
      }, false);
    } else if (span.attachEvent) {
      span.attachEvent("onclick", function () {
        document.getElementById(self._addUID("GPisochronChoiceAltDist")).click();
      });
    }
    div.appendChild(span);
    return div;
  },
  // ################################################################### //
  // ############### Methods to the value iso into form ################ //
  // ################################################################### //

  /**
   * Create isochron inputs values
   * see event !
   * @param {Boolean} checked - checked
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormValueIsochronElement: function _createIsoPanelFormValueIsochronElement(checked) {
    // contexte
    var context = this;
    var div = document.createElement("div");
    div.id = this._addUID("GPisochronValueChron");
    div.className = checked ? "GPflexInput gpf-flex fr-mt-1w" : "GPelementHidden gpf-hidden";
    var label = document.createElement("label");
    label.id = this._addUID("GPisochronValueChronLabel");
    label.className = "gpf-label fr-label";
    label.htmlFor = this._addUID("GPisochronValueChronInput");
    label.innerHTML = "Temps";
    div.appendChild(label);
    var input1 = document.createElement("input");
    input1.id = this._addUID("GPisochronValueChronInput1");
    input1.className = "gpf-input fr-input";
    input1.min = "0";
    input1.step = "1";
    input1.value = "0";
    input1.type = "number";
    if (input1.addEventListener) {
      input1.addEventListener("change", function (e) {
        if (typeof context.onIsoValueChronTimeMinuteChange === "function") {
          context.onIsoValueChronTimeHourChange(e);
        }
      });
    } else if (input1.attachEvent) {
      input1.attachEvent("onchange", function (e) {
        if (typeof context.onIsoValueChronTimeMinuteChange === "function") {
          context.onIsoValueChronTimeHourChange(e);
        }
      });
    }
    div.appendChild(input1);
    var label1 = document.createElement("label");
    label1.innerHTML = "h";
    label1.className = "gpf-label fr-label";
    div.appendChild(label1);
    var input2 = document.createElement("input");
    input2.id = this._addUID("GPisochronValueChronInput2");
    input2.className = "gpf-input fr-input";
    input2.min = "0";
    input2.max = "59";
    input2.step = "1";
    input2.value = "0";
    input2.type = "number";
    if (input2.addEventListener) {
      input2.addEventListener("change", function (e) {
        if (typeof context.onIsoValueChronTimeMinuteChange === "function") {
          context.onIsoValueChronTimeMinuteChange(e);
        }
      });
    } else if (input2.attachEvent) {
      input2.attachEvent("onchange", function (e) {
        if (typeof context.onIsoValueChronTimeMinuteChange === "function") {
          context.onIsoValueChronTimeMinuteChange(e);
        }
      });
    }
    div.appendChild(input2);
    var label2 = document.createElement("label");
    label2.innerHTML = "min";
    label2.className = "gpf-label fr-label";
    div.appendChild(label2);
    return div;
  },
  /**
   * Create isodistance inputs values
   * see event !
   * @param {Boolean} checked - checked
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormValueIsodistanceElement: function _createIsoPanelFormValueIsodistanceElement(checked) {
    // contexte
    var context = this;
    var div = document.createElement("div");
    div.id = this._addUID("GPisochronValueDist");
    div.className = checked ? "GPflexInput gpf-flex fr-mt-1w" : "GPelementHidden gpf-hidden";
    var label = document.createElement("label");
    label.id = this._addUID("GPisochronValueDistLabel");
    label.className = "gpf-label fr-label fr-mr-1w";
    label.htmlFor = this._addUID("GPisochronValueDistInput");
    label.innerHTML = "Distance";
    div.appendChild(label);
    var input1 = document.createElement("input");
    input1.id = this._addUID("GPisochronValueDistInput");
    input1.className = "gpf-input fr-input fr-ml-1w";
    input1.min = "0";
    input1.step = "any";
    input1.value = "0";
    input1.type = "number";
    if (input1.addEventListener) {
      input1.addEventListener("change", function (e) {
        if (typeof context.onIsoValueDistChange === "function") {
          context.onIsoValueDistChange(e);
        }
      });
    } else if (input1.attachEvent) {
      input1.attachEvent("onchange", function (e) {
        if (typeof context.onIsoValueDistChange === "function") {
          context.onIsoValueDistChange(e);
        }
      });
    }
    div.appendChild(input1);
    var label1 = document.createElement("label");
    label1.innerHTML = "km";
    label.className = "gpf-label fr-label";
    div.appendChild(label1);
    return div;
  },
  // ################################################################### //
  // ############ Methods to the mode choice into form ################# //
  // ################################################################### //

  /**
   * Create Container to Mode choice
   *
   * FIXME
   * don't call this._createIsoPanelFormModeChoiceTransportElement
   * don't call this._createIsoPanelFormModeChoiceDirectionElement
   *
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormModeChoiceElement: function _createIsoPanelFormModeChoiceElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPisochronModeChoice");
    div.className = "fr-my-4w";

    // div.appendChild(this._createIsoPanelFormModeChoiceTransportElement());
    // div.appendChild(this._createIsoPanelFormModeChoiceDirectionElement());

    return div;
  },
  /**
   * Create Mode choice transport
   * see event !
   * FIXME event not useful
   * @param {Array} transports - transports in a list
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormModeChoiceTransportElement: function _createIsoPanelFormModeChoiceTransportElement(transports) {
    // contexte d'execution
    var context = this;
    var divContainer = document.createElement("div");
    divContainer.id = this._addUID("GPisochronTransportChoice");
    var label = document.createElement("label");
    label.className = "GPisochronModeLabel gpf-label fr-label";
    label.innerHTML = "Mode de transport";
    divContainer.appendChild(label);

    /* jshint -W083 */
    for (var i = 0; i < transports.length; i++) {
      var transport = transports[i];
      var div = document.createElement("div");
      div.className = "GPisochronTransportChoice gpf-flex gpf-radio-group fr-radio-group fr-m-1w";
      if (transport === "Voiture") {
        var inputCar = document.createElement("input");
        inputCar.id = this._addUID("GPisochronTransportCar");
        inputCar.type = "radio";
        inputCar.name = "GPisochronTransport";
        if (i === 0) {
          inputCar.checked = true;
        }
        // gestionnaire d'evenement :
        // on stocke le mode de transport,
        // utilisation pour la requête sur le service de calcul d'itiniraire
        if (inputCar.addEventListener) {
          inputCar.addEventListener("change", function (e) {
            context.onIsoModeTransportChange(e);
          });
        } else if (inputCar.attachEvent) {
          inputCar.attachEvent("onchange", function (e) {
            context.onIsoModeTransportChange(e);
          });
        }
        // info : internet explorer support
        inputCar.value = "Voiture";
        div.appendChild(inputCar);
        var labelCar = document.createElement("label");
        labelCar.className = "GPisochronTransportImg gpf-label fr-label";
        labelCar.htmlFor = this._addUID("GPisochronTransportCar");
        labelCar.title = "Voiture";
        labelCar.innerHTML = "Voiture";
        div.appendChild(labelCar);
      }
      if (transport === "Pieton") {
        var inputPedestrian = document.createElement("input");
        inputPedestrian.id = this._addUID("GPisochronTransportPedestrian");
        inputPedestrian.type = "radio";
        inputPedestrian.name = "GPisochronTransport";
        if (i === 0) {
          inputPedestrian.checked = true;
        }
        // gestionnaire d'evenement :
        // on stocke le mode de transport,
        // utilisation pour la requête sur le service de calcul d'itiniraire
        if (inputPedestrian.addEventListener) {
          inputPedestrian.addEventListener("change", function (e) {
            context.onIsoModeTransportChange(e);
          });
        } else if (inputPedestrian.attachEvent) {
          inputPedestrian.attachEvent("onchange", function (e) {
            context.onIsoModeTransportChange(e);
          });
        }
        // info : internet explorer support
        inputPedestrian.value = "Pieton";
        div.appendChild(inputPedestrian);
        var labelPedestrian = document.createElement("label");
        labelPedestrian.className = "GPisochronTransportImg gpf-label fr-label";
        labelPedestrian.htmlFor = this._addUID("GPisochronTransportPedestrian");
        labelPedestrian.title = "Piéton";
        labelPedestrian.innerHTML = "Piéton";
        div.appendChild(labelPedestrian);
      }
      divContainer.appendChild(div);
    }
    return divContainer;
  },
  /**
   * Create Mode choice direction
   * see event!
   *
   * @param {Array} directions - directions to display in list ("Departure", "Arrival"). First element will be selected by default
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormModeChoiceDirectionElement: function _createIsoPanelFormModeChoiceDirectionElement(directions) {
    // contexte d'execution
    var self = this;
    var div = document.createElement("div");
    div.id = this._addUID("GPisochronDirectionChoice");
    var label = document.createElement("label");
    label.className = "GPisochronModeLabel gpf-label fr-label";
    label.innerHTML = "Sens de parcours";
    div.appendChild(label);
    var select = document.createElement("select");
    select.id = this._addUID("GPisochronDirectionSelect");
    select.className = "GPselect gpf-select fr-select";
    // gestionnaire d'evenement :
    // on stocke la valeur du mode de calcul,
    // utilisation pour la requête sur le service de calcul d'iso
    select.addEventListener("change", function (e) {
      self.onIsoModeDirectionChange(e);
    });
    for (var i = 0; i < directions.length; i++) {
      var direction = directions[i];
      if (direction.toLowerCase() === "departure") {
        var departureOption = document.createElement("option");
        if (i === 0) {
          departureOption.selected = "selected";
        }
        departureOption.value = "departure";
        departureOption.text = "Départ";
        select.appendChild(departureOption);
      }
      if (direction.toLowerCase() === "arrival") {
        var arrivalOption = document.createElement("option");
        if (i === 0) {
          arrivalOption.selected = "selected";
        }
        arrivalOption.value = "arrival";
        arrivalOption.text = "Arrivée";
        select.appendChild(arrivalOption);
      }
    }
    div.appendChild(select);
    return div;
  },
  // ################################################################### //
  // ################# Methods to the choice exclusions ################ //
  // ################################################################### //

  /**
   * Label to Exclusions Options
   *
   * @returns {DOMElement} DOM element
   */
  _createShowIsoExclusionsPictoElement: function _createShowIsoExclusionsPictoElement() {
    var self = this;
    var button = document.createElement("button");
    button.id = this._addUID("GPshowIsoExclusionsPicto");
    button.className = "GPelementHidden GPshowAdvancedToolPicto GPshowMoreOptionsImage GPshowMoreOptions GPshowIsoExclusionsPicto gpf-hidden gpf-btn fr-btn--sm fr-btn--secondary fr-icon-arrow-down-fill";
    button.title = "Exclusions";
    // button.style.top = "240px";
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", true);

    // Close all results and panels when minimizing the widget
    if (button.addEventListener) {
      button.addEventListener("click", function (e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self.onShowIsoSettingsClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function (e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self.onShowIsoSettingsClick(e);
      });
    }
    return button;
  },
  /**
   * Create Container to Exclusions
   *
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormExclusionsElement: function _createIsoPanelFormExclusionsElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPisoExclusions");
    var label = document.createElement("label");
    label.className = "GPisoExclusionsLabel gpf-label fr-label";
    label.innerHTML = "Passages autorisés";
    div.appendChild(label);

    // div.appendChild(this._createIsoPanelFormExclusionOptionsElement());

    return div;
  },
  /**
   * Create Exclusions Options
   * see event !
   * FIXME event not useful
   * @param {Array} exclusions - exclusions to display in list
   * @returns {DOMElement} DOM element
   */
  _createIsoPanelFormExclusionOptionsElement: function _createIsoPanelFormExclusionOptionsElement(exclusions) {
    // contexte d'execution
    var context = this;
    var div = document.createElement("div");
    div.className = "GPisoExclusionsOptions gpf-flex fr-checkbox-group fr-m-1w";

    /* jshint -W083 */
    for (var value in exclusions) {
      if (exclusions.hasOwnProperty(value)) {
        var status = exclusions[value];
        switch (value) {
          case "toll":
            var inputToll = document.createElement("input");
            inputToll.id = this._addUID("GPisoExclusionsToll");
            inputToll.type = "checkbox";
            inputToll.checked = !status;
            // gestionnaire d'evenement :
            // on stocke l'exclusion,
            // utilisation pour la requête sur le service de calcul d'itiniraire
            if (inputToll.addEventListener) {
              inputToll.addEventListener("change", function (e) {
                context.onIsoExclusionsChange(e);
              });
            } else if (inputToll.attachEvent) {
              inputToll.attachEvent("onchange", function (e) {
                context.onIsoExclusionsChange(e);
              });
            }
            // info : internet explorer support
            inputToll.value = "Toll";
            div.appendChild(inputToll);
            var labelToll = document.createElement("label");
            labelToll.className = "GPisoExclusionsOption";
            labelToll.htmlFor = this._addUID("GPisoExclusionsToll");
            labelToll.innerHTML = "Péages";
            div.appendChild(labelToll);
            break;
          case "tunnel":
            var inputTunnel = document.createElement("input");
            inputTunnel.id = this._addUID("GPisoExclusionsTunnel");
            inputTunnel.type = "checkbox";
            inputTunnel.checked = !status;
            // gestionnaire d'evenement :
            // on stocke l'exclusion,
            // utilisation pour la requête sur le service de calcul d'itiniraire
            if (inputTunnel.addEventListener) {
              inputTunnel.addEventListener("change", function (e) {
                context.onIsoExclusionsChange(e);
              });
            } else if (inputTunnel.attachEvent) {
              inputTunnel.attachEvent("onchange", function (e) {
                context.onIsoExclusionsChange(e);
              });
            }
            // info : internet explorer support
            inputTunnel.value = "Tunnel";
            div.appendChild(inputTunnel);
            var labelTunnel = document.createElement("label");
            labelTunnel.className = "GPisoExclusionsOption";
            labelTunnel.htmlFor = this._addUID("GPisoExclusionsTunnel");
            labelTunnel.innerHTML = "Tunnels";
            div.appendChild(labelTunnel);
            break;
          case "bridge":
            var inputBridge = document.createElement("input");
            inputBridge.id = this._addUID("GPisoExclusionsBridge");
            inputBridge.type = "checkbox";
            inputBridge.checked = !status;
            // gestionnaire d'evenement :
            // on stocke l'exclusion,
            // utilisation pour la requête sur le service de calcul d'itiniraire
            if (inputBridge.addEventListener) {
              inputBridge.addEventListener("change", function (e) {
                context.onIsoExclusionsChange(e);
              });
            } else if (inputBridge.attachEvent) {
              inputBridge.attachEvent("onchange", function (e) {
                context.onIsoExclusionsChange(e);
              });
            }
            // info : internet explorer support
            inputBridge.value = "Bridge";
            div.appendChild(inputBridge);
            var labelBridge = document.createElement("label");
            labelBridge.className = "GPisoExclusionsOption";
            labelBridge.htmlFor = this._addUID("GPisoExclusionsBridge");
            labelBridge.innerHTML = "Ponts";
            div.appendChild(labelBridge);
            break;
        }
      }
    }
    return div;
  },
  // ################################################################### //
  // ############################### Submit Form ####################### //
  // ################################################################### //

  /**
   * Create Submit Form Element
   *
   * @returns {DOMElement} DOM element
   */
  _createIsoSubmitFormElement: function _createIsoSubmitFormElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GPisochronSubmit");
    input.className = "GPsubmit gpf-btn fr-btn fr-btn--secondary";
    input.type = "submit";
    input.value = "Calculer";
    return input;
  },
  // ################################################################### //
  // ############################### Reset picto ####################### //
  // ################################################################### //

  /**
   * Create Reset Picto Element
   *
   * @returns {DOMElement} DOM element
   */
  _createIsoFormResetElement: function _createIsoFormResetElement() {
    var self = this;
    var buttonReset = document.createElement("button");
    buttonReset.id = this._addUID("GPisochronReset");
    buttonReset.className = "GPresetPicto GPisochronReset gpf-btn gpf-btn-icon-reset gpf-btn-icon-isocurve-reset fr-btn fr-btn--secondary";
    buttonReset.title = "Réinitialiser les paramètres";
    buttonReset.setAttribute("tabindex", "0");
    buttonReset.setAttribute("aria-pressed", false);
    buttonReset.addEventListener("click", function (e) {
      var status = e.target.ariaPressed === "true";
      e.target.setAttribute("aria-pressed", !status);
      self.onIsoResetClick(e);
    });
    return buttonReset;
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (IsoDOM);

/***/ }),

/***/ "./src/packages/Controls/LayerImport/LayerImportDOM.js":
/*!*************************************************************!*\
  !*** ./src/packages/Controls/LayerImport/LayerImportDOM.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Utils/SelectorID */ "./src/packages/Utils/SelectorID.js");

var LayerImportDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Map loading
   *
   * @returns {DOMElement} container
   */
  _createLoadingElement: function _createLoadingElement() {
    var div = document.createElement("div");
    div.id = "GPmapLoading";
    div.className = "";
    return div;
  },
  /**
   * Main container (DOM)
   *
   * @returns {DOMElement} DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GPimport");
    container.className = "GPwidget gpf-widget gpf-widget-button";
    return container;
  },
  // ################################################################### //
  // ######################### show widget ############################# //
  // ################################################################### //

  /**
   * Show Import
   *
   * @returns {DOMElement} DOM element
   */
  _createShowImportPictoElement: function _createShowImportPictoElement() {
    // contexte d'execution
    var self = this;
    var button = document.createElement("button");
    button.id = this._addUID("GPshowImportPicto");
    button.className = "GPshowOpen GPshowAdvancedToolPicto GPshowImportPicto gpf-btn gpf-btn-icon gpf-btn-icon-import fr-btn";
    button.title = "Ouvrir l'import de couches";
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);

    // Close all results and panels when minimizing the widget
    if (button.addEventListener) {
      button.addEventListener("click", function (e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self._onShowImportClick();
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function (e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        self._onShowImportClick();
      });
    }
    return button;
  },
  // ################################################################### //
  // ################################ Panel ############################ //
  // ################################################################### //

  /**
   * Create Container Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createImportPanelElement: function _createImportPanelElement() {
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GPimportPanel");
    dialog.className = "GPpanel gpf-panel fr-modal";
    return dialog;
  },
  _createImportPanelDivElement: function _createImportPanelDivElement() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    return div;
  },
  /**
   * Create Header Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createImportPanelHeaderElement: function _createImportPanelHeaderElement() {
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header fr-modal__header";
    return container;
  },
  /**
   * Create Header Title Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createImportPanelTitleElement: function _createImportPanelTitleElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportHeaderTitle");
    div.className = "GPpanelTitle gpf-panel__title fr-modal__title fr-m-1w";
    div.innerHTML = "Import de données";
    return div;
  },
  /**
   * Create Header close div
   *
   * @returns {DOMElement} DOM element
   */
  _createImportPanelCloseElement: function _createImportPanelCloseElement() {
    // contexte
    var self = this;
    var divClose = document.createElement("button");
    divClose.id = this._addUID("GPimportPanelClose");
    divClose.className = "GPpanelClose GPimportPanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--secondary fr-m-1w";
    divClose.title = "Fermer le panneau";

    // Link panel close / visibility checkbox
    if (divClose.addEventListener) {
      divClose.addEventListener("click", function () {
        document.getElementById(self._addUID("GPshowImportPicto")).click();
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function () {
        document.getElementById(self._addUID("GPshowImportPicto")).click();
      });
    }
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible"; // afficher en dsfr
    span.innerText = "Fermer";
    divClose.appendChild(span);
    return divClose;
  },
  // ################################################################### //
  // ########################### Form panel ############################ //
  // ################################################################### //

  /**
   * Create Form
   * see event !
   *
   * @returns {DOMElement} DOM element
   */
  _createImportPanelFormElement: function _createImportPanelFormElement() {
    // contexte d'execution
    var self = this;
    var form = document.createElement("form");
    form.id = this._addUID("GPimportForm");
    form.className = "GPform gpf-panel__content fr-modal__content";

    // TODO ?
    if (form.addEventListener) {
      form.addEventListener("submit", function (e) {
        e.preventDefault();
        self._onImportSubmit();
      });
    } else if (form.attachEvent) {
      form.attachEvent("onsubmit", function (e) {
        e.preventDefault();
        self._onImportSubmit();
      });
    }
    return form;
  },
  /**
   * Create Container for import type choice
   *
   * @param {Array} importTypes - import types to be displayed (and used)
   * @returns {DOMElement} DOM element
   */
  _createImportTypeLineElement: function _createImportTypeLineElement(importTypes) {
    // contexte d'execution
    var context = this;
    var div = document.createElement("div");
    div.id = this._addUID("GPimportTypeLine");
    div.className = "GPimportInputLine";
    var label = document.createElement("label");
    label.id = this._addUID("GPimportTypeLabel");
    label.className = "GPlabel gpf-label fr-label";
    label.innerHTML = "Type de donnée";
    label.title = "Type de donnée";
    div.appendChild(label);
    var select = document.createElement("select");
    select.setAttribute("aria-labelledby", this._addUID("GPimportTypeLabel"));
    select.className = "GPselect gpf-select fr-select";
    // gestionnaire d'evenement : on stocke la valeur du type d'import
    if (select.addEventListener) {
      select.addEventListener("change", function (e) {
        if (this.value === "KML" || this.value === "GPX" || this.value === "GeoJSON" || this.value === "MAPBOX") {
          // static import
          document.getElementById(context._addUID("GPimportStaticParams")).className = "GPelementVisible gpf-visible fr-my-4w";
          document.getElementById(context._addUID("GPimportServiceParams")).className = "GPelementHidden gpf-hidden";
        } else if (this.value === "WMS" || this.value === "WMTS" || this.value === "WFS") {
          // service import
          document.getElementById(context._addUID("GPimportServiceParams")).className = "GPelementVisible gpf-visible fr-my-4w";
          document.getElementById(context._addUID("GPimportStaticParams")).className = "GPelementHidden gpf-hidden";
        }
        context._onImportTypeChange(e);
      });
    } else if (select.attachEvent) {
      select.attachEvent("onchange", function () {
        if (this.value === "KML" || this.value === "GPX" || this.value === "GeoJSON" || this.value === "MAPBOX") {
          // static import
          document.getElementById(context._addUID("GPimportStaticParams")).className = "GPelementVisible gpf-visible fr-my-4w";
          document.getElementById(context._addUID("GPimportServiceParams")).className = "GPelementHidden gpf-hidden";
        } else if (this.value === "WMS" || this.value === "WMTS" || this.value === "WFS") {
          // service import
          document.getElementById(context._addUID("GPimportServiceParams")).className = "GPelementVisible gpf-visible fr-my-4w";
          document.getElementById(context._addUID("GPimportStaticParams")).className = "GPelementHidden gpf-hidden";
        }
        context._onImportTypeChange();
      });
    }
    select.id = this._addUID("GPimportTypeSelect");

    // on prend soit les valeurs passées par l'utilisateur, soit des valeurs par défaut
    if (!importTypes || !Array.isArray(importTypes)) {
      importTypes = ["KML", "GPX", "GeoJSON", "MAPBOX", "WMS", "WMTS", "WFS"];
    }
    var option;
    for (var i = 0; i < importTypes.length; i++) {
      option = document.createElement("option");
      option.value = importTypes[i];
      option.text = importTypes[i] === "MAPBOX" ? "Tuiles vectorielles" : importTypes[i];
      select.appendChild(option);
    }
    div.appendChild(select);
    return div;
  },
  /**
   * Create Waiting Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createImportWaitingElement: function _createImportWaitingElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportWaitingContainer");
    div.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
    var p = document.createElement("p");
    p.className = "GPwaitingContainerInfo gpf-waiting_info";
    p.innerHTML = "Recherche en cours...";
    div.appendChild(p);
    return div;
  },
  // ################################################################### //
  // ##### Params for static import (KML / GPX / GeoJSON) ############## //
  // ################################################################### //

  /**
   * Create container for KML/GPX/GeoJSON parameters
   * @param {String} currentType - GeoJSON, GPX or KML value
   * @returns {DOMElement} DOM element
   */
  _createImportStaticParamsContainer: function _createImportStaticParamsContainer(currentType) {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportStaticParams");
    if (currentType === "KML" || currentType === "GPX" || currentType === "GeoJSON" || currentType === "MAPBOX") {
      div.className = "GPelementVisible gpf-visible fr-my-4w";
    } else {
      div.className = "GPelementHidden gpf-hidden";
    }
    return div;
  },
  /**
   * Create name label for KML/GPX/GeoJSON parameters
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticNameLabel: function _createStaticNameLabel() {
    var div = document.createElement("div");
    div.className = "GPimportInputLine fr-mb-1w";
    var label = document.createElement("label");
    label.className = "GPlabel gpf-label fr-label";
    label.htmlFor = this._addUID("GPimportName");
    label.innerHTML = "Nom";
    label.title = "Nom";
    div.appendChild(label);
    var input = document.createElement("input");
    input.type = "text";
    input.id = this._addUID("GPimportName");
    input.className = "GPinput gpf-input fr-input";
    div.appendChild(input);
    return div;
  },
  /**
   * Create import choice for KML/GPX/GeoJSON parameters (local or url)
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticModeChoiceDiv: function _createStaticModeChoiceDiv() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportChoice");
    div.className = "fr-my-1w";
    return div;
  },
  /**
   * Create local import choice for KML/GPX/GeoJSON parameters
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticLocalChoiceDiv: function _createStaticLocalChoiceDiv() {
    var context = this;
    var div = document.createElement("div");
    div.className = "GPimportChoiceAlt gpf-radio-group fr-radio-group";
    var input = document.createElement("input");
    input.type = "radio";
    if (input.addEventListener) {
      input.addEventListener("change", function (e) {
        document.getElementById(context._addUID("GPimportValueLocal")).className = "GPimportInputLine fr-mb-1w";
        document.getElementById(context._addUID("GPimportValueUrl")).className = "GPelementHidden gpf-hidden";
        context._onStaticImportTypeChange(e);
      });
    } else if (input.appendChild) {
      input.appendChild("onchange", function () {
        document.getElementById(context._addUID("GPimportValueLocal")).className = "GPimportInputLine fr-mb-1w";
        document.getElementById(context._addUID("GPimportValueUrl")).className = "GPelementHidden gpf-hidden";
        context._onStaticImportTypeChange();
      });
    }
    input.name = "GPimportChoiceMode";
    input.value = "local";
    input.checked = true;
    input.id = this._addUID("GPimportChoiceAltLocal");
    div.appendChild(input);
    var label = document.createElement("label");
    label.className = "GPimportChoiceAltTxt gpf-label fr-label";
    label.htmlFor = this._addUID("GPimportChoiceAltLocal");
    label.innerHTML = "par fichier local";
    label.title = "par fichier local";
    div.appendChild(label);
    return div;
  },
  /**
   * Create url import choice for KML/GPX/GeoJSON parameters
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticUrlChoiceDiv: function _createStaticUrlChoiceDiv() {
    var context = this;
    var div = document.createElement("div");
    div.className = "GPimportChoiceAlt gpf-radio-group fr-radio-group";
    var input = document.createElement("input");
    input.type = "radio";
    if (input.addEventListener) {
      input.addEventListener("change", function (e) {
        document.getElementById(context._addUID("GPimportValueUrl")).className = "GPimportInputLine";
        document.getElementById(context._addUID("GPimportValueLocal")).className = "GPelementHidden gpf-hidden";
        context._onStaticImportTypeChange(e);
      });
    } else if (input.appendChild) {
      input.appendChild("onchange", function () {
        document.getElementById(context._addUID("GPimportValueUrl")).className = "GPimportInputLine";
        document.getElementById(context._addUID("GPimportValueLocal")).className = "GPelementHidden gpf-hidden";
        context._onStaticImportTypeChange();
      });
    }
    input.id = this._addUID("GPimportChoiceAltUrl");
    input.name = "GPimportChoiceMode";
    input.value = "url";
    input.checked = false;
    div.appendChild(input);
    var label = document.createElement("label");
    label.className = "GPimportChoiceAltTxt gpf-label fr-label";
    label.htmlFor = this._addUID("GPimportChoiceAltUrl");
    label.innerHTML = "par URL";
    label.title = "par URL";
    div.appendChild(label);
    return div;
  },
  /**
   * Create input div for KML/GPX/GeoJSON parameters local import
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticLocalInputDiv: function _createStaticLocalInputDiv() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportValueLocal");
    div.className = "GPimportInputLine";
    return div;
  },
  /**
   * Create input label for KML/GPX/GeoJSON parameters local import
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticLocalInputLabel: function _createStaticLocalInputLabel() {
    var label = document.createElement("label");
    label.className = "GPlabel gpf-label fr-label fr-mb-1w";
    label.htmlFor = this._addUID("GPimportFile");
    label.innerHTML = "Fichier local";
    label.title = "Fichier local";
    return label;
  },
  /**
   * Create file input for KML/GPX/GeoJSON parameters local import
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticLocalInput: function _createStaticLocalInput() {
    var input = document.createElement("input");
    input.type = "file";
    input.id = this._addUID("GPimportFile");
    input.className = "GPimportInputFile gpf-upload fr-upload";
    return input;
  },
  /**
   * Create input div for KML/GPX/GeoJSON parameters url import
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticUrlInputDiv: function _createStaticUrlInputDiv() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportValueUrl");
    div.className = "GPelementHidden gpf-hidden";
    return div;
  },
  /**
   * Create input label for KML/GPX/GeoJSON parameters url import
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticUrlInputLabel: function _createStaticUrlInputLabel() {
    var label = document.createElement("label");
    label.className = "GPlabel gpf-label fr-label";
    label.htmlFor = this._addUID("GPimportUrl");
    label.innerHTML = "URL";
    label.title = "URL";
    return label;
  },
  /**
   * Create url input for KML/GPX/GeoJSON parameters url import
   *
   * @returns {DOMElement} DOM element
   */
  _createStaticUrlInput: function _createStaticUrlInput() {
    var input = document.createElement("input");
    input.type = "text";
    input.id = this._addUID("GPimportUrl");
    input.className = "GPinput gpf-input fr-input";
    return input;
  },
  // ################################################################### //
  // ######## Params for service params import (WMS//WMTS/WFS) ######### //
  // ################################################################### //

  /**
   * Create container for WMS/WMTS/WFS parameters
   * @param {String} currentType - WMS, WMTS or WFS value
   * @returns {DOMElement} DOM element
   */
  _createServiceParamsContainer: function _createServiceParamsContainer(currentType) {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportServiceParams");
    if (currentType === "WMS" || currentType === "WMTS" || currentType === "WFS") {
      div.className = "GPelementVisible gpf-visible";
    } else {
      div.className = "GPelementHidden gpf-hidden";
    }
    return div;
  },
  /**
   * Create div for WMS/WMTS/WFS url
   *
   * @returns {DOMElement} DOM element
   */
  _createServiceUrlDiv: function _createServiceUrlDiv() {
    var div = document.createElement("div");
    div.className = "GPimportInputLine";
    return div;
  },
  /**
   * Create input label for WMS/WMTS/WFS url
   *
   * @returns {DOMElement} DOM element
   */
  _createServiceUrlInputLabel: function _createServiceUrlInputLabel() {
    var label = document.createElement("label");
    label.className = "GPlabel gpf-label fr-label";
    label.htmlFor = this._addUID("GPimportServiceUrl");
    label.innerHTML = "URL du service";
    label.title = "URL du service";
    return label;
  },
  /**
   * Create input for WMS/WMTS/WFS parameters url
   *
   * @returns {DOMElement} DOM element
   */
  _createServiceUrlInput: function _createServiceUrlInput() {
    var input = document.createElement("input");
    input.type = "text";
    input.id = this._addUID("GPimportServiceUrl");
    input.className = "GPinput gpf-input fr-input";
    return input;
  },
  // ################################################################### //
  // ########################### Submit Form ########################### //
  // ################################################################### //

  /**
   * Create Submit Form Element
   *
   * @returns {DOMElement} DOM element
   */
  _createImportSubmitFormElement: function _createImportSubmitFormElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GPimportSubmit");
    input.className = "GPsubmit gpf-btn fr-btn fr-btn--secondary";
    input.type = "submit";
    input.value = "Importer";
    return input;
  },
  // ################################################################### //
  // ########################### GetCap Panel ########################## //
  // ################################################################### //

  /**
   * Create GetCap Panel Element
   *
   * @returns {DOMElement} DOM element
   */
  _createImportGetCapPanelElement: function _createImportGetCapPanelElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportGetCapPanel");
    div.className = "GPpanel gpf-panel fr-modal";
    return div;
  },
  /**
   * Create GetCap Panel Header Element
   *
   * @returns {DOMElement} DOM element
   */
  _createImportGetCapPanelHeaderElement: function _createImportGetCapPanelHeaderElement() {
    // contexte
    var context = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header fr-modal__header";

    // panel title
    var panelTitle = document.createElement("div");
    panelTitle.className = "GPpanelTitle gpf-panel__title fr-modal__title";
    panelTitle.innerHTML = "Couches accessibles";
    panelTitle.title = "Couches accessibles";
    container.appendChild(panelTitle);

    // close picto
    var closeDiv = document.createElement("button");
    closeDiv.className = "GPpanelClose GPimportGetCapPanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--secondary fr-m-1w";
    closeDiv.title = "Fermer le panneau";
    closeDiv.id = this._addUID("GPimportGetCapPanelClose");
    if (closeDiv.addEventListener) {
      closeDiv.addEventListener("click", function () {
        document.getElementById(context._addUID("GPshowImportPicto")).click();
        document.getElementById(context._addUID("GPimportGetCapPanel")).style.display = "none";
        context._onGetCapPanelClose();
      });
    } else if (closeDiv.attachEvent) {
      closeDiv.attachEvent("click", function () {
        document.getElementById(context._addUID("GPshowImportPicto")).click();
        document.getElementById(context._addUID("GPimportGetCapPanel")).style.display = "none";
        context._onGetCapPanelClose();
      });
    }
    container.appendChild(closeDiv);
    return container;
  },
  /**
   * Create GetCap Results List Element
   *
   * @returns {DOMElement} DOM element
   */
  _createImportGetCapResultsContainer: function _createImportGetCapResultsContainer() {
    var container = document.createElement("div");
    container.className = "GPimportGetCapRoot gpf-panel__list";
    container.id = this._addUID("GPimportGetCapResults");
    return container;
  },
  _addImportGetCapResultListRubrique: function _addImportGetCapResultListRubrique(title, container) {
    var ul = document.createElement("ul");
    ul.className = "GPimportGetCapListRubrique";
    ul.title = title;
    container.appendChild(ul);
    return container;
  },
  _addImportGetCapResultRubrique: function _addImportGetCapResultRubrique(title, container) {
    var li = document.createElement("li");
    li.className = "GPimportGetCapRubrique gpf-panel__items";

    // input
    var input = document.createElement("input");
    input.id = "GPimportGetCapRubrique-" + _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].generate();
    input.className = "GPimportGetCapRubrique";
    input.type = "checkbox";
    li.appendChild(input);

    // label for
    var label = document.createElement("label");
    label.className = "GPimportGetCapRubriqueTitle gpf-label fr-btn fr-btn--secondary";
    label.htmlFor = input.id;
    label.innerHTML = title;
    label.title = title;
    li.appendChild(label);
    container.appendChild(li);
    return container;
  },
  _addImportGetCapResultListLayer: function _addImportGetCapResultListLayer(container) {
    var ul = document.createElement("ul");
    ul.className = "GPimportGetCapListLayer";
    container.appendChild(ul);
    return container;
  },
  _addImportGetCapResultLayer: function _addImportGetCapResultLayer(description, id, container) {
    var li = document.createElement("li");
    li.className = "GPimportGetCapProposal gpf-panel__items";
    li.innerHTML = description.content;
    li.title = description.title;
    li.id = "GPimportGetCapProposal_" + id;
    var context = this;
    if (li.addEventListener) {
      li.addEventListener("click", function (e) {
        context._onGetCapResponseLayerClick(e);
      });
    } else if (li.attachEvent) {
      li.attachEvent("onclick", function () {
        context._onGetCapResponseLayerClick();
      });
    }
    container.appendChild(li);
    return container;
  },
  // ################################################################### //
  // ########################### MapBox Panel ########################## //
  // ################################################################### //

  /**
   * Create MapBox Panel Element
   *
   * @returns {DOMElement} DOM element
   */
  _createImportMapBoxPanelElement: function _createImportMapBoxPanelElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GPimportMapBoxPanel");
    div.className = "GPpanel gpf-panel fr-modal";
    return div;
  },
  /**
   * Create MapBox Panel Header Element
   *
   * @returns {DOMElement} DOM element
   */
  _createImportMapBoxPanelHeaderElement: function _createImportMapBoxPanelHeaderElement() {
    // contexte
    var context = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header fr-modal__header";

    // return picto
    var returnDiv = document.createElement("button");
    returnDiv.id = this._addUID("GPimportMapBoxPanelReturnPicto");
    returnDiv.title = "Masquer le panneau";
    returnDiv.className = "GPreturnPicto GPimportMapBoxPanelReturnPicto gpf-btn gpf-btn-icon-return fr-btn fr-btn--secondary";
    if (returnDiv.addEventListener) {
      returnDiv.addEventListener("click", function (e) {
        document.getElementById(context._addUID("GPshowImportPicto")).click();
        context._onMapBoxReturnPictoClick(e);
      });
    } else if (returnDiv.attachEvent) {
      returnDiv.attachEvent("onclick", function (e) {
        document.getElementById(context._addUID("GPshowImportPicto")).click();
        context._onMapBoxReturnPictoClick(e);
      });
    }
    container.appendChild(returnDiv);

    // panel title
    var panelTitle = document.createElement("div");
    panelTitle.className = "GPpanelTitle gpf-panel__title fr-modal__title";
    panelTitle.innerHTML = "Edition des styles";
    panelTitle.title = "Edition des styles";
    container.appendChild(panelTitle);

    // close picto
    var closeDiv = document.createElement("button");
    closeDiv.className = "GPpanelClose GPimportMapBoxPanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--secondary fr-m-1w";
    closeDiv.title = "Fermer le panneau";
    closeDiv.id = this._addUID("GPimportMapBoxPanelClose");
    if (closeDiv.addEventListener) {
      closeDiv.addEventListener("click", function () {
        document.getElementById(context._addUID("GPshowImportPicto")).click();
        document.getElementById(context._addUID("GPimportMapBoxPanel")).style.display = "none";
        context._onMapBoxPanelClose();
      });
    } else if (closeDiv.attachEvent) {
      closeDiv.attachEvent("click", function () {
        document.getElementById(context._addUID("GPshowImportPicto")).click();
        document.getElementById(context._addUID("GPimportMapBoxPanel")).style.display = "none";
        context._onMapBoxPanelClose();
      });
    }
    container.appendChild(closeDiv);
    return container;
  },
  /**
   * Create MapBox Results List Element
   *
   * @returns {DOMElement} DOM element
   */
  _createImportMapBoxResultsContainer: function _createImportMapBoxResultsContainer() {
    var container = document.createElement("div");
    container.className = "GPimportMapBoxpRoot";
    container.id = this._addUID("GPimportMapBoxResults");
    return container;
  }

  // _addImportMapBoxResultListSource : function (id, source, container) {
  //     var ul = document.createElement("ul");
  //     ul.className = "GPimportMapBoxListSource";
  //     ul.title = id;
  //
  //     var label = document.createElement("label");
  //     label.className = "GPimportMapBoxListSourceTitle";
  //     label.innerHTML = "Listes des couches pour la source '" + id + "' :";
  //     label.title = source.attribution || id;
  //     ul.appendChild(label);
  //
  //     container.appendChild(ul);
  //     return container;
  // },
  //
  // _addImportMapBoxResultSource : function (layer, container) {
  //     var li = document.createElement("li");
  //     li.className = "GPimportMapBoxSource";
  //
  //     // input
  //     var input = document.createElement("input");
  //     input.id = "GPimportMapBoxSource-" + SelectorID.generate();
  //     input.className = "GPimportMapBoxSource";
  //     input.type = "checkbox";
  //     li.appendChild(input);
  //
  //     // label for
  //     var name = layer["source-layer"] || layer.id || layer.source;
  //     var label = document.createElement("label");
  //     label.className = "GPimportMapBoxSourceTitle";
  //     label.htmlFor = input.id;
  //     label.innerHTML = name;
  //     label.title = JSON.stringify(layer.metadata) || name;
  //     li.appendChild(label);
  //
  //     container.appendChild(li);
  //     return container;
  // },
  //
  // _addImportMapBoxStyleSource : function (layer, container) {
  //     // contexte
  //     var self = this;
  //
  //     var _style = false;
  //     var _obj = {};
  //     var _layer = JSON.parse(JSON.stringify(layer)); // on utilise une copie  !
  //     if (_layer.paint && Object.keys(_layer.paint).length) {
  //         _style = true;
  //         _obj.paint = _layer.paint;
  //     }
  //
  //     // pas de style dans paint, on teste dans layout !
  //     if (_layer.layout && Object.keys(_layer.layout).length) {
  //         _style = true;
  //         _obj.layout = _layer.layout;
  //         // on supprime visibility à l'affichage uniquement
  //         // cf. _addImportMapBoxVisibilitySource !
  //         if (_layer.layout.visibility) {
  //             delete _obj.visibility;
  //         }
  //     }
  //
  //     function syntaxHighlight (json) {
  //         json = json.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  //         return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)/g, function (match) {
  //             var cls = "gp-json-number";
  //             if (/^"/.test(match)) {
  //                 if (/:$/.test(match)) {
  //                     cls = "gp-json-key";
  //                 } else {
  //                     cls = "gp-json-string";
  //                 }
  //             } else if (/true|false/.test(match)) {
  //                 cls = "gp-json-boolean";
  //             } else if (/null/.test(match)) {
  //                 cls = "gp-json-null";
  //             }
  //             return "<span class='" + cls + "'>" + match + "</span>";
  //         });
  //     }
  //
  //     var div = document.createElement("div");
  //     div.className = "GPimportMapBoxSourceStyle";
  //
  //     if (_style) {
  //         var strJson = JSON.stringify(_obj, null, 4);
  //
  //         var label = document.createElement("label");
  //         label.innerHTML = "JSON Styles :";
  //         div.appendChild(label);
  //         var pre = document.createElement("pre");
  //         pre.className = "GPimportMapBoxJsonEdit";
  //         pre.innerHTML = syntaxHighlight(strJson);
  //         if (pre.addEventListener) {
  //             pre.addEventListener("click", function (e) {
  //                 self._onSwitchStyleEditSourceMapBox(e);
  //             });
  //         } else if (pre.appendChild) {
  //             pre.appendChild("onclick", function (e) {
  //                 self._onSwitchStyleEditSourceMapBox(e);
  //             });
  //         }
  //         div.appendChild(pre);
  //     }
  //
  //     container.appendChild(div);
  //     return container;
  // },
  //
  // _addImportMapBoxFilterSource : function (layer, container) {
  //     // contexte
  //     var self = this;
  //
  //     var _filter = false;
  //     // FIXME tag filter est obselete !
  //     // on doit utiliser les expressions dans "paint" ou "layout" !
  //     if (layer.filter && layer.filter.length) {
  //         _filter = true;
  //     }
  //
  //     var div = document.createElement("div");
  //     div.className = "GPimportMapBoxSourceFilter";
  //
  //     if (_filter) {
  //         var label = document.createElement("label");
  //         label.innerHTML = "JSON Filtres :";
  //         div.appendChild(label);
  //         var pre = document.createElement("pre");
  //         pre.className = "GPimportMapBoxJsonEdit";
  //         pre.innerHTML = JSON.stringify(layer.filter, null, 4);
  //         if (pre.addEventListener) {
  //             pre.addEventListener("click", function (e) {
  //                 self._onSwitchFilterEditSourceMapBox(e);
  //             });
  //         } else if (pre.appendChild) {
  //             pre.appendChild("onclick", function (e) {
  //                 self._onSwitchFilterEditSourceMapBox(e);
  //             });
  //         }
  //         div.appendChild(pre);
  //     }
  //
  //     container.appendChild(div);
  //     return container;
  // },
  //
  // _addImportMapBoxScaleSource : function (layer, container) {
  //     // contexte
  //     var self = this;
  //
  //     var _scaleMin = layer.minzoom || 0;
  //     var _scaleMax = layer.maxzoom || 21;
  //
  //     var div = document.createElement("div");
  //     div.className = "GPimportMapBoxSourceScale";
  //
  //     var labelMin = document.createElement("label");
  //     labelMin.className = "GPimportMapBoxSourceScaleLabel";
  //     labelMin.innerHTML = "minZoom :";
  //     div.appendChild(labelMin);
  //
  //     var inputMin = document.createElement("input");
  //     inputMin.className = "GPimportMapBoxSourceScaleInput";
  //     inputMin.type = "range";
  //     inputMin.value = _scaleMin;
  //     inputMin.title = _scaleMin;
  //     inputMin.disabled = false;
  //     inputMin.min = 0;
  //     inputMin.max = 21;
  //     if (inputMin.addEventListener) {
  //         inputMin.addEventListener("change", function (e) {
  //             self._onChangeScaleMinSourceMapBox(e, layer);
  //         });
  //     } else if (inputMin.appendChild) {
  //         inputMin.appendChild("onchange", function (e) {
  //             self._onChangeScaleMinSourceMapBox(e, layer);
  //         });
  //     }
  //     div.appendChild(inputMin);
  //
  //     div.appendChild(document.createElement("br"));
  //
  //     var labelMax = document.createElement("label");
  //     labelMax.className = "GPimportMapBoxSourceScaleLabel";
  //     labelMax.innerHTML = "maxZoom :";
  //     div.appendChild(labelMax);
  //
  //     var inputMax = document.createElement("input");
  //     inputMax.className = "GPimportMapBoxSourceScaleInput";
  //     inputMax.type = "range";
  //     inputMax.value = _scaleMax;
  //     inputMax.title = _scaleMax;
  //     inputMax.disabled = false;
  //     inputMax.min = 0;
  //     inputMax.max = 21;
  //     if (inputMax.addEventListener) {
  //         inputMax.addEventListener("change", function (e) {
  //             self._onChangeScaleMaxSourceMapBox(e, layer);
  //         });
  //     } else if (inputMax.appendChild) {
  //         inputMax.appendChild("onchange", function (e) {
  //             self._onChangeScaleMaxSourceMapBox(e, layer);
  //         });
  //     }
  //     div.appendChild(inputMax);
  //
  //     container.appendChild(div);
  //     return container;
  // },
  //
  // _addImportMapBoxVisibilitySource : function (layer, container) {
  //     // contexte
  //     var self = this;
  //
  //     var _visibility = true;
  //     if (layer.layout && layer.layout.visibility && layer.layout.visibility === "none") {
  //         _visibility = false;
  //     }
  //
  //     var div = document.createElement("div");
  //     div.className = "GPimportMapBoxSourceVisibility";
  //
  //     var label = document.createElement("label");
  //     label.className = "GPimportMapBoxSourceVisibilityLabel";
  //     label.innerHTML = "Visibilité :";
  //     div.appendChild(label);
  //
  //     var input = document.createElement("input");
  //     input.className = "GPimportMapBoxSourceVisibilityInput";
  //     input.type = "checkbox";
  //     input.checked = _visibility;
  //     input.disabled = false;
  //     if (input.addEventListener) {
  //         input.addEventListener("change", function (e) {
  //             self._onChangeVisibilitySourceMapBox(e, layer);
  //         });
  //     } else if (input.appendChild) {
  //         input.appendChild("onchange", function (e) {
  //             self._onChangeVisibilitySourceMapBox(e, layer);
  //         });
  //     }
  //     div.appendChild(input);
  //
  //     container.appendChild(div);
  //     return container;
  // }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayerImportDOM);

/***/ }),

/***/ "./src/packages/Controls/LayerSwitcher/LayerSwitcher.js":
/*!**************************************************************!*\
  !*** ./src/packages/Controls/LayerSwitcher/LayerSwitcher.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CSS_Controls_LayerSwitcher_GPFlayerSwitcher_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../CSS/Controls/LayerSwitcher/GPFlayerSwitcher.css */ "./src/packages/CSS/Controls/LayerSwitcher/GPFlayerSwitcher.css");
/* harmony import */ var _Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Control */ "./src/packages/Controls/Control.js");
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ol/Observable */ "ol/Observable");
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_Observable__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_extent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ol/extent */ "ol/extent");
/* harmony import */ var ol_extent__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_extent__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Utils/SelectorID */ "./src/packages/Utils/SelectorID.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
/* harmony import */ var _LayerSwitcherDOM__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./LayerSwitcherDOM */ "./src/packages/Controls/LayerSwitcher/LayerSwitcherDOM.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
// import CSS

// import "../../CSS/Controls/LayerSwitcher/GPFlayerSwitcherStyle.css";
// import OpenLayers
// import Control from "ol/control/Control";



// import local


// DOM

var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_5__["default"].getLogger("layerswitcher");

/**
 * @classdesc
 * OpenLayers Control to manage map layers : their order, visibility and opacity, and display their informations (title, description, legends, metadata...)
 *
 * @constructor
 * @extends {ol.control.Control}
 * @alias ol.control.LayerSwitcher
 * @type {ol.control.LayerSwitcher}
 * @param {Object} options - control options
 * @param {Array} [options.layers] - list of layers to be configured. Each array element is an object, with following properties :
 * @param {ol.layer.Layer} [options.layers.layer] - ol.layer.Layer layer to be configured (that has been added to map)
 * @param {Object} [options.layers.config] - custom configuration object for layer information (title, description, legends, metadata, quicklook url), with following properties :
 * @param {String} [options.layers.config.title] - layer alias, to be displayed in widget layer list. E.g. : "Cartes IGN"
 * @param {String} [options.layers.config.description] - layer description, to be displayed on title hover, or in layer information panel.
 * @param {String} [options.layers.config.quicklookUrl] - link to a quick look image for this layer.
 * @param {Array} [options.layers.config.legends] - array of layer legends. Each array element is an object, with following properties :
 *      - url (String, mandatory) : link to a legend
 *      - minScaleDenominator (Number, optional) : min scale denominator for legend validity.
 * @param {Array} [options.layers.config.metadata] - array of layer metadata. Each array element is an object, with property url (String, mandatory) : link to a metadata
 * @param {Object} [options.options] - ol.control.Control options (see {@link http://openlayers.org/en/latest/apidoc/ol.control.Control.html ol.control.Control})
 * @param {Boolean} [options.options.collapsed = true] - Specify if widget has to be collapsed (true) or not (false) on map loading. Default is true.
 * @example
 * map.addControl(new ol.control.LayerSwitcher(
 *  [
 *      {
 *          layer : wms1,
 *          config : {
 *              title : "test layer name 1",
 *              description : "test layer desc 1",
 *          }
 *      }
 *  ],
 *  {
 *      collapsed : true
 *  }
 * ));
 */
var LayerSwitcher = /*#__PURE__*/function (_Control) {
  /**
   * See {@link ol.control.LayerSwitcher}
   * @module LayerSwitcher
   * @alias module:~controls/LayerSwitcher
   * @param {*} options - options
   * @example
   * import LayerSwitcher from "gpf-ext-ol/controls/LayerSwitcher"
   * ou 
   * import { LayerSwitcher } from "gpf-ext-ol"
   */
  function LayerSwitcher(options) {
    var _this;
    _classCallCheck(this, LayerSwitcher);
    options = options || {};
    var _options = options.options || {};
    var _layers = options.layers || [];

    // call ol.control.Control constructor
    _this = _callSuper(this, LayerSwitcher, [{
      element: _options.element,
      target: _options.target,
      render: _options.render
    }]);
    if (!(_this instanceof LayerSwitcher)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    if (!Array.isArray(_layers)) {
      throw new Error("ERROR WRONG_TYPE : layers should be an array");
    }
    if (_typeof(_options) !== "object") {
      throw new Error("ERROR WRONG_TYPE : options should be an object");
    }
    _this._initialize(_options, _layers);
    _this.container = _this._initContainer(_options);

    // ajout du container
    _this.element ? _this.element.appendChild(_this.container) : _this.element = _this.container;
    return _possibleConstructorReturn(_this, _this);
  }

  // ################################################################### //
  // ############## public methods (getters, setters) ################## //
  // ################################################################### //

  /**
   * Overload setMap function, that enables to catch map events, such as movend events.
   *
   * @param {ol.Map} map - Map.
   */
  _inherits(LayerSwitcher, _Control);
  return _createClass(LayerSwitcher, [{
    key: "setMap",
    value: function setMap(map) {
      var _this2 = this;
      // info : cette méthode est appelée (entre autres?) après un map.addControl() ou map.removeControl()

      if (map) {
        // dans le cas de l'ajout du contrôle à la map
        // on ajoute les couches
        this._addMapLayers(map);

        // At every map movement, layer switcher may be updated,
        // according to layers on map, and their range.
        this._listeners.onMoveListener = map.on("moveend", function () {
          return _this2._onMapMoveEnd(map);
        });

        // add event listeners when a new layer is added to map, to add it in LayerSwitcher control (and DOM)
        this._listeners.onAddListener = map.getLayers().on("add", function (evt) {
          var layer = evt.element;
          var id;
          // on attribue un nouvel identifiant à cette couche,
          // sauf si c'est une couche qui a déjà été ajoutée dans le LayerSwitcher au préalable (si gpLayerId existe)
          if (!layer.hasOwnProperty("gpLayerId")) {
            id = _this2._layerId;
            layer.gpLayerId = id;
            _this2._layerId++;
          } else {
            id = layer.gpLayerId;
          }
          if (!_this2._layers[id]) {
            _this2.addLayer(layer);
          }
        });

        // add event listeners when a layer is removed from map, to remove it from LayerSwitcher control (and DOM)
        this._listeners.onRemoveListener = map.getLayers().on("remove", function (evt) {
          var layer = evt.element;
          var id = layer.gpLayerId;
          if (_this2._layers[id]) {
            _this2.removeLayer(layer);
          }
        });
      } else {
        // we are in a setMap(null) case
        // we forget the listeners linked to the layerSwitcher
        (0,ol_Observable__WEBPACK_IMPORTED_MODULE_2__.unByKey)(this._listeners.onMoveListener);
        (0,ol_Observable__WEBPACK_IMPORTED_MODULE_2__.unByKey)(this._listeners.onAddListener);
        (0,ol_Observable__WEBPACK_IMPORTED_MODULE_2__.unByKey)(this._listeners.onRemoveListener);

        // we put all the layers at Zindex = 0, without changing the visual order
        // in order that the next added layers are not hidden by layers with Zindex > 0
        for (var i = this._layersOrder.length - 1; i >= 0; i--) {
          this._layersOrder[i].layer.setZIndex(0);
        }
      }

      // on appelle la méthode setMap originale d'OpenLayers
      _get(_getPrototypeOf(LayerSwitcher.prototype), "setMap", this).call(this, map);

      // position
      if (this.options.position) {
        this.setPosition(this.options.position);
      }
    }

    /**
     * Add a new layer to control (when added to map) or add new layer configuration
     *
     * @param {ol.layer.Layer} layer - layer to add to layer switcher
     * @param {Object} [config] - additional options for layer configuration
     * @param {Object} [config.title] - layer title (default is layer identifier)
     * @param {Object} [config.description] - layer description (default is null)
     * @param {Object} [config.legends] - layer legends (default is an empty array)
     * @param {Object} [config.metadata] - layer metadata (default is an empty array)
     * @param {Object} [config.quicklookUrl] - layer quicklookUrl (default is null)
     * @example
     *   layerSwitcher.addLayer(
     *       gpParcels,
     *       {
     *           title : "Parcelles cadastrales",
     *           description : "description de la couche",
     *           quicklookUrl : "http://quicklookUrl.fr"
     *       }
     *   )
     */
  }, {
    key: "addLayer",
    value: function addLayer(layer, config) {
      var _this3 = this;
      var map = this.getMap();
      config = config || {};
      if (!layer) {
        logger.log("[ERROR] LayerSwitcher:addLayer - missing layer parameter");
        return;
      }
      var id = layer.gpLayerId;
      if (typeof id === "undefined") {
        logger.trace("[WARN] LayerSwitcher:addLayer - configuration cannot be set for this layer (layer id not found)", layer);
        return;
      }

      // make sure layer is in map layers
      var isLayerInMap = false;
      map.getLayers().forEach(function (lyr) {
        if (lyr.gpLayerId === id) {
          isLayerInMap = true;
        }
      });
      if (!isLayerInMap) {
        logger.log("[ERROR] LayerSwitcher:addLayer - configuration cannot be set for ", layer, " layer (layer is not in map.getLayers() )");
        return;
      }

      // if layer is not already in layers list, add it to control (layers list and container div)
      if (!this._layers[id]) {
        // 1. add layer to layers list
        var layerInfos = this.getLayerInfo(layer) || {};
        var opacity = layer.getOpacity();
        var visibility = layer.getVisible();
        var isInRange = this.isInRange(layer, map);
        var layerOptions = {
          layer: layer,
          id: id,
          opacity: opacity != null ? opacity : 1,
          visibility: visibility != null ? visibility : true,
          inRange: isInRange != null ? isInRange : true,
          title: config.title != null ? config.title : layerInfos._title || id,
          description: config.description || layerInfos._description || null,
          legends: config.legends || layerInfos._legends || [],
          metadata: config.metadata || layerInfos._metadata || [],
          quicklookUrl: config.quicklookUrl || layerInfos._quicklookUrl || null
        };
        this._layers[id] = layerOptions;

        // 2. create layer div (to be added to control main container)
        // Création de la div correspondante à cette couche
        var layerDiv = this._createLayerDiv(layerOptions);
        // on stocke la div dans les options de la couche, pour une éventuelle réorganisation (setZIndex par ex)
        this._layers[id].div = layerDiv;

        // 3. réorganisation des couches si un zIndex est spécifié
        // FIXME :
        //  _forceNullzIndex !?
        //  getZIndex() retourne undefined au lieu de 0 !?
        if (layer.getZIndex && layer.getZIndex() !== 0 && typeof layer.getZIndex() !== "undefined" || layer._forceNullzIndex) {
          // réorganisation des couches si un zIndex est spécifié
          this._updateLayersOrder();
        } else {
          // sinon on ajoute la couche au dessus des autres
          this._layersOrder.unshift(layerOptions);
          this._lastZIndex++;
          layer.setZIndex(this._lastZIndex);
          this._layerListContainer.insertBefore(layerDiv, this._layerListContainer.firstChild);
        }

        // 3. Add listeners for opacity and visibility changes
        this._listeners.updateLayerOpacity = layer.on("change:opacity", function (e) {
          return _this3._updateLayerOpacity(e);
        });
        this._listeners.updateLayerVisibility = layer.on("change:visible", function (e) {
          return _this3._updateLayerVisibility(e);
        });
        if (this._layers[id].onZIndexChangeEvent == null) {
          this._layers[id].onZIndexChangeEvent = layer.on("change:zIndex", function () {
            return _this3._updateLayersOrder();
          });
        }

        // user may also add a new configuration for an already added layer
      } else {
        // add new configuration parameters to layer informations
        for (var prop in config) {
          if (config.hasOwnProperty(prop)) {
            this._layers[id][prop] = config[prop];
          }
        }
        // set new title in layer div
        if (config.title) {
          var nameDiv = document.getElementById(this._addUID("GPname_ID_" + id));
          if (nameDiv) {
            nameDiv.innerHTML = config.title;
            nameDiv.title = config.description || config.title;
          }
        }
        // add layer info picto if necessary
        var infodiv = document.getElementById(this._addUID("GPinfo_ID_" + id));
        if (!document.getElementById(this._addUID("GPinfo_ID_" + id)) && config.description) {
          var advancedTools = document.getElementById(this._addUID("GPadvancedTools_ID_" + id));
          if (advancedTools) {
            advancedTools.appendChild(this._createAdvancedToolInformationElement({
              id: id
            }));
          }
        }
        // close layer info element if open, to update information.
        if (infodiv && infodiv.className === "GPlayerInfoOpened") {
          document.getElementById(this._addUID("GPlayerInfoPanel")).className = "GPlayerInfoPanelClosed";
          infodiv.className = "GPlayerInfo";
        }
      }
    }
  }, {
    key: "removeLayer",
    value:
    /**
     * Remove a layer from control
     *
     * @param {ol.layer.Layer} layer - layer.
     * @deprecated on the future version ...
     */
    function removeLayer(layer) {
      if (!layer) {
        return;
      }
      (0,ol_Observable__WEBPACK_IMPORTED_MODULE_2__.unByKey)(this._listeners.updateLayerOpacity);
      (0,ol_Observable__WEBPACK_IMPORTED_MODULE_2__.unByKey)(this._listeners.updateLayerVisibility);
      // olObservableUnByKey(this._listeners.updateLayersOrder);

      logger.trace(layer);
      var layerID = layer.gpLayerId;
      var layerList = document.getElementById(this._addUID("GPlayersList")).firstChild;
      // close layer info element if open.
      var infodiv = document.getElementById(this._addUID("GPinfo_ID_" + layerID));
      if (infodiv && infodiv.className === "GPlayerInfoOpened") {
        document.getElementById(this._addUID("GPlayerInfoPanel")).className = "GPlayerInfoPanelClosed";
        infodiv.className = "GPlayerInfo";
      }
      // remove layer div
      var layerDiv = document.getElementById(this._addUID("GPlayerSwitcher_ID_" + layerID));
      if (layerDiv) {
        layerList.removeChild(layerDiv);
      }
      var layerIndex = Math.abs(layer.getZIndex() - this._lastZIndex);
      // on retire la couche de la liste ordonnée des layers
      this._layersOrder.splice(layerIndex, 1);
      this._lastZIndex--;
      // on met à jour les zindex des couches restantes
      var layerOrderTemp = this._layersOrder;
      for (var i = 0; i < layerOrderTemp.length; i++) {
        layerOrderTemp[i].layer.setZIndex(this._lastZIndex - i);
      }
      // on retire la couche de la liste des layers
      delete this._layers[layerID];
    }

    /**
     * Collapse or display control main container
     *
     * @param {Boolean} collapsed - True to collapse control, False to display it
     */
  }, {
    key: "setCollapsed",
    value: function setCollapsed(collapsed) {
      if (collapsed === undefined) {
        logger.log("[ERROR] LayerSwitcher:setCollapsed - missing collapsed parameter");
        return;
      }
      var isCollapsed = !document.getElementById(this._addUID("GPshowLayersList")).checked;
      if (collapsed && isCollapsed || !collapsed && !isCollapsed) {
        return;
      }
      // on simule l'ouverture du panneau après un click
      if (!isCollapsed) {
        var layers = document.getElementsByClassName("GPlayerInfoOpened");
        for (var i = 0; i < layers.length; i++) {
          layers[i].className = "GPlayerInfo";
        }
        document.getElementById(this._addUID("GPlayerInfoPanel")).className = "GPlayerInfoPanelClosed";
      }
      document.getElementById(this._addUID("GPshowLayersList")).checked = !collapsed;
    }

    /**
     * Returns true if widget is collapsed (minimize), false otherwise
     * @returns {Boolean} is collapsed
     */
  }, {
    key: "getCollapsed",
    value: function getCollapsed() {
      return this.collapsed;
    }

    /**
     * Display or hide removeLayerPicto from layerSwitcher for this layer
     *
     * @param {ol.layer.Layer} layer - ol.layer to be configured
     * @param {Boolean} removable - specify if layer can be remove from layerSwitcher (true) or not (false). Default is true
     */
  }, {
    key: "setRemovable",
    value: function setRemovable(layer, removable) {
      if (!layer) {
        return;
      }
      var layerID = layer.gpLayerId;
      if (layerID == null) {
        // on teste si layerID est null ou undefined
        logger.log("[LayerSwitcher:setRemovable] layer should be added to map before calling setRemovable method");
        return;
      }
      var removalDiv = document.getElementById(this._addUID("GPremove_ID_" + layerID));
      if (removalDiv) {
        if (removable === false) {
          removalDiv.style.display = "none";
        } else if (removable === true) {
          removalDiv.style.display = "block";
        } else {}
      }
    }

    // ################################################################### //
    // ##################### init component ############################## //
    // ################################################################### //

    /**
     * Initialize LayerSwitcher control (called by constructor)
     *
     * @param {Object} options - ol.control.Control options (see {@link http://openlayers.org/en/latest/apidoc/ol.control.Control.html ol.control.Control})
     * @param {Array} layers - list of layers to be configured. Each array element is an object, with following properties :
     * @private
     */
  }, {
    key: "_initialize",
    value: function _initialize(options, layers) {
      // identifiant du contrôle : utile pour suffixer les identifiants CSS (pour gérer le cas où il y en a plusieurs dans la même page)
      this._uid = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_4__["default"].generate();
      this.options = options;
      this.options.layers = layers;

      // {Object} control layers list. Each key is a layer id, and its value is an object of layers options (layer, id, opacity, visibility, title, description...)
      this._layers = {};
      // [Array] array of ordered control layers
      this._layersOrder = [];
      // [Object] associative array of layers ordered by zindex (keys are zindex values, and corresponding values are arrays of layers at this zindex)
      this._layersIndex = {};
      // {Number} layers max z index, to order layers using their z index
      this._lastZIndex = 0;
      // {Number} layers max id, incremented when a new layer is added
      this._layerId = 0;
      /** {Boolean} true if widget is collapsed, false otherwise */
      this.collapsed = options.collapsed !== undefined ? options.collapsed : true;
      // div qui contiendra les div des listes.
      this._layerListContainer = null;
      // [Object] listeners added to the layerSwitcher saved here in order to delete them if we remove the control from the map)
      this._listeners = {};

      // add options layers to layerlist.
      // (seulement les couches configurées dans les options du layerSwitcher par l'utilisateur),
      // les autres couches de la carte seront ajoutées dans la méthode setMap
      for (var i = 0; i < layers.length; i++) {
        // recup la layer, son id,
        var layer = layers[i].layer;
        if (layer) {
          var id;
          // si elles ont déjà un identifiant (gpLayerId), on le récupère, sinon on en crée un nouveau, en incrémentant this_layerId.
          if (!layer.hasOwnProperty("gpLayerId")) {
            id = this._layerId;
            layer.gpLayerId = id;
            this._layerId++;
          } else {
            id = layer.gpLayerId;
          }

          // et les infos de la conf si elles existent (title, description, legends, quicklook, metadata)
          var conf = layers[i].config || {};
          var opacity = layer.getOpacity();
          var visibility = layer.getVisible();
          var layerOptions = {
            layer: layer,
            // la couche ol.layer concernée
            id: id,
            opacity: opacity != null ? opacity : 1,
            visibility: visibility != null ? visibility : true,
            title: conf.title != null ? conf.title : conf.id ? conf.id : id,
            description: conf.description || null,
            legends: conf.legends || [],
            metadata: conf.metadata || [],
            quicklookUrl: conf.quicklookUrl || null
          };
          this._layers[id] = layerOptions;
        }
      }
    }

    /**
     * Create control main container (called by constructor)
     *
     * @returns {DOMElement} container - control container
     * @private
     */
  }, {
    key: "_initContainer",
    value: function _initContainer() {
      // creation du container principal
      var container = this._createMainContainerElement();

      // ajout dans le container principal d'affichage des layers
      var input = this._createMainLayersShowElement();
      container.appendChild(input);

      // gestion du mode "collapsed"
      if (!this.collapsed) {
        input.checked = "checked";
        this.collapsed = false;
      } else {
        this.collapsed = true;
      }

      // on ajoute un écouteur d'évènement sur le bouton (checkbox) de dépliement/repliement des couches,
      // pour modifier la propriété this.collapsed quand on clique dessus
      var context = this;
      // event listener
      var changeCollapsed = function changeCollapsed(e) {
        this.collapsed = !e.target.checked;
        // on génère nous même l'evenement OpenLayers de changement de pté
        // (utiliser layerSwitcher.on("change:collapsed", function ) pour s'abonner à cet évènement)
        this.dispatchEvent("change:collapsed");
      };
      input.addEventListener("click", function (e) {
        changeCollapsed.call(context, e);
      });

      // ajout dans le container principal du picto du controle
      var picto = this._createMainPictoElement();
      container.appendChild(picto);

      // ajout dans le container principal de la liste des layers
      var divL = this._createMainLayersElement();
      container.appendChild(divL);
      var div = this._layerListContainer = this._createMainLayersDivElement();
      divL.appendChild(div);

      // creation du mode draggable
      this._createDraggableElement(div, this);

      // ajout dans le container principal du panneau d'information
      var divI = this._createMainInfoElement();
      container.appendChild(divI);
      return container;
    }

    /**
     * Add all map layers to control main container
     *
     * @param {Object} map - ol.Map object, to which control is added
     * @private
     */
  }, {
    key: "_addMapLayers",
    value: function _addMapLayers(map) {
      var _this4 = this;
      this._layersIndex = {};

      // on parcourt toutes les couches de la carte, pour les ajouter à la liste du controle si ce n'est pas déjà le cas.
      // idée : le layerSwitcher doit représenter l'ensemble des couches de la carte.
      map.getLayers().forEach(function (layer) {
        // ajout des couches de la carte à la liste
        var id;
        // si elles ont déjà un identifiant (gpLayerId), on le récupère, sinon on en crée un nouveau, en incrémentant this_layerId.
        if (!layer.hasOwnProperty("gpLayerId")) {
          id = _this4._layerId;
          layer.gpLayerId = id;
          _this4._layerId++;
        } else {
          id = layer.gpLayerId;
        }
        var layerInfos = _this4.getLayerInfo(layer) || {};
        if (!_this4._layers[id]) {
          // si la couche n'est pas encore dans la liste des layers (this._layers), on l'ajoute
          var opacity = layer.getOpacity();
          var visibility = layer.getVisible();
          var isInRange = _this4.isInRange(layer, map);
          var layerOptions = {
            layer: layer,
            id: id,
            opacity: opacity != null ? opacity : 1,
            visibility: visibility != null ? visibility : true,
            inRange: isInRange != null ? isInRange : true,
            title: layerInfos._title || id,
            description: layerInfos._description || null,
            legends: layerInfos._legends || [],
            metadata: layerInfos._metadata || [],
            quicklookUrl: layerInfos._quicklookUrl || null
          };
          _this4._layers[id] = layerOptions;
        } else {
          // si elle existe déjà, on met à jour ses informations (visibility, opacity, inRange)
          _this4._layers[id].opacity = layer.getOpacity();
          _this4._layers[id].visibility = layer.getVisible();
          _this4._layers[id].inRange = _this4.isInRange(layer, map);
        }

        // Ajout de listeners sur les changements d'opacité, visibilité
        _this4._listeners.updateLayerOpacity = layer.on("change:opacity", function (e) {
          return _this4._updateLayerOpacity(e);
        });
        _this4._listeners._updateLayerVisibility = layer.on("change:visible", function (e) {
          return _this4._updateLayerVisibility(e);
        });

        // récupération des zindex des couches s'ils existent, pour les ordonner.
        if (layer.getZIndex !== undefined) {
          var layerIndex = layer.getZIndex() || 0; // FIXME le zIndex peut être undefined !? donc par defaut à 0 !
          if (!_this4._layersIndex[layerIndex] || !Array.isArray(_this4._layersIndex[layerIndex])) {
            _this4._layersIndex[layerIndex] = [];
          }
          _this4._layersIndex[layerIndex].push(_this4._layers[id]);
        }
        ;
      });

      // on récupère l'ordre d'affichage des couches entre elles dans la carte, à partir de zindex.
      for (var zindex in this._layersIndex) {
        if (this._layersIndex.hasOwnProperty(zindex)) {
          var layers = this._layersIndex[zindex];
          for (var l = 0; l < layers.length; l++) {
            // à ce stade layers[l] est une couche de this._layers.
            // on conserve l'ordre des couches : la première est celle qui se situe tout en haut, et la dernière est le "fond de carte"
            this._layersOrder.unshift(layers[l]);
            // et on réordonne les couches avec des zindex, uniques.
            this._lastZIndex++;
            layers[l].layer.setZIndex(this._lastZIndex);
            if (this._layers[layers[l].layer.gpLayerId].onZIndexChangeEvent == null) {
              this._layers[layers[l].layer.gpLayerId].onZIndexChangeEvent = layers[l].layer.on("change:zIndex", function () {
                return _this4._updateLayersOrder();
              });
            }
          }
        }
      }

      // on ajoute les div correspondantes aux différentes couches (dans l'ordre inverse d'affichage) dans le controle.
      for (var j = 0; j < this._layersOrder.length; j++) {
        var layerOptions = this._layersOrder[j];
        var layerDiv = this._createLayerDiv(layerOptions);
        this._layerListContainer.appendChild(layerDiv);
        // on stocke la div dans les options de la couche, pour une éventuelle réorganisation (setZIndex par ex)
        this._layers[layerOptions.id].div = layerDiv;
      }
    }

    /**
     * create layer div (to append to control DOM element).
     *
     * @param {Object} layerOptions - layer options (id, title, description, legends, metadata, quicklookUrl ...)
     *
     * @returns {DOMElement} DOM element
     *
     * @private
     */
  }, {
    key: "_createLayerDiv",
    value: function _createLayerDiv(layerOptions) {
      var isLegends = layerOptions.legends && layerOptions.legends.length !== 0;
      var isMetadata = layerOptions.metadata && layerOptions.metadata.length !== 0;
      var isQuicklookUrl = layerOptions.quicklookUrl;
      // on n'affiche les informations que si elles sont renseignées (pour ne pas avoir un panneau vide)
      if (isLegends || isMetadata || isQuicklookUrl) {
        layerOptions.displayInformationElement = true;
      }

      // ajout d'une div pour cette layer dans le control
      var layerDiv = this._createContainerLayerElement(layerOptions);
      if (!layerOptions.inRange) {
        layerDiv.classList.add("outOfRange");
      }
      return layerDiv;
    }

    // ################################################################### //
    // ######################### DOM events ############################## //
    // ################################################################### //

    /**
     * Change layer opacity on layer opacity picto click
     *
     * @param {Object} e - event
     * @private
     */
  }, {
    key: "_onChangeLayerOpacity",
    value: function _onChangeLayerOpacity(e) {
      var divId = e.target.id; // ex GPvisibilityPicto_ID_26
      var layerID = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_4__["default"].index(divId); // ex. 26
      var layer = this._layers[layerID].layer;
      var opacityValue = e.target.value;
      var opacityId = document.getElementById(this._addUID("GPopacityValue_ID_" + layerID));
      opacityId.innerHTML = opacityValue + "%";
      layer.setOpacity(opacityValue / 100);
    }

    /**
     * Update picto opacity value on layer opacity change
     *
     * @param {Object} e - event
     * @private
     */
  }, {
    key: "_updateLayerOpacity",
    value: function _updateLayerOpacity(e) {
      var opacity = e.target.getOpacity();
      if (opacity > 1) {
        opacity = 1;
      }
      if (opacity < 0) {
        opacity = 0;
      }
      var id = e.target.gpLayerId;
      var layerOpacityInput = document.getElementById(this._addUID("GPopacityValueDiv_ID_" + id));
      if (layerOpacityInput) {
        layerOpacityInput.value = Math.round(opacity * 100);
      }
      var layerOpacitySpan = document.getElementById(this._addUID("GPopacityValue_ID_" + id));
      if (layerOpacitySpan) {
        layerOpacitySpan.innerHTML = Math.round(opacity * 100) + "%";
      }
    }

    /**
     * Change layer visibility on layer visibility picto click
     *
     * @param {Object} e - event
     * @private
     */
  }, {
    key: "_onVisibilityLayerClick",
    value: function _onVisibilityLayerClick(e) {
      var divId = e.target.id; // ex GPvisibilityPicto_ID_26
      var layerID = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_4__["default"].index(divId); // ex. 26
      var layer = this._layers[layerID].layer;
      layer.setVisible(e.target.checked);
    }

    /**
     * Change picto visibility on layer visibility change
     *
     * @param {Object} e - event
     * @private
     */
  }, {
    key: "_updateLayerVisibility",
    value: function _updateLayerVisibility(e) {
      var visible = e.target.getVisible();
      var id = e.target.gpLayerId;
      var layerVisibilityInput = document.getElementById(this._addUID("GPvisibility_ID_" + id));
      if (layerVisibilityInput) {
        layerVisibilityInput.checked = visible;
      }
    }

    /**
     * Change layers order in layerswitcher (control container) on a layer index change (on map) or when a layer is added to a specific zindex
     *
     * @private
     */
  }, {
    key: "_updateLayersOrder",
    value: function _updateLayersOrder() {
      var _this5 = this;
      // info :
      // 1. on récupère les zindex et les couches associées dans un tableau associatif (objet)
      // 2. on réordonne les couche selon leur index : on leur attribue de nouveaux zindex uniques
      // 3. on vide le container des layers, et rajoute les div des couches dans l'ordre décroissant des zindex

      var map = this.getMap();
      if (!map) {
        return;
      }
      this._layersIndex = {};
      var layerIndex;
      var id;

      // on parcourt toutes les couches pour récupérer leur ordre :
      // on stocke les couches dans un tableau associatif ou les clés sont les zindex, et les valeurs sont des tableaux des couches à ce zindex.
      map.getLayers().forEach(function (layer) {
        id = layer.gpLayerId;

        // on commence par désactiver temporairement l'écouteur d'événements sur le changement de zindex.
        (0,ol_Observable__WEBPACK_IMPORTED_MODULE_2__.unByKey)(_this5._layers[id].onZIndexChangeEvent);
        _this5._layers[id].onZIndexChangeEvent = null;

        // on ajoute la couche dans le tableau (de l'objet this._layersIndex) correspondant à son zindex
        layerIndex = null;
        if (layer.getZIndex !== undefined) {
          layerIndex = layer.getZIndex();
          if (!_this5._layersIndex[layerIndex] || !Array.isArray(_this5._layersIndex[layerIndex])) {
            _this5._layersIndex[layerIndex] = [];
          }
          _this5._layersIndex[layerIndex].push(_this5._layers[id]);
        }
        ;
      });

      // on réordonne les couches entre elles dans la carte, à partir des zindex stockés ci-dessus.
      this._lastZIndex = 0;
      this._layersOrder = [];
      for (var zindex in this._layersIndex) {
        if (this._layersIndex.hasOwnProperty(zindex)) {
          var layers = this._layersIndex[zindex];
          for (var l = 0; l < layers.length; l++) {
            // à ce stade layers[l] est une couche de this._layers.
            // on conserve l'ordre des couches : la première est celle qui se situe tout en haut, et la dernière est le "fond de carte"
            this._layersOrder.unshift(layers[l]);
            // et on réordonne les couches avec des zindex, uniques.
            this._lastZIndex++;
            // layers[l].layer.setZIndex(lastZIndex);
            // et on réactive l'écouteur d'événement sur les zindex
            if (this._layers[layers[l].layer.gpLayerId].onZIndexChangeEvent == null) {
              this._layers[layers[l].layer.gpLayerId].onZIndexChangeEvent = layers[l].layer.on("change:zIndex", function () {
                return _this5._updateLayersOrder();
              });
            }
          }
        }
      }
      if (this._layerListContainer) {
        // on vide le container précédent
        while (this._layerListContainer.firstChild) {
          this._layerListContainer.removeChild(this._layerListContainer.firstChild);
        }
        // et on rajoute les div correspondantes aux différentes couches, dans l'ordre décroissant des zindex
        for (var j = 0; j < this._layersOrder.length; j++) {
          var layerOptions = this._layersOrder[j];
          this._layerListContainer.appendChild(layerOptions.div);
        }
      } else {
        logger.log("[ol.control.LayerSwitcher] _updateLayersOrder : layer list container not found to update layers order ?!");
      }
    }

    /**
     * Open layer information panel on picto click
     *
     * @param {Event} e - MouseEvent
     * @private
     */
  }, {
    key: "_onOpenLayerInfoClick",
    value: function _onOpenLayerInfoClick(e) {
      var divId = e.target.id; // ex GPvisibilityPicto_ID_26
      var layerID = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_4__["default"].index(divId); // ex. 26
      var layerOptions = this._layers[layerID];
      var panel;
      var info;

      // Close layer info panel
      divId = document.getElementById(e.target.id);
      if (divId.className === "GPlayerInfoOpened") {
        if (divId.classList !== undefined) {
          divId.classList.remove("GPlayerInfoOpened");
          divId.classList.add("GPlayerInfo");
        }
        panel = document.getElementById(this._addUID("GPlayerInfoPanel"));
        if (panel.classList !== undefined) {
          panel.classList.remove("GPpanel");
          panel.classList.remove("GPlayerInfoPanelOpened");
          panel.classList.add("GPlayerInfoPanelClosed");
        }
        info = document.getElementById(this._addUID("GPlayerInfoContent"));
        panel.removeChild(info);
        return;
      }
      var layers = document.getElementsByClassName("GPlayerInfoOpened");
      for (var i = 0; i < layers.length; i++) {
        layers[i].className = "GPlayerInfo";
      }

      // Open layer info panel
      if (divId.classList !== undefined) {
        divId.classList.remove("GPlayerInfo");
        divId.classList.add("GPlayerInfoOpened");
      }
      panel = document.getElementById(this._addUID("GPlayerInfoPanel"));
      if (panel.classList !== undefined) {
        panel.classList.add("GPpanel");
        panel.classList.remove("GPlayerInfoPanelClosed");
        panel.classList.add("GPlayerInfoPanelOpened");
      }
      info = document.getElementById(this._addUID("GPlayerInfoContent"));
      if (info) {
        panel.removeChild(info);
      }

      // on récupère les infos associées au layer pour mettre dynamiquement le contenu du panel d'informations
      var obj = {
        title: layerOptions.title,
        description: layerOptions.description,
        quicklookUrl: layerOptions.quicklookUrl,
        metadata: layerOptions.metadata,
        legends: layerOptions.legends
      };
      // get layer max scale denominator
      var maxResolution = layerOptions.layer.getMaxResolution();
      if (maxResolution === Infinity) {
        obj._maxScaleDenominator = 560000000;
      } else {
        obj._maxScaleDenominator = Math.round(maxResolution / 0.00028);
      }
      var infoLayer = this._createContainerLayerInfoElement(obj);
      panel.appendChild(infoLayer);
    }

    /**
     * remove layer from layer switcher and map on picto click
     *
     * @param {Event} e - MouseEvent
     * @private
     */
  }, {
    key: "_onDropLayerClick",
    value: function _onDropLayerClick(e) {
      var divId = e.target.id; // ex GPvisibilityPicto_ID_26
      var layerID = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_4__["default"].index(divId); // ex. 26
      var layer = this._layers[layerID].layer;

      // le retrait de la couche va déclencher l'ecouteur d'évenement,
      // et appeler this.removeLayer qui va supprimer la div.
      this.getMap().getLayers().remove(layer);
    }

    /**
     * change layers order (on map) on drag and drop (on control container)
     *
     * @private
     */
  }, {
    key: "_onDragAndDropLayerClick",
    value: function _onDragAndDropLayerClick() {
      var _this6 = this;
      // INFO : e.oldIndex et e.newIndex marchent en mode AMD mais pas Bundle.
      var map = this.getMap();

      // on récupère l'ordre des div dans le contrôle pour réordonner les couches (avec zindex)
      var matchesLayers = document.querySelectorAll("div.GPlayerSwitcher_layer");
      var maxZIndex = matchesLayers.length;
      // on vide la liste ordonnée avant de la remplir avec l'ordre des couches selon les div.
      this._layersOrder = [];
      for (var i = 0; i < matchesLayers.length; i++) {
        var tag = matchesLayers[i].id;
        var id = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_4__["default"].index(tag);
        var layer = this._layers[id].layer;

        // on commence par désactiver temporairement l'écouteur d'événements sur le changement de zindex.
        (0,ol_Observable__WEBPACK_IMPORTED_MODULE_2__.unByKey)(this._layers[id].onZIndexChangeEvent);
        this._layers[id].onZIndexChangeEvent = null;
        if (layer.setZIndex) {
          // maxZIndex--;
          layer.setZIndex(maxZIndex);
          this._layersOrder.push(this._layers[id]);
          maxZIndex--;
        }

        // et on réactive l'écouteur d'événement sur les zindex
        if (this._layers[id].onZIndexChangeEvent == null) {
          this._layers[id].onZIndexChangeEvent = layer.on("change:zIndex", function () {
            return _this6._updateLayersOrder();
          });
        }
      }

      // mise à jour de la visu
      map.updateSize();
    }

    /**
     * check layers range on map movement
     *
     * @param {ol.Map} map - ol map on which event occured
     * @private
     */
  }, {
    key: "_onMapMoveEnd",
    value: function _onMapMoveEnd(map) {
      var _this7 = this;
      // pour chaque couche de la map, on vérifie qu'elle soit toujours dans la visu (inRange)
      map.getLayers().forEach(function (layer) {
        var id = layer.gpLayerId;
        if (_this7._layers[id]) {
          var layerOptions = _this7._layers[id];

          // Check if layer is out of range.
          var layerDiv;
          if (_this7.isInRange(layer, map) && !layerOptions.inRange) {
            layerOptions.inRange = true;
            layerDiv = document.getElementById(_this7._addUID("GPlayerSwitcher_ID_" + id));
            layerDiv.classList.remove("outOfRange");
          } else if (!_this7.isInRange(layer, map) && layerOptions.inRange) {
            layerOptions.inRange = false;
            layerDiv = document.getElementById(_this7._addUID("GPlayerSwitcher_ID_" + id));
            layerDiv.classList.add("outOfRange");
          }
        }
      });
    }

    // ################################################################### //
    // ############################ Utils ################################ //
    // ################################################################### //

    /**
     * Returns Layer Container Id associated with given olLayer
     *
     * @param {ol.layer.Layer} olLayer - ol layer object
     * @returns {String} - div container Id ; null if layer not found.
     */
  }, {
    key: "getLayerDOMId",
    value: function getLayerDOMId(olLayer) {
      var foundId = null;
      this.getMap().getLayers().forEach(function (layer) {
        if (layer === olLayer) {
          foundId = layer.hasOwnProperty("gpLayerId") ? layer.gpLayerId : null;
        }
      });

      // TODO : recuperer "GPlayerSwitcher_ID" depuis une constante
      return foundId !== null ? this._addUID("GPlayerSwitcher_ID_" + foundId) : null;
    }

    /**
     * Check if map view is out of layer range (in terms of extent and zoom)
     *
     * @param {Object} layer - the ol.layer object
     * @param {Object} map   - the ol.Map object
     * @returns {Boolean} outOfRange - false if map view is out of layer range
     */
  }, {
    key: "isInRange",
    value: function isInRange(layer, map) {
      if (!map) {
        return;
      }
      // check if map zoom is in layer zoom range
      var mapResolution = map.getView().getResolution();
      if (mapResolution > layer.getMaxResolution() || mapResolution < layer.getMinResolution()) {
        return false;
      }

      // check if map extent intersects layer extent (if defined)
      var mapExtent = map.getView().calculateExtent(map.getSize());
      var layerExtent = layer.getExtent();
      if (layerExtent && !(0,ol_extent__WEBPACK_IMPORTED_MODULE_3__.intersects)(mapExtent, layerExtent)) {
        return false;
      }
      return true;
    }

    /**
     * Get layer informations : title, description, quicklookurl, legends, metadata
     *
     * @param {Object} layer - the ol.layer object
     * @returns {Object} layerInfo - layer informations
     */
  }, {
    key: "getLayerInfo",
    value: function getLayerInfo(layer) {
      var layerInfo = {};
      if (layer.getProperties !== undefined && layer.getSource !== undefined) {
        var layerProperties = layer.getProperties();
        var src = layerProperties.source;
        if (src) {
          layerInfo._title = src._title || layerProperties.id || "";
          layerInfo._description = src._description || "";
          layerInfo._quicklookUrl = src._quicklookUrl || "";
          layerInfo._metadata = src._metadata || [];
          layerInfo._legends = src._legends || [];
        }
      }
      return layerInfo;
    }
  }]);
}(_Control__WEBPACK_IMPORTED_MODULE_1__["default"]);

// on récupère les méthodes de la classe commune LayerSwitcherDOM
Object.assign(LayerSwitcher.prototype, _LayerSwitcherDOM__WEBPACK_IMPORTED_MODULE_6__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayerSwitcher);

// Expose LayerSwitcher as ol.control.LayerSwitcher (for a build bundle)
if (window.ol && window.ol.control) {
  window.ol.control.LayerSwitcher = LayerSwitcher;
}

/***/ }),

/***/ "./src/packages/Controls/LayerSwitcher/LayerSwitcherDOM.js":
/*!*****************************************************************!*\
  !*** ./src/packages/Controls/LayerSwitcher/LayerSwitcherDOM.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var sortablejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sortablejs */ "./node_modules/sortablejs/modular/sortable.esm.js");

var LayerSwitcherDOM = {
  /**
   * Creation du drag and drop
   *
   * @param {Object} elementDraggable - Element HTML (DOM) Container
   * @param {Object} context - this
   */
  _createDraggableElement: function _createDraggableElement(elementDraggable, context) {
    // FIXME retirer cette détection user-agent pour solution propre
    // option forcefallback pour réparer sortable sous Chrome 97
    // option forcefallback casse le layerswitcher du portail sous firefox
    if (navigator.userAgent.match(/chrome|chromium|crios/i)) {
      sortablejs__WEBPACK_IMPORTED_MODULE_0__["default"].create(elementDraggable, {
        handle: ".GPlayerName",
        draggable: ".draggable-layer",
        ghostClass: "GPghostLayer",
        animation: 200,
        forceFallback: true,
        // Call event function on drag and drop
        onEnd: function onEnd(e) {
          // FIXME pas terrrible, mais il faut bien passer ce contexte...
          context._onDragAndDropLayerClick(e);
        }
      });
    } else {
      sortablejs__WEBPACK_IMPORTED_MODULE_0__["default"].create(elementDraggable, {
        handle: ".GPlayerName",
        draggable: ".draggable-layer",
        ghostClass: "GPghostLayer",
        animation: 200,
        // Call event function on drag and drop
        onEnd: function onEnd(e) {
          // FIXME pas terrrible, mais il faut bien passer ce contexte...
          context._onDragAndDropLayerClick(e);
        }
      });
    }
  },
  // ################################################################### //
  // ######################### Main container ########################## //
  // ################################################################### //

  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Creation du container principal (DOM)
   *
   * @returns {DOMElement} container - layer switcher DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GPlayerSwitcher");
    container.className = "GPwidget gpf-widget gpf-widget-button";
    return container;
  },
  /**
   * Creation du container principal d"affichage des layers (DOM)
   *
   * @returns {DOMElement} input - element for minimizing/maximizing the layer switcher
   */
  _createMainLayersShowElement: function _createMainLayersShowElement() {
    // <!-- Hidden checkbox for minimizing/maximizing -->
    var input = document.createElement("input");
    input.id = this._addUID("GPshowLayersList");
    input.type = "checkbox";
    return input;
  },
  /**
   * Creation du container principal des layers (DOM)
   *
   * @returns {DOMElement} container - layers list container
   */
  _createMainLayersElement: function _createMainLayersElement() {
    // ajout de la liste des layers dans le container principal
    // <div id="GPlayersList" class="GPpanel">
    //   (...)
    // </div>
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GPlayersList");
    dialog.className = "GPpanel gpf-panel fr-modal";
    return dialog;
  },
  _createMainLayersDivElement: function _createMainLayersDivElement() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    return div;
  },
  /**
   * Creation du container du picto du controle (DOM)
   *
   * @returns {DOMElement} label
   */
  _createMainPictoElement: function _createMainPictoElement() {
    var self = this;
    var button = document.createElement("button");
    button.id = this._addUID("GPshowLayersListPicto");
    button.className = "GPshowOpen GPshowAdvancedToolPicto gpf-btn gpf-btn-icon-layerswitcher fr-btn";
    button.htmlFor = this._addUID("GPshowLayersList");
    button.title = "Afficher/masquer le gestionnaire de couches";
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    if (button.addEventListener) {
      button.addEventListener("click", function (e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        document.getElementById(self._addUID("GPshowLayersList")).checked = status;
        if (document.getElementById(self._addUID("GPshowLayersList")).checked) {
          var layers = document.getElementsByClassName("GPlayerInfoOpened");
          for (var i = 0; i < layers.length; i++) {
            layers[i].className = "GPlayerInfo";
          }
          document.getElementById(self._addUID("GPlayerInfoPanel")).className = "GPlayerInfoPanelClosed";
        }
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function (e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        if (document.getElementById(self._addUID("GPshowLayersList")).checked) {
          var layers = document.getElementsByClassName("GPlayerInfoOpened");
          for (var i = 0; i < layers.length; i++) {
            layers[i].className = "GPlayerInfo";
          }
          document.getElementById(self._addUID("GPlayerInfoPanel")).className = "GPlayerInfoPanelClosed";
        }
      });
    }
    return button;
  },
  /**
   * Creation du container du panneau d"information (DOM)
   *
   * @returns {DOMElement} container
   */
  _createMainInfoElement: function _createMainInfoElement() {
    // gestion du panneau d"information dans le container principal
    // <div id="GPlayerInfoPanel" class="GPlayerInfoPanelClosed">...</div>
    var div = document.createElement("div");
    div.id = this._addUID("GPlayerInfoPanel");
    div.className = "GPpanel GPlayerInfoPanelClosed gpf-panel fr-modal";
    return div;
  },
  // ################################################################### //
  // ######################### Layer container ######################### //
  // ################################################################### //

  /**
   * Creation du container du layer (DOM)
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
   * @param {Object} obj.layer - couche (ol ou leaflet)
   * @param {String} obj.id - identifiant de la couche (pour ol ou leaflet)
   * @param {String} obj.title - nom de la couche à afficher dans le controle
   * @param {String} obj.description - description de la couche à afficher
   * @param {Boolean} obj.visibility - visibilité de la couche dans la carte (true or false)
   * @param {Float} obj.opacity - opacité de la couche
   *
   * @returns {DOMElement} container
   */
  _createContainerLayerElement: function _createContainerLayerElement(obj) {
    // exemple :
    // <div id="GPlayerSwitcher_ID_Layer1" class="GPlayerSwitcher_layer outOfRange">
    //     <!-- Basic toolbar : visibility / layer name
    //     _createBasicToolElement
    //           _createBasicToolVisibilityElement
    //           _createBasicToolNameElement
    //     -->
    //     <!-- Hidden checkbox + label for showing advanced toolbar
    //     _createAdvancedToolShowElement
    //     -->
    //     <!-- Advanced toolbar : layer info / opacity slider / opacity value / removal
    //     _createAdvancedToolElement
    //           _createAdvancedToolDeleteElement
    //           _createAdvancedToolInformationElement
    //           _createAdvancedToolOpacityElement
    //     -->
    // </div>

    // <!-- Layer entry in layer list -->
    // <!-- Every item is marked with layerID, which is defined at layer import -->
    var container = document.createElement("div");
    container.id = this._addUID("GPlayerSwitcher_ID_" + obj.id);
    container.className = "GPlayerSwitcher_layer gpf-panel__content fr-modal__content draggable-layer";

    // ajout des outils basiques (visibility / layer name)
    container.appendChild(this._createBasicToolElement(obj));

    // liste des outils avancés (layer info / opacity slider / opacity value / removal)
    var array = this._createAdvancedToolShowElement(obj);
    for (var i = 0; i < array.length; i++) {
      container.appendChild(array[i]);
    }

    // ajout des outils avancés
    container.appendChild(this._createAdvancedToolElement(obj));
    return container;
  },
  // ################################################################### //
  // ############################ Layer tool ########################### //
  // ################################################################### //

  /**
   * Creation du container des outils basiques du layer (DOM)
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
   *
   * @returns {DOMElement} container
   */
  _createBasicToolElement: function _createBasicToolElement(obj) {
    // exemple :
    // <div id="GPbasicTools_ID_1" class="GPlayerBasicTools">
    //      <!-- _createBasicToolVisibilityElement -->
    //      <!-- _createBasicToolNameElement -->
    // </div>

    var div = document.createElement("div");
    div.id = this._addUID("GPbasicTools_ID_" + obj.id);
    div.className = "GPlayerBasicTools";
    div.appendChild(this._createBasicToolNameElement(obj));
    var array = this._createBasicToolVisibilityElement(obj);
    for (var i = 0; i < array.length; i++) {
      div.appendChild(array[i]);
    }
    return div;
  },
  /**
   * Creation du nom du layer (DOM)
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
   *
   * @returns {DOMElement} container
   */
  _createBasicToolNameElement: function _createBasicToolNameElement(obj) {
    // exemple :
    // <span id="GPname_ID_Layer1" class="GPlayerName" title="Quartiers prioritaires de la ville">Quartiers prioritaires de la ville</span>
    var label = document.createElement("label");
    label.id = this._addUID("GPname_ID_" + obj.id);
    label.className = "GPlayerName gpf-label fr-label";
    label.title = obj.description || obj.title;
    label.innerHTML = obj.title;
    return label;
  },
  /**
   * Creation de l'icone de visibilité du layer (DOM)
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
    * @returns {DOMElement[]} array containing input and label elements
   */
  _createBasicToolVisibilityElement: function _createBasicToolVisibilityElement(obj) {
    // exemple :
    // <input type="checkbox" id="GPvisibility_ID_Layer1" checked="">
    // <label for="GPvisibility_ID_Layer1" id="GPvisibilityPicto_ID_Layer1" class="GPlayerVisibility" title="Afficher/masquer la couche"></label>

    var list = [];
    var checked = typeof obj.visibility !== "undefined" ? obj.visibility : true;
    var id = this._addUID("GPvisibility_ID_" + obj.id);
    var input = document.createElement("input");
    input.id = id;
    input.type = "checkbox";
    input.checked = checked;
    var label = document.createElement("label");
    label.htmlFor = id;
    label.id = this._addUID("GPvisibilityPicto_ID_" + obj.id);
    label.className = "GPlayerVisibility gpf-label fr-label";
    label.title = "Afficher/masquer la couche";

    // add event for visibility change
    var context = this;
    if (input.addEventListener) {
      input.addEventListener("click", function (e) {
        context._onVisibilityLayerClick(e);
      });
    } else if (input.attachEvent) {
      // internet explorer
      input.attachEvent("onclick", function (e) {
        context._onVisibilityLayerClick(e);
      });
    }
    list.push(input);
    list.push(label);
    return list;
  },
  /**
   * Creation de l'affichage du menu des outils avancés du layer (DOM)
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
   *
   * @returns {DOMElement[]} array containing input and label elements
   */
  _createAdvancedToolShowElement: function _createAdvancedToolShowElement(obj) {
    // <input type="checkbox" id="GPshowAdvancedTools_ID_Layer1">
    // <label for="GPshowAdvancedTools_ID_Layer1" id="GPshowAdvancedToolsPicto_ID_Layer1" class="GPshowMoreOptions GPshowLayerAdvancedTools" title="Plus d'outils"></label>

    var list = [];
    var label = document.createElement("label");
    label.id = this._addUID("GPshowAdvancedToolsPicto_ID_" + obj.id);
    label.htmlFor = this._addUID("GPshowAdvancedTools_ID_" + obj.id);
    label.title = "Plus d'outils";
    label.className = "GPshowMoreOptions GPshowLayerAdvancedTools gpf-label fr-label";
    var input = document.createElement("input");
    input.type = "checkbox";
    input.id = this._addUID("GPshowAdvancedTools_ID_" + obj.id);
    list.push(input);
    list.push(label);
    return list;
  },
  /**
   * Creation du container des outils avancés du layer (DOM)
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
   *
   * @returns {DOMElement} container
   */
  _createAdvancedToolElement: function _createAdvancedToolElement(obj) {
    // exemple :
    // <div id="GPadvancedTools_ID_Layer1" class="GPlayerAdvancedTools">
    //     <!-- _createAdvancedToolDeleteElement -->
    //     <!-- _createAdvancedToolInformationElement -->
    //     <!-- _createAdvancedToolOpacityElement -->
    // </div>

    var container = document.createElement("div");
    container.id = this._addUID("GPadvancedTools_ID_" + obj.id);
    container.className = "GPlayerAdvancedTools";
    container.appendChild(this._createAdvancedToolDeleteElement(obj));

    // si on n'a de l'informations à afficher, on met en place ce composant
    if (obj.title && obj.description) {
      container.appendChild(this._createAdvancedToolInformationElement(obj));
    }
    if (obj.type !== "feature") {
      var array = this._createAdvancedToolOpacityElement(obj);
      for (var i = 0; i < array.length; i++) {
        container.appendChild(array[i]);
      }
    }
    return container;
  },
  /**
   * Creation de l'icone de suppression du layer (DOM)
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
   *
   * @returns {DOMElement} container
   */
  _createAdvancedToolDeleteElement: function _createAdvancedToolDeleteElement(obj) {
    // exemple :
    // <div id="GPremove_ID_Layer1" class="GPlayerRemove" title="Supprimer la couche" onclick="GPdropLayer(this);"></div>

    var div = document.createElement("div");
    div.id = this._addUID("GPremove_ID_" + obj.id);
    div.className = "GPlayerRemove";
    div.title = "Supprimer la couche";
    div.layerId = obj.id;
    var context = this;
    if (div.addEventListener) {
      div.addEventListener("click", function (e) {
        context._onDropLayerClick(e);
      });
    } else if (div.attachEvent) {
      // internet explorer
      div.attachEvent("onclick", function (e) {
        context._onDropLayerClick(e);
      });
    }
    return div;
  },
  /**
   * Creation de l'icone d'information du layer (DOM)
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
   *
   * @returns {DOMElement} container
   */
  _createAdvancedToolInformationElement: function _createAdvancedToolInformationElement(obj) {
    // exemple :
    // <div id="GPinfo_ID_Layer1" class="GPlayerInfo" title="Informations/légende" onclick="GPopenLayerInfo(this);"></div>

    var div = document.createElement("div");
    div.id = this._addUID("GPinfo_ID_" + obj.id);
    div.className = "GPlayerInfo";
    div.title = "Informations/légende";
    div.layerId = obj.id;
    // add event on click
    var context = this;
    if (div.addEventListener) {
      div.addEventListener("click", function (e) {
        context._onOpenLayerInfoClick(e);
      });
    } else if (div.attachEvent) {
      // internet explorer
      div.attachEvent("onclick", function (e) {
        context._onOpenLayerInfoClick(e);
      });
    }
    return div;
  },
  /**
   * Creation de l'icone de gestion de l'opacité du layer (DOM)
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
   *
   * @returns {DOMElement[]} array of two containers
   */
  _createAdvancedToolOpacityElement: function _createAdvancedToolOpacityElement(obj) {
    // exemple :
    // <div id="GPopacity_ID_Layer1" class="GPlayerOpacity" title="Opacité">
    //   <input id="GPopacityRange_ID_Layer1" type="range" value="100" oninput="GPchangeLayerOpacity(this);" onchange="GPchangeLayerOpacity(this);">
    // </div>
    // <div class="GPlayerOpacityValue" id="GPopacityValueDiv_ID_Layer1">
    //   <span id="GPopacityValue_ID_Layer1">100</span>
    //   %
    // </div>

    var list = [];

    // curseur pour changer l'opacité
    var divO = document.createElement("div");
    divO.id = this._addUID("GPopacity_ID_" + obj.id);
    divO.className = "GPlayerOpacity";
    divO.title = "Opacité";
    var opacity = typeof obj.opacity !== "undefined" ? obj.opacity : 1;
    opacity = Math.round(opacity * 100);
    var input = document.createElement("input");
    input.id = this._addUID("GPopacityValueDiv_ID_" + obj.id);
    input.type = "range";
    input.value = opacity;
    input.ariaLabel = "Opacité";

    // add event for opacity change
    var context = this;
    if (input.addEventListener) {
      input.addEventListener("change", function (e) {
        context._onChangeLayerOpacity(e);
      });
    } else if (input.attachEvent) {
      // internet explorer
      input.attachEvent("onchange", function (e) {
        context._onChangeLayerOpacity(e);
      });
    }
    if (input.addEventListener) {
      input.addEventListener("input", function (e) {
        context._onChangeLayerOpacity(e);
      });
    } else if (input.attachEvent) {
      // internet explorer
      input.attachEvent("oninput", function (e) {
        context._onChangeLayerOpacity(e);
      });
    }
    divO.appendChild(input);

    // Valeur d'opacité
    var divC = document.createElement("div");
    divC.id = this._addUID("GPopacityValueDiv_ID_" + obj.id);
    divC.className = "GPlayerOpacityValue";
    var span = document.createElement("span");
    span.id = this._addUID("GPopacityValue_ID_" + obj.id);
    span.innerHTML = opacity + "%";
    divC.appendChild(span);
    list.push(divO);
    list.push(divC);
    return list;
  },
  // ################################################################### //
  // ############################ Layer info ########################### //
  // ################################################################### //

  /**
   * Creation du container du layer info (DOM)
   *
   * TODO GPlayerInfoPopup : ???
   * TODO GPlayerInfoLink  : mettre en forme les échelles !
   *
   * @param {Object} obj - options de la couche à ajouter dans le layer switcher
   *
   * @returns {DOMElement} container
   */
  _createContainerLayerInfoElement: function _createContainerLayerInfoElement(obj) {
    var container = document.createElement("div");
    container.id = this._addUID("GPlayerInfoContent");
    var title = document.createElement("div");
    title.id = this._addUID("GPlayerInfoTitle");
    title.innerHTML = obj.title;
    container.appendChild(title);
    if (obj.quicklookUrl) {
      var quick = document.createElement("div");
      quick.id = this._addUID("GPlayerInfoQuicklook");
      quick.title = "Afficher un aperçu de la couche";
      var refquick = document.createElement("a");
      refquick.href = obj.quicklookUrl;
      refquick.appendChild(quick);
      container.appendChild(refquick);
    }
    var close = document.createElement("div");
    close.id = this._addUID("GPlayerInfoClose");
    close.title = "Fermer la fenêtre";
    var self = this;
    /** Call event function on close click */
    var onCloseClick = function onCloseClick() {
      document.getElementById(self._addUID("GPlayerInfoPanel")).className = "GPlayerInfoPanelClosed";
      var layers = document.getElementsByClassName("GPlayerInfoOpened");
      for (var i = 0; i < layers.length; i++) {
        layers[i].className = "GPlayerInfo";
      }
    };
    if (close.addEventListener) {
      close.addEventListener("click", onCloseClick);
    } else if (close.attachEvent) {
      // internet explorer
      close.attachEvent("onclick", onCloseClick);
    }
    container.appendChild(close);
    var desc = document.createElement("div");
    desc.id = this._addUID("GPlayerInfoDescription");
    desc.innerHTML = obj.description;
    container.appendChild(desc);
    if (obj.metadata) {
      var mtd = document.createElement("div");
      mtd.id = this._addUID("GPlayerInfoMetadata");
      var mtdtitle = document.createElement("div");
      mtdtitle.className = "GPlayerInfoSubtitle";
      mtdtitle.innerHTML = "Métadonnées";
      mtd.appendChild(mtdtitle);
      for (var i = 0; i < obj.metadata.length; i++) {
        var urlmtd = obj.metadata[i].url;
        var mtdlink = document.createElement("div");
        mtdlink.className = "GPlayerInfoLink";
        var refmtd = document.createElement("a");
        refmtd.href = urlmtd;
        refmtd.innerHTML = urlmtd;
        mtdlink.appendChild(refmtd);
        mtd.appendChild(mtdlink);
      }
      if (obj.metadata.length !== 0) {
        container.appendChild(mtd);
      }
    }
    if (obj.legends) {
      var lgd = document.createElement("div");
      lgd.id = this._addUID("GPlayerInfoLegend");
      var lgdtitle = document.createElement("div");
      lgdtitle.className = "GPlayerInfoSubtitle";
      lgdtitle.innerHTML = "Légende";
      lgd.appendChild(lgdtitle);
      var legends = {};
      var maxScale = obj.maxScaleDenominator || 560000000;

      // on crée un tableau temporaire pour ordonner les légendes selon le dénominateur d'échelle
      for (var k = 0; k < obj.legends.length; k++) {
        var minScale = obj.legends[k].minScaleDenominator;
        if (minScale) {
          var s = minScale.toString();
          minScale = Math.round(parseInt(s.substring(0, 3), 10) / 10) * Math.pow(10, s.length - 2);
        } else {
          minScale = 270;
        }
        legends[minScale] = obj.legends[k];
      }
      for (var scale in legends) {
        if (legends.hasOwnProperty(scale)) {
          var urllgd = legends[scale].url;
          // on n'affiche pas les légendes pointant vers "nolegend.jpg"
          if (typeof urllgd === "string" && urllgd.toLowerCase().indexOf("nolegend.jpg") === -1) {
            // TODO GPlayerInfoPopup
            var lgdlink = document.createElement("div");
            lgdlink.className = "GPlayerInfoLink";
            maxScale = legends[scale].maxScaleDenominator || maxScale;
            var reflgd = document.createElement("a");
            reflgd.href = urllgd;
            reflgd.innerHTML = "Du 1/" + scale + " au 1/" + maxScale;
            lgdlink.appendChild(reflgd);
            lgd.appendChild(lgdlink);
          } else {
            delete legends[scale];
          }
        }
      }
      if (Object.keys(legends).length !== 0) {
        container.appendChild(lgd);
      }
    }
    return container;
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayerSwitcherDOM);

/***/ }),

/***/ "./src/packages/Controls/LocationSelector/LocationSelector.js":
/*!********************************************************************!*\
  !*** ./src/packages/Controls/LocationSelector/LocationSelector.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CSS_Controls_LocationSelector_GPFlocation_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../CSS/Controls/LocationSelector/GPFlocation.css */ "./src/packages/CSS/Controls/LocationSelector/GPFlocation.css");
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ol/control/Control */ "ol/control/Control");
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_control_Control__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ol/Overlay */ "ol/Overlay");
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_Overlay__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ol/proj */ "ol/proj");
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_proj__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ol/Observable */ "ol/Observable");
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_Observable__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var geoportal_access_lib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! geoportal-access-lib */ "./node_modules/geoportal-access-lib/src/Gp.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../Utils/Helper */ "./src/packages/Utils/Helper.js");
/* harmony import */ var _Utils_GeocodeUtils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../Utils/GeocodeUtils */ "./src/packages/Utils/GeocodeUtils.js");
/* harmony import */ var _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../Utils/SelectorID */ "./src/packages/Utils/SelectorID.js");
/* harmony import */ var _Utils_Markers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Utils/Markers */ "./src/packages/Controls/Utils/Markers.js");
/* harmony import */ var _LocationSelectorDOM__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./LocationSelectorDOM */ "./src/packages/Controls/LocationSelector/LocationSelectorDOM.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
// import CSS

// import "../../CSS/Controls/LocationSelector/GPFlocationStyle.css";
// import OpenLayers




// import geoportal library access

// import local





// DOM

var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_6__["default"].getLogger("locationselector");

/**
 * @classdesc
 *
 * LocationSelector component. Enables to select a location, using autocompletion or picking location on the map
 * @constructor
 * @extends {ol.control.Control}
 * @alias ol.control.LocationSelector
 * @type {ol.control.LocationSelector}
 * @param {Object} [options] - component options
 * @param {String} [options.apiKey] - API key for autocomplete service call. The key "calcul" is used by default.
 * @param {Boolean} [options.ssl = true] - use of ssl or not (default true, service requested using https protocol)
 * @param {Boolean} [options.displayInfo = true] - whether to display info in a popup or not (not implemented yet) Default is true
 * @param {Object} [options.tag] - tag options
 * @param {Number} [options.tag.id = 1] - order id number in a locations group, in case several LocationSelector are used. For instance in route case : departure tag id should be 0, arrival tag id should be 1, and other ones : 2, 3, ...
 * @param {Number} [options.tag.groupId = null] - locationSelector global component id (in case locationSelector is called by another graphic component, e.g. route control)
 * @param {String} [options.tag.label] - text to display in component (e.g. "Departure"). Default is ">"
 * @param {Object} [options.tag.markerOpts] - options to use your own marker. Default is a lightOrange marker.
 * @param {String} [options.tag.markerOpts.url] - marker base64 encoded url (ex "data:image/png;base64,...""). Mandatory for a custom marker
 * @param {Array} [options.tag.markerOpts.offset] - Offsets in pixels used when positioning the overlay. The first element in the array is the horizontal offset. A positive value shifts the overlay right. The second element in the array is the vertical offset. A positive value shifts the overlay down. Default is [0, 0]. (see {@link http://openlayers.org/en/latest/apidoc/ol.Overlay.html ol.Overlay})
 * @param {Boolean} [options.tag.display = true] - whether to display or hide component. Default is true
 * @param {Boolean} [options.tag.addOption = false] - whether to display picto to add another LocationSelector (in case of route control)
 * @param {Boolean} [options.tag.removeOption = false] - whether to display picto to remove a LocationSelector (in case of route control)
 * @param {Object} [options.autocompleteOptions] - autocomplete service options (see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~autoComplete Gp.Services.autoComplete()} to know all autocomplete options)
 * @example
 *  var locationselector = new LocationSelector({
 *      apiKey : "",
 *      tag : {
 *         id : 1,
 *         groupId : null,
 *         label : "Départ",
 *         markerOpts : {
 *              url : "...",
 *              offset : [0,0]
 *         },
 *         display : true
 *      },
 *      autocompleteOptions : {}
 *  });
 */
var LocationSelector = /*#__PURE__*/function (_Control) {
  /**
   * See {@link ol.control.LocationSelector}
   * @module LocationSelector
   * @alias module:~controls/LocationSelector
   * @param {*} options - options
   * @example
   * import LocationSelector from "gpf-ext-ol/controls/LocationSelector"
   * ou 
   * import { LocationSelector } from "gpf-ext-ol"
   */
  function LocationSelector(options) {
    var _this;
    _classCallCheck(this, LocationSelector);
    options = options || {};
    _this = _callSuper(this, LocationSelector, [{
      element: options.element || document.createElement("div"),
      render: options.render,
      target: options.target
    }]);
    if (!(_this instanceof LocationSelector)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }

    // initialisation du composant
    _this.initialize(options);

    // creation du DOM
    _this._container = _this._initContainer();

    // ajout du container
    _this.element ? _this.element.appendChild(_this._container) : _this.element = _this._container;
    return _possibleConstructorReturn(_this, _this);
  }

  /**
   * initialize component
   *
   * @param {Object} options - options
   */
  _inherits(LocationSelector, _Control);
  return _createClass(LocationSelector, [{
    key: "initialize",
    value: function initialize(options) {
      // set default options
      this.options = {
        tag: {
          id: 1,
          // numero d'ordre sur un groupe de locations
          groupId: null,
          // id du composant global contenant le LocationSelector
          label: ">",
          display: true,
          addOption: false,
          removeOption: false
        },
        displayInfo: true,
        autocompleteOptions: {}
      };

      // merge with user options
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_7__["default"].mergeParams(this.options, options);

      /** uuid */
      this._uid = this.options.tag.groupId || _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_9__["default"].generate();
      // info : si un uid (groupId) est spécifié
      // (par ex si ce composant est appélé par un autre composant graphique)
      // alors on le récupère, sinon c'est qu'il est indépendant : on génère donc un uuid

      /** container map */
      this._map = null;

      /** container principal des entrées  */
      this._inputsContainer = null;

      /** container du label du point */
      this._buttonLabel = null;

      /** container de la saisi de l'autocompletion */
      this._inputAutoComplete = null;

      /** container du pointer de saisi sur la carte */
      this._inputShowPointerContainer = null;

      /** label du pointer de saisi sur la carte (avec img) */
      this._inputShowPointer = null;

      /** container des coordonnées */
      this._inputCoordinateContainer = null;

      /** elements pour ajouter ou supprimer un nouveau point */
      this._addPointElement = null;
      this._removePointElement = null;

      /** coordonnées du point selectionné, en EPSG:4326 */
      this._coordinate = null;

      /** container des reponses de l'autocompletion */
      this._suggestedContainer = null;
      this._suggestedList = null;

      /** listes des reponses de l'autocompletion */
      this._suggestedLocations = [];

      /** localisant */
      this._currentLocation = null;

      /** marker */
      this._initMarker();

      /** ressources du services d'autocompletion (ayant droit!) */
      this._resources = {};

      // listener key for event click on map
      this.listenerKey = null;
    }

    /**
     * initialize marker : url and offset
     *
     * @private
     */
  }, {
    key: "_initMarker",
    value: function _initMarker() {
      // init marker properties
      this._marker = null;
      this._markerUrl = "";
      this._markerOffset = [0, 0];
      if (this.options.tag.markerOpts && this.options.tag.markerOpts.url) {
        // get marker src url
        this._markerUrl = this.options.tag.markerOpts.url;

        // get marker offset
        var offset = this.options.tag.markerOpts.offset;
        if (offset) {
          if (Array.isArray(offset) && offset.length === 2) {
            this._markerOffset = offset;
          } else {
            logger.log("markerOpts.offset should be an array. e.g. : [0,0]");
          }
        }
      } else {
        // set default options for marker
        this._markerUrl = _Utils_Markers__WEBPACK_IMPORTED_MODULE_10__["default"]["lightOrange"];
        this._markerOffset = _Utils_Markers__WEBPACK_IMPORTED_MODULE_10__["default"].defaultOffset;
      }
    }

    // ################################################################### //
    // ########################## publics methods ######################## //
    // ################################################################### //

    /**
     * get coordinate
     *
     * @returns {Array} this._coordinate - point coordinate (EPSG:4326) : [lon, lat]
     */
  }, {
    key: "getCoordinate",
    value: function getCoordinate() {
      return this._coordinate;
    }

    /**
     * set coordinate
     * @param {Object} coordinate - Coordinate in the map projection by default, otherwise, the projection is entered in the following parameter
     * @param {String} crs - Coordinate projection
     */
  }, {
    key: "setCoordinate",
    value: function setCoordinate(coordinate, crs) {
      var map = this.getMap();
      var proj = map.getView().getProjection().getCode();
      // on utilise la projection de la carte
      if (!crs) {
        crs = proj;
      }
      this._setCoordinate(coordinate, crs);

      // on utilise toujours la projection de la carte pour placer le marker
      coordinate = (0,ol_proj__WEBPACK_IMPORTED_MODULE_3__.transform)(coordinate, crs, proj);
      this._setMarker([coordinate[0], coordinate[1]], null, false);
    }

    /**
     * clean all and input
     */
  }, {
    key: "clear",
    value: function clear() {
      this.clearResults();
      this._buttonLabel.click();
    }

    /**
     * clear all results and the marker.
     */
  }, {
    key: "clearResults",
    value: function clearResults() {
      this._currentLocation = null;
      this._coordinate = null;
      this._hideSuggestedLocation();
      this._clearSuggestedLocation();
      this._setMarker();
      // map.un("click", (e) => this.onMouseMapClick(e));
      (0,ol_Observable__WEBPACK_IMPORTED_MODULE_4__.unByKey)(this.listenerKey);
    }

    // ################################################################### //
    // ##################### init component (private) #################### //
    // ################################################################### //

    /**
     * initialize component container
     *
     * @returns {DOMElement} DOM element
     */
  }, {
    key: "_initContainer",
    value: function _initContainer() {
      var _this2 = this;
      var id = this.options.tag.id;

      // create main container
      var container = this._createMainContainerElement();
      var inputs = this._inputsContainer = this._createLocationPointElement(id, this.options.tag.display);
      container.appendChild(inputs);
      var _buttonLabel = this._buttonLabel = this._createLocationPointLabelElement(id, this.options.tag.label);
      inputs.appendChild(_buttonLabel);
      var _inputAutoComplete = this._inputAutoComplete = this._createLocationAutoCompleteteInputElement(id);
      if (_inputAutoComplete.addEventListener) {
        _inputAutoComplete.addEventListener("click", function () {
          return _this2.onAutoCompleteInputClick();
        });
      } else if (_inputAutoComplete.attachEvent) {
        _inputAutoComplete.attachEvent("onclick", function () {
          return _this2.onAutoCompleteInputClick();
        });
      }
      inputs.appendChild(_inputAutoComplete);
      var _inputCoordinate = this._inputCoordinateContainer = this._createLocationCoordinateInputElement(id);
      inputs.appendChild(_inputCoordinate);
      var _inputShowPointer = this._inputShowPointerContainer = this._createLocationPointerShowInputElement(id);
      inputs.appendChild(_inputShowPointer);
      var _inputPointer = this._inputShowPointer = this._createLocationPointerInputElement(id);
      inputs.appendChild(_inputPointer);
      if (this.options.tag.addOption) {
        var _inputAddStage = this._addPointElement = this._createLocationAddPointElement();
        inputs.appendChild(_inputAddStage);
      }
      if (this.options.tag.removeOption) {
        var _inputRemoveStage = this._removePointElement = this._createLocationRemovePointElement(id);
        inputs.appendChild(_inputRemoveStage);
      }
      var resultsPanel = this._suggestedContainer = this._createLocationAutoCompleteElement(id);
      var results = this._suggestedList = this._createLocationAutoCompleteResultElement(id);
      resultsPanel.appendChild(results);
      container.appendChild(resultsPanel);
      return container;
    }

    // ################################################################### //
    // ###################### handlers events (dom) ###################### //
    // ################################################################### //

    /**
     * this method is called by event 'click' on 'GPlocationOrigin' input
     *
     * @private
     */
  }, {
    key: "onAutoCompleteInputClick",
    value: function onAutoCompleteInputClick() {
      if (this._inputAutoComplete && this._inputAutoComplete.value.length > 2) {
        this._displaySuggestedLocation();
      }
    }

    /**
     * this method is called by event 'keyup' on 'GProuteOrigin' tag input
     * (cf. this._createRouteAutoCompleteteInputElement), and it gets the value of input.
     * this value is passed as a parameter for the service autocomplete (text).
     * the results of the request are displayed into a drop down menu.
     * FIXME
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "onAutoCompleteSearchText",
    value: function onAutoCompleteSearchText(e) {
      var _this3 = this;
      var value = e.target.value;
      if (!value) {
        return;
      }

      // on recupere les options du service
      var serviceOptions = this.options.autocompleteOptions || {};
      var _customOnSuccess = serviceOptions.onSuccess || null;
      var _customOnFailure = serviceOptions.onFailure || null;

      // on sauvegarde le localisant
      this._currentLocation = value;

      // on limite les requêtes à partir de 3 car. saisie !
      if (value.length < 3) {
        this._clearSuggestedLocation();
        return;
      }

      // INFORMATION
      // on effectue la requête au service d'autocompletion.
      // on met en place des callbacks afin de recuperer les resultats ou
      // les messages d'erreurs du service.
      // les resultats sont affichés dans une liste deroulante.
      // les messages d'erreurs sont affichés sur la console (?)
      var context = this;
      this._requestAutoComplete({
        text: value,
        maximumResponses: 5,
        // FIXME je limite le nombre de reponse car le container DOM est limité dans l'affichage !!!
        // callback onSuccess
        onSuccess: function onSuccess(results) {
          if (results) {
            var locations = results.suggestedLocations;
            context._fillAutoCompletedLocationListContainer(locations);
            if (_customOnSuccess) {
              _customOnSuccess.call(this, results);
            }
          }
        },
        // callback onFailure
        onFailure: function onFailure(error) {
          // FIXME
          // où affiche t on les messages : ex. 'No suggestion matching the search' ?
          // doit on nettoyer la liste des suggestions dernierement enregistrée :
          context._clearSuggestedLocation();
          logger.log(error.message);
          if (_customOnFailure) {
            _customOnFailure.call(this, error);
          }
        }
      });
      var map = this.getMap();
      map.on("click", function () {
        return _this3._hideSuggestedLocation();
      });
      map.on("pointerdrag", function () {
        return _this3._hideSuggestedLocation();
      });
    }

    /**
     * this method is called by event 'click' on 'GPautoCompleteResultsList' tag div
     * (cf. this._createAutoCompleteListElement), and it selects the location.
     * this location displays a marker on the map.
     * FIXME
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "onAutoCompletedResultsItemClick",
    value: function onAutoCompletedResultsItemClick(e) {
      var idx = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_9__["default"].index(e.target.id);
      if (!idx) {
        return;
      }

      // FIXME
      // les coordonnées sont inversées entre les 2 services !?
      // AutoCompletion : lon/lat ("EPSG:4326")
      // Geocoding : lat/lon
      var position = [this._suggestedLocations[idx].position.x, this._suggestedLocations[idx].position.y];
      // on sauvegarde le point courant (en EPSG:4326, [lon, lat])
      this._coordinate = position;
      var info = {
        type: this._suggestedLocations[idx].type,
        fields: this._suggestedLocations[idx]
      };

      // on ajoute le texte de l'autocomplétion dans l'input
      var label = _Utils_GeocodeUtils__WEBPACK_IMPORTED_MODULE_8__["default"].getSuggestedLocationFreeform(this._suggestedLocations[idx]);
      this._setLabel(label);

      // Info : la position est en EPSG:4326, à transformer dans la projection de la carte
      var view = this.getMap().getView();
      var mapProj = view.getProjection().getCode();
      if (mapProj !== "EPSG:4326") {
        // on retransforme les coordonnées de la position dans la projection de la carte
        position = (0,ol_proj__WEBPACK_IMPORTED_MODULE_3__.transform)(position, "EPSG:4326", mapProj);
      }
      // on centre la vue et positionne le marker, à la position reprojetée dans la projection de la carte
      this._setPosition(position);
      this._setMarker(position, info, this.options.displayInfo);
    }

    /**
     * this method is called by event 'click' on 'GProuteOriginPointerImg' tag input
     * (cf. this._createRoutePointerInputElement), and it create or remove the event of click map.
     *
     * @private
     */
  }, {
    key: "onActivateMapPointClick",
    value: function onActivateMapPointClick() {
      var _this4 = this;
      var map = this.getMap();
      if (this._inputShowPointerContainer.checked) {
        // on efface l'ancien resultat
        this.clearResults();
        this.listenerKey = map.on("click", function (e) {
          return _this4.onMouseMapClick(e);
        });
        this._setCursor("crosshair");
      } else {
        // map.un("click", (e) => this.onMouseMapClick(e));
        (0,ol_Observable__WEBPACK_IMPORTED_MODULE_4__.unByKey)(this.listenerKey);
        this._setCursor();
      }
    }

    /**
     * this method is called by event 'click' on 'GProuteOriginLabel' tag label
     * (cf. this._createRoutePointLabelElement).
     * this point is erased.
     *Missing
     * @private
     */
  }, {
    key: "onLocationClearPointClick",
    value: function onLocationClearPointClick() {
      this._setCursor();
      this.clearResults();
    }

    /**
     * this method is called by event 'click' on 'GProuteStageRemove' tag input
     * (cf. this._createRouteRemovePointElement).
     * this point is deleted
     *
     * @private
     */
  }, {
    key: "onLocationRemovePointClick",
    value: function onLocationRemovePointClick() {
      this._setCursor();
      this.clearResults();
    }

    /**
     * TODO this method is called by event 'click' on 'GProuteStageAdd' tag input
     * (cf. this._createRouteAddPointElement).
     * this point is added as a parameter for the service route.
     *
     * @param {Object} e - HTMLElement
     */
  }, {
    key: "onLocationAddPointClick",
    value: function onLocationAddPointClick(e) {
      logger.log("onRouteAddPointClick", e);
    }

    // ################################################################### //
    // #################### handlers events (control) #################### //
    // ################################################################### //

    /**
     * this method is called by event 'click' on map
     * (cf. this.onRouteMapPointClick), and it gets the coordinate of click on map.
     * this point is saved as a parameter for the service route.
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "onMouseMapClick",
    value: function onMouseMapClick(e) {
      var coordinate = e.coordinate;
      if (!e.map || !e.map.getView()) {
        return;
      }
      var crs = e.map.getView().getProjection();
      this._setCoordinate(coordinate, crs);
      this._setMarker([coordinate[0], coordinate[1]], null, false);

      // on desactive l'event sur la map !
      this.onActivateMapPointClick(e);
    }

    // ################################################################### //
    // ################# pivates methods use by events ################### //
    // ################################################################### //

    /**
     * this sends the label to the panel.
     *
     * @param {String} label - label suggested location
     * @private
     */
  }, {
    key: "_setLabel",
    value: function _setLabel(label) {
      this._inputAutoComplete.value = label;
    }

    /**
     * this change the cursor of the map when entering a point.
     *
     * @param {String} cursor - cursor style
     * @private
     */
  }, {
    key: "_setCursor",
    value: function _setCursor(cursor) {
      var map = this.getMap();
      var div = map.getTargetElement();
      if (cursor) {
        div.style.cursor = cursor;
      } else {
        div.style.cursor = null;
      }
    }

    /**
     * this sends the coordinates to the panel.
     *
     * @method _setCoordinate
     * @param {Array} olCoordinate - ol.Coordinate object [lon, lat] ou [x, y] (proj = map proj system)
     * @param {Object} crs - coordinate CRS (ol.proj.Projection)
     * @private
     */
  }, {
    key: "_setCoordinate",
    value: function _setCoordinate(olCoordinate, crs) {
      // structure
      // ol.Coordinate
      //      [
      //          4   // lon ou x
      //          48  // lat ou y
      //      ]

      // on transforme olCoodinate (dont la projection est celle de la carte) en EPSG:4326
      this._coordinate = (0,ol_proj__WEBPACK_IMPORTED_MODULE_3__.transform)(olCoordinate, crs, "EPSG:4326");

      // INFO : si on veut des DMS
      // var coords = ol.coordinate.toStringHDMS(this._coordinate, 2).split("N ");
      // // coords est du type : "48° 00′ 00″ N 2° 00′ 00″ E". On veut récupérer les 2 coordonnées séparément.
      // var lat = coords[0] + "N";
      // var lng = coords[1];

      // Pour avoir des degrés décimaux :
      var lat = this._coordinate[0].toFixed(4);
      var lng = this._coordinate[1].toFixed(4);
      var value = lng + " / " + lat;
      this.GPdisplayCoordinate(value);
    }

    /**
     * this method is called by this.on*ResultsItemClick()
     * and set center at given position.
     *
     * @param {Array} position - ol.Coordinate object [lon, lat] (en lat/lon : "EPSG:4326")
     * @private
     */
  }, {
    key: "_setPosition",
    value: function _setPosition(position) {
      var view = this.getMap().getView();
      view.setCenter(position);
    }

    /**
     * this method is called by this.on*ResultsItemClick()
     * and displays a marker.
     * FIXME : marker IGN et informations ?
     *
     * @param {Array} position - ol.Coordinate object [lon, lat] ou [x, y]
     * @param {Object} information - suggested or geocoded information
     * @param {Boolean} display - display a popup information
     * @private
     */
  }, {
    key: "_setMarker",
    value: function _setMarker(position, information, display) {
      var map = this.getMap();
      // remove previous markers
      if (this._marker != null) {
        map.removeOverlay(this._marker);
        this._marker = null;
      }
      if (position) {
        var markerDiv = document.createElement("img");
        markerDiv.src = this._markerUrl;
        this._marker = new (ol_Overlay__WEBPACK_IMPORTED_MODULE_2___default())({
          position: position,
          offset: this._markerOffset,
          element: markerDiv,
          stopEvent: false
        });
        map.addOverlay(this._marker);
        if (display) {
          logger.log("marker information : ", information);
        }
        // // FIXME
        // // doit on mettre une information
        // // - correctement construite ?
        // // - uniquement informatif ?
        // // - RIEN ?
        // if (display) {
        //     var popupContent = null;
        //
        //     var values = [];
        //
        //     values.push(information.fields.fullText || "");
        //     values.push(information.fields.street || "");
        //     values.push(information.fields.postalCode || "");
        //     values.push(information.fields.commune || "");
        //
        //     if (information.type === "PositionOfInterest") {
        //         values.push(information.fields.poi || "");
        //         values.push(information.fields.kind || "");
        //     }
        //
        //     popupContent = values.join(" | ");
        //
        //     this._marker.bindPopup(popupContent);
        // }
      }
    }

    /**
     * this method is called by this.onAutoCompleteSearchText()
     * and it clears all suggested location.
     *
     * @private
     */
  }, {
    key: "_clearSuggestedLocation",
    value: function _clearSuggestedLocation() {
      // suppression du dom
      this._suggestedLocations = [];
      if (this._suggestedList) {
        while (this._suggestedList.firstChild) {
          this._suggestedList.removeChild(this._suggestedList.firstChild);
        }
      }
    }

    /**
     * this method is called by event 'click' on map
     * and it hide suggested locations
     *
     * @private
     */
  }, {
    key: "_hideSuggestedLocation",
    value: function _hideSuggestedLocation() {
      if (this._suggestedContainer) {
        this._suggestedContainer.classList.replace("GPelementVisible", "GPelementHidden");
        this._suggestedContainer.classList.replace("gpf-visible", "gpf-hidden");
      }
    }

    /**
     * this method is called by this.onAutoCompleteSearchText()
     * and it clears all suggested location.
     *
     * @private
     */
  }, {
    key: "_displaySuggestedLocation",
    value: function _displaySuggestedLocation() {
      if (this._suggestedContainer) {
        this._suggestedContainer.classList.replace("GPelementHidden", "GPelementVisible");
        this._suggestedContainer.classList.replace("gpf-hidden", "gpf-visible");
      }
    }

    /**
     * this method is called by this.onAutoCompleteSearch()
     * and executes a request to the service.
     *
     * @param {Object} settings - service settings
     * @param {String}   settings.text - text
     * @param {Function} settings.onSuccess - callback
     * @param {Function} settings.onFailure - callback
     * @private
     */
  }, {
    key: "_requestAutoComplete",
    value: function _requestAutoComplete(settings) {
      logger.log("_requestAutoComplete()", settings);

      // on ne fait pas de requête si on n'a pas renseigné de parametres !
      if (!settings || Object.keys(settings).length === 0) {
        return;
      }

      // on ne fait pas de requête si la parametre 'text' est vide !
      if (!settings.text) {
        return;
      }
      logger.log(settings);
      var options = {};
      // on recupere les options du service
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_7__["default"].assign(options, this.options.autocompleteOptions);
      // ainsi que la recherche et les callbacks
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_7__["default"].assign(options, settings);

      // les ressources
      var resources = this._resources["AutoCompletion"] || null;
      if (resources && Array.isArray(resources)) {
        if (!options.filterOptions) {
          options.filterOptions = {};
        }
        options.filterOptions.type = resources;
      }

      // cas où la clef API n'est pas renseignée dans les options du service,
      // on utilise celle renseignée au niveau du controle ou la clé "calcul" par défaut.
      options.apiKey = options.apiKey || this.options.apiKey;

      // si l'utilisateur a spécifié le paramètre ssl au niveau du control, on s'en sert
      // true par défaut (https)
      if (typeof options.ssl !== "boolean") {
        if (typeof this.options.ssl === "boolean") {
          options.ssl = this.options.ssl;
        } else {
          options.ssl = true;
        }
      }
      logger.log(options);
      geoportal_access_lib__WEBPACK_IMPORTED_MODULE_5__["default"].Services.autoComplete(options);
    }

    /**
     * this method is called by this.onAutoCompleteSearchText()
     * and fills the container of the location list.
     * it creates a HTML Element per location
     * (cf. this. ...)
     *
     * @param {Object[]} locations - locations
     *
     * @private
     */
  }, {
    key: "_fillAutoCompletedLocationListContainer",
    value: function _fillAutoCompletedLocationListContainer(locations) {
      if (!locations || locations.length === 0) {
        return;
      }

      // on vide la liste avant de la construire
      var element = this._suggestedList;
      if (element.childElementCount) {
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      }
      for (var i = 0; i < locations.length; i++) {
        // Proposals are dynamically filled in Javascript by autocomplete service
        this._createLocationAutoCompletedLocationElement(this.options.tag.id, locations[i], i);
      }

      // sauvegarde de l'etat des locations
      this._suggestedLocations = locations;
    }
  }]);
}((ol_control_Control__WEBPACK_IMPORTED_MODULE_1___default()));

// on récupère les méthodes de la classe DOM
Object.assign(LocationSelector.prototype, _LocationSelectorDOM__WEBPACK_IMPORTED_MODULE_11__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LocationSelector);

// Expose LocationSelector as ol.control.LocationSelector (for a build bundle)
if (window.ol && window.ol.control) {
  window.ol.control.LocationSelector = LocationSelector;
}

/***/ }),

/***/ "./src/packages/Controls/LocationSelector/LocationSelectorDOM.js":
/*!***********************************************************************!*\
  !*** ./src/packages/Controls/LocationSelector/LocationSelectorDOM.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Utils/SelectorID */ "./src/packages/Utils/SelectorID.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_GeocodeUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Utils/GeocodeUtils */ "./src/packages/Utils/GeocodeUtils.js");



var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__["default"].getLogger("LocationSelectorDOM");
var LocationSelectorDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   * @returns {DOMElement} DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.className = this._addUID("GPlocationPoint"); // ceci permet de gerer les groupes de points !
    container.className += " GPwidget gpf-widget ";
    return container;
  },
  /**
   * Create Container Point
   * see event !
   *
   * @param {Number} id - tag ID
   * @param {Number} display  - display
   * @returns {DOMElement} DOM element
   */
  _createLocationPointElement: function _createLocationPointElement(id, display) {
    var div = document.createElement("div");
    div.id = this._addUID("GPlocationPoint_" + id);
    div.className = display ? "GPflexInput GPlocationStageFlexInput gpf-flex" : "GPflexInput GPelementHidden gpf-flex gpf-hidden";
    div.style.cssText = "";
    return div;
  },
  /**
   * Create Container Point
   * see event !
   *
   * @param {Number} id - tag ID
   * @param {String} text - label
   * @returns {DOMElement} DOM element
   */
  _createLocationPointLabelElement: function _createLocationPointLabelElement(id, text) {
    // contexte d'execution
    var self = this;
    var buttonOrigin = document.createElement("button");
    buttonOrigin.id = this._addUID("GPlocationOriginLabel_" + id);
    buttonOrigin.innerHTML = text;
    buttonOrigin.className = "GPlocationOriginLabel gpf-btn gpf-btn-icon-label fr-btn fr-btn--secondary";
    buttonOrigin.addEventListener("click", function (e) {
      var i = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(this.id);
      var points = document.getElementsByClassName(self._addUID("GPlocationPoint"));
      for (var j = 0; j < points.length; j++) {
        var tag = points[j].childNodes[0].id;
        var id = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(tag);
        document.getElementById(self._addUID("GPlocationPoint_" + id)).style.cssText = "";
      }
      document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).value = "";
      document.getElementById(self._addUID("GPlocationOrigin_" + i)).value = "";
      document.getElementById(self._addUID("GPlocationPoint_" + i)).style.cssText = "";
      document.getElementById(self._addUID("GPlocationOriginPointer_" + i)).checked = false;
      document.getElementById(self._addUID("GPlocationOrigin_" + i)).className = "GPelementShow gpf-show  gpf-input fr-input";
      document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).className = "GPelementHidden gpf-hidden";
      if (document.getElementById(self._addUID("GPlocationStageRemove_" + i))) {
        document.getElementById(self._addUID("GPlocationStageRemove_" + i)).className = "GPlocationStageRemove gpf-btn gpf-btn-icon-remove fr-btn--sm fr-btn--secondary";
      }
      if (document.getElementById(self._addUID("GPlocationStageAdd"))) {
        document.getElementById(self._addUID("GPlocationStageAdd")).className = "GPlocationStageAdd gpf-btn gpf-btn-icon-add fr-btn--sm fr-btn--secondary";
      }
      // document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).disabled = true;
      self.onLocationClearPointClick(e);
    });
    return buttonOrigin;
  },
  /**
   * Create Input AutoComplete Point tag
   *
   * @param {Number} id - tag ID
   * @returns {DOMElement} DOM element
   */
  _createLocationAutoCompleteteInputElement: function _createLocationAutoCompleteteInputElement(id) {
    // contexte d'execution
    var self = this;
    var inputOrigin = document.createElement("input");
    inputOrigin.id = this._addUID("GPlocationOrigin_" + id);
    inputOrigin.className = "GPelementShow gpf-show gpf-input fr-input";
    inputOrigin.type = "text";
    inputOrigin.placeholder = "Saisir une adresse";
    inputOrigin.autocomplete = "off";
    inputOrigin.addEventListener("keyup", function (e) {
      var charCode = e.which || e.keyCode;
      if (charCode === 13 || charCode === 10 || charCode === 38 || charCode === 40) {
        return;
      }
      var i = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(this.id);
      if (document.getElementById(self._addUID("GPlocationOrigin_" + i)).value.length > 2) {
        document.getElementById(self._addUID("GPlocationAutoCompleteList_" + i)).classList.replace("GPelementHidden", "GPelementVisible");
        document.getElementById(self._addUID("GPlocationAutoCompleteList_" + i)).classList.replace("gpf-hidden", "gpf-visible");
      } else {
        document.getElementById(self._addUID("GPlocationAutoCompleteList_" + i)).classList.replace("GPelementVisible", "GPelementHidden");
        document.getElementById(self._addUID("GPlocationAutoCompleteList_" + i)).classList.replace("gpf-visible", "gpf-hidden");
      }
      // gestionnaire d'evenement :
      // on récupère la valeur de saisie pour une requête sur le service d'autocompletion.
      // le resultat de la requête nous permet de recuperer les coordonnées du point...
      self.onAutoCompleteSearchText(e);
    });
    inputOrigin.addEventListener("keydown", function (e) {
      var charCode = e.which || e.keyCode;
      var container = document.getElementById(self._addUID("GPlocationAutoCompleteResult_" + id));

      // si aucun container !?
      if (!container) {
        return;
      }
      var curr = container.getElementsByClassName("GPautoCompleteProposal current");
      var list = container.getElementsByClassName("GPautoCompleteProposal");

      // si aucune suggestion, on ne va pas plus loin !
      var length = list.length;
      if (!length) {
        return;
      }
      var current = null;

      // si aucun item courant, on prend le 1er !
      if (!curr.length) {
        current = list[0];
        current.className = "GPautoCompleteProposal current";
        current.style.color = "#000000";
        current.style["background-color"] = "#CEDBEF";
        return;
      } else {
        current = curr[0];
      }
      var index = parseInt(_Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(current.id), 10);
      var next = index === length - 1 ? list[0] : list[index + 1];
      var prev = index === 0 ? list[length - 1] : list[index - 1];
      current.style["background-color"] = "";
      current.style.color = "";
      prev.style["background-color"] = "";
      prev.style.color = "";
      next.style["background-color"] = "";
      next.style.color = "";
      switch (charCode) {
        case 38:
          // arrow up
          logger.log("arrow up");
          current.className = "GPautoCompleteProposal";
          prev.className = "GPautoCompleteProposal current";
          prev.style.color = "#000000";
          prev.style["background-color"] = "#CEDBEF";
          break;
        case 40:
          // arrow down
          logger.log("arrow down");
          current.className = "GPautoCompleteProposal";
          next.className = "GPautoCompleteProposal current";
          next.style.color = "#000000";
          next.style["background-color"] = "#CEDBEF";
          break;
        case 13:
          // enter
          logger.log("enter");
          current.click(e);
          break;
      }
      current.focus();
    });
    return inputOrigin;
  },
  /**
   * Create Input Coordinate Point tag
   *
   * @param {Number} id - tag ID
   * @returns {DOMElement} DOM element
   */
  _createLocationCoordinateInputElement: function _createLocationCoordinateInputElement(id) {
    // contexte d'execution
    var self = this;
    var inputOriginCoord = document.createElement("input");
    inputOriginCoord.id = this._addUID("GPlocationOriginCoords_" + id);
    inputOriginCoord.className = "GPelementHidden gpf-input gpf-hidden fr-input";
    inputOriginCoord.type = "text";
    inputOriginCoord.disabled = false;
    inputOriginCoord.addEventListener("click", function () {
      var i = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(this.id);
      document.getElementById(self._addUID("GPlocationOriginLabel_" + i)).click();
    });
    return inputOriginCoord;
  },
  /**
   * Create Show Pointer tag
   *
   * @param {Number} id - tag ID
   * @returns {DOMElement} DOM element
   */
  _createLocationPointerShowInputElement: function _createLocationPointerShowInputElement(id) {
    var inputOriginPointer = document.createElement("input");
    inputOriginPointer.id = this._addUID("GPlocationOriginPointer_" + id);
    inputOriginPointer.className = "GPelementHidden gpf-hidden";
    inputOriginPointer.type = "checkbox";
    return inputOriginPointer;
  },
  /**
   * Create Input Pointer tag
   *
   * @param {Number} id - tag ID
   * @returns {DOMElement} DOM element
   */
  _createLocationPointerInputElement: function _createLocationPointerInputElement(id) {
    // contexte d'execution
    var self = this;
    var buttonOriginPointer = document.createElement("button");
    buttonOriginPointer.id = this._addUID("GPlocationOriginPointerImg_" + id);
    buttonOriginPointer.htmlFor = this._addUID("GPlocationOriginPointer_" + id);
    buttonOriginPointer.className = "GPlocationOriginPointerImg gpf-btn gpf-btn-icon-pointer fr-btn fr-btn--secondary";
    buttonOriginPointer.title = "Pointer un lieu sur la carte";
    buttonOriginPointer.addEventListener("click", function (e) {
      e.preventDefault();
      e.stopPropagation();
      var i = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(this.id);
      var points = document.getElementsByClassName(self._addUID("GPlocationPoint"));
      var j;
      var tag;
      var id;
      for (j = 0; j < points.length; j++) {
        tag = points[j].childNodes[0].id;
        id = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(tag);
        if (i !== id) {
          document.getElementById(self._addUID("GPlocationOriginPointer_" + id)).checked = false;
          if (document.getElementById(self._addUID("GPlocationOriginCoords_" + id)).value === "Pointer un lieu sur la carte") {
            document.getElementById(self._addUID("GPlocationOriginCoords_" + id)).value = "";
            document.getElementById(self._addUID("GPlocationOrigin_" + id)).className = "GPelementShow gpf-show  gpf-input fr-input";
            document.getElementById(self._addUID("GPlocationOriginCoords_" + id)).className = "GPelementHidden gpf-hidden";
          }
        }
      }
      if (document.getElementById(self._addUID("GPlocationOriginPointer_" + i)).checked) {
        document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).value = "";
        for (j = 0; j < points.length; j++) {
          tag = points[j].childNodes[0].id;
          id = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(tag);
          document.getElementById(self._addUID("GPlocationPoint_" + id)).style.cssText = "";
        }
        if (document.getElementById(self._addUID("GPlocationStageRemove_" + i))) {
          document.getElementById(self._addUID("GPlocationStageRemove_" + i)).className = "GPlocationStageRemove  gpf-btn gpf-btn-icon-remove fr-btn--sm fr-btn--secondary";
        }
        if (document.getElementById(self._addUID("GPlocationStageAdd"))) {
          document.getElementById(self._addUID("GPlocationStageAdd")).className = "GPlocationStageAdd gpf-btn gpf-btn-icon-add fr-btn--sm fr-btn--secondary";
        }
        document.getElementById(self._addUID("GPlocationOriginPointer_" + i)).checked = false;
        document.getElementById(self._addUID("GPlocationOrigin_" + i)).className = "GPelementShow gpf-show  gpf-input fr-input";
        document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).className = "GPelementHidden gpf-hidden";
      } else {
        document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).value = "Pointer un lieu sur la carte";
        for (j = 0; j < points.length; j++) {
          tag = points[j].childNodes[0].id;
          id = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(tag);
          if (i === id) {
            document.getElementById(self._addUID("GPlocationPoint_" + id)).style.cssText = "";
          } else {
            document.getElementById(self._addUID("GPlocationPoint_" + id)).style.display = "none";
          }
        }
        if (document.getElementById(self._addUID("GPlocationStageRemove_" + i))) {
          document.getElementById(self._addUID("GPlocationStageRemove_" + i)).className = "GPelementHidden gpf-hidden";
        }
        if (document.getElementById(self._addUID("GPlocationStageAdd"))) {
          document.getElementById(self._addUID("GPlocationStageAdd")).className = "GPelementHidden gpf-hidden";
        }
        document.getElementById(self._addUID("GPlocationOriginPointer_" + i)).checked = true;
        document.getElementById(self._addUID("GPlocationOrigin_" + i)).className = "GPelementHidden gpf-hidden";
        document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).className = "GPelementShow gpf-show gpf-input fr-input";
        document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).disabled = true;
      }
      // gestionnaire d'evenement :
      // on stocke la valeur du point, utilisée pour la requête sur le service de calcul d'itiniraire
      self.onActivateMapPointClick(e);
    });
    return buttonOriginPointer;
  },
  /**
   * Create Remove Point tag
   * see event !
   *
   * @param {Number} id - tag ID
   * @returns {DOMElement} DOM element
   */
  _createLocationRemovePointElement: function _createLocationRemovePointElement(id) {
    // contexte d'execution
    var self = this;
    var buttonRm = document.createElement("button");
    buttonRm.id = this._addUID("GPlocationStageRemove_" + id);
    buttonRm.className = "GPlocationOpen GPlocationStageRemove gpf-btn gpf-btn-icon-remove fr-btn--sm fr-btn--secondary";
    buttonRm.title = "Supprimer l'étape";
    buttonRm.setAttribute("tabindex", "0");
    buttonRm.setAttribute("aria-pressed", false);
    buttonRm.addEventListener("click", function (e) {
      var status = e.target.ariaPressed === "true";
      e.target.setAttribute("aria-pressed", !status);
      var points = document.getElementsByClassName(self._addUID("GPlocationPoint"));
      var last = points.length - 1;
      var start = points[0].childNodes[0].id;
      var end = points[last].childNodes[0].id;
      var startID = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(start);
      var endID = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(end);
      if (id !== startID && id !== endID) {
        var i = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(this.id);
        document.getElementById(self._addUID("GPlocationPoint_" + i)).className = "GPflexInput GPelementHidden gpf-flex gpf-hidden";
        document.getElementById(self._addUID("GPlocationOrigin_" + i)).value = "";
        document.getElementById(self._addUID("GPlocationOrigin_" + i)).className = "GPelementShow gpf-show gpf-input fr-input";
        document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).value = "";
        document.getElementById(self._addUID("GPlocationOriginCoords_" + i)).className = "GPelementHidden gpf-hidden";
        document.getElementById(self._addUID("GPlocationStageAdd")).style.display = "";
        // Moving up exclusions picto
        // var exclusionsPictoTop = document.getElementById(self._addUID("GPshowLocationExclusionsPicto")).style.top;
        // document.getElementById(self._addUID("GPshowLocationExclusionsPicto")).style.top = (parseInt(exclusionsPictoTop) - 33).toString() + "px";

        // gestionnaire d'evenement :
        // on supprime le point, utilisé pour la requête sur le service d'itiniraire
        self.onLocationRemovePointClick(e);
      }
    });
    return buttonRm;
  },
  /**
   * Create Add Point tag
   * see event !
   *
   * @returns {DOMElement} DOM element
   */
  _createLocationAddPointElement: function _createLocationAddPointElement() {
    // contexte d'execution
    var self = this;
    var buttonAdd = document.createElement("button");
    buttonAdd.id = this._addUID("GPlocationStageAdd");
    buttonAdd.className = "GPlocationOpen GPlocationStageAdd gpf-btn gpf-btn-icon-add fr-btn--sm fr-btn--secondary";
    buttonAdd.title = "Ajouter une étape";
    buttonAdd.setAttribute("tabindex", "0");
    buttonAdd.setAttribute("aria-pressed", false);
    buttonAdd.addEventListener("click", function (e) {
      var lastStage = 1;
      var nbStages = 0;
      var points = document.getElementsByClassName(self._addUID("GPlocationPoint"));
      for (var i = 1; i < points.length - 1; i++) {
        var tag = points[i].childNodes[0].id;
        var id = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(tag);
        if (document.getElementById(self._addUID("GPlocationPoint_" + id))) {
          if (document.getElementById(self._addUID("GPlocationPoint_" + id)).className === "GPflexInput GPelementHidden gpf-flex gpf-hidden") {
            if (lastStage === 1) {
              lastStage = id;
            }
          } else {
            nbStages++;
          }
        }
      }
      // FIXME algo à revoir : lastStage = id hors si id = 300 sur 3 points !?
      if (lastStage < points.length) {
        document.getElementById(self._addUID("GPlocationPoint_" + lastStage)).className = "GPflexInput GPlocationStageFlexInput gpf-flex";
        // Moving down exclusions picto
        // var exclusionsPictoTop = document.getElementById(self._addUID("GPshowLocationExclusionsPicto")).style.top;
        // document.getElementById(self._addUID("GPshowLocationExclusionsPicto")).style.top = (parseInt(exclusionsPictoTop) + 33).toString() + "px";
      }
      if (nbStages === 4) {
        document.getElementById(self._addUID("GPlocationStageAdd")).style.display = "none";
      }
      // gestionnaire d'evenement :
      // on ajoute le point, utilisé pour la requête sur le service d'itiniraire
      var status = e.target.ariaPressed === "true";
      e.target.setAttribute("aria-pressed", !status);
      self.onLocationAddPointClick(e);
    });
    return buttonAdd;
  },
  _createLocationAutoCompleteElement: function _createLocationAutoCompleteElement(id) {
    var div = document.createElement("div");
    div.id = this._addUID("GPlocationAutoCompleteList_" + id);
    div.className = "GPlocationAutoCompleteList GPelementHidden gpf-panel gpf-hidden fr-modal"; // GPpanel ?

    // FIXME on decompose la fonction pour les besoins du controle,
    // on ajoutera ces childs à la main...
    // div.appendChild(this._createLocationAutoCompleteResultElement ());

    return div;
  },
  /**
   * Create Results autocompletion to the point
   * see event!
   *
   * @param {Number} id - tag ID
   * @returns {DOMElement} DOM element
   */
  _createLocationAutoCompleteResultElement: function _createLocationAutoCompleteResultElement(id) {
    // contexte d'execution
    var self = this;
    var div = document.createElement("div");
    div.id = this._addUID("GPlocationAutoCompleteResult_" + id);
    div.className = "GPadvancedAutoCompleteResult gpf-panel__list";
    if (div.addEventListener) {
      div.addEventListener("click", function (e) {
        self.onAutoCompletedResultsItemClick(e);
        document.getElementById(self._addUID("GPlocationAutoCompleteList_" + id)).classList.replace("GPelementHidden", "GPelementVisible");
        document.getElementById(self._addUID("GPlocationAutoCompleteList_" + id)).classList.replace("gpf-hidden", "gpf-visible");
      }, false);
    } else if (div.attachEvent) {
      div.attachEvent("onclick", function (e) {
        self.onAutoCompletedResultsItemClick(e);
        document.getElementById(self._addUID("GPlocationAutoCompleteList_" + id)).classList.replace("GPelementHidden", "GPelementVisible");
        document.getElementById(self._addUID("GPlocationAutoCompleteList_" + id)).classList.replace("gpf-hidden", "gpf-visible");
      });
    }
    return div;
  },
  /**
   * Autocompletion result to a point.
   * Proposals are dynamically filled in Javascript by autocomplete service
   *
   * TODO formaliser le contenu des reponse
   *
   * @param {Number} id - tag ID
   * @param {Object} location - suggested location result
   * @param {Number} n  - number of the point
   */
  _createLocationAutoCompletedLocationElement: function _createLocationAutoCompletedLocationElement(id, location, n) {
    var container = document.getElementById(this._addUID("GPlocationAutoCompleteResult_" + id));
    var div = document.createElement("div");
    div.id = this._addUID("AutoCompletedLocation_" + n);
    div.className = "GPautoCompleteProposal gpf-panel__items";
    div.innerHTML = _Utils_GeocodeUtils__WEBPACK_IMPORTED_MODULE_2__["default"].getSuggestedLocationFreeform(location);
    container.appendChild(div);
  },
  /**
  * Display Coordinate
  * @param {String} value - a Coordinate
  */
  GPdisplayCoordinate: function GPdisplayCoordinate(value) {
    var points = document.getElementsByClassName(this._addUID("GPlocationPoint"));
    for (var i = 0; i < points.length; i++) {
      var tag = points[i].childNodes[0].id;
      var id1 = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(tag);
      if (document.getElementById(this._addUID("GPlocationOriginPointer_" + id1)).checked) {
        document.getElementById(this._addUID("GPlocationOriginCoords_" + id1)).value = value;
        document.getElementById(this._addUID("GPlocationOriginCoords_" + id1)).disabled = false;
        for (var j = 0; j < points.length; j++) {
          tag = points[j].childNodes[0].id;
          var id2 = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(tag);
          document.getElementById(this._addUID("GPlocationPoint_" + id2)).style.cssText = "";
          if (document.getElementById(this._addUID("GPlocationStageRemove_" + id2))) {
            document.getElementById(this._addUID("GPlocationStageRemove_" + id2)).className = "GPlocationStageRemove gpf-btn gpf-btn-icon-remove fr-btn--sm fr-btn--secondary";
          }
        }
        document.getElementById(this._addUID("GPlocationOriginPointer_" + id1)).checked = false;
        if (document.getElementById(this._addUID("GPlocationStageAdd"))) {
          document.getElementById(this._addUID("GPlocationStageAdd")).className = "GPlocationStageAdd gpf-btn gpf-btn-icon-add fr-btn--sm";
        }
        return;
      }
    }
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LocationSelectorDOM);

/***/ }),

/***/ "./src/packages/Controls/Measures/Measures.js":
/*!****************************************************!*\
  !*** ./src/packages/Controls/Measures/Measures.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ol/Overlay */ "ol/Overlay");
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_Overlay__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ol/interaction */ "ol/interaction");
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_interaction__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ol/style */ "ol/style");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_style__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ol/layer/Vector */ "ol/layer/Vector");
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_layer_Vector__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ol/source/Vector */ "ol/source/Vector");
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_source_Vector__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_Interactions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Utils/Interactions */ "./src/packages/Controls/Utils/Interactions.js");
/* harmony import */ var _LayerSwitcher_LayerSwitcher__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../LayerSwitcher/LayerSwitcher */ "./src/packages/Controls/LayerSwitcher/LayerSwitcher.js");
// import OpenLayers





// import local


// import local with ol dependencies


// Derived from OpenLayers measure example
// http://openlayers.org/en/latest/examples/measure.html

var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_5__["default"].getLogger("measures");

/**
 * @type {ol.control.Measures}
 * @abstract
 * Measures Tools :
 * - length
 * - aera
 * - azimut
 */
var Measures = {
  // ****************************************************************** //
  // > Default Styles
  // ****************************************************************** //

  /*
   * Pointer
   */
  DEFAULT_POINTER_STYLE: new ol_style__WEBPACK_IMPORTED_MODULE_2__.Circle({
    radius: 5,
    stroke: new ol_style__WEBPACK_IMPORTED_MODULE_2__.Stroke({
      color: "#002A50",
      width: 2
    }),
    fill: new ol_style__WEBPACK_IMPORTED_MODULE_2__.Fill({
      color: "rgba(255, 155, 0, 0.7)"
    })
  }),
  /*
   * Measures style line
   */
  DEFAULT_DRAW_START_STYLE: new ol_style__WEBPACK_IMPORTED_MODULE_2__.Style({
    fill: new ol_style__WEBPACK_IMPORTED_MODULE_2__.Fill({
      color: "rgba(0, 183, 152, 0.2)"
    }),
    stroke: new ol_style__WEBPACK_IMPORTED_MODULE_2__.Stroke({
      color: "#002A50",
      lineDash: [10, 10],
      width: 2
    })
  }),
  /*
   * Measures final style line
   */
  DEFAULT_DRAW_FINISH_STYLE: new ol_style__WEBPACK_IMPORTED_MODULE_2__.Style({
    fill: new ol_style__WEBPACK_IMPORTED_MODULE_2__.Fill({
      color: "rgba(0, 183, 152, 0.3)"
    }),
    stroke: new ol_style__WEBPACK_IMPORTED_MODULE_2__.Stroke({
      color: "#002A50",
      width: 3
    })
  }),
  // ****************************************************************** //
  // > ToolBox : these tools work together
  // ****************************************************************** //
  // sample :
  // tools[name_control][0].(active|instance|map)
  // tools : {
  //      MeasureLength : [
  //          { active : true, instance : [Object MeasureLength], map : "map1" },
  //          { active : true, instance : [Object MeasureLength], map : "map2" }
  //      ],
  //      MeasureArea : [],
  //      MeasureAzimuth : []
  // }
  tools: {
    MeasureLength: [],
    MeasureArea: [],
    MeasureAzimuth: []
  },
  // ****************************************************************** //
  // > Variables
  // ****************************************************************** //

  /**
   * Global measure draw interaction
   * @type {ol.interaction.Draw}
   */
  measureDraw: null,
  /**
   * Global vector source for measure
   * @type {ol.source.Vector}
   */
  measureSource: null,
  /**
   * Global vector layer for measure
   * @type {ol.layer.Vector}
   */
  measureVector: null,
  /**
   * Currently drawn feature.
   * @type {ol.Feature}
   */
  sketch: null,
  /**
   * The measure tooltip element.
   * @type {Element}
   */
  measureTooltipElement: null,
  /**
   * Overlay to show the measurement.
   * @type {ol.Overlay}
   */
  measureTooltip: null,
  /**
   * TODO The help tooltip element.
   * @type {Element}
   */
  helpTooltipElement: null,
  /**
   * TODO Overlay to show the help.
   * @type {ol.Overlay}
   */
  helpTooltip: null,
  // ****************************************************************** //
  // > Methods Public
  // ****************************************************************** //

  /** Desactived Tool Measure */
  clean: function clean() {
    var _class = this.CLASSNAME;
    logger.trace("[" + _class + "] deactived tool !");
    // sur la desactivation de l'outil de mesure
    // on fait un nettoyage des ressources
    // ainsi que le DOM
    this.clearMeasure();
    this.clearMeasureToolTip();
    this.removeMeasureEvents();
    this._pictoContainer.setAttribute("aria-pressed", false);
  },
  // ****************************************************************** //
  // > Methods Events
  // ****************************************************************** //

  /**
   * Handle pointer move.
   *
   * @param {ol.MapBrowserEvent} e - The event.
   */
  onPointerMoveHandler: function onPointerMoveHandler(e) {
    if (e.dragging) {
      return;
    }

    /** @type {ol.Coordinate|undefined} */
    var tooltipCoord = e.coordinate;
    if (this.sketch) {
      var output;
      var geom = this.sketch.getGeometry();
      output = this.format(geom);
      if (geom.getType() === "LineString") {
        tooltipCoord = geom.getLastCoordinate();
      } else if (geom.getType() === "Polygon") {
        tooltipCoord = geom.getInteriorPoint().getCoordinates();
      } else {
        return;
      }
      this.measureTooltipElement.innerHTML = output;
      this.measureTooltip.setPosition(tooltipCoord);
    }
  },
  /**
   * Main program !
   * This method is called by event 'click' on control picto
   *
   * @param {Object} e - HTMLElement
   * @param {String} type - LineString or Polygon
   * @private
   */
  onShowMeasureClick: function onShowMeasureClick(e, type) {
    var map = this.getMap();
    var currentMapId = map.getTargetElement().id;

    // contexte d'execution
    var context = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : null;
    if (context) {
      // Pour info
      // les objets de mesures ont du code partagé
      // (afin de gerer les interactions entre eux).
      // Dans un mode "modules", on partage cet objet (this.tools) via le contexte
      // d'execution (ex. avec window)
      this.tools = context.gpShareMeasures || {};
    }

    // desactivation des controles de mesures sur la carte courrante
    var mySelf = this.CLASSNAME; // this.constructor.name : pas possible en mode minifié/manglifié !
    for (var className in this.tools) {
      if (this.tools.hasOwnProperty(className)) {
        var measures = this.tools[className];
        for (var i = 0; i < measures.length; i++) {
          var o = measures[i];
          if (o && o.active && className !== mySelf && o.map === currentMapId) {
            o.active = false;
            if (o.instance !== null) {
              // au cas où le controle a été supprimé !
              o.instance.clean();
            }
          }
        }
      }
    }

    // desactivation des autres interactions parasites
    _Utils_Interactions__WEBPACK_IMPORTED_MODULE_6__["default"].unset(map, {
      current: "Measures"
    });
    var opened = this._pictoContainer.ariaPressed;
    if (opened === "true") {
      this.addMeasureEvents();
      this.initMeasureInteraction();
      this.addMeasureInteraction(type);
      for (var j = 0; j < this.tools[mySelf].length; j++) {
        if (this.tools[mySelf][j].map === currentMapId) {
          this.tools[mySelf][j].active = true;
        }
      }
    } else {
      this.clearMeasure();
      this.clearMeasureToolTip();
      this.removeMeasureEvents();
      for (var k = 0; k < this.tools[mySelf].length; k++) {
        if (this.tools[mySelf][k].map === currentMapId) {
          this.tools[mySelf][k].active = false;
        }
      }
    }
  },
  // ****************************************************************** //
  // > Methods not Public
  // ****************************************************************** //

  /**
   * Clear all dom tooltip of length, area or azimut object.
   */
  clearMeasureToolTip: function clearMeasureToolTip() {
    var map = this.getMap();
    if (!map) {
      return;
    }
    var mapContainer = map.getTargetElement();
    // au cas où il y'aurait plusieurs container de carte !
    var overlays = mapContainer.getElementsByClassName("ol-overlaycontainer");
    for (var k = 0; k < overlays.length; k++) {
      var nodes = overlays[k];
      var len = nodes.children.length;
      var nodesToRemove = [];
      for (var i = 0; i < len; i++) {
        var node = nodes.children[i];
        if (node.children.length !== 0) {
          var child = node.children[0];
          if (child.className === "GPmeasureTooltip GPmeasureTooltip-static" || child.className === "GPmeasureTooltip GPmeasureTooltip-measure") {
            nodesToRemove.push(node);
          }
        }
      }
      for (var j = 0; j < nodesToRemove.length; j++) {
        nodes.removeChild(nodesToRemove[j]);
      }
    }
  },
  /**
   * Clear all length, area or azimut object.
   */
  clearMeasure: function clearMeasure() {
    var map = this.getMap();

    // FIXME !?
    // if (this.measureTooltip) {
    //     map.removeOverlay(this.measureTooltip);
    //     this.measureTooltip = null;
    // }

    if (this.measureVector) {
      map.removeLayer(this.measureVector);
      this.measureVector = null;
    }
    if (this.measureDraw) {
      map.removeInteraction(this.measureDraw);
      this.measureDraw = null;
    }
  },
  /**
   * Creates a new measure tooltip
   * FIXME bug d'affichage de la tooltip de saisie en cours si on ne termine pas
   * la saisie  !?
   *
   * @param {ol.Map} map - The Map.
   */
  createMeasureTooltip: function createMeasureTooltip(map) {
    if (this.measureTooltipElement) {
      this.measureTooltipElement.parentNode.removeChild(this.measureTooltipElement);
    }
    this.measureTooltipElement = document.createElement("div");
    this.measureTooltipElement.className = "GPmeasureTooltip GPmeasureTooltip-measure";
    this.measureTooltip = new (ol_Overlay__WEBPACK_IMPORTED_MODULE_0___default())({
      element: this.measureTooltipElement,
      stopEvent: false,
      offset: [0, -15],
      positioning: "bottom-center"
    });
    map.addOverlay(this.measureTooltip);
  },
  /**
   * TODO evolution
   * Creates a new help tooltip
   *
   * @param {ol.Map} map - The Map.
   */
  createHelpTooltip: function createHelpTooltip(map) {
    if (this.helpTooltipElement) {
      this.helpTooltipElement.parentNode.removeChild(this.helpTooltipElement);
    }
    this.helpTooltipElement = document.createElement("div");
    this.helpTooltipElement.className = "tooltip hidden";
    this.helpTooltip = new (ol_Overlay__WEBPACK_IMPORTED_MODULE_0___default())({
      element: this.helpTooltipElement,
      stopEvent: false,
      offset: [15, 0],
      positioning: "center-left"
    });
    map.addOverlay(this.helpTooltip);
  },
  /**
   * Creates a style for drawing
   *
   * @param {Object} styles - styles.
   */
  createStylingMeasureInteraction: function createStylingMeasureInteraction(styles) {
    this.options.styles = styles || {};

    // style de depart
    logger.trace("style start", this.options.styles.start);

    // Creation à partir des styles par défaut
    var startStyleOpts = {
      image: Measures.DEFAULT_POINTER_STYLE,
      fill: Measures.DEFAULT_DRAW_START_STYLE.getFill(),
      stroke: Measures.DEFAULT_DRAW_START_STYLE.getStroke()
    };
    // ecrasement à partir des propriétés renseignées
    if (this.options.styles.hasOwnProperty("pointer") && this.options.styles.pointer instanceof Image) {
      startStyleOpts.image = this.options.styles.pointer;
    }
    if (this.options.styles.hasOwnProperty("start") && this.options.styles.start instanceof ol_style__WEBPACK_IMPORTED_MODULE_2__.Style) {
      if (this.options.styles.start.getFill() != null) {
        startStyleOpts.fill = this.options.styles.start.getFill();
      }
      if (this.options.styles.start.getStroke() != null) {
        startStyleOpts.stroke = this.options.styles.start.getStroke();
      }
    }
    this.options.styles.start = new ol_style__WEBPACK_IMPORTED_MODULE_2__.Style(startStyleOpts);

    // style de fin
    logger.trace("style finish", this.options.styles.finish);
    var finishStyleOpts = {
      fill: Measures.DEFAULT_DRAW_FINISH_STYLE.getFill(),
      stroke: Measures.DEFAULT_DRAW_FINISH_STYLE.getStroke()
    };
    // ecrasement à partir des propriétés renseignées
    if (this.options.styles.hasOwnProperty("finish") && this.options.styles.finish instanceof ol_style__WEBPACK_IMPORTED_MODULE_2__.Style) {
      if (this.options.styles.finish.getFill() != null) {
        finishStyleOpts.fill = this.options.styles.finish.getFill();
      }
      if (this.options.styles.finish.getStroke() != null) {
        finishStyleOpts.stroke = this.options.styles.finish.getStroke();
      }
    }
    this.options.styles.finish = new ol_style__WEBPACK_IMPORTED_MODULE_2__.Style(finishStyleOpts);
  },
  /**
   * Add the measure interaction
   *
   * @param {String} type - LineString or Polygon.
   */
  addMeasureInteraction: function addMeasureInteraction(type) {
    var map = this.getMap();

    // Creates and adds the interaction
    var self = this;
    this.measureDraw = new ol_interaction__WEBPACK_IMPORTED_MODULE_1__.Draw({
      source: this.measureSource,
      // condition : permet de gerer la suppression des derniers points saisis
      condition: function condition(event) {
        if (event.originalEvent.ctrlKey) {
          if (self.sketch) {
            this.removeLastPoint();
          }
          return false;
        }
        return true;
      },
      type: type,
      style: this.options.styles.start || Measures.DEFAULT_DRAW_START_STYLE
    });
    this.measureDraw.setProperties({
      name: "Measures",
      source: this
    });
    map.addInteraction(this.measureDraw);

    // Create tooltips
    this.createMeasureTooltip(map);

    // Event start measuring
    this.measureDraw.on("drawstart", function (evt) {
      // set sketch
      self.sketch = evt.feature;
    });

    // Event end measuring
    this.measureDraw.on("drawend", function () {
      // FIXME MaJ de la tooltip en mode mobile !
      if (self.sketch) {
        var output;
        var tooltipCoord;
        var geom = self.sketch.getGeometry();
        output = self.format(geom);
        if (geom.getType() === "LineString") {
          tooltipCoord = geom.getLastCoordinate();
        } else if (geom.getType() === "Polygon") {
          tooltipCoord = geom.getInteriorPoint().getCoordinates();
        } else {
          return;
        }
        self.measureTooltipElement.innerHTML = output;
        self.measureTooltip.setPosition(tooltipCoord);
      }
      self.measureTooltipElement.className = "GPmeasureTooltip GPmeasureTooltip-static";
      self.measureTooltip.setOffset([0, -7]);

      // unset sketch
      self.sketch = null;
      // unset tooltip so that a new one can be created
      self.measureTooltipElement = null;
      self.createMeasureTooltip(map);
    });
  },
  /**
   * Init the measure interaction
   */
  initMeasureInteraction: function initMeasureInteraction() {
    var _this = this;
    var map = this.getMap();
    this.measureSource = new (ol_source_Vector__WEBPACK_IMPORTED_MODULE_4___default())();
    this.measureVector = new (ol_layer_Vector__WEBPACK_IMPORTED_MODULE_3___default())({
      source: this.measureSource,
      style: this.options.styles.finish || Measures.DEFAULT_DRAW_FINISH_STYLE
    });

    // on rajoute le champ gpResultLayerId permettant d'identifier une couche crée par le composant.
    this.measureVector.gpResultLayerId = "measure";
    map.addLayer(this.measureVector);

    // Si un layer switcher est présent dans la carte, on lui affecte des informations pour cette couche
    map.getControls().forEach(function (control) {
      if (control instanceof _LayerSwitcher_LayerSwitcher__WEBPACK_IMPORTED_MODULE_7__["default"]) {
        // un layer switcher est présent dans la carte
        var layerId = _this.measureVector.gpLayerId;
        // on n'ajoute des informations que s'il n'y en a pas déjà (si le titre est le numéro par défaut)
        if (control._layers[layerId].title === layerId) {
          control.addLayer(_this.measureVector, {
            title: _this.options.layerDescription.title,
            description: _this.options.layerDescription.description
          });
        }
      }
    });
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Measures);

/***/ }),

/***/ "./src/packages/Controls/Route/Route.js":
/*!**********************************************!*\
  !*** ./src/packages/Controls/Route/Route.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CSS_Controls_Route_GPFroute_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../CSS/Controls/Route/GPFroute.css */ "./src/packages/CSS/Controls/Route/GPFroute.css");
/* harmony import */ var _Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Control */ "./src/packages/Controls/Control.js");
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ol/Observable */ "ol/Observable");
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_Observable__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ol/Overlay */ "ol/Overlay");
/* harmony import */ var ol_Overlay__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_Overlay__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ol/layer/Vector */ "ol/layer/Vector");
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_layer_Vector__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ol/source/Vector */ "ol/source/Vector");
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ol_source_Vector__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var ol_events_condition__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ol/events/condition */ "ol/events/condition");
/* harmony import */ var ol_events_condition__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ol_events_condition__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ol/interaction */ "ol/interaction");
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(ol_interaction__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ol/style */ "ol/style");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(ol_style__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ol/proj */ "ol/proj");
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(ol_proj__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var geoportal_access_lib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! geoportal-access-lib */ "./node_modules/geoportal-access-lib/src/Gp.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../Utils/Helper */ "./src/packages/Utils/Helper.js");
/* harmony import */ var _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../Utils/SelectorID */ "./src/packages/Utils/SelectorID.js");
/* harmony import */ var _Utils_Markers__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../Utils/Markers */ "./src/packages/Controls/Utils/Markers.js");
/* harmony import */ var _Utils_Draggable__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../Utils/Draggable */ "./src/packages/Utils/Draggable.js");
/* harmony import */ var _Utils_Interactions__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../Utils/Interactions */ "./src/packages/Controls/Utils/Interactions.js");
/* harmony import */ var _LocationSelector_LocationSelector__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../LocationSelector/LocationSelector */ "./src/packages/Controls/LocationSelector/LocationSelector.js");
/* harmony import */ var _Export_Export__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../Export/Export */ "./src/packages/Controls/Export/Export.js");
/* harmony import */ var _LayerSwitcher_LayerSwitcher__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../LayerSwitcher/LayerSwitcher */ "./src/packages/Controls/LayerSwitcher/LayerSwitcher.js");
/* harmony import */ var _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../Formats/GeoJSON */ "./src/packages/Formats/GeoJSON.js");
/* harmony import */ var _RouteDOM__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./RouteDOM */ "./src/packages/Controls/Route/RouteDOM.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
// import CSS

// import "../../CSS/Controls/Route/GPFrouteStyle.css";
// import OpenLayers
// import Control from "ol/control/Control";





// import GeoJSON from "ol/format/GeoJSON";




// import geoportal library access

// import local






// import local with ol dependencies




// DOM

var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_11__["default"].getLogger("route");

/**
 * @classdesc
 *
 * Route Control.
 *
 * @constructor
 * @alias ol.control.Route
 * @type {ol.control.Route}
 * @extends {ol.control.Control}
 * @param {Object} options - route control options
 * @param {String}   [options.apiKey] - API key for services call (route and autocomplete services). The key "calcul" is used by default.
 * @param {Boolean}   [options.ssl = true] - use of ssl or not (default true, service requested using https protocol)
 * @param {Boolean} [options.collapsed = true] - Specify if widget has to be collapsed (true) or not (false) on map loading. Default is true.
 * @param {Boolean} [options.draggable = false] - Specify if widget is draggable
 * @param {Boolean|Object} [options.export = false] - Specify if button "Export" is displayed. For the use of the options of the "Export" control, see {@link ol.control.Export}
 * @param {Object}  [options.exclusions = {"toll" : false, "tunnel" : false, "bridge" : false}] - list of exclusions with status (true = checked). By default : no exclusions checked.
 * @param {Array}   [options.graphs = ["Voiture", "Pieton"]] - list of resources, by default : ["Voiture", "Pieton"]. The first element is selected.
 * @param {Object} [options.routeOptions = {}] - route service options. see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~route Gp.Services.route()} to know all route options.
 * @param {Object} [options.autocompleteOptions = {}] - autocomplete service options. see {@link http://ignf.github.io/geoportal-access-lib/latest/jsdoc/module-Services.html#~autoComplete Gp.Services.autoComplete()} to know all autocomplete options
 * @param {Object} [options.markersOpts] - options to use your own markers. Object properties can be "departure", "stages" or "arrival". Corresponding value is an object with following properties :
 * @param {String} [options.markersOpts.url] - marker base64 encoded url (ex "data:image/png;base64,...""). Mandatory for a custom marker
 * @param {Array} [options.markersOpts.offset] - Offsets in pixels used when positioning the overlay. The first element in the array is the horizontal offset. A positive value shifts the overlay right. The second element in the array is the vertical offset. A positive value shifts the overlay down. Default is [0, 0]. (see http://openlayers.org/en/latest/apidoc/ol.Overlay.html)
 * @param {Object} [options.layerDescription = {}] - Layer informations to be displayed in LayerSwitcher widget (only if a LayerSwitcher is also added to the map)
 * @param {String} [options.layerDescription.title = "Itinéraire"] - Layer title to be displayed in LayerSwitcher
 * @param {String} [options.layerDescription.description = "Itinéraire basé sur un graphe"] - Layer description to be displayed in LayerSwitcher
 * @fires route:drawstart
 * @fires route:drawend
 * @fires route:compute
 * @fires export:compute
 * @example
 *  var route = ol.control.Route({
 *      "collapsed" : true
 *      "draggable" : true,
 *      "export"    : false,
 *      "exclusions" : {
 *         "toll" : true,
 *         "bridge" : false,
 *         "tunnel" : true
 *      },
 *      "graphs" : ['Pieton', 'Voiture'],
 *      "markersOpts" : {
 *          "departure" : {
 *              "url" : "...",
 *              "offset" : [0,0]
 *          },
 *          "stages" : {
 *              "url" : "...",
 *              "offset" : [0,0]
 *          },
 *          "arrival" : {
 *              "url" : "...",
 *              "offset" : [0,0]
 *          }
 *      }
 *      "autocompleteOptions" : {},
 *      "routeOptions" : {}
 *  });
 *
 *  // if you want to pluggued the control Export with options :
 *  var route = new ol.control.Route({
 *    export : {
 *      name : "export",
 *      format : "geojson",
 *      title : "Exporter",
 *      menu : false
 *    }
 *  });
 */
var Route = /*#__PURE__*/function (_Control) {
  /**
   * See {@link ol.control.Route}
   * @module Route
   * @alias module:~controls/Route
   * @param {*} options - options
   * @example
   * import Route from "gpf-ext-ol/controls/Route"
   * ou 
   * import { Route } from "gpf-ext-ol"
   */
  function Route(options) {
    var _this;
    _classCallCheck(this, Route);
    options = options || {};

    // call ol.control.Control constructor
    _this = _callSuper(this, Route, [{
      element: options.element,
      target: options.target,
      render: options.render
    }]);
    if (!(_this instanceof Route)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }

    // initialisation du composant
    _this.initialize(options);

    // Widget main DOM container
    _this._container = _this._createMainContainerElement();

    // ajout du container
    _this.element ? _this.element.appendChild(_this._container) : _this.element = _this._container;
    return _possibleConstructorReturn(_this, _this);
  }

  /**
   * Overwrite OpenLayers setMap method
   *
   * @param {ol.Map} map - Map.
   */
  _inherits(Route, _Control);
  return _createClass(Route, [{
    key: "setMap",
    value: function setMap(map) {
      if (map) {
        // enrichissement du DOM du container
        this._container = this._initContainer(map);
        this.element = this._container;

        // ajout d'un bouton d'export
        if (this.options["export"]) {
          var opts = _Utils_Helper__WEBPACK_IMPORTED_MODULE_12__["default"].assign({
            control: this
          }, this.options["export"]);
          this["export"] = new _Export_Export__WEBPACK_IMPORTED_MODULE_18__["default"](opts);
          this["export"].render();
          var self = this;
          this["export"].on("export:compute", function (e) {
            self.dispatchEvent({
              type: "export:compute",
              content: e.content
            });
          });
        }

        // mode "draggable"
        if (this.draggable) {
          _Utils_Draggable__WEBPACK_IMPORTED_MODULE_15__["default"].dragElement(this._panelRouteContainer, this._panelHeaderRouteContainer, this.options.position ? null : map.getTargetElement());
        }

        // mode "collapsed"
        if (!this.collapsed) {
          this._showRouteButton.setAttribute("aria-pressed", true);
        }
      }

      // on appelle la méthode setMap originale d'OpenLayers
      _get(_getPrototypeOf(Route.prototype), "setMap", this).call(this, map);

      // position
      if (this.options.position) {
        this.setPosition(this.options.position);
      }
    }
  }, {
    key: "getCollapsed",
    value:
    // ################################################################### //
    // ##################### public methods ############################## //
    // ################################################################### //

    /**
     * Returns true if widget is collapsed (minimized), false otherwise
     *
     * @returns {Boolean} collapsed - true if widget is collapsed
     */
    function getCollapsed() {
      return this.collapsed;
    }

    /**
     * Collapse or display widget main container
     *
     * @param {Boolean} collapsed - True to collapse widget, False to display it
     */
  }, {
    key: "setCollapsed",
    value: function setCollapsed(collapsed) {
      if (collapsed === undefined) {
        logger.log("[ERROR] Route:setCollapsed - missing collapsed parameter");
        return;
      }
      if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
        return;
      }
      if (collapsed) {
        document.getElementById("GProutePanelClose-" + this._uid).click();
      } else {
        this._showRouteButton.click();
      }
      this.collapsed = collapsed;
    }

    /**
     * Get vector layer where geoJson route is drawn
     *
     * @returns {Object} layer - ol.layer.Vector route layer
     */
  }, {
    key: "getLayer",
    value: function getLayer() {
      return this._geojsonSections;
    }

    /**
     * Set vector layer where route geometry is drawn
     *
     * @param {Object} layer - ol.layer.Vector route layer
     */
  }, {
    key: "setLayer",
    value: function setLayer(layer) {
      if (!layer) {
        this._geojsonSections = null;
        return;
      }
      if (!(layer instanceof (ol_layer_Vector__WEBPACK_IMPORTED_MODULE_4___default()))) {
        logger.log("no valid layer given for hosting drawn features.");
        return;
      }

      // application des styles
      layer.setStyle(this._defaultFeatureStyle);
      // sauvegarde
      this._geojsonSections = layer;
    }

    /**
     * Get vector layer
     *
     * @returns {String} geojson - GeoJSON format layer
     */
  }, {
    key: "getGeoJSON",
    value: function getGeoJSON() {
      return JSON.stringify(this._geojsonObject);
    }

    /**
     * Set vector layer
     *
     * @param {String} geojson - GeoJSON format layer
     */
  }, {
    key: "setGeoJSON",
    value: function setGeoJSON(geojson) {
      try {
        this._geojsonObject = JSON.parse(geojson);
      } catch (e) {
        logger.log("no valid geojson given :" + e.message);
      }
    }

    /**
     * Get route informations
     *
     * @returns {Object} data - route informations
     */
  }, {
    key: "getData",
    value: function getData() {
      var points = [];
      for (var index = 0; index < this._currentPoints.length; index++) {
        var p = this._currentPoints[index];
        points.push(p.getCoordinate());
      }
      var data = {
        type: "route",
        points: points,
        transport: this._currentTransport,
        exclusions: this._currentExclusions,
        computation: this._currentComputation,
        results: {}
      };
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_12__["default"].assign(data.results, this._currentRouteInformations);
      return data;
    }

    /**
     * Set route data
     *
     * @param {Object} data - control informations
     * @param {String} data.transport - transport type
     * @param {String} data.computation - computation type
     * @param {Array} data.exclusions - list of exclusions
     * @param {Array} data.points - list of points : [[lon, lat]]
     * @param {Object} data.results - service response
     */
  }, {
    key: "setData",
    value: function setData(data) {
      // INFO
      // transmettre toutes les informations necessaires pour reconstruire le panneau de resultats
      this._currentTransport = data.transport;
      this._currentComputation = data.computation;
      this._currentExclusions = data.exclusions;
      // INFO
      // nettoyer les points du calcul précedent
      for (var i = 0; i < this._currentPoints.length; i++) {
        var point = this._currentPoints[i];
        if (point.getCoordinate()) {
          // clean de l'objet sans declencher les evenements qui suppriment la couche précedente !
          // /!\ point.clear()
          point.clearResults();
          // clean du dom
          var id = i + 1 + "-" + this._uid;
          document.getElementById("GPlocationOriginCoords_" + id).value = "";
          document.getElementById("GPlocationOrigin_" + id).value = "";
          document.getElementById("GPlocationPoint_" + id).style.cssText = "";
          if (i > 0 && i < 6) {
            // on masque les points intermediaires
            document.getElementById("GPlocationPoint_" + id).className = "GPflexInput GPelementHidden gpf-flex gpf-hidden ";
          }
          document.getElementById("GPlocationOriginPointer_" + id).checked = false;
          document.getElementById("GPlocationOrigin_" + id).className = "GPelementVisible gpf-visible";
          document.getElementById("GPlocationOriginCoords_" + id).className = "GPelementHidden gpf-hidden";
        }
      }
      // ajout des nouvelles coordonnnées
      for (var j = 0; j < data.points.length; j++) {
        var c = data.points[j];
        if (c) {
          this._currentPoints[j].setCoordinate(c, "EPSG:4326");
        }
      }
      this._currentRouteInformations = data.results;
    }

    /**
     * Get container
     *
     * @returns {DOMElement} container
     */
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this._container;
    }

    /**
     * Get default style
     *
     * @returns {ol.style} style
     */
  }, {
    key: "getStyle",
    value: function getStyle() {
      return this._defaultFeatureStyle;
    }

    /**
     * This method is public.
     * It allows to init the control.
     */
  }, {
    key: "init",
    value: function init() {
      // INFO
      // reconstruire le panneau de resultats sans lancer de calcul
      // * construire la liste des points (cf. RouteDOM._createRoutePanelFormElement())
      // * construire les resultats

      // init points
      for (var index = 0; index < this._currentPoints.length; index++) {
        var point = this._currentPoints[index];
        var id = index + 1;
        var coordinate = point.getCoordinate();
        if (coordinate) {
          var input = document.getElementById("GPlocationOrigin_" + id + "-" + this._uid);
          input.value = coordinate[1].toFixed(4) + " / " + coordinate[0].toFixed(4);
          if (index > 0 && index < 6) {
            document.getElementById("GPlocationPoint_" + id + "-" + this._uid).className = "GPflexInput GPlocationStageFlexInput gpf-flex";
          }
        }
      }

      // add points into panel
      var points = document.getElementsByClassName("GPlocationPoint-" + this._uid);
      this._addRouteResultsStagesValuesElement(points);

      // set transport mode
      var transportdiv;
      if (this._currentTransport === "Pieton") {
        transportdiv = document.getElementById("GProuteTransportPedestrian-" + this._uid);
        if (transportdiv) {
          transportdiv.checked = "true";
        }
      } else {
        transportdiv = document.getElementById("GProuteTransportCar-" + this._uid);
        if (transportdiv) {
          transportdiv.checked = "true";
        }
      }

      // set computation mode
      var computationdiv = document.getElementById("GProuteComputationSelect-" + this._uid);
      if (computationdiv) {
        computationdiv.value = this._currentComputation;
      }

      // set exclusions
      var tollInput = document.getElementById("GProuteExclusionsToll-" + this._uid);
      if (tollInput) {
        if (this._currentExclusions.indexOf("toll") !== -1) {
          tollInput.checked = false;
        } else {
          tollInput.checked = true;
        }
      }
      var tunnelInput = document.getElementById("GProuteExclusionsTunnel-" + this._uid);
      if (tunnelInput) {
        if (this._currentExclusions.indexOf("tunnel") !== -1) {
          tunnelInput.checked = false;
        } else {
          tunnelInput.checked = true;
        }
      }
      var bridgeInput = document.getElementById("GProuteExclusionsBridge-" + this._uid);
      if (bridgeInput) {
        if (this._currentExclusions.indexOf("bridge") !== -1) {
          bridgeInput.checked = false;
        } else {
          bridgeInput.checked = true;
        }
      }
      var distance = this._currentRouteInformations.totalDistance;
      var duration = this._currentRouteInformations.totalTime;

      // Détails avec simplifications des troncons
      var instructions = this._simplifiedInstructions(this._currentRouteInformations.routeInstructions);
      if (instructions) {
        this._fillRouteResultsDetailsContainer(distance, duration, instructions);
      }

      // affichage du panneau de details du controle !
      this._formRouteContainer.className = "GPelementHidden gpf-hidden gpf-panel__content fr-modal__content";
      this._hideWaitingContainer();
      this._resultsRouteContainer.className = "";
    }

    /**
     * Clean UI : reinit control
     */
  }, {
    key: "clean",
    value: function clean() {
      this._currentTransport = null;
      this._currentExclusions = [];
      this._currentComputation = null;
      for (var i = 0; i < this._currentPoints.length; i++) {
        this._currentPoints[i].clear();
      }
      this._removeRouteStepLocations();
      this._clearRouteInputOptions();
      this._clearRouteResultsDetails();
      this.setLayer();
      this._formRouteContainer.className = "gpf-panel__content fr-modal__content";
      this._resultsRouteContainer.className = "GPelementHidden gpf-hidden";
    }

    // ################################################################### //
    // ##################### init component ############################## //
    // ################################################################### //

    /**
     * Initialize route control (called by Route constructor)
     *
     * @param {Object} options - constructor options
     * @private
     */
  }, {
    key: "initialize",
    value: function initialize(options) {
      this._checkInputOptions(options);

      // set default options
      this.options = {
        collapsed: true,
        draggable: false,
        "export": false,
        graphs: ["Voiture", "Pieton"],
        exclusions: {
          toll: false,
          tunnel: false,
          bridge: false
        },
        routeOptions: {},
        autocompleteOptions: {},
        layerDescription: {
          title: "Itinéraire",
          description: "Itinéraire basé sur un graphe"
        }
      };

      // merge with user options
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_12__["default"].assign(this.options, options);

      // cas particulier des markers par défaut
      var defaultMarkersOpts = {
        departure: {
          url: _Utils_Markers__WEBPACK_IMPORTED_MODULE_14__["default"]["red"],
          offset: _Utils_Markers__WEBPACK_IMPORTED_MODULE_14__["default"].defaultOffset
        },
        stages: {
          url: _Utils_Markers__WEBPACK_IMPORTED_MODULE_14__["default"]["lightOrange"],
          offset: _Utils_Markers__WEBPACK_IMPORTED_MODULE_14__["default"].defaultOffset
        },
        arrival: {
          url: _Utils_Markers__WEBPACK_IMPORTED_MODULE_14__["default"]["darkOrange"],
          offset: _Utils_Markers__WEBPACK_IMPORTED_MODULE_14__["default"].defaultOffset
        }
      };
      // on récupère les options de chaque type de marker si spécifié
      this.options.markersOpts = _Utils_Helper__WEBPACK_IMPORTED_MODULE_12__["default"].assign(defaultMarkersOpts, options.markersOpts);

      /** {Boolean} specify if Route control is collapsed (true) or not (false) */
      this.collapsed = this.options.collapsed;

      /** {Boolean} specify if Route control is draggable (true) or not (false) */
      this.draggable = this.options.draggable;
      this._uid = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_13__["default"].generate();

      // containers principaux
      this._showRouteButton = null;
      this._panelRouteContainer = null;
      this._panelHeaderRouteContainer = null;
      this._waitingContainer = null;
      this._formRouteContainer = null;
      this._resultsRouteContainer = null;
      this._showRouteExclusionsElement = null;

      // liste de points selectionnée
      this._currentPoints = [];

      // Mode de transport selectionné : 'Voiture' ou 'Pieton'
      this._currentTransport = null;
      this._initTransport();

      // Mode de calcul selectionné : 'Plus rapide' ou 'plus court'
      this._currentComputation = null;
      this._initComputation();

      // Exclusions selectionnées : Tunnel, Toll et Bridge
      this._currentExclusions = [];
      this._initExclusions();

      // si un calcul est en cours ou non
      this._waiting = false;
      // timer pour cacher la patience après un certain temps
      this._timer = null;

      // la geometrie du parcours
      this._geojsonRoute = null;

      // la geometrie des troncons
      this._geojsonSections = null;

      // la geometrie des troncons au format GeoJSON
      this._geojsonObject = null;

      // bouton export
      this["export"] = null;

      // le container de la popup (pour les troncons selectionnés)
      this._popupContent = null;
      this._popupDiv = this._initPopupDiv();
      // l'overlay ol.Overlay correspondant à la popup (pour les troncons selectionnés)
      this._popupOverlay = null;

      // ol.interaction.Select associées à la couche des résultats (troncons)
      this._resultsSelectInteraction = null;
      this._resultsHoverInteraction = null;

      // styles pour les sélections des features
      this._defaultFeatureStyle = new ol_style__WEBPACK_IMPORTED_MODULE_8__.Style({
        stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__.Stroke({
          color: "rgba(0,183,152,0.9)",
          width: 12
        })
      });
      this._selectedFeatureStyle = new ol_style__WEBPACK_IMPORTED_MODULE_8__.Style({
        stroke: new ol_style__WEBPACK_IMPORTED_MODULE_8__.Stroke({
          color: "rgba(255,102,0,0.9)",
          width: 12
        })
      });

      // reponse du service
      // Ex. {
      //   totalTime, totalDistance, bbox, routeGeometry,
      //   routeInstructions : [{duration, distance, code, instruction, bbox, geometry}]
      // }
      this._currentRouteInformations = null;

      // liste des ressources avec droits par service
      // Ex. {
      //   "Route" : {
      //       key : "ger4g456re45er456t4er5ge5",
      //       resources : ["Pieton", "Voiture"]
      //   }
      // }
      this._resources = {};

      // listener key for event on pointermove or moveend map
      this.listenerKey = null;
    }

    /**
     * this method is called by this.initialize()
     *
     * @param {Object} options - options
     *
     * @private
     */
  }, {
    key: "_checkInputOptions",
    value: function _checkInputOptions(options) {
      // vérification des options
      // mode de transport
      if (options.graphs) {
        // on ne permet pas de passer un tableau vide : on spécifie au moins un graph
        if (Array.isArray(options.graphs) && options.graphs.length) {
          for (var i = 0; i < options.graphs.length; i++) {
            if (typeof options.graphs[i] === "string") {
              if (options.graphs[i].toLowerCase() === "pieton") {
                options.graphs[i] = "Pieton";
              }
              if (options.graphs[i].toLowerCase() === "voiture") {
                options.graphs[i] = "Voiture";
              }
            } else {
              logger.log("[ol.control.Route] ERROR : parameter 'graphs' elements should be of type 'string'");
              options.graphs[i] = null;
            }
          }
        } else {
          logger.warn("'graphs' parameter should be an array");
          options.graphs = null;
        }
      }

      // collapsed
      if (options.collapsed === "true") {
        options.collapsed = true;
      }
      if (options.collapsed === "false") {
        options.collapsed = false;
      }
    }

    /**
     * initialize component container (DOM)
     *
     * @param {Object} map - the map
     *
     * @returns {DOMElement} DOM element
     *
     * @private
     */
  }, {
    key: "_initContainer",
    value: function _initContainer(map) {
      var _this2 = this;
      // get main container
      var container = this._container;
      var picto = this._showRouteButton = this._createShowRoutePictoElement();
      container.appendChild(picto);
      var routePanel = this._panelRouteContainer = this._createRoutePanelElement();
      var routePanelDiv = this._createRoutePanelDivElement();
      routePanel.appendChild(routePanelDiv);

      // header form
      var routeHeader = this._panelHeaderRouteContainer = this._createRoutePanelHeaderElement();
      routePanelDiv.appendChild(routeHeader);

      // form
      var routeForm = this._formRouteContainer = this._createRoutePanelFormElement();

      // form: menu des points
      var points = this._createRoutePanelFormPointsElement(map);
      for (var i = 0; i < points.length; i++) {
        routeForm.appendChild(points[i]);
      }

      // form: menu des modes
      var choice = this._createRoutePanelFormModeChoiceElement();
      choice.appendChild(this._createRoutePanelFormModeChoiceTransportElement(this.options.graphs));
      choice.appendChild(this._createRoutePanelFormModeChoiceComputeElement());
      routeForm.appendChild(choice);

      // form: menu des exclusions
      this._showRouteExclusionsElement = this._createShowRouteExclusionsPictoElement();
      routeForm.appendChild(this._showRouteExclusionsElement);
      var exclusion = this._createRoutePanelFormExclusionsElement();
      exclusion.appendChild(this._createRoutePanelFormExclusionOptionsElement(this.options.exclusions));
      routeForm.appendChild(exclusion);
      var panelFooter = this._createRoutePanelFooterElement();
      routeForm.appendChild(panelFooter);
      var buttonReset = this._createRouteFormResetElement();
      panelFooter.appendChild(buttonReset);

      // form: bouton du calcul
      var buttonSubmit = this._createRouteSubmitFormElement();
      panelFooter.appendChild(buttonSubmit);
      routePanelDiv.appendChild(routeForm);

      // results
      var routeResults = this._resultsRouteContainer = this._createRoutePanelResultsElement();
      routePanelDiv.appendChild(routeResults);

      // waiting
      var waiting = this._waitingContainer = this._createRouteWaitingElement();
      routePanelDiv.appendChild(waiting);
      container.appendChild(routePanel);
      // hide autocomplete suggested locations on container click
      if (container.addEventListener) {
        container.addEventListener("click", function (e) {
          return _this2._hideRouteSuggestedLocations(e);
        });
      }
      return container;
    }

    // ################################################################### //
    // ####################### init application ########################## //
    // ################################################################### //

    /**
     * this method is called by the constructor and initialize transport mode
     * ("Voiture" ou "Pieton")
     *
     * @private
     */
  }, {
    key: "_initTransport",
    value: function _initTransport() {
      // Mode de transport selectionné
      this._currentTransport = "Voiture"; // par defaut

      // par defaut
      var transport = this.options.graphs;
      if (!transport || transport.length === 0) {
        this.options.graphs = ["Voiture", "Pieton"];
      }

      // option
      if (Array.isArray(transport) && transport.length) {
        // FIXME pb si le 1er graphe n'est pas une ressource connue !
        if (transport[0] === "Voiture" || transport[0] === "Pieton") {
          this._currentTransport = transport[0];
        }
      }

      // TODO option sur le service
      var serviceOptions = this.options.routeOptions;
      if (serviceOptions.graph) {
        this._currentTransport = serviceOptions.graph;
      }
    }

    /**
     * this method is called by the constructor and initialize computation mode
     * (fastest or shortest)
     *
     * @private
     */
  }, {
    key: "_initComputation",
    value: function _initComputation() {
      // Mode de calcul selectionné
      this._currentComputation = "fastest"; // par defaut

      // TODO option sur le service
      var serviceOptions = this.options.routeOptions;
      if (serviceOptions.routePreference) {
        this._currentComputation = serviceOptions.routePreference;
      }
    }

    /**
     * this method is called by the constructor and initialize exclusions
     *
     * @private
     */
  }, {
    key: "_initExclusions",
    value: function _initExclusions() {
      // Exclusions selectionnées : Tunnel, Toll et Bridge
      this._currentExclusions = []; // par defaut

      // par defaut
      var exclusion = this.options.exclusions;
      if (!exclusion || _typeof(exclusion) === "object" && Object.keys(exclusion).length === 0) {
        this.options.exclusions = {
          toll: false,
          tunnel: false,
          bridge: false
        };
      }

      // option
      if (exclusion && _typeof(exclusion) === "object" && Object.keys(exclusion).length) {
        for (var k in exclusion) {
          if (exclusion.hasOwnProperty(k)) {
            if (exclusion[k]) {
              this._currentExclusions.push(k);
            }
          }
        }
      }

      // TODO option sur le service
      var serviceOptions = this.options.routeOptions;
      if (Array.isArray(serviceOptions.exclusions)) {
        this._currentExclusions = serviceOptions.exclusions;
      }
    }

    /**
     * this method is called by this.initialize() and initialize popup div
     * (to display results information on route result click)
     *
     * @return {Object} element - DOM element for popup
     * @private
     */
  }, {
    key: "_initPopupDiv",
    value: function _initPopupDiv() {
      var context = this;
      var element = document.createElement("div");
      element.className = "gp-feature-info-div";
      var closer = document.createElement("input");
      closer.type = "button";
      closer.className = "gp-styling-button closer";
      // on closer click : remove popup
      closer.onclick = function () {
        if (context._popupOverlay != null) {
          context._popupOverlay.setPosition(undefined);
        }
        return false;
      };
      this._popupContent = document.createElement("div");
      this._popupContent.className = "gp-features-content-div";
      element.appendChild(this._popupContent);
      element.appendChild(closer);
      return element;
    }

    // ################################################################### //
    // ############################## DOM ################################ //
    // ################################################################### //

    /**
     * Create List Points
     * Overwrite RouteDOM method !
     *
     * @param {Object} map - the map
     *
     * @returns {Array} List DOM element
     * @private
     */
  }, {
    key: "_createRoutePanelFormPointsElement",
    value: function _createRoutePanelFormPointsElement(map) {
      var points = [];
      var count = 1;

      // point de depart
      var start = new _LocationSelector_LocationSelector__WEBPACK_IMPORTED_MODULE_17__["default"]({
        apiKey: this.options.apiKey || null,
        tag: {
          id: count,
          groupId: this._uid,
          markerOpts: this.options.markersOpts["departure"],
          label: "Départ",
          display: true
        },
        autocompleteOptions: this.options.autocompleteOptions || null
      });
      start.setMap(map);
      // on ajoute des écouteurs d'évènements (en plus de ceux de LocationSelector),
      // pour prendre en compte les CSS spécifiques de GProuteForm
      this._addFormPointsEventListeners(start);
      points.push(start._container);
      this._currentPoints.push(start);

      // points intermediaires
      for (count = 2; count < 7; count++) {
        var step = new _LocationSelector_LocationSelector__WEBPACK_IMPORTED_MODULE_17__["default"]({
          apiKey: this.options.apiKey || null,
          tag: {
            id: count,
            groupId: this._uid,
            label: "Etape",
            markerOpts: this.options.markersOpts["stages"],
            display: false,
            removeOption: true
          },
          autocompleteOptions: this.options.autocompleteOptions || null
        });
        step.setMap(map);
        this._addFormPointsEventListeners(step);
        points.push(step._container);
        this._currentPoints.push(step);
      }

      // point d'arrivée
      var end = new _LocationSelector_LocationSelector__WEBPACK_IMPORTED_MODULE_17__["default"]({
        apiKey: this.options.apiKey || null,
        tag: {
          id: count,
          groupId: this._uid,
          markerOpts: this.options.markersOpts["arrival"],
          label: "Arrivée",
          display: true,
          addOption: true
        },
        autocompleteOptions: this.options.autocompleteOptions || null
      });
      end.setMap(map);
      this._addFormPointsEventListeners(end);
      points.push(end._container);
      this._currentPoints.push(end);
      return points;
    }

    /**
     * Attach events listeners to route form points (locationSelector)
     *
     * @param {Object} formPoint - route form point (locationSelector)
     * @private
     */
  }, {
    key: "_addFormPointsEventListeners",
    value: function _addFormPointsEventListeners(formPoint) {
      var _this3 = this;
      if (!formPoint) {
        return;
      }
      if (formPoint._buttonLabel.addEventListener) {
        // display form on origin label click
        formPoint._buttonLabel.addEventListener("click", function (e) {
          return _this3.onRouteOriginLabelClick(e);
        });
        // minimize form on input show pointer, and set map event listeners (see this.onRouteOriginPointerClick)
        formPoint._inputShowPointer.addEventListener("click", function (e) {
          return _this3.onRouteOriginPointerClick(e, formPoint);
        });
        if (formPoint._removePointElement) {
          formPoint._removePointElement.addEventListener("click", function (e) {
            logger.trace("click on _removePointElement", e);
            // Moving up exclusions picto
            // var exclusionsPictoTop = context._showRouteExclusionsElement.style.top;
            // context._showRouteExclusionsElement.style.top = (parseInt(exclusionsPictoTop, 10) - 33).toString() + "px";
          });
        }
        if (formPoint._addPointElement) {
          formPoint._addPointElement.addEventListener("click", function (e) {
            logger.trace("click on _addPointElement", e);
            // Moving down exclusions picto
            // var exclusionsPictoTop = context._showRouteExclusionsElement.style.top;
            // context._showRouteExclusionsElement.style.top = (parseInt(exclusionsPictoTop, 10) + 33).toString() + "px";
          });
        }
      } else if (formPoint._buttonLabel.attachEvent) {
        // attachEvent: Internet explorer event listeners management
        formPoint._buttonLabel.attachEvent("onclick", function (e) {
          return _this3.onRouteOriginLabelClick(e);
        });
        formPoint._inputShowPointer.attachEvent("onclick", function (e) {
          return _this3.onRouteOriginPointerClick(e, formPoint);
        });
        if (formPoint._removePointElement) {
          formPoint._removePointElement.attachEvent("onclick", function (e) {
            // Moving up exclusions picto
            // var exclusionsPictoTop = context._showRouteExclusionsElement.style.top;
            // context._showRouteExclusionsElement.style.top = (parseInt(exclusionsPictoTop, 10) - 33).toString() + "px";
          });
        }
        if (formPoint._addPointElement) {
          formPoint._addPointElement.attachEvent("onclick", function (e) {
            // Moving down exclusions picto
            // var exclusionsPictoTop = context._showRouteExclusionsElement.style.top;
            // context._showRouteExclusionsElement.style.top = (parseInt(exclusionsPictoTop, 10) + 33).toString() + "px";
          });
        }
      }
    }

    // ################################################################### //
    // ####################### handlers events to dom #################### //
    // ################################################################### //

    /**
     * this method is called by event 'submit' on 'GProuteForm' tag form
     * (cf. this._createRoutePanelFormElement), and it displays the results.
     *
     * @param {Object} options - options
     * @private
     */
  }, {
    key: "onRouteComputationSubmit",
    value: function onRouteComputationSubmit(options) {
      logger.log("onRouteComputationSubmit", options);

      // FIXME on lance une requête en EPSG:4326, les coordonnées
      // doivent donc être du type cad en lat/lon.
      // or, BUG du service du calcul d'itineraire car les
      // coordonnées envoyées doivent être en lon/lat avec une SRS en EPSG:4326 !?
      // sinon, ça plante...

      // Liste des points
      var points = this._currentPoints;

      // - point de depart (info: points[0].getCoordinate est du type [lon, lat], en EPSG:4326)
      var start;
      if (points[0] && points[0].getCoordinate) {
        var startCoordinate = points[0].getCoordinate();
        start = {
          x: startCoordinate[0],
          y: startCoordinate[1]
        };
        logger.log("start", start);
      }

      // - point d'arrivée
      var end;
      var endPoint = points[points.length - 1];
      if (endPoint && endPoint.getCoordinate) {
        var endCoordinate = endPoint.getCoordinate();
        end = {
          x: endCoordinate[0],
          y: endCoordinate[1]
        };
        logger.log("end", end);
      }

      // - les étapes
      var step = [];
      for (var i = 1; i < points.length - 1; i++) {
        if (points[i] && points[i].getCoordinate) {
          var iCoordinate = points[i].getCoordinate();
          if (iCoordinate) {
            var coordinate = {
              x: iCoordinate[0],
              y: iCoordinate[1]
            };
            logger.log("step", coordinate);
            step.push(coordinate);
          }
        }
      }

      // valeurs selectionnées
      this._currentTransport = options.transport;
      this._currentComputation = options.computation;
      this._currentExclusions = options.exclusions;

      // on recupere les éventuelles options du service passées par l'utilisateur
      var routeOptions = this.options.routeOptions;

      // OVERLOAD : la resource bd-topo-osrm ne gère pas le calcul piéton en mode fastest
      // dans ce cas, on utilise valhalla dans le cas d'une utilisation par défaut du widget
      // sans paramétrage de resource explicitement demandé
      var routeResource;
      if (!routeOptions.resource) {
        if (this._currentComputation === "fastest" && this._currentTransport === "Pieton") {
          routeResource = "bdtopo-valhalla";
        }
      } else {
        routeResource = routeOptions.resource;
      }

      // gestion du protocole et du timeout
      // le timeout est indispensable sur le protocole JSONP.
      var _protocol = routeOptions.protocol || "XHR";
      var _timeout = routeOptions.timeOut || 0;
      if (_protocol === "JSONP" && _timeout === 0) {
        // FIXME le timeout est obligatoire pour ce type de protocole...
        _timeout = 15000;
      }

      // gestion des callback
      var bOnFailure = !!(routeOptions.onFailure !== null && typeof routeOptions.onFailure === "function"); // cast variable to boolean
      var bOnSuccess = !!(routeOptions.onSuccess !== null && typeof routeOptions.onSuccess === "function");

      // on met en place l'affichage des resultats dans la fenetre de resultats.
      var context = this;
      this._requestRouting({
        startPoint: start,
        endPoint: end,
        viaPoints: step,
        graph: routeOptions.graph || this._currentTransport,
        routePreference: routeOptions.routePreference || this._currentComputation,
        exclusions: routeOptions.exclusions || this._currentExclusions,
        geometryInInstructions: true,
        distanceUnit: "m",
        timeOut: _timeout,
        protocol: _protocol,
        resource: routeResource,
        // callback onSuccess
        onSuccess: function onSuccess(results) {
          logger.log(results);
          if (results) {
            context._fillRouteResultsDetails(results);
          }
          if (bOnSuccess) {
            routeOptions.onSuccess.call(context, results);
          }
        },
        // callback onFailure
        onFailure: function onFailure(error) {
          context._hideWaitingContainer();
          context._clearRouteResultsDetails();
          logger.log(error.message);
          if (bOnFailure) {
            routeOptions.onFailure.call(context, error);
          }
        }
      });
    }

    /**
     * this method is called by event 'click' on 'GPlocationOriginLabel' label
     * and set 'GProuteForm' CSS class to "" (normal)
     *
     * @param {Object} routeControl - context : route Control (this)
     * @private
     */
  }, {
    key: "onRouteOriginLabelClick",
    value: function onRouteOriginLabelClick() {
      this._formRouteContainer.className = "gpf-panel__content fr-modal__content";
      // on désactive l'écouteur d'événements sur la carte (pour ne pas placer un marker au clic)
      // map.un(
      //     "click",
      //     () => {
      //         // on ne rétablit pas le mode "normal" si on est dans le panel des résultats (où className = "GProuteComponentHidden")
      //         if (this._formRouteContainer.className === "GProuteFormMini") {
      //             this._formRouteContainer.className = "gpf-panel__content fr-modal__content";
      //         }
      //     }
      // );
      (0,ol_Observable__WEBPACK_IMPORTED_MODULE_2__.unByKey)(this.listenerKey);
      this.dispatchEvent("route:drawend");
    }

    /**
     * this method is called by event 'click' on 'GPlocationOriginPointerImg' label
     * and display or minimize 'GProuteForm', using CSS class ("GProuteFormMini" or "")
     *
     * @param {Object} e - context : route Control (equivalent to this)
     * @param {Object} locationSelector - context : locationSelector input (one of this._currentPoints)
     * @private
     */
  }, {
    key: "onRouteOriginPointerClick",
    value: function onRouteOriginPointerClick(e, locationSelector) {
      var _this4 = this;
      var map = this.getMap();
      if (locationSelector._inputShowPointerContainer.checked) {
        // au click sur l'input pour pointer sur la carte: on minimise le formulaire
        this._formRouteContainer.className = "GProuteFormMini gpf-panel__content fr-modal__content";
        // et au clic sur la carte, on réaffichera le formulaire "normal"
        this.listenerKey = map.on("click", function () {
          // on ne rétablit pas le mode "normal" si on est dans le panel des résultats (où className = "GProuteComponentHidden")
          if (_this4._formRouteContainer.className === "GProuteFormMini gpf-panel__content fr-modal__content") {
            _this4._formRouteContainer.className = "gpf-panel__content fr-modal__content";
          }
          (0,ol_Observable__WEBPACK_IMPORTED_MODULE_2__.unByKey)(_this4.listenerKey);
          /**
          * event triggered at the end of drawing input
          *
          * @event route:drawend
          */
          _this4.dispatchEvent("route:drawend");
        });
        /**
        * event triggered at the start of drawing input
        *
        * @event route:drawstart
        */
        this.dispatchEvent("route:drawstart");
      } else {
        // si on déselectionne le pointer, on rétablit le formulaire en mode normal
        this._formRouteContainer.className = "";
        // et on enlève l'écouteur d'évènement sur la carte
        // map.un(
        //     "click",
        //     () => {
        //         // on ne rétablit pas le mode "normal" si on est dans le panel des résultats (où className = "GProuteComponentHidden")
        //         if (this._formRouteContainer.className === "GProuteFormMini") {
        //             this._formRouteContainer.className = "gpf-panel__content fr-modal__content";
        //         }
        //     }
        // );
        (0,ol_Observable__WEBPACK_IMPORTED_MODULE_2__.unByKey)(this.listenerKey);
        this.dispatchEvent("route:drawend");
      }
    }

    /**
     * this method is called by event 'click' on 'GPshowRoutePicto'
     * tag label (cf. this._createShowRoutePictoElement),
     * and it cleans all value of input.
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "onShowRoutePanelClick",
    value: function onShowRoutePanelClick(e) {
      var map = this.getMap();
      // on supprime toutes les interactions
      _Utils_Interactions__WEBPACK_IMPORTED_MODULE_16__["default"].unset(map);
      // clean !
      if (!this._geojsonSections && !this._waiting) {
        this._clear();
      }
      var opened = this._showRouteButton.ariaPressed;
      this.collapsed = !(opened === "true");
      // on génère nous même l'evenement OpenLayers de changement de pté
      // (utiliser ol.control.Route.on("change:collapsed", function ) pour s'abonner à cet évènement)
      this.dispatchEvent("change:collapsed");
    }

    /**
     * this method is called by event 'change' on 'GProuteComputationSelect' tag select
     * (cf. this._createRoutePanelFormModeChoiceComputeElement).
     * this value is saved as a parameter for the service route.
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "onRouteModeComputationChange",
    value: function onRouteModeComputationChange(e) {
      var idx = e.target.selectedIndex;
      var value = e.target.options[idx].value;
      if (!value) {
        return;
      }
      logger.log(value);
      this._currentComputation = value;
    }

    /**
     * this method is called by event 'change' on 'GProuteResultsComputationSelect' tag select
     * (cf. this._createRouteResultsElement).
     * this value is saved as a parameter for the service route,
     * and this launches the route request !
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "onRouteModeComputationChangeAndRun",
    value: function onRouteModeComputationChangeAndRun(e) {
      // event choice computation
      this.onRouteModeComputationChange(e);

      // clean avant un nouveau calcul !
      this._clearRouteResultsDetails();
      this._clearRouteResultsGeometry();
      this._clearRouteResultsFeatureGeometry();

      // submit request
      this.onRouteComputationSubmit({
        computation: this._currentComputation,
        transport: this._currentTransport,
        exclusions: this._currentExclusions
      });
    }

    /**
     * this method is called by event 'change' on 'GProuteTransportCar' or 'GProuteTransportPedestrian' tag input
     * (cf. this._createRoutePanelFormModeChoiceTransportElement).
     * this value is saved as a parameter for the service route.
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "onRouteModeTransportChange",
    value: function onRouteModeTransportChange(e) {
      var value = e.target.value;
      if (!value) {
        return;
      }
      this._currentTransport = value;
    }

    /**
     * TODO this method is called by event 'click' on 'GPshowRouteExclusionsPicto' tag input
     * (cf. this._createShowRouteExclusionsPictoElement), and it displays the panel options of exclusions.
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "onShowRouteExclusionsClick",
    value: function onShowRouteExclusionsClick(e) {
      logger.log("onShowRouteExclusionsClick", e);
      // FIXME not use ?!
    }

    /**
     * this method is called by event 'change' on 'GProuteExclusionsToll'
     * or 'GProuteExclusionsTunnel' or 'GProuteExclusionsBridge' tag input
     * (cf. this._createRoutePanelFormExclusionOptionsElement).
     * this value is saved as a parameter for the service route.
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "onRouteExclusionsChange",
    value: function onRouteExclusionsChange(e) {
      var value = e.target.value;
      var checked = e.target.checked;
      if (!value || typeof value !== "string") {
        return;
      }
      value = value.toLowerCase();
      var bFound = false;
      var iFound = null;
      for (var i = 0; i < this._currentExclusions.length; i++) {
        if (this._currentExclusions[i] === value) {
          iFound = i;
          bFound = true;
        }
      }
      // on l'ajoute si la valeur n'existe pas et est déselectionnée
      // info : checked = passage autorisé (ce n'est pas une exclusion)
      if (!bFound && !checked) {
        this._currentExclusions.push(value);
      }
      // on la retire si la valeur existe et est selectionnée
      if (bFound && checked) {
        this._currentExclusions.splice(iFound, 1);
      }
    }

    /**
     * this method is called by event 'click' on 'GProuteReset'
     * tag label (cf. this._createRouteFormResetElement),
     * and it cleans all route input options and results.
     *
     * @private
     */
  }, {
    key: "onRouteResetClick",
    value: function onRouteResetClick() {
      // clear points
      var currentPoints = this._currentPoints;
      for (var i = 0; i < currentPoints.length; i++) {
        currentPoints[i].clear();
      }

      // clear results
      this._clear();
      this._clearRouteInputOptions();
    }

    /**
     * this method is called by event 'click' on 'GProuteSubmit'
     * tag label (cf. this._createRouteSubmitFormElement),
     * and it cleans the route geometry.
     *
     * @private
     */
  }, {
    key: "onShowRouteResultsNewClick",
    value: function onShowRouteResultsNewClick() {
      // clean avant un nouveau calcul !
      this._clearRouteResultsDetails();
      this._clearRouteResultsGeometry();
      this._clearRouteResultsFeatureGeometry();
    }

    /**
     * this method is called by event 'mouseover' on 'GProuteResultsDetailsInstruction_'
     * tag label (cf. this._addRouteResultsDetailsElement),
     * and it makes a style on feature route.
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "onRouteResultsDetailsMouseOver",
    value: function onRouteResultsDetailsMouseOver(e) {
      // récupération de l'id de l'instruction survolée
      var tagid = e.target.id; // ex GProuteResultsDetailsInstruction_125
      var idx = tagid.substring(tagid.indexOf("_") + 1); // ex. 125

      // on passe le texte en gras
      if (e.target.classList) {
        e.target.classList.add("GProuteResultsDetailsInstructionHighlight");
      }
      if (!this._geojsonSections) {
        return;
      }

      // on récupère l'entité correspondante à l'instruction survolée
      var f = this._geojsonSections.getSource().getFeatureById(parseInt(idx, 10));
      // et on lui affecte un nouveau style
      f.setStyle(this._selectedFeatureStyle);
    }

    /**
     * this method is called by event 'mouseout' on 'GProuteResultsDetailsInstruction_'
     * tag label (cf. this._addRouteResultsDetailsElement),
     * and it deletes a style on feature route.
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "onRouteResultsDetailsMouseOut",
    value: function onRouteResultsDetailsMouseOut(e) {
      // récupération de l'id de l'instruction survolée
      var tagid = e.target.id; // ex GProuteResultsDetailsInstruction_125
      var idx = tagid.substring(tagid.indexOf("_") + 1); // ex. 125

      // on repasse le texte en style normal
      if (e.target.classList) {
        e.target.classList.remove("GProuteResultsDetailsInstructionHighlight");
      }
      if (!this._geojsonSections) {
        return;
      }
      // on récupère l'entité correspondante à l'instruction qui était survolée
      var f = this._geojsonSections.getSource().getFeatureById(parseInt(idx, 10));
      // et on lui réaffecte un style normal
      f.setStyle(null);
    }

    // ################################################################### //
    // ########################### Routing ############################### //
    // ############## (methods to request and results) ################### //

    /**
     * this method is called by this.onRouteComputationSubmit()
     * and executes a request to the service.
     *
     * @param {Object} options - route service request options
     * @param {Function} options.onSuccess - callback
     * @param {Function} options.onFailure - callback
     * @private
     */
  }, {
    key: "_requestRouting",
    value: function _requestRouting(options) {
      // on ne fait pas de requête si on n'a pas renseigné de parametres !
      if (!options || _typeof(options) === "object" && Object.keys(options).length === 0) {
        return;
      }

      // on ne fait pas de requête si
      // - la parametre 'startPoint' est vide !
      if (!options.startPoint) {
        return;
      }
      // - la parametre 'endPoint' est vide !
      if (!options.endPoint) {
        return;
      }

      // cas où la clef API n'est pas renseignée dans les options du service,
      // on utilise celle renseignée au niveau du controle (calcul par défaut)
      options.apiKey = this.options.routeOptions.apiKey || this.options.apiKey;

      // si l'utilisateur a spécifié le paramètre ssl au niveau du control, on s'en sert
      // true par défaut (https)
      if (typeof options.ssl !== "boolean") {
        if (typeof this.options.ssl === "boolean") {
          options.ssl = this.options.ssl;
        } else {
          options.ssl = true;
        }
      }
      logger.log(options);

      // mise en place de la patience
      this._displayWaitingContainer();

      // appel du service de calcul d'itinéraires
      geoportal_access_lib__WEBPACK_IMPORTED_MODULE_10__["default"].Services.route(options);
    }

    /**
     * this method is called by this.onRouteComputationSubmit() (in case of route computation success)
     * and fills the container of the route instructions list, distance and time
     * information, also, constructs the geometry route.
     *
     * @param {Object} results - results of the route calculation
     *
     * @private
     */
  }, {
    key: "_fillRouteResultsDetails",
    value: function _fillRouteResultsDetails(results) {
      // 1. Affichage des distances et durées
      var distance = results.totalDistance;
      var duration = results.totalTime;
      // Détails avec simplifications des troncons
      var instructions = this._simplifiedInstructions(results.routeInstructions);
      // var instructions = results.routeInstructions;

      if (instructions) {
        this._fillRouteResultsDetailsContainer(distance, duration, instructions);
      }

      // 2. Affichage des géométries
      // Geometrie simplifiée (si renseignée)
      var geometry = results.routeGeometry;
      if (geometry) {
        this._fillRouteResultsDetailsGeometry(geometry, this._defaultFeatureStyle);
      }

      // Geometries des tronçon (si renseignée)
      if (instructions && instructions[0].geometry) {
        this._fillRouteResultsDetailsFeatureGeometry(instructions, this._defaultFeatureStyle);
      }

      // 3. Zoom sur l'emprise de l'itinéraire (si spécifiée)
      var bbox = results.bbox;
      if (bbox) {
        var map = this.getMap();
        var bounds = [bbox.left, bbox.bottom, bbox.right, bbox.top];
        // reprojection dans la projection de la carte (bbox initialement en EPSG:4326)
        var mapProj = map.getView().getProjection().getCode();
        if (mapProj !== "EPSG:4326") {
          bounds = (0,ol_proj__WEBPACK_IMPORTED_MODULE_9__.transformExtent)(bounds, "EPSG:4326", mapProj);
        }
        map.getView().fit(bounds, map.getSize());
      }

      // sauvegarde de l'etat des resultats
      this._currentRouteInformations = results;

      /**
       * event triggered when the compute is finished
       *
       * @event route:compute
       * @property {Object} type - event
       * @property {Object} target - instance Route
       * @example
       * Route.on("route:compute", function (e) {
       *   console.log(e.target.getData());
       * })
       */
      this.dispatchEvent({
        type: "route:compute"
      });

      // mise à jour du controle !
      this._formRouteContainer.className = "GPelementHidden gpf-hidden gpf-panel__content fr-modal__content";
      this._hideWaitingContainer();
      this._resultsRouteContainer.className = "";
    }

    /**
     * this method is called by this._fillRouteResultsDetails()
     * and fills the container of the route instructions list, distance and time
     * information.
     *
     * @param {Number} distance - distance
     * @param {Number} duration - duration
     * @param {Object[]} instructions - list of instructions
     *
     * @private
     */
  }, {
    key: "_fillRouteResultsDetailsContainer",
    value: function _fillRouteResultsDetailsContainer(distance, duration, instructions) {
      // Distance et Durée
      this._resultsRouteValuesContainer = this._addRouteResultsValuesElement(distance, duration, this._convertSecondsToTime);

      // Détails
      this._resultsRouteDetailsContainer = this._addRouteResultsDetailsElement(instructions, this._convertSecondsToTime);
    }

    /**
     * this method is called by this._fillRouteResultsDetails()
     * and constructs the geometry route.
     *
     * @param {Object} geometry - geoJSON object for route geometry
     * @param {Object} style - route ol.style.Style object
     * @private
     */
  }, {
    key: "_fillRouteResultsDetailsGeometry",
    value: function _fillRouteResultsDetailsGeometry(geometry, style) {
      this._clearRouteResultsGeometry();
      var map = this.getMap();
      if (!geometry) {
        return;
      }

      // création de l'objet geoJSON
      var geojsonObject = {
        type: "FeatureCollection",
        features: [{
          type: "Feature",
          crs: {
            type: "name",
            properties: {
              name: "EPSG:4326"
            }
          },
          geometry: geometry
        }]
      };
      var geojsonformat = new _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_20__["default"]({
        defaultDataProjection: "EPSG:4326",
        defaultStyle: style
      });
      var features = geojsonformat.readFeatures(geojsonObject, {
        dataProjection: "EPSG:4326",
        featureProjection: "EPSG:3857"
      });

      // ajout de la géométrie comme nouvelle couche vecteur à la carte
      this._geojsonRoute = new (ol_layer_Vector__WEBPACK_IMPORTED_MODULE_4___default())({
        source: new (ol_source_Vector__WEBPACK_IMPORTED_MODULE_5___default())({
          features: features
        }),
        style: style
      });
      map.addLayer(this._geojsonRoute);
    }

    /**
     * this method is called by this._fillRouteResultsDetails()
     * and constructs the geometries street with informations.
     *
     * @param {Array} instructions - route instructions list (containing geoJSON geometry)
     * @param {Object} style - route ol.style.Style object
     * @private
     */
  }, {
    key: "_fillRouteResultsDetailsFeatureGeometry",
    value: function _fillRouteResultsDetailsFeatureGeometry(instructions, style) {
      var _this5 = this;
      this._clearRouteResultsFeatureGeometry();
      var map = this.getMap();

      // 1. création de l'objet geoJSON
      this._geojsonObject = {
        type: "FeatureCollection",
        crs: {
          type: "name",
          properties: {
            name: "EPSG:4326"
          }
        },
        features: []
      };

      // 2. Remplissage de l'objet geoJSON : ajout des géométries de chaque instruction
      for (var i = 0; i < instructions.length; i++) {
        var o = instructions[i];
        var id = i + 1;
        var coords = o.geometry.coordinates;
        for (var j = 0; j < coords.length; j++) {
          // remarque : les coordonnées sont au format string, à convertir en nombres
          if (typeof coords[j][0] === "string") {
            coords[j][0] = parseFloat(coords[j][0]);
            coords[j][1] = parseFloat(coords[j][1]);
          }
        }
        this._geojsonObject.features.push({
          type: "Feature",
          geometry: o.geometry,
          properties: {
            popupContent: "(" + id + ") distance : " + this._convertDistance(o.distance) + " / temps : " + this._convertSecondsToTime(o.duration)
          },
          id: id
        });
      }

      // Ajout du point de depart du tracé
      this._geojsonObject.features.push({
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: this._currentPoints[0].getCoordinate()
        },
        properties: {
          description: "Point de départ",
          "marker-symbol": this.options.markersOpts.departure.url
        }
      });

      // Ajout des points d'étapes
      for (var k = 1; k < this._currentPoints.length - 1; k++) {
        if (this._currentPoints[k] && this._currentPoints[k].getCoordinate) {
          var coordinates = this._currentPoints[k].getCoordinate();
          if (coordinates) {
            this._geojsonObject.features.push({
              type: "Feature",
              geometry: {
                type: "Point",
                coordinates: coordinates
              },
              properties: {
                description: "Point d'étape",
                "marker-symbol": this.options.markersOpts.stages.url
              }
            });
          }
        }
      }

      // Ajout du point d'arrivée du tracé
      this._geojsonObject.features.push({
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: this._currentPoints[this._currentPoints.length - 1].getCoordinate()
        },
        properties: {
          description: "Point d'arrivée",
          "marker-symbol": this.options.markersOpts.arrival.url
        }
      });

      // Création du format GeoJSON, avec reprojection des géométries
      var geojsonformat = new _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_20__["default"]({
        defaultDataProjection: "EPSG:4326",
        defaultStyle: style
      });
      var mapProj = this.getMap().getView().getProjection().getCode();
      var features = geojsonformat.readFeatures(this._geojsonObject, {
        dataProjection: "EPSG:4326",
        featureProjection: mapProj
      });

      // 3. Ajout du tracé de l'itinéraire (geoJSON) comme nouvelle couche vecteur à la carte
      this._geojsonSections = new (ol_layer_Vector__WEBPACK_IMPORTED_MODULE_4___default())({
        source: new (ol_source_Vector__WEBPACK_IMPORTED_MODULE_5___default())({
          features: features
        }),
        style: style,
        opacity: 0.9
      });
      var graph;
      if (this._currentTransport === "Pieton") {
        graph = "piéton";
        this._geojsonSections.gpResultLayerId = "Pieton$OGC:OPENLS;Itineraire";
      } else {
        graph = "voiture";
        this._geojsonSections.gpResultLayerId = "Voiture$OGC:OPENLS;Itineraire";
      }
      // ajout à la carte
      map.addLayer(this._geojsonSections);

      // 4. Si un layer switcher est présent dans la carte, on lui affecte des informations pour cette couche
      map.getControls().forEach(function (control) {
        if (control instanceof _LayerSwitcher_LayerSwitcher__WEBPACK_IMPORTED_MODULE_19__["default"]) {
          // un layer switcher est présent dans la carte
          var layerId = _this5._geojsonSections.gpLayerId;
          // on n'ajoute des informations que s'il n'y en a pas déjà (si le titre est le numéro par défaut)
          if (control._layers[layerId].title === layerId) {
            control.addLayer(_this5._geojsonSections, {
              title: _this5.options.layerDescription.title + " (" + graph + ")",
              description: _this5.options.layerDescription.description
            });
          }
        }
      }, this);

      // 5. Ajout de popups aux troncons
      // Création de l'interaction : survol des features (=troncons de l'itinéraire)
      this._resultsHoverInteraction = new ol_interaction__WEBPACK_IMPORTED_MODULE_7__.Select({
        condition: ol_events_condition__WEBPACK_IMPORTED_MODULE_6__.pointerMove,
        layers: [this._geojsonSections],
        style: this._selectedFeatureStyle
      });
      this._resultsHoverInteraction.on("select", function (e) {
        return _this5._onResultsFeatureMouseOver(e);
      });
      map.addInteraction(this._resultsHoverInteraction);

      // Création de l'interaction : selection des features (=troncons de l'itinéraire)
      this._resultsSelectInteraction = new ol_interaction__WEBPACK_IMPORTED_MODULE_7__.Select({
        layers: [this._geojsonSections],
        style: this._selectedFeatureStyle
      });
      this._resultsSelectInteraction.on("select", function (e) {
        return _this5._onResultsFeatureSelect(e);
      });
      map.addInteraction(this._resultsSelectInteraction);
    }

    /**
     * this method is called on route features hover
     * and highlight instruction label
     *
     * @param {Object} e - event
     *
     * @private
     */
  }, {
    key: "_onResultsFeatureMouseOver",
    value: function _onResultsFeatureMouseOver(e) {
      if (e.selected.length !== 0) {
        // si on a bien survolé un tronçon, on surligne l'instruction correspondante
        var f = e.selected[0];
        var selectedInstruction = document.getElementById("GProuteResultsDetailsInstruction_" + f.getId() + "-" + this._uid);
        if (selectedInstruction && selectedInstruction.classList) {
          selectedInstruction.classList.add("GProuteResultsDetailsInstructionHighlight");
        }
      }

      // si on déselectionne un tronçon (mouseout), on rétablit un style normal pour l'instruction
      if (e.deselected.length !== 0) {
        var deselectedFeature = e.deselected[0];
        // on repasse l'instruction correspondante en normal
        var deSelectedInstruction = document.getElementById("GProuteResultsDetailsInstruction_" + deselectedFeature.getId() + "-" + this._uid);
        if (deSelectedInstruction && deSelectedInstruction.classList) {
          deSelectedInstruction.classList.remove("GProuteResultsDetailsInstructionHighlight");
        }
      }
    }

    /**
     * this method is called on route features select
     * and set a popup with feature information
     *
     * @param {Object} e - on select event
     * @private
     */
  }, {
    key: "_onResultsFeatureSelect",
    value: function _onResultsFeatureSelect(e) {
      var map = this.getMap();
      if (e.selected.length !== 0) {
        // si on a sélectionné un troncon, on lui ajoute une popup
        var f = e.selected[0];
        this._popupContent.innerHTML = f.getProperties().popupContent;
        if (!this._popupOverlay) {
          // ajout de la popup a la carte comme un overlay
          this._popupOverlay = new (ol_Overlay__WEBPACK_IMPORTED_MODULE_3___default())({
            element: this._popupDiv,
            positioning: "bottom-center",
            position: e.mapBrowserEvent.coordinate
          });
          map.addOverlay(this._popupOverlay);
        } else {
          // si l'overlay est déjà créé, on modifie juste sa position
          this._popupOverlay.setPosition(e.mapBrowserEvent.coordinate);
        }
      } else {
        // si aucun troncon n'est sélectionné (click à côté du tracé),
        // on fait disparaitre la popup si elle existe
        if (this._popupOverlay != null) {
          this._popupOverlay.setPosition(undefined);
        }
      }
    }

    // ################################################################### //
    // ############################# Clean ############################### //
    // ################################################################### //

    /**
     * this method is called by this.onShowRoutePanelClick()
     * and it clears all elements (reinit).
     *
     * @private
     */
  }, {
    key: "_clear",
    value: function _clear() {
      this._currentTransport = null;
      this._currentExclusions = [];
      this._currentComputation = null;

      // les resultats
      this._clearRouteResultsDetails();
      // la geometrie
      this._clearRouteResultsGeometry();
      this._clearRouteResultsFeatureGeometry();
      // les points
      for (var i = 0; i < this._currentPoints.length; i++) {
        this._currentPoints[i].clear();
      }
      // suppression des points intermédiaires
      this._removeRouteStepLocations();
    }

    /**
     * this method is called by this.onRouteResetClick()
     * and it clears all options inputs (reinit).
     *
     * @private
     */
  }, {
    key: "_clearRouteInputOptions",
    value: function _clearRouteInputOptions() {
      // reinit options to default
      this._initTransport();
      this._initComputation();
      this._initExclusions();

      // set transport mode to default
      var transportdiv;
      if (this._currentTransport === "Pieton") {
        transportdiv = document.getElementById("GProuteTransportPedestrian-" + this._uid);
        if (transportdiv) {
          transportdiv.checked = "true";
        }
      } else {
        transportdiv = document.getElementById("GProuteTransportCar-" + this._uid);
        if (transportdiv) {
          transportdiv.checked = "true";
        }
      }

      // set computation mode to default
      var computationdiv = document.getElementById("GProuteComputationSelect-" + this._uid);
      if (computationdiv) {
        computationdiv.value = this._currentComputation;
      }

      // set exclusions to default
      var tollInput = document.getElementById("GProuteExclusionsToll-" + this._uid);
      if (tollInput) {
        if (this._currentExclusions.indexOf("toll") !== -1) {
          tollInput.checked = false;
        } else {
          tollInput.checked = true;
        }
      }
      var tunnelInput = document.getElementById("GProuteExclusionsTunnel-" + this._uid);
      if (tunnelInput) {
        if (this._currentExclusions.indexOf("tunnel") !== -1) {
          tunnelInput.checked = false;
        } else {
          tunnelInput.checked = true;
        }
      }
      var bridgeInput = document.getElementById("GProuteExclusionsBridge-" + this._uid);
      if (bridgeInput) {
        if (this._currentExclusions.indexOf("bridge") !== -1) {
          bridgeInput.checked = false;
        } else {
          bridgeInput.checked = true;
        }
      }
    }

    /**
     * this method is called by this._clear()
     * and it removes step location inputs (excepted departure and arrival)
     *
     * @private
     */
  }, {
    key: "_removeRouteStepLocations",
    value: function _removeRouteStepLocations() {
      var points = document.querySelectorAll("div[id^=\"GPlocationPoint\"]");
      if (points.length !== 0) {
        var goodPoints = [];
        for (var k = 0; k < points.length; k++) {
          if (points[k].id.indexOf(this._uid) !== -1) {
            goodPoints.push(points[k]);
          }
        }
        // on boucle sur les points intermédiaires
        for (var i = 1; i < goodPoints.length - 1; i++) {
          // on va regarder les classes associées
          var classList = goodPoints[i].classList;
          if (classList.length !== 0) {
            for (var j = 0; j < classList.length; j++) {
              if (classList[j] === "GPlocationStageFlexInput") {
                // si l'élément est visible, on le supprime en simulant un clic sur la croix (x)
                document.getElementById(this._addUID("GPlocationStageRemove_" + (i + 1))).click();
              }
            }
          }
        }
      }
    }

    /**
     * this method is called by this.onRouteComputationSubmit() (in case of failure)
     * and it clears all route instructions.
     *
     * @private
     */
  }, {
    key: "_clearRouteResultsDetails",
    value: function _clearRouteResultsDetails() {
      this._currentRouteInformations = null;

      // doit on nettoyer le container "GProuteResultsDetails" ?
      // il sera de toute façon écrasé par la prochaine requête...
      if (this._resultsRouteDetailsContainer) {
        var detailsDiv = this._resultsRouteDetailsContainer;
        if (detailsDiv.childElementCount) {
          while (detailsDiv.firstChild) {
            detailsDiv.removeChild(detailsDiv.firstChild);
          }
        }
      }
      if (this._resultsRouteValuesContainer) {
        var valuesDiv = this._resultsRouteValuesContainer;
        if (valuesDiv.childElementCount) {
          while (valuesDiv.firstChild) {
            valuesDiv.removeChild(valuesDiv.firstChild);
          }
        }
      }
    }

    /**
     * this method is called by this.onRouteComputationSubmit()
     * and it clears all route geometries.
     *
     * @private
     */
  }, {
    key: "_clearRouteResultsGeometry",
    value: function _clearRouteResultsGeometry() {
      var map = this.getMap();
      if (this._geojsonRoute != null) {
        map.removeLayer(this._geojsonRoute);
        this._geojsonRoute = null;
      }
    }

    /**
     * this method is called by this.onRouteComputationSubmit()
     * and it clears all route geometries.
     *
     * @private
     */
  }, {
    key: "_clearRouteResultsFeatureGeometry",
    value: function _clearRouteResultsFeatureGeometry() {
      var map = this.getMap();

      // on retire la couche itinéraire de la carte
      if (this._geojsonSections != null) {
        map.removeLayer(this._geojsonSections);
        this._geojsonSections = null;
        this._geojsonObject = null;
      }
      // on retire l'overlay de la popup de la carte
      if (this._popupOverlay != null) {
        map.removeOverlay(this._popupOverlay);
        this._popupOverlay = null;
      }
      // et les interactions liées à cette couche
      if (this._resultsSelectInteraction != null) {
        map.removeInteraction(this._resultsSelectInteraction);
        this._resultsSelectInteraction = null;
      }
      if (this._resultsHoverInteraction != null) {
        map.removeInteraction(this._resultsHoverInteraction);
        this._resultsHoverInteraction = null;
      }
    }

    /**
     * this method is called by event 'click' on control main container
     * and hide suggested Locations (unless target is an autocomplete input)
     *
     * @param {Object} e - event
     *
     * @private
     */
  }, {
    key: "_hideRouteSuggestedLocations",
    value: function _hideRouteSuggestedLocations(e) {
      // si on clique sur un input de saisie de locationSelector
      if (e.target && e.target.id && e.target.id.indexOf("GPlocationOrigin_") !== -1) {
        // on récupère le numéro du point
        var pointId = parseInt(e.target.id.split("_")[1][0], 10) - 1;
        // et on cache les autres résultats d'autocomplétion (sauf celui sur lequel on clique)
        for (var j = 0; j < this._currentPoints.length; j++) {
          if (j !== parseInt(pointId, 10)) {
            this._currentPoints[j]._hideSuggestedLocation();
          }
        }
      } else {
        // si on clique ailleurs dans le DOM du control, on cache tous les résultats d'autocomplétion
        for (var i = 0; i < this._currentPoints.length; i++) {
          this._currentPoints[i]._hideSuggestedLocation();
        }
      }
    }

    /**
     * this method displays waiting container and sets a timeout
     *
     * @private
     */
  }, {
    key: "_displayWaitingContainer",
    value: function _displayWaitingContainer() {
      this._waitingContainer.className = "GPwaitingContainer GPwaitingContainerVisible gpf-waiting gpf-waiting--visible";
      this._waiting = true;

      // mise en place d'un timeout pour réinitialiser le panel (cacher la patience)
      // si on est toujours en attente (si la requête est bloquée par exemple)
      // ceci est vrai, uniquement sur le protocole JSONP !
      var opts = this.options.routeOptions;
      if (opts && opts.timeOut) {
        if (this._timer) {
          clearTimeout(this._timer);
          this._timer = null;
        }
        var context = this;
        this._timer = setTimeout(function () {
          if (context._waiting === true) {
            context._hideWaitingContainer();
          } else {
            if (context._timer) {
              clearTimeout(context._timer);
            }
          }
        }, 16000);
      }
    }

    /**
     * this method hides waiting container and clears timeout
     *
     * @private
     */
  }, {
    key: "_hideWaitingContainer",
    value: function _hideWaitingContainer() {
      if (this._waiting) {
        this._waitingContainer.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
        this._waiting = false;
        var opts = this.options.routeOptions;
        if (opts && opts.timeOut) {
          clearTimeout(this._timer);
          this._timer = null;
        }
      }
    }

    // ################################################################### //
    // ########################## Geometry ############################### //
    // ################################################################### //

    /**
     * simplified instructions
     *
     * @param {Object[]} instructions - list of instructions
     *
     * @returns {Object[]} simplified instructions
     *
     * @private
     */
  }, {
    key: "_simplifiedInstructions",
    value: function _simplifiedInstructions(instructions) {
      var newInstructions = [];

      // cas où...
      var current = instructions[0];
      if (instructions.length === 1) {
        newInstructions.push(current);
      }
      for (var i = 1; i < instructions.length; i++) {
        var o = instructions[i];
        if (o.instruction === current.instruction) {
          current.distance = (parseFloat(o.distance) + parseFloat(current.distance)).toString();
          current.duration = (parseFloat(o.duration) + parseFloat(current.duration)).toString();
          for (var j = 1; j < o.geometry.coordinates.length; j++) {
            current.geometry.coordinates.push(o.geometry.coordinates[j]);
          }
        } else {
          newInstructions.push(current);
          current = o;
          // last
          if (i === instructions.length - 1) {
            newInstructions.push(o);
            current = null;
          }
        }
      }
      logger.log(newInstructions);
      return newInstructions;
    }

    // ################################################################### //
    // ################# Utils for Distance/Duration ##################### //
    // ################################################################### //

    /**
     * convert seconds to time : HH:MM:SS
     *
     * @param {Number} duration - duration in seconds
     *
     * @returns {String} time in hours/minutes/seconds
     *
     * @private
     */
  }, {
    key: "_convertSecondsToTime",
    value: function _convertSecondsToTime(duration) {
      var time = "";
      duration = Math.round(duration);
      var hours = Math.floor(duration / (60 * 60));
      var divisor4minutes = duration % (60 * 60);
      var minutes = Math.floor(divisor4minutes / 60);
      // if (!minutes) {
      //     minutes = "00";
      // }

      // var divisor4seconds = divisor4minutes % 60;
      // var seconds = Math.ceil(divisor4seconds);
      // if (!seconds) {
      //     seconds = "00";
      // }

      if (hours) {
        time = hours + "h ";
      }
      time += minutes + " min";
      return time;
    }

    /**
     * convert distance in meters or kilometers
     *
     * @param {Number} distance - distance in meters
     *
     * @returns {String} distance in km
     *
     * @private
     */
  }, {
    key: "_convertDistance",
    value: function _convertDistance(distance) {
      var d = "";
      var distanceKm = parseInt(distance / 1000, 10);
      if (!distanceKm) {
        d = parseInt(distance, 10) + " m"; // arrondi !
      } else {
        d = distanceKm + " km";
      }
      return d;
    }
  }]);
}(_Control__WEBPACK_IMPORTED_MODULE_1__["default"]);

// on récupère les méthodes de la classe commune ReverseGeocodingDOM
Object.assign(Route.prototype, _RouteDOM__WEBPACK_IMPORTED_MODULE_21__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Route);

// Expose Route as ol.control.Route (for a build bundle)
if (window.ol && window.ol.control) {
  window.ol.control.Route = Route;
}

/***/ }),

/***/ "./src/packages/Controls/Route/RouteDOM.js":
/*!*************************************************!*\
  !*** ./src/packages/Controls/Route/RouteDOM.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Utils/SelectorID */ "./src/packages/Utils/SelectorID.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_GeocodeUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Utils/GeocodeUtils */ "./src/packages/Utils/GeocodeUtils.js");



var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__["default"].getLogger("RouteDOM");
var RouteDOM = {
  /**
  * Add uuid to the tag ID
  * @param {String} id - id selector
  * @returns {String} uid - id selector with an unique id
  */
  _addUID: function _addUID(id) {
    var uid = this._uid ? id + "-" + this._uid : id;
    return uid;
  },
  /**
   * Main container (DOM)
   *
   * @returns {DOMElement} DOM element
   */
  _createMainContainerElement: function _createMainContainerElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GProute");
    container.className = "GPwidget gpf-widget gpf-widget-button";
    return container;
  },
  // ################################################################### //
  // ################# Methods to display Main Panel ################### //
  // ################################################################### //

  /**
   * Show route control
   * see event !
   *
   * @returns {DOMElement} DOM element
   */
  _createShowRoutePictoElement: function _createShowRoutePictoElement() {
    // contexte d'execution
    var context = this;
    var button = document.createElement("button");
    button.id = this._addUID("GPshowRoutePicto");
    button.className = "GPshowOpen GPshowAdvancedToolPicto GPshowRoutePicto gpf-btn gpf-btn-icon gpf-btn-icon-route fr-btn";
    button.title = "Ouvrir le calcul d'itinéraire";
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);

    // gestionnaire d'evenement :
    // on ouvre le menu de saisie du calcul d'itiniraire
    // L'ouverture/Fermeture permet de faire le menage
    // (reinitialisation)
    if (button.addEventListener) {
      button.addEventListener("click", function (e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowRoutePanelClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function (e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowRoutePanelClick(e);
      });
    }
    return button;
  },
  // ################################################################### //
  // ################## Methods to display Inputs Panel ################ //
  // ################################################################### //

  /**
   * Create Container Panel
   *
   * FIXME
   * don't call this._createRoutePanelHeaderElement
   * don't call this._createRoutePanelFormElement
   * don't call this._createRoutePanelResultsElement
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelElement: function _createRoutePanelElement() {
    var dialog = document.createElement("dialog");
    dialog.id = this._addUID("GProutePanel");
    dialog.className = "GPpanel gpf-panel fr-modal";

    // dialog.appendChild(this._createRoutePanelHeaderElement());
    // dialog.appendChild(this._createRoutePanelFormElement());
    // dialog.appendChild(this._createRoutePanelResultsElement());

    return dialog;
  },
  _createRoutePanelDivElement: function _createRoutePanelDivElement() {
    var div = document.createElement("div");
    div.className = "gpf-panel__body fr-modal__body";
    return div;
  },
  /**
   * Create Header Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelHeaderElement: function _createRoutePanelHeaderElement() {
    // contexte d'execution
    var self = this;
    var container = document.createElement("div");
    container.className = "GPpanelHeader gpf-panel__header fr-modal__header";
    var div = document.createElement("div");
    div.className = "GPpanelTitle gpf-panel__title fr-modal__title fr-m-1w";
    div.innerHTML = "Calcul d'itinéraire";
    container.appendChild(div);
    var divClose = document.createElement("button");
    divClose.id = this._addUID("GProutePanelClose");
    divClose.className = "GPpanelClose GProutePanelClose gpf-btn gpf-btn-icon-close fr-btn--close fr-btn fr-btn--secondary fr-m-1w";
    divClose.title = "Masquer le panneau";

    // Link panel close / visibility checkbox
    if (divClose.addEventListener) {
      divClose.addEventListener("click", function () {
        document.getElementById(self._addUID("GPshowRoutePicto")).click();
      }, false);
    } else if (divClose.attachEvent) {
      divClose.attachEvent("onclick", function () {
        document.getElementById(self._addUID("GPshowRoutePicto")).click();
      });
    }
    var span = document.createElement("span");
    span.className = "GPelementHidden gpf-visible"; // afficher en dsfr
    span.innerText = "Fermer";
    divClose.appendChild(span);
    container.appendChild(divClose);
    return container;
  },
  /**
   * Create Footer Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFooterElement: function _createRoutePanelFooterElement() {
    var container = document.createElement("div");
    container.className = "GPpanelFooter gpf-panel__footer fr-modal__footer";
    return container;
  },
  /**
   * Create Form
   * see evenement !
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormElement: function _createRoutePanelFormElement() {
    // contexte d'execution
    var self = this;
    var form = document.createElement("form");
    form.id = this._addUID("GProuteForm");
    form.className = "gpf-panel__content fr-modal__content";
    form.setAttribute("onkeypress", "return event.keyCode != 13;"); // FIXME hack pour desactiver l'execution via 'enter' au clavier !

    form.addEventListener("submit", function (e) {
      logger.log(e);
      e.preventDefault();

      // points
      var points = document.getElementsByClassName(self._addUID("GPlocationPoint"));

      // Must have at least two origin points
      var start = points[0].childNodes[0].id;
      var end = points[points.length - 1].childNodes[0].id;
      var startID = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(start);
      var endID = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(end);
      if (document.getElementById(self._addUID("GPlocationOrigin_" + startID)).value === "" && document.getElementById(self._addUID("GPlocationOriginCoords_" + startID)).value === "" || document.getElementById(self._addUID("GPlocationOrigin_" + endID)).value === "" && document.getElementById(self._addUID("GPlocationOriginCoords_" + endID)).value === "") {
        return false;
      }

      // Send stages to results panel
      self._addRouteResultsStagesValuesElement(points);

      // on peut récuperer les valeurs utiles pour les transmettre au service d'iti...
      // - le mode de calcul
      // - le mode de transport
      // - les exclusions
      // Les points sont déjà stockés dans l'application.

      // computation mode params
      var modeComputation = null;
      if (document.getElementById(self._addUID("GProuteComputationSelect"))) {
        var select = document.getElementById(self._addUID("GProuteResultsComputationSelect"));
        select.selectedIndex = document.getElementById(self._addUID("GProuteComputationSelect")).selectedIndex;
        modeComputation = select.options[select.selectedIndex].value;
      }

      // transport mode params
      var modeTransport = null;
      // voiture ?
      if (document.getElementById(self._addUID("GProuteTransportCar"))) {
        if (document.getElementById(self._addUID("GProuteTransportCar")).checked) {
          modeTransport = document.getElementById(self._addUID("GProuteTransportCar")).value;
        }
      }
      // pieton ?
      if (document.getElementById(self._addUID("GProuteTransportPedestrian"))) {
        if (document.getElementById(self._addUID("GProuteTransportPedestrian")).checked) {
          modeTransport = document.getElementById(self._addUID("GProuteTransportPedestrian")).value;
        }
      }

      // exclusions params
      var exclusions = [];
      var exclusionsElement = document.getElementsByClassName("GProuteExclusionsOption");
      for (var j = 0; j < exclusionsElement.length; j++) {
        var id = exclusionsElement[j].htmlFor;
        var el = document.getElementById(id);
        if (!el.checked) {
          exclusions.push(el.value);
        }
      }
      self.onRouteComputationSubmit({
        computation: modeComputation,
        transport: modeTransport,
        exclusions: exclusions
      });

      // FIXME mise à jour du controle dans le composant JS !
      // document.getElementById(self._addUID("GProuteForm")).className = "GPelementHidden";
      // document.getElementById(self._addUID("GProuteResultsPanel")).className = "";

      return false;
    });
    return form;
  },
  /**
   * Create Results Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelResultsElement: function _createRoutePanelResultsElement() {
    var container = document.createElement("div");
    container.id = this._addUID("GProuteResultsPanel");
    container.className = "GPelementHidden gpf-hidden";
    container.appendChild(this._createRouteResultsStagesElement());
    container.appendChild(this._createRouteResultsElement());
    var divBorderUp = document.createElement("div");
    divBorderUp.className = "GPfakeBorder GPfakeBorderLeft";
    container.appendChild(divBorderUp);
    container.appendChild(this._createRouteShowResultsDetailsElement());
    var labelShow = document.createElement("label");
    labelShow.htmlFor = this._addUID("GProuteResultsShowDetails");
    labelShow.innerHTML = "Afficher le détail";
    container.appendChild(labelShow);
    var labelHide = document.createElement("label");
    labelHide.htmlFor = this._addUID("GProuteResultsShowDetails");
    labelHide.innerHTML = "Masquer le détail";
    container.appendChild(labelHide);
    var divBorderDown = document.createElement("div");
    divBorderDown.className = "GPfakeBorder";
    container.appendChild(divBorderDown);
    container.appendChild(this._createRouteResultsDetailsElement());
    return container;
  },
  /**
   * Create Waiting Panel
   *
   * @returns {DOMElement} DOM element
   */
  _createRouteWaitingElement: function _createRouteWaitingElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GProuteCalcWaitingContainer");
    div.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
    var p = document.createElement("p");
    p.className = "GPwaitingContainerInfo gpf-waiting_info";
    p.innerHTML = "Recherche en cours...";
    div.appendChild(p);
    return div;
  },
  // ################################################################### //
  // ############### Methods to the window results ##################### //
  // ################################################################### //

  /**
   * Create Results Stages
   * (results dynamically generate !)
   *
   * @returns {DOMElement} DOM element
   */
  _createRouteResultsStagesElement: function _createRouteResultsStagesElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GProuteResultsStages");
    return div;
  },
  /**
   * Add Stages Results
   *
   * @param {DOMElement} points - list of points
   */
  _addRouteResultsStagesValuesElement: function _addRouteResultsStagesValuesElement(points) {
    document.getElementById(this._addUID("GProuteResultsStages")).innerHTML = "";
    for (var i = 0; i < points.length; i++) {
      var tag = points[i].childNodes[0].id;
      var id = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_0__["default"].index(tag);
      if (document.getElementById(this._addUID("GPlocationPoint_" + id)).className === "GPflexInput GPlocationStageFlexInput gpf-flex") {
        var resultStage = document.createElement("div");
        resultStage.className = "GProuteResultsStages";
        var resultStageLabel = document.createElement("div");
        resultStageLabel.className = "GProuteResultStageLabel";
        resultStageLabel.innerHTML = document.getElementById(this._addUID("GPlocationOriginLabel_" + id)).innerHTML + " :";
        resultStage.appendChild(resultStageLabel);
        var resultStageValue = document.createElement("div");
        resultStageValue.className = "GProuteResultStageValue";
        var elementCoords = document.getElementById(this._addUID("GPlocationOriginCoords_" + id));
        var stageCoords = elementCoords.value;
        var visible = elementCoords.className === "GPelementVisible gpf-visible";
        if (stageCoords !== null && stageCoords !== "" && visible) {
          resultStageValue.innerHTML = stageCoords;
        } else {
          resultStageValue.innerHTML = document.getElementById(this._addUID("GPlocationOrigin_" + id)).value;
        }
        resultStage.appendChild(resultStageValue);
        if (resultStageValue.innerHTML !== "") {
          document.getElementById(this._addUID("GProuteResultsStages")).appendChild(resultStage);
        }
      }
    }
  },
  /**
   * Create Show Results
   * see event!
   *
   * @returns {DOMElement} DOM element
   */
  _createRouteResultsElement: function _createRouteResultsElement() {
    // contexte
    var self = this;
    var container = document.createElement("div");
    container.id = this._addUID("GProuteResults");

    // FIXME Route results are dynamically filled in Javascript by route service
    var divValue = document.createElement("div");
    divValue.id = this._addUID("GProuteResultsValues");
    container.appendChild(divValue);
    var divMode = document.createElement("div");
    divMode.id = this._addUID("GProuteResultsMode");
    var select = document.createElement("select");
    select.id = this._addUID("GProuteResultsComputationSelect");
    select.className = "GPselect";
    // gestionnaire d'evenement :
    // on stocke la valeur du mode de calcul, et on relance le calcul d'itiniraire
    select.addEventListener("change", function (e) {
      self.onRouteModeComputationChangeAndRun(e);
    });
    var computes = [{
      code: "fastest",
      label: "Plus rapide"
    }, {
      code: "shortest",
      label: "Plus court"
    }];
    for (var i = 0; i < computes.length; i++) {
      var option = document.createElement("option");
      option.value = computes[i].code;
      option.text = computes[i].label;
      select.appendChild(option);
    }
    divMode.appendChild(select);
    container.appendChild(divMode);
    var divNew = document.createElement("div");
    divNew.id = this._addUID("GProuteResultsNew");
    divNew.title = "Modifier le calcul";
    divNew.addEventListener("click", function (e) {
      document.getElementById(self._addUID("GProuteResultsPanel")).className = "GPelementHidden gpf-hidden";
      document.getElementById(self._addUID("GProuteForm")).className = "gpf-panel__content fr-modal__content";
      self.onShowRouteResultsNewClick(e);
    });
    container.appendChild(divNew);
    return container;
  },
  /**
   * Add Results Duration and Distance
   * (results dynamically generate !)
   * see event!
   * @param {Number} distance - distance
   * @param {Number} duration - duration
   * @param {Function} fconvert - fconvert
   *
   * @returns {DOMElement} DOM element
   */
  _addRouteResultsValuesElement: function _addRouteResultsValuesElement(distance, duration, fconvert) {
    var div = document.getElementById(this._addUID("GProuteResultsValues"));

    // clean !
    if (div.childElementCount) {
      while (div.firstChild) {
        div.removeChild(div.firstChild);
      }
    }
    var containerDistance = document.createElement("div");
    containerDistance.className = "GProuteResultsValue";
    var labelDistance = document.createElement("label");
    labelDistance.className = "GProuteResultsValueLabel";
    labelDistance.innerHTML = "Distance :";
    containerDistance.appendChild(labelDistance);
    var distanceLabel = 0;
    var isKm = parseInt(distance / 1000, 10);
    if (!isKm) {
      distanceLabel = Math.round(distance) + " m";
    } else {
      var distanceArrondi = Math.round(distance);
      distanceArrondi = distanceArrondi / 1000;
      distanceLabel = distanceArrondi + " km";
    }
    var divDistance = document.createElement("div");
    divDistance.id = this._addUID("GProuteResultsValueDist");
    divDistance.innerHTML = distanceLabel;
    containerDistance.appendChild(divDistance);
    div.appendChild(containerDistance);
    var containerDuration = document.createElement("div");
    containerDuration.className = "GProuteResultsValue";
    var labelDuration = document.createElement("label");
    labelDuration.className = "GProuteResultsValueLabel";
    labelDuration.innerHTML = "Durée :";
    containerDuration.appendChild(labelDuration);
    var divDuration = document.createElement("div");
    divDuration.id = this._addUID("GProuteResultsValueDist");
    divDuration.innerHTML = fconvert(duration);
    containerDuration.appendChild(divDuration);
    div.appendChild(containerDuration);
    return div;
  },
  /**
   * Create Show Results Details
   *
   * @returns {DOMElement} DOM element
   */
  _createRouteShowResultsDetailsElement: function _createRouteShowResultsDetailsElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GProuteResultsShowDetails");
    input.type = "checkbox";
    return input;
  },
  /**
   *  Create Results Details
   *
   * @returns {DOMElement} DOM element
   */
  _createRouteResultsDetailsElement: function _createRouteResultsDetailsElement() {
    // <!-- Route results details are dynamically filled in Javascript by route service -->
    var div = document.createElement("div");
    div.id = this._addUID("GProuteResultsDetails");
    return div;
  },
  /**
   *  Add Results Details
   * (results dynamically generate !)
   * @param {Object[]} instructions - instructions
   * @param {Function} fconvert - fconvert
   *
   * @returns {DOMElement} DOM element
   */
  _addRouteResultsDetailsElement: function _addRouteResultsDetailsElement(instructions, fconvert) {
    // contexte
    var context = this;
    var div = document.getElementById(this._addUID("GProuteResultsDetails"));

    // clean !
    if (div.childElementCount) {
      while (div.firstChild) {
        div.removeChild(div.firstChild);
      }
    }

    // calcul des valeurs cumulé !
    var distanceCumul = 0;
    var durationCumul = 0;

    /* jshint -W083 */
    for (var i = 0; i < instructions.length; i++) {
      var id = i + 1;
      var o = instructions[i];
      var divNum = document.createElement("div");
      divNum.className = "GProuteResultsDetailsNumber";
      divNum.innerHTML = id + ".";
      div.appendChild(divNum);
      durationCumul += parseFloat(o.duration);
      distanceCumul += parseFloat(o.distance);
      var distance = 0;
      var isCumulKm = parseInt(distanceCumul / 1000, 10);
      if (!isCumulKm) {
        distance = Math.round(distanceCumul) + " m";
      } else {
        var distanceArrondi = Math.round(distanceCumul);
        distanceArrondi = distanceArrondi / 1000;
        distance = distanceArrondi + " km";
      }
      var divIns = document.createElement("div");
      divIns.className = "GProuteResultsDetailsInstruction";
      divIns.id = this._addUID("GProuteResultsDetailsInstruction_" + id);
      divIns.title = "distance : " + distance + " / " + "temps : " + fconvert(durationCumul);
      divIns.innerHTML = o.instruction;
      divIns.addEventListener("mouseover", function (e) {
        context.onRouteResultsDetailsMouseOver(e);
      });
      divIns.addEventListener("mouseout", function (e) {
        context.onRouteResultsDetailsMouseOut(e);
      });
      divIns.addEventListener("click", function (e) {
        // mode mobile !
        if (typeof context.onRouteResultsDetailsClick === "function") {
          context.onRouteResultsDetailsClick(e);
        }
      });
      div.appendChild(divIns);
    }
    return div;
  },
  // ################################################################### //
  // ################### Methods to the form points #################### //
  // ################# OVERWRITTEN BY LOCATIONSELECTOR ! ################# //

  /**
   * Create Point
   * see event !
   * OVERWRITTEN BY LOCATIONSELECTOR !
   * (version initial without LOCATIONSELECTOR PLUGIN)
   * @param {Integer} n - n
   * @param {String} text - text
   * @param {Boolean} visibility - visibility
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormPointElement: function _createRoutePanelFormPointElement(n, text, visibility) {
    // contexte d'execution
    var context = this;
    var div = document.createElement("div");
    div.id = "GProutePoint" + n;
    div.className = visibility ? "GPflexInput GProuteStageFlexInput" : "GPflexInput GProuteStageFlexInputHidden";
    var labelOrigin = document.createElement("label");
    labelOrigin.id = "GProuteOriginLabel" + n;
    labelOrigin.htmlFor = "GProuteOrigin" + n;
    labelOrigin.innerHTML = text;
    labelOrigin.addEventListener("click", function () {
      var i = this.id.charAt(this.id.length - 1);
      document.getElementById("GProuteOriginCoords" + i).value = "";
      for (var j = 1; j < 8; j++) {
        document.getElementById("GProutePoint" + j).style.display = "flex";
      }
      document.getElementById("GProuteForm").className = "gpf-panel__content fr-modal__content";
      document.getElementById("GProuteOriginPointer" + i).checked = false;
      document.getElementById("GProuteOrigin" + i).className = "GPelementVisible gpf-visible";
      document.getElementById("GProuteOriginCoords" + i).className = "GPelementHidden gpf-hidden";
    });
    div.appendChild(labelOrigin);
    var inputOrigin = document.createElement("input");
    inputOrigin.id = "GProuteOrigin" + n;
    inputOrigin.className = "GPelementVisible gpf-visible";
    inputOrigin.type = "text";
    inputOrigin.placeholder = "Saisir une adresse";
    inputOrigin.addEventListener("keyup", function (e) {
      var charCode = e.which || e.keyCode;
      if (charCode === 13 || charCode === 10) {
        return;
      }
      var i = this.id.charAt(this.id.length - 1);
      if (document.getElementById("GProuteOrigin" + i).value.length > 2) {
        document.getElementById("GProuteAutoCompleteList" + i).style.display = "block";
      } else {
        document.getElementById("GProuteAutoCompleteList" + i).style.display = "none";
      }
      // gestionnaire d'evenement :
      // on récupère la valeur de saisie pour une requête sur le service d'autocompletion.
      // le resultat de la requête nous permet de recuperer les coordonnées du point...
      context.onAutoCompleteSearchText(e);
    });
    inputOrigin.addEventListener("blur", function () {
      var i = this.id.charAt(this.id.length - 1);
      document.getElementById("GProuteAutoCompleteList" + i).style.display = "none";
    });
    div.appendChild(inputOrigin);
    var inputOriginCoord = document.createElement("input");
    inputOriginCoord.id = "GProuteOriginCoords" + n;
    inputOriginCoord.className = "GPelementHidden gpf-hidden";
    inputOriginCoord.type = "text";
    inputOriginCoord.disabled = true;
    div.appendChild(inputOriginCoord);
    var inputOriginPointer = document.createElement("input");
    inputOriginPointer.id = "GProuteOriginPointer" + n;
    inputOriginPointer.type = "checkbox";
    div.appendChild(inputOriginPointer);
    var labelOriginPointer = document.createElement("label");
    labelOriginPointer.id = "GProuteOriginPointerImg" + n;
    labelOriginPointer.htmlFor = "GProuteOriginPointer" + n;
    labelOriginPointer.className = "GProuteOriginPointerImg";
    labelOriginPointer.title = "Pointer un lieu sur la carte";
    labelOriginPointer.addEventListener("click", function (evt) {
      evt.preventDefault();
      evt.stopPropagation();
      var i = this.id.charAt(this.id.length - 1);
      var j;
      for (j = 1; j < 8; j++) {
        if (i !== j) {
          document.getElementById("GProuteOriginPointer" + j).checked = false;
          if (document.getElementById("GProuteOriginCoords" + j).value === "Pointer un lieu sur la carte") {
            document.getElementById("GProuteOriginCoords" + j).value = "";
            document.getElementById("GProuteOrigin" + j).className = "GPelementVisible gpf-visible";
            document.getElementById("GProuteOriginCoords" + j).className = "GPelementHidden gpf-hidden";
          }
        }
      }
      if (document.getElementById("GProuteOriginPointer" + i).checked) {
        document.getElementById("GProuteOriginCoords" + i).value = "";
        for (j = 1; j < 8; j++) {
          document.getElementById("GProutePoint" + j).style.display = "flex";
        }
        document.getElementById("GProuteForm").className = "gpf-panel__content fr-modal__content";
        document.getElementById("GProuteOriginPointer" + i).checked = false;
        document.getElementById("GProuteOrigin" + i).className = "GPelementVisible gpf-visible";
        document.getElementById("GProuteOriginCoords" + i).className = "GPelementHidden gpf-hidden";
      } else {
        document.getElementById("GProuteOriginCoords" + i).value = "Pointer un lieu sur la carte";
        for (j = 1; j < 8; j++) {
          if (i === j) {
            document.getElementById("GProutePoint" + j).style.display = "flex";
          } else {
            document.getElementById("GProutePoint" + j).style.display = "none";
          }
        }
        document.getElementById("GProuteForm").className = "GProuteFormMini gpf-panel__content fr-modal__content";
        document.getElementById("GProuteOriginPointer" + i).checked = true;
        document.getElementById("GProuteOrigin" + i).className = "GPelementHidden gpf-hidden";
        document.getElementById("GProuteOriginCoords" + i).className = "GPelementVisible gpf-visible";
      }
      // gestionnaire d'evenement :
      // on stocke la valeur du point, utilisée pour la requête sur le service de calcul d'itiniraire
      context.onRouteMapPointClick(evt);
    });
    div.appendChild(labelOriginPointer);
    return div;
  },
  /**
   * Create Remove Point tag
   * see event !
   * OVERWRITTEN BY LOCATIONSELECTOR !
   * (version initial without LOCATIONSELECTOR PLUGIN)
   * @param {Integer} n - n
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormRemoveStageElement: function _createRoutePanelFormRemoveStageElement(n) {
    // contexte d'execution
    var context = this;
    var divRm = document.createElement("div");
    divRm.id = "GProuteStageRemove" + n;
    divRm.className = "GProuteStageRemove";
    divRm.title = "Supprimer l'étape";
    if (n !== 1 && n !== 7) {
      divRm.addEventListener("click", function (e) {
        var i = this.id.charAt(this.id.length - 1);
        document.getElementById("GProutePoint" + i).className = "GPflexInput GProuteStageFlexInputHidden";
        document.getElementById("GProuteOrigin" + i).value = "";
        document.getElementById("GProuteOrigin" + i).className = "GPelementVisible gpf-visible";
        document.getElementById("GProuteOriginCoords" + i).value = "";
        document.getElementById("GProuteOriginCoords" + i).className = "GPelementHidden gpf-hidden";
        document.getElementById("GProuteStageAdd").style.display = "";
        // Moving up exclusions picto
        // var exclusionsPictoTop = document.getElementById("GPshowRouteExclusionsPicto").style.top;
        // document.getElementById("GPshowRouteExclusionsPicto").style.top = (parseInt(exclusionsPictoTop, 10) - 33).toString() + "px";
        // gestionnaire d'evenement :
        // on supprime le point, utilisé pour la requête sur le service d'itiniraire
        context.onRouteRemovePointClick(e);
      });
    }
    return divRm;
  },
  /**
   * Create Add Point tag
   * see event !
   * OVERWRITTEN BY LOCATIONSELECTOR !
   * (version initial without LOCATIONSELECTOR PLUGIN)
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormAddStageElement: function _createRoutePanelFormAddStageElement() {
    // contexte d'execution
    var context = this;
    var divAdd = document.createElement("div");
    divAdd.id = "GProuteStageAdd";
    divAdd.title = "Ajouter une étape";
    divAdd.addEventListener("click", function (e) {
      var lastStage = 1;
      var nbStages = 0;
      for (var i = 2; i < 7; i++) {
        if (document.getElementById("GProutePoint" + i).className === "GPflexInput GProuteStageFlexInputHidden") {
          if (lastStage === 1) {
            lastStage = i;
          }
        } else {
          nbStages++;
        }
      }
      if (lastStage < 7) {
        document.getElementById("GProutePoint" + lastStage).className = "GPflexInput GProuteStageFlexInput";
        // Moving down exclusions picto
        // var exclusionsPictoTop = document.getElementById("GPshowRouteExclusionsPicto").style.top;
        // document.getElementById("GPshowRouteExclusionsPicto").style.top = (parseInt(exclusionsPictoTop, 10) + 33).toString() + "px";
      }
      if (nbStages === 4) {
        document.getElementById("GProuteStageAdd").style.display = "none";
      }
      // gestionnaire d'evenement :
      // on ajoute le point, utilisé pour la requête sur le service d'itiniraire
      context.onRouteAddPointClick(e);
    });
    return divAdd;
  },
  /**
   * Create Results autocompletion to the point
   * see event!
   * OVERWRITTEN BY LOCATIONSELECTOR !
   * (version initial without LOCATIONSELECTOR PLUGIN)
   * @param {Integer} n - n
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormAutoCompleteListElement: function _createRoutePanelFormAutoCompleteListElement(n) {
    // contexte d'execution
    var context = this;
    var div = document.createElement("div");
    div.id = "GProuteAutoCompleteList" + n;
    div.className = "GPadvancedAutoCompleteList";
    if (div.addEventListener) {
      div.addEventListener("click", function (e) {
        context.onAutoCompletedResultsItemClick(e);
        document.getElementById("GProuteAutoCompleteList" + n).style.display = "none";
      }, false);
    } else if (div.attachEvent) {
      div.attachEvent("onclick", function (e) {
        context.onAutoCompletedResultsItemClick(e);
        document.getElementById("GProuteAutoCompleteList" + n).style.display = "none";
      });
    }

    // Proposals are dynamically filled in Javascript by autocomplete service
    // <div class="GPautoCompleteProposal">...</div>

    return div;
  },
  /**
   * Autocompletion result to a point.
   * Proposals are dynamically filled in Javascript by autocomplete service
   * OVERWRITTEN BY LOCATIONSELECTOR !
   * (version initial without LOCATIONSELECTOR PLUGIN)
   *
   *
   * @param {Object} location - suggested location results
   * @param {Number} n  - number of the point
   * @param {Number} id - ID
   */
  _createRouteAutoCompletedLocationElement: function _createRouteAutoCompletedLocationElement(location, n, id) {
    var container = document.getElementById("GProuteAutoCompleteList" + n);
    var div = document.createElement("div");
    div.id = "AutoCompletedLocation" + id;
    div.className = "GPautoCompleteProposal";
    div.innerHTML = _Utils_GeocodeUtils__WEBPACK_IMPORTED_MODULE_2__["default"].getSuggestedLocationFreeform(location);
    container.appendChild(div);
  },
  // ################################################################### //
  // ############## Methods to the choice mode into form ############### //
  // ################################################################### //

  /**
   * Create Container to Mode choice transport
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormModeChoiceElement: function _createRoutePanelFormModeChoiceElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GProuteModeChoice");

    // div.appendChild(this._createRoutePanelFormModeChoiceTransportElement());
    // div.appendChild(this._createRoutePanelFormModeChoiceComputeElement());

    return div;
  },
  /**
   * Create Mode choice transport
   * see event !
   * FIXME event not useful
   * @param {String[]} transports - transports
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormModeChoiceTransportElement: function _createRoutePanelFormModeChoiceTransportElement(transports) {
    // contexte d'execution
    var context = this;
    var divContainer = document.createElement("div");
    divContainer.id = this._addUID("GProuteTransportChoice");
    var label = document.createElement("label");
    label.className = "GProuteModeLabel gpf-label fr-label";
    label.innerHTML = "Mode de transport";
    divContainer.appendChild(label);

    /* jshint -W083 */
    for (var i = 0; i < transports.length; i++) {
      var transport = transports[i];
      var div = document.createElement("div");
      div.className = "GProuteTransportChoice gpf-flex gpf-radio-group fr-radio-group fr-my-1w";
      if (transport === "Voiture") {
        var inputCar = document.createElement("input");
        inputCar.id = this._addUID("GProuteTransportCar");
        inputCar.type = "radio";
        inputCar.name = "GProuteTransport";
        inputCar.value = "Voiture";
        if (i === 0) {
          inputCar.checked = true;
        }
        // gestionnaire d'evenement :
        // on stocke le mode de transport,
        // utilisation pour la requête sur le service de calcul d'itiniraire
        if (inputCar.addEventListener) {
          inputCar.addEventListener("change", function (e) {
            context.onRouteModeTransportChange(e);
          });
        } else if (inputCar.attachEvent) {
          inputCar.attachEvent("onchange", function (e) {
            context.onRouteModeTransportChange(e);
          });
        }
        div.appendChild(inputCar);
        var labelCar = document.createElement("label");
        labelCar.className = "GProuteTransportImg gpf-label fr-label";
        labelCar.htmlFor = this._addUID("GProuteTransportCar");
        labelCar.title = "Voiture";
        labelCar.innerHTML = "Voiture";
        div.appendChild(labelCar);
      }
      if (transport === "Pieton") {
        var inputPedestrian = document.createElement("input");
        inputPedestrian.id = this._addUID("GProuteTransportPedestrian");
        inputPedestrian.type = "radio";
        inputPedestrian.name = "GProuteTransport";
        inputPedestrian.value = "Pieton";
        if (i === 0) {
          inputPedestrian.checked = true;
        }
        // gestionnaire d'evenement :
        // on stocke le mode de transport,
        // utilisation pour la requête sur le service de calcul d'itiniraire
        if (inputPedestrian.addEventListener) {
          inputPedestrian.addEventListener("change", function (e) {
            context.onRouteModeTransportChange(e);
          });
        } else if (inputPedestrian.attachEvent) {
          inputPedestrian.attachEvent("onchange", function (e) {
            context.onRouteModeTransportChange(e);
          });
        }
        div.appendChild(inputPedestrian);
        var labelPedestrian = document.createElement("label");
        labelPedestrian.className = "GProuteTransportImg gpf-label fr-label";
        labelPedestrian.htmlFor = this._addUID("GProuteTransportPedestrian");
        labelPedestrian.title = "Piéton";
        labelPedestrian.innerHTML = "Piéton";
        div.appendChild(labelPedestrian);
      }
      divContainer.appendChild(div);
    }
    return divContainer;
  },
  /**
   * Create Mode choice computation
   * see event!
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormModeChoiceComputeElement: function _createRoutePanelFormModeChoiceComputeElement() {
    // contexte d'execution
    var context = this;
    var div = document.createElement("div");
    div.id = this._addUID("GProuteComputationChoice");
    var label = document.createElement("label");
    label.htmlFor = this._addUID("GProuteComputationSelect");
    label.innerHTML = "Mode de calcul";
    var span = document.createElement("span");
    span.className = "GProuteModeLabel";
    span.appendChild(label);
    div.appendChild(span);
    var select = document.createElement("select");
    select.id = this._addUID("GProuteComputationSelect");
    select.className = "GPselect gpf-select fr-select";
    // gestionnaire d'evenement :
    // on stocke la valeur du mode de calcul,
    // utilisation pour la requête sur le service de calcul d'itiniraire
    select.addEventListener("change", function (e) {
      context.onRouteModeComputationChange(e);
    });
    var computes = [{
      code: "fastest",
      label: "Plus rapide"
    }, {
      code: "shortest",
      label: "Plus court"
    }];
    for (var i = 0; i < computes.length; i++) {
      var option = document.createElement("option");
      option.value = computes[i].code;
      option.text = computes[i].label;
      select.appendChild(option);
    }
    div.appendChild(select);
    return div;
  },
  // ################################################################### //
  // ################# Methods to the choice exclusions ################ //
  // ################################################################### //

  /**
   * Label to Exclusions Options
   * see event !
   * FIXME event not useful
   *
   * @returns {DOMElement} DOM element
   */
  _createShowRouteExclusionsPictoElement: function _createShowRouteExclusionsPictoElement() {
    // contexte d'execution
    var context = this;
    var button = document.createElement("button");
    button.id = this._addUID("GPshowRouteExclusionsPicto");
    button.className = "GPelementHidden GPshowAdvancedToolPicto GPshowMoreOptionsImage GPshowMoreOptions GPshowRouteExclusionsPicto gpf-hidden gpf-btn fr-btn--sm fr-btn--secondary fr-icon-arrow-down-fill";
    button.title = "Exclusions";
    // button.style.top = "185px";
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", true);

    // gestionnaire d'evenement :
    // on ouvre le menu des options des exclusions
    if (button.addEventListener) {
      button.addEventListener("click", function (e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowRouteExclusionsClick(e);
      });
    } else if (button.attachEvent) {
      button.attachEvent("onclick", function (e) {
        var status = e.target.ariaPressed === "true";
        e.target.setAttribute("aria-pressed", !status);
        context.onShowRouteExclusionsClick(e);
      });
    }
    return button;
  },
  /**
   * Create Container to Exclusions
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormExclusionsElement: function _createRoutePanelFormExclusionsElement() {
    var div = document.createElement("div");
    div.id = this._addUID("GProuteExclusions");
    var label = document.createElement("label");
    label.className = "GProuteExclusionsLabel fr-m-1w";
    label.innerHTML = "Passages autorisés";
    div.appendChild(label);

    // div.appendChild(this._createRoutePanelFormExclusionOptionsElement());

    return div;
  },
  /**
   * Create Exclusions Options
   * see event !
   * FIXME event not useful
   * @param {Object[]} exclusions - exclusions
   *
   * @returns {DOMElement} DOM element
   */
  _createRoutePanelFormExclusionOptionsElement: function _createRoutePanelFormExclusionOptionsElement(exclusions) {
    // contexte d'execution
    var context = this;
    var div = document.createElement("div");
    div.className = "GProuteExclusionsOptions gpf-flex fr-checkbox-group fr-m-1w";

    /* jshint -W083 */
    for (var value in exclusions) {
      if (exclusions.hasOwnProperty(value)) {
        var status = exclusions[value];
        switch (value) {
          case "toll":
            var inputToll = document.createElement("input");
            inputToll.id = this._addUID("GProuteExclusionsToll");
            inputToll.type = "checkbox";
            inputToll.value = "Toll";
            inputToll.checked = !status;
            // gestionnaire d'evenement :
            // on stocke l'exclusion,
            // utilisation pour la requête sur le service de calcul d'itiniraire
            if (inputToll.addEventListener) {
              inputToll.addEventListener("change", function (e) {
                context.onRouteExclusionsChange(e);
              });
            } else if (inputToll.attachEvent) {
              inputToll.attachEvent("onchange", function (e) {
                context.onRouteExclusionsChange(e);
              });
            }
            div.appendChild(inputToll);
            var labelToll = document.createElement("label");
            labelToll.className = "GProuteExclusionsOption";
            labelToll.htmlFor = this._addUID("GProuteExclusionsToll");
            labelToll.innerHTML = "Péages";
            div.appendChild(labelToll);
            break;
          case "tunnel":
            var inputTunnel = document.createElement("input");
            inputTunnel.id = this._addUID("GProuteExclusionsTunnel");
            inputTunnel.type = "checkbox";
            inputTunnel.value = "Tunnel";
            inputTunnel.checked = !status;
            // gestionnaire d'evenement :
            // on stocke l'exclusion,
            // utilisation pour la requête sur le service de calcul d'itiniraire
            if (inputTunnel.addEventListener) {
              inputTunnel.addEventListener("change", function (e) {
                context.onRouteExclusionsChange(e);
              });
            } else if (inputTunnel.attachEvent) {
              inputTunnel.attachEvent("onchange", function (e) {
                context.onRouteExclusionsChange(e);
              });
            }
            div.appendChild(inputTunnel);
            var labelTunnel = document.createElement("label");
            labelTunnel.className = "GProuteExclusionsOption";
            labelTunnel.htmlFor = this._addUID("GProuteExclusionsTunnel");
            labelTunnel.innerHTML = "Tunnels";
            div.appendChild(labelTunnel);
            break;
          case "bridge":
            var inputBridge = document.createElement("input");
            inputBridge.id = this._addUID("GProuteExclusionsBridge");
            inputBridge.type = "checkbox";
            inputBridge.value = "Bridge";
            inputBridge.checked = !status;
            // gestionnaire d'evenement :
            // on stocke l'exclusion,
            // utilisation pour la requête sur le service de calcul d'itiniraire
            if (inputBridge.addEventListener) {
              inputBridge.addEventListener("change", function (e) {
                context.onRouteExclusionsChange(e);
              });
            } else if (inputBridge.attachEvent) {
              inputBridge.attachEvent("onchange", function (e) {
                context.onRouteExclusionsChange(e);
              });
            }
            div.appendChild(inputBridge);
            var labelBridge = document.createElement("label");
            labelBridge.className = "GProuteExclusionsOption";
            labelBridge.htmlFor = this._addUID("GProuteExclusionsBridge");
            labelBridge.innerHTML = "Ponts";
            div.appendChild(labelBridge);
            break;
        }
      }
    }
    return div;
  },
  // ################################################################### //
  // ############################### Submit Form ####################### //
  // ################################################################### //

  /**
   * Create Submit Form Element
   *
   * @returns {DOMElement} DOM element
   */
  _createRouteSubmitFormElement: function _createRouteSubmitFormElement() {
    var input = document.createElement("input");
    input.id = this._addUID("GProuteSubmit");
    input.className = "GPsubmit gpf-btn gpf-btn-icon-submit  fr-btn fr-btn--secondary";
    input.type = "submit";
    input.value = "Calculer";
    return input;
  },
  // ################################################################### //
  // ############################### Reset picto ####################### //
  // ################################################################### //

  /**
   * Create Reset Picto Element
   *
   * @returns {DOMElement} DOM element
   */
  _createRouteFormResetElement: function _createRouteFormResetElement() {
    var self = this;
    var buttonReset = document.createElement("button");
    buttonReset.id = this._addUID("GProuteReset");
    buttonReset.title = "Réinitialiser les paramètres";
    buttonReset.className = "GPresetPicto gpf-btn gpf-btn-icon-return fr-btn fr-btn--secondary";
    buttonReset.title = "Réinitialiser les paramètres";
    buttonReset.setAttribute("tabindex", "0");
    buttonReset.setAttribute("aria-pressed", false);
    buttonReset.addEventListener("click", function (e) {
      var status = e.target.ariaPressed === "true";
      e.target.setAttribute("aria-pressed", !status);
      self.onRouteResetClick(e);
    });
    return buttonReset;
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RouteDOM);

/***/ }),

/***/ "./src/packages/Controls/ToolBoxMeasure/MeasureToolBox.js":
/*!****************************************************************!*\
  !*** ./src/packages/Controls/ToolBoxMeasure/MeasureToolBox.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CSS_Controls_ToolBoxMeasure_GPFtoolBoxMeasure_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../CSS/Controls/ToolBoxMeasure/GPFtoolBoxMeasure.css */ "./src/packages/CSS/Controls/ToolBoxMeasure/GPFtoolBoxMeasure.css");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Utils/Helper */ "./src/packages/Utils/Helper.js");
/* harmony import */ var _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Utils/SelectorID */ "./src/packages/Utils/SelectorID.js");
/* harmony import */ var _MeasureToolBoxDOM__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MeasureToolBoxDOM */ "./src/packages/Controls/ToolBoxMeasure/MeasureToolBoxDOM.js");
// import CSS

// import "../../CSS/Controls/ToolBoxMeasure/GPFtoolBoxMeasureStyle.css";
// import local



// DOM

var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__["default"].getLogger("toolbox");

/**
 * @type {ol.control.MeasureToolBox}
 * MeasureToolBox - Boite à outils (ToolBox) pour les outils de mesures.
 * - distance
 * - aire
 * - azimut
 */
var MeasureToolBox = {
  /**
   * liste des uid/map (pour chaque toolbox)
   * { map : uid }
   * Ex. { "map1" : 465456456486845 }
   */
  _toolbox: {},
  /**
   * Ajout d'un controle dans la ToolBox.
   * Creation de la toolbox si besoin...
   *
   * @param {ol.Map} map - map
   * @param {ol.control.Control} ctrl - objet à ajouter
   */
  add: function add(map, ctrl) {
    logger.trace("ToolBox.add()", ctrl);
    if (!map) {
      logger.trace("map doesn't exist !?");
      return;
    }

    // contexte d'execution
    var context = typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : null;
    if (context) {
      // Pour info
      // l'objet ToolBox devrait être partagé avec les outils de mesures...,
      // mais, ce n'est pas le cas pour le mode modules cad un module par extension.
      // c'est pourquoi, on l'enregistre dans le contexte, qui lui est partagé (ex. window)
      this._toolbox = context.gpShareMeasureToolBox || {};
    }
    var mapContainer = map.getTargetElement();
    var mapDocument = mapContainer.ownerDocument;
    var mapId = mapContainer.id;
    if (!this._toolbox || Object.keys(this._toolbox).length === 0) {
      this._toolbox = {};
      this._toolbox[mapId] = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_3__["default"].generate();
    } else {
      if (!this._toolbox[mapId]) {
        this._toolbox[mapId] = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_3__["default"].generate();
      }
    }
    var uid = this._toolbox[mapId];
    if (!mapDocument.getElementById(this.getToolBoxID(uid))) {
      logger.trace("create toolbox !");
      // creation et ajout de la toolbox sur la map
      var toolboxContainer = this._createToolBoxContainerElement(uid);
      toolboxContainer.style.pointerEvents = "auto"; // ajout pour ol6
      var overlaysContainer = mapContainer.getElementsByClassName("ol-overlaycontainer-stopevent");
      overlaysContainer[0].appendChild(toolboxContainer);
      // mapContainer.appendChild(toolboxContainer);
    }

    // ajout du widget dans la toolbox
    var widgetContainer = mapDocument.getElementById(this.getWidgetID(uid));
    ctrl.setTarget(widgetContainer);
    if (context) {
      // Pour info
      // on partage (enregistre) l'objet ToolBox dans le contexte d'execution !
      context.gpShareMeasureToolBox = this._toolbox;
    }
    logger.trace("add control to toolbox !");
  }
};
_Utils_Helper__WEBPACK_IMPORTED_MODULE_2__["default"].assign(MeasureToolBox, _MeasureToolBoxDOM__WEBPACK_IMPORTED_MODULE_4__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MeasureToolBox);

/***/ }),

/***/ "./src/packages/Controls/ToolBoxMeasure/MeasureToolBoxDOM.js":
/*!*******************************************************************!*\
  !*** ./src/packages/Controls/ToolBoxMeasure/MeasureToolBoxDOM.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var MeasureToolBoxDOM = {
  _toolboxId: "GPtoolbox-measure-main",
  _buttonId: "GPtoolbox-measure-button",
  _widgetId: "GPtoolbox-measure-widget",
  /**
  * get toolBox ID
  * @param {Number} uid - uid
  * @returns {String} id selector unique
  */
  getToolBoxID: function getToolBoxID(uid) {
    return uid ? this._toolboxId + "-" + uid : this._toolboxId;
  },
  /**
  * get button ID
  * @param {Number} uid - uid
  * @returns {String} id selector unique
  */
  getButtonID: function getButtonID(uid) {
    return uid ? this._buttonId + "-" + uid : this._buttonId;
  },
  /**
  * get toolBox Container for widget
  * @param {Number} uid - uid
  * @returns {String} id selector unique
  */
  getWidgetID: function getWidgetID(uid) {
    return uid ? this._widgetId + "-" + uid : this._widgetId;
  },
  /**
   * Main container (DOM)
   * @param {Number} uid - uid
   * @returns {DOMElement} DOM element
   */
  _createToolBoxContainerElement: function _createToolBoxContainerElement(uid) {
    // <div id="GPtoolbox-measure-main">
    //   <button id="GPtoolbox-measure-button">&#9776;</button>
    //   <div id="GPtoolbox-measure-widget">
    //     <!-- HERE : widgets tools measures -->
    //   </div>
    // </div>
    var container = document.createElement("div");
    container.id = this.getToolBoxID(uid);
    container.className = "GPshowAdvancedToolPicto";
    var button = document.createElement("button");
    button.id = this.getButtonID(uid);
    button.className = "GPshowOpen GPshowAdvancedToolPicto GPshowToolBoxPicto gpf-btn gpf-btn-icon-toolbox fr-btn";
    button.setAttribute("tabindex", "0");
    button.setAttribute("aria-pressed", false);
    var self = this;
    button.addEventListener("click", function (e) {
      var status = e.target.ariaPressed === "true";
      e.target.setAttribute("aria-pressed", !status);
      this.blur(); // permet de perdre le focus !
      var widget = document.getElementById(self.getWidgetID(uid));
      if (widget.style.display === "block") {
        widget.style.display = "none";
      } else {
        widget.style.display = "block";
      }
    });
    container.appendChild(button);
    var widget = document.createElement("div");
    widget.id = this.getWidgetID(uid);
    widget.addEventListener("click", function () {

      /*
          e.preventDefault();
           // FIXME desactiver tous les outils sur
          // l'ouverture/fermeture de la toolbox ?
           var current = e.target.parentNode.getAttribute("for");
          var widgets = this.querySelectorAll("div > input");
          for (var i = 0; i < widgets.length; i++) {
              var id = widgets[i].id;
               if (document.getElementById(id) &&
                  document.getElementById(id).checked &&
                  document.querySelector("#" + id + " + label")) {
                      document.querySelector("#" + id + " + label").click();
                      // document.getElementById(id).checked = true;
              }
               if (current === id && widgets[i].checked) {
                  widgets[i].checked = false;
              } else if (current === id && !widgets[i].checked) {
                  widgets[i].checked = true;
              }
          }
      */
    }, false);
    container.appendChild(widget);
    return container;
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MeasureToolBoxDOM);

/***/ }),

/***/ "./src/packages/Controls/Utils/Interactions.js":
/*!*****************************************************!*\
  !*** ./src/packages/Controls/Utils/Interactions.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ol/control/Control */ "ol/control/Control");
/* harmony import */ var ol_control_Control__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_control_Control__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ol/interaction */ "ol/interaction");
/* harmony import */ var ol_interaction__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_interaction__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Utils/Helper */ "./src/packages/Utils/Helper.js");
// import OpenLayers


// import local


var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_2__["default"].getLogger("interactions");

/**
 * @private
 * @description
 * Pourquoi et comment l'utiliser ?
 * Cette classe permet de gérer les interactions entre chaque extension.
 * Une extension qui active une interaction avec la carte, doit desactiver
 * les autres interactions issues d'autre extensions.
 * La désactivation d'une interaction s'accompagne d'actions telles que
 * le nettoyage des dessins, l'état du composant graphique, ...
 *
 * Ex
 * // desactive toutes les interactions avec l'opération par defaut : clean
 * Interactions.unset(map);
 * // desactive les interactions sauf celles de Drawing. On execute des
 * // operations particulieres : status, collapse et message
 * Interactions.unset(map, {
 *    current : "Drawing",
 *    status : false,
 *    collapse : true,
 *    messsage : ["WARNING", "Ceci est un avertissement !"]
 * });
 *
 * Dans le code de l'extension, il faut placer des informations dans l'interaction :
 * interaction.setProperties({
 *     name : "Drawing",
 *     source : this
 * });
 */
var Interactions = {
  /**
   * Liste des extensions qui utilisent le mécanisme des interactions
   */
  _extensions: ["Measures", "ElevationPath", "Drawing"],
  /**
   * Options par defaut
   * - current : ex. "Drawing"
   *       c'est l'extension qui demande la desactivation des autres interactions.
   *       Par defaut, toutes les interactions sont desactivées.
   * - clean :
   *       c'est la suppression des interactions, des dessins de la carte,
   *       ainsi que la reinitialisation de l'état graphique.
   *       Les extensions doivent implementer la méthode 'clean()'.
   *       Par defaut, tous les dessins sont supprimés
   */
  _options: {
    current: null,
    clean: null
  },
  /**
   * Permet de desactive les interactions (Draw) de la carte pour les extensions,
   * sauf l'interaction courrante (si elle est renseignée avec l'option 'current').
   * Il est possible d'ajouter des fonctionnalités via les options.
   * Par defaut, l'option 'clean' est renseignée...
   *
   * @param {Object} map - the map
   * @param {Object} options - options
   */
  unset: function unset(map, options) {
    logger.trace("unset()");
    var opts = {};
    _Utils_Helper__WEBPACK_IMPORTED_MODULE_3__["default"].mergeParams(opts, this._options);
    _Utils_Helper__WEBPACK_IMPORTED_MODULE_3__["default"].mergeParams(opts, options);
    var interactions = map.getInteractions().getArray();
    for (var i = 0; i < interactions.length; i++) {
      if (interactions[i].getActive() && (interactions[i] instanceof ol_interaction__WEBPACK_IMPORTED_MODULE_1__.Draw || interactions[i] instanceof ol_interaction__WEBPACK_IMPORTED_MODULE_1__.Select || interactions[i] instanceof ol_interaction__WEBPACK_IMPORTED_MODULE_1__.Modify)) {
        var prop = interactions[i].getProperties();
        var name = prop.name;
        if (typeof name !== "undefined" && this._extensions.indexOf(name) > -1) {
          // doit on desactiver l'interaction courrante ?
          if (opts.current && opts.current === name) {
            continue;
          }
          interactions[i].setActive(false);
          // instance de l'extension
          var source = prop.source;
          if (typeof source !== "undefined" && source instanceof (ol_control_Control__WEBPACK_IMPORTED_MODULE_0___default())) {
            // opérations sur le composant graphique
            for (var action in opts) {
              if (opts.hasOwnProperty(action)) {
                if (action === "current") {
                  continue;
                }
                if (typeof source[action] === "function") {
                  var args = Array.isArray(opts[action]) ? opts[action] : [opts[action]];
                  source[action].apply(source, args);
                }
              }
            }
          }
        } else {
          interactions[i].setActive(false);
        }
      }
    }
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Interactions);

/***/ }),

/***/ "./src/packages/Controls/Utils/Markers.js":
/*!************************************************!*\
  !*** ./src/packages/Controls/Utils/Markers.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var Marker = {
  lightOrange: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAgCAYAAAC/40AfAAASf3pUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjapZpptuO4DYX/cxVZAsEBIJfD8ZzsIMvPB8mvpq5OupN6Xc8uW5Yo4OIOdIfzr3/e8A/+lNo1lGpNu2rkT+mlp8GTFt8/4/ktsTy/nz85f96Tn18P6fN6TLzkB30ObPo5/ut1+XaC92HwrP5worY+b8yf3+jlc/72y4k+F8q+Il/F/pyof06U0/uGfE4w3tuK2pv9eAvzvI/7607a+zf4r/tVE3sffv13Maq3K9fJKZ0sOfL7U6ycsv/NIQ+eVH6nXDhQsj3P31fssxIK8rs6ffvTWdH1pZbfHvRTV749+6Vbnwpwa790q6TPIfmXIuu3x9++HqT+vitP6X+4cmmfZ+nn10eVz4p+qf5T/Lvbfe6ZuxhFKbV+burrFp9nHDe5hF+6BZamdEfBUOPRfzo/jZtfQGHHFSc/S7ok2nWlyJYhV87zuGSxxJJOSMaTlFbKz4stW+ppZe9f8R+5yXLPOze6uJ62l5y+rUWey/a4wnO1xpW3cGgSTiZ85G//hL/7gXt9FES8luOtFetKyYvNMrxz/pvD6IjcT1HrU+Cvn1//eF8zHaxeZR+Rzqnne4r5NvPFVn4anTmw8vjOoNj+nIAScenKYiTTAbomuYpKtJRMhEI2GjRYus/MpANSa9osMpWcld605JfmIybPoakmXg68DpnRiZqVOWt0aNCsUir4sdLA0Ki5llqrVqut9jo0a9GqqqZOisOylWDV1MyadRstt9Jq02attd5GTz1DmhBpt95672NwzcGZB58eHDDGTDPPMmuYOm222edYwGeVVZcuW231NXbaecMfW7fttvseRw5QOuXUo8dOO/2MC9RuDrfcevXabbff8a1rn7b+4edvdE0+XUtPp/xA+9Y1XjX7OoU4nVTvGQ1LoQgdN28BgE7es9iklOSd857FDv3lmlhk9Z5t8Y7RwXIk1StfvQvp7ah37v/qW7DyU9/S/9q54K37m537Y99+17XtJLyejr1T6EWNmenjmJEa/zGtf3wMnycdEnrmgScKh+W2rFIB58FVtiU7CVaLdS1hHXPoPkvVW5b2oXDBZM5kyN7VVS1pzsLdAoljo1+6tE5b+ciweuqaTNwEgrpb3atwvSOzw3Aa7Git98o4VD3nq3Nz/50yiEw9MXMCh+hOfU+a3euZl0IjZX1tW/VQIF0lHO5kjFqF2hvlvCOvrEi+yhlzzHKu6fCXapZzFpUqw+TMUoU1TrM8K8eEt2CcvwpvlcXjErqqEPqJVIoz1cQ7CdQOB0qqW1QrkrCsK6Afva0R7pobdpd7pG47/Z7UpwDkCm4ql9Y8G2Oi4+S0rJ3LiVdtruM9Jb1Ja6ESIbdenfb7pXSsmRIcyTStcG9xoGh7gbLD1W/ra462dTTubFKUsWyMLTThhmZUszvGdgZEZizn7D1Pvb3VmlkuoOsHSOIrxmpt0EbpgB81ynTMBlDt4TB1Vq5U0EsVt3mfgfWpNiTznwumVxaPWHprbym/Svr9MfzZG/QkgrS9IGdlYQ6i4zdpbQ/m9sbCKqv0ZKwrI5D8c+V9b9uzAIzM/Z4lm07xdl/X4aOlTekLNI+orHQcAKRJpdnQM8CoBLRYV9plleJl8yJpa3OPe+a+2ljD2pnF7GnxzrzWZijn2Ke3SytrYTJHl3CK9lQgFlNNC3tc+vJx88VLOxAB9avWjwIU0L+9m61oK7lrkrd4DEFof16knx/5sM6pOzqQ89r9dFase7a2kvXApdQOnAIH5T1mG+BM+ikt1QrNMltZKx0fC2XliVbK2enAuDk5P93TQXSY4nS4IchETYYPGGuNXfPJe8dboIixZ13bJ3mSES4KnZel1RgaaOZA8OcESKbuDaQOmjUXww93t1szsyHSFGynylw7HKfe096ywI75p6qE/1AWLgx4tMx14z2j6kyisec64EDuBCwwy/Hkm8cNzHK6iw7YiNbnVQpjdjOH0neUT9rCo7fozG2DjiOBKQKQC/0ivclYZtIwF7fDPLR2xsKkM0cZc3h3ubjIPgBmOYr3S+fTa5Zz1mfVLToJjbVH2GgN1DhKaQuluyAVe7PRRMRsWBqIgqYBoNC+NuDliY1RKG/iF5V5dztbGlQLAybsk82qaE3fzPS1zo1n5ygmKC4wsUvbiNBGerilBnJoSE4DG6x13BXWzXBv4vYFstG1VoOoC6oGPXX/UIRoN9Ib52D6Juin06jZss0ksVys5ZihjGxtMgDdLmq0EzXjzAC3GYCBXfJmwiQVEFzdurMKcZKkpyctqt0wSD0I04f4UnjXutEEdDzPuPOKKFPiKejaATr81NlRGzDe3HRwNPkVbr8UG4ZhJjM8BolsXMthNArGnMEfadoZhuRvosTdXPLOb6A0JOrIp3/hv06r4ESq1wpWZVzvZn6y/7vgYoE/RL0HgLxUNSFWB62gtiN2hhEcIbWpICkUOvvAoA/4gwScv+C0v8MJXQ+Nhqg1bgvZyqdP8vWsKBV8RUCGpsq1Orzz87Z547iFBkQcRUQrWKA86w2AavJxAguRhd6xoAOTYog6816YrroLXcGYxwUwoyFHxbtxwRY8c6zO2TQAYZkL53DIRQdBfHU1oxhJNzYpyVhcSYrFDSNPjwSTWZx0C7pf0DkOS8j9rA2q42RUpIpREda6Y4OVDMScySKSXydzjIPsENagrkkhcCt4BqZhB/N2onoPdi7ctdN3/3Qrd4qgPo8DCaYdnU9QE0W7h/vF5XGz3/AdFCBL/iqDfzDxQUSMGzfioPgJEvYDInjPyQaugchuEgbt4iCQY5ZDnwpnKTiqgj3mLhg1NCq+QwLyYPY43chRPVrq0WriYlciCNXr9VZ3eICCMIBS4nhvGEAIw0qEhaAkDex6p7qYKmQHB1AbnfAkxigx1QyOzGYXWYL/CubfGEbWGIDhxA3eiL9PpQDHRUgAbReX0ZAINyI0tQyUgcVzKFiDBOCFjXMlQ6QIYkMb7saZZliZxQwEHn7o2G6Dw8gKBXCjW9HZ5/SKXUR+OGGzMloZaAvkmmvAMyBcC4kU4YA7WToAmhlidyGKa0VSxUljYxnPcmeRgXsRbqRzbRBckHloBPPrw4Zr9/nkeMzb5VrMpFf9AdVcbrK+uoGUwtqrX/d3dJMJxvohLt7qvV04IsR7p1zM26eJ1/k1x//g+d/H8D4BAfSL+aSxxKRFa8VwUdeY6QURKy/NDAFrToKxoZTYfM331eZeAgxflY4XBZ69YaDqBP0056yGHyqnI9Rm+K1p4rSSFV9wIQGusB4PwEsdXUP9DnZtZ94jN0xuBSPBvXtoV2+0IasUFkXDKp3lXoDfe5DX9kLTOsqO9cOHgM9dqcdiEIusVMgFQy508wSbpxADbn2mkuCEx6EsXBGIAZaI1QujONgyMWaU1cti1qaQEDl1Vj7vsZFkI2m+A1t7/N49QJhK5OIUe/mWkE5sXwYa+J+lLKYCuDVajRjq3pAsYg3SQnkfQcb5LTz7xuPjv3k+dmCWUDi39Gl2ps4dXcYVJ+59d99wRJHQ9LtAD2XCRjYYkN8YUkIsrfFM5Bua5BDFyIKdxluACNO7zFkGegGi99np8n9j/ehWp2oYY4SOQWj9XHz1WcHWQL0BTYasCIpgkjyEg2C5TjD10bCGFz/PM8b5+O4Qk/m+Q5382uG5+CN3633jvfzjO4W5+TohQ8+pxIiNEfMI6VGFDe3Vd7VByDt4j0ebGrIEM2FxoZRLB0ld8XEkKBgMwyDC7QsJysobUBnjBgjRwxnsynv/tfjqx2VNJC2GPT4rjSDBV4jDl/3nVG6B+hHJ/bY9TyerWAXsIZHtzugCQWRAOXCVZl5Xxtv3fWErmHaDtJp8l2EikIXuKSylj/uCveU2fazmTH53yCEnm+KTd2E8hu4qTrIvHDJGlUkZS4IXFcPl7A8fAbrNqGf3Qh0xQTZ0SOsbIwDBLK/x9DWhsopPIiRsgHCMYjfP9wzMjbM37G0lr8B9aaI3NOogBL6Xs2HMOSH289KUQKo/Buvw+9qVTK6UUwqBuBPJFVPro5AfXk+Hn4zJjMj3RBR5J8BC2PqEG63CIG16OTfx+pr5fu30UWcS0DFuDuKHtdFjnLuM6psYkD2+oF5CjVvhS0CnoHwa/WNusfqXim5qQpjM1ZuFIjyYKi4vxKw4DZoiVeu6o4ZKaXzoURuq4nOHt6Fa9ATnU7ncxo7g6UE+0kYg8fExDzwLcq3ErIGXRo5wH+cRiu336mjg3/3hG2IT6ohLvVXuTCXB0dhTZ+++gRgyV/xAITch2WCqEVVrzPAxLgXRI1voOfSbmnM3/CXgYh8rPhxfDFL225b2jePCd7J7H2GzAwgjZgFyJj8SfsUItFBpFvCwUUQDA4ArY0Ch61SNvFZ8rw4vVhHyw5p9f3bEFDt1PjrID05RjBzVgqbJUJXSLARoRkQCNSZf5olAkobc12LqI73yrQJsCI4mLYS/rubukwKjPDlOFkPFgSrnRyNwuAcbiRm94aPI9zdmLUkujYQqcYLjaGRIFnZ9jYRcLJlv/hX30BiQgE6j5A+dU2RwwDKwGdzTAYnH2f2ctN0O7I1HTtBURMBcroAlYgjM8GYBFvPdA+imolWmjWHi4gzYfRqHKRuMrUQIsUDygBhBxs1jo+CJ/IRoNDEAuvemMJCC/Xg00L/U+v7I1Ly3qnhB/Jnv36SmOB4fM0A35hihOAcqHpM4x/zAdUx8e02G/BVzGxEpEBsqKathzVgltlb3EfNtLcNVGPPt0TpvbA+eMs3SfMcK04ln8fXDhgIiSOwUm4lj8jugXZhmRg6AHMb9gijciwnTDnNhKBXDI9m3iD38ciZ0YLpbxWho2ISpAY66Q2ZZgwv9YyzHM2QkASaOBrCM9OP4q+8xXnvSaycEuDbB4cHeJeEM08EstvvA765nu7r4RjF5YxNiO742DawE9XUMghITWK87c1sOWHBLFCdbxFqYR1wcoI8cBOX6jFuFBLCGvrO4QGX1bQxLMyX1IOX6X7bSfq7geCNzFbDeFfsL4sAm9acvxwtCFjQCGbaQ5SXYzrfVaxzOdTr6hCG35oVdOc2NjGrlX48wehxksic+UH1zZFGbgTZ0K7g4w03xafwEKo3qmAT1ovmmWMLjkxQfaNJsfbCSfP/Bjam3D72Oor77aumCQix5g05JlNJPOM40mKCcXes2BgAqwbwjX9C6YD5GLvF1Btsafh9ONbfSezJDaSKHSLBCtccxqI9oQpBKdPOW8ElM6cLAUEp480Jj9F8ZWZlutjwrw34IF3Ru/nXGEPVdmdKGfy3h2xPSckwZ++JVZyTNxYgPu4Xr7t9dEwC884PvdGPaUoDyS8JT24R1WOfECBGsahPUmDtm+cTW6WDpaAjUzlyS1kncYJEIDAiZyxN0E5/siGdvg+9mUv9KxWpkpJZHQvPvaxZnxBcgaAiXh+X94PwInyIy3xvwy/LG3eRYB/K+3Rv/0tbkr5t1/t2Cf/2ywR63xthCV3sBUwghIvm+R2nAiiQx9m1ALsHxHN59A48pBKgBad+otn9vQ+k4H3eDprO46VGMaI8i2WtEMWRIDaGfMTZn+VEuSgW8+gwAObmZIcwd38EfjH/1vT7fEMfSUMtuvYNP3y02Lp8384OnnB5SE3yl2JVLXkupN8SeLMR0edpWPOdiYAzEoLsnU06ADN0M4jS0g3qw/pl6ie/3qbB8IAwhZKSSWdYi2UeyRcdX7oYRIJHqRg3ohnS35cvNC0hB48rizpKbfgIpJ4K8UTXsMyPJS8f3molSYALLgj3yJXXfIQUczfMrnTGm9vXmbqT9Cxm1gL0Av0xdB/GsoGePVRtqwDiU7NkOC5OoSHUj2313k5QM26h2luk7Bj3ZCNe/pU0Qy4KK4CUIssMEE7uGyWV2uHjb+uw+wh8kX2daUJevGzUyICdt1kJizKnhNN9fJdvgDiNkP/wLw3jTrngRHBUjR54lJbBuOeAjo47O6yybKKQ1+BYN9E7SdXSh7kg7fhkCp+XcFTAgpvpIdDeDnincsPl3LFAaQHpywRwhptNoKXGKHlun1+/eKorKDU6M+vPdy4TRM3hBqOByFyqMtsOze740DPsC8pAEAoG/Lv5/CMA8eARSjpFJ/D3fpm7bv13y/1/gYgKdVn1LkvDNrMDBe5OOZLrnE6TOLjSDqjEAmIBNMzyKH+RuFd8whbrQq0Eg9sSGkBz/Ho6Yxe0G6mANNHo8de/ikteZX99WyNEZrVJf5T6opO+8RJLMjhgqGLMdsOXbSlqCutkhdPhvUMPc/H7Tgqm9nnHDvwF6YngoNZcUVAAAAYRpQ0NQSUNDIHByb2ZpbGUAAHicfZE9SMNAHMVfU0tFKh3sUMUhQ3WyICriqFUoQoVSK7TqYHLpFzRpSFJcHAXXgoMfi1UHF2ddHVwFQfADxNXFSdFFSvxfUmgR48FxP97de9y9A4RmlalmzzigapaRSSbEXH5VDL4igCjCGERIYqY+l06n4Dm+7uHj612cZ3mf+3P0KwWTAT6ReJbphkW8QTy9aemc94kjrCwpxOfEYwZdkPiR67LLb5xLDgs8M2JkM/PEEWKx1MVyF7OyoRJPEccUVaN8IeeywnmLs1qts/Y9+QtDBW1lmes0h5HEIpaQhggZdVRQhYU4rRopJjK0n/DwDzn+NLlkclXAyLGAGlRIjh/8D353axYnJ9ykUAIIvNj2xwgQ3AVaDdv+Prbt1gngfwautI6/1gRmPklvdLTYERDeBi6uO5q8B1zuANEnXTIkR/LTFIpF4P2MvikPDNwCfWtub+19nD4AWeoqdQMcHAKjJcpe93h3b3dv/55p9/cDPGdykYtTXU4AAA0aaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA0LjQuMC1FeGl2MiI+CiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpHSU1QPSJodHRwOi8vd3d3LmdpbXAub3JnL3htcC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgeG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOjkyYWVkNjM2LWY3MDMtNDAzOC1hNzM4LWZiYzYxYzZlMTljNCIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5NWMzZWI3NC0zYWRmLTRkYzUtOWZjZS1iODQ4NTc3Nzg4ODQiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0NjI3ZDg3NC1lZDIyLTRiZTUtYTlkNS00NDlmMzVhZDIxYzgiCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJMaW51eCIKICAgR0lNUDpUaW1lU3RhbXA9IjE2ODQ5NDE5Mjc4OTUzMDYiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4zMCIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIKICAgeG1wOkNyZWF0b3JUb29sPSJHSU1QIDIuMTAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDphM2U3ZWQ1MS0xNTI4LTRhYjAtODVjOS0zNzNkNzgxZGM2ZmMiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoTGludXgpIgogICAgICBzdEV2dDp3aGVuPSIyMDIzLTA1LTI0VDE3OjI1OjI3KzAyOjAwIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PofUkY4AAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnBRgPGRuA4VZTAAAFcElEQVRYw82YW2xbVRaGv7XP8bHjXByHQkNhWigdVX1AikRBMBoQ8wASl4fRqPDAAxIPKAVxeRqQRohHBEVCaoGKUBCl4qHcNKCZVKMRRQxtgTaACLRKqlwB14NzM2ni2D2XvXjgBFXQOnFiA1uy/HB89u9/7bX+vf4l1HnpK57hTNCE0AzqAS5gAAuEID5KiWSiLPf4tp7YUjcSu4yLZzdi2IJyNXANcBlwAdAKzAHTwDhwDKEPywC+GZWHbPi7IKOvZIWguAnlr8BtwJ+AxDJeDYCPgF6Ed0hkh+Weov5mZLTHJMDeBjwYk0itYJtKTOpZML3SbYNfnYz2SBr0buARYENcFytdFvga2AGyT7p14Vcjoz3ShOgdKDuAi+pUewpMIDyCypvSreWGk9HdroOEV2F4A1hfTxGJCX2D5U7U/UzuD6NaXq49NRJhBsOjwMVLEtE4gaL4W5cV3IsxPEoizDT0ZLTHcSH6M/BWLLlVwpQKuPzhb+i8sRkv04Y/e5rvPigxtnM9trKU2k0D28A5LN3RsmXbrbFOU8DtQLpqfJqu97nh6TydmzvwWpOI8VDbxqbrkmz62yk+/Ps6yoe8KkeV/hHHfgrMNyrNEkBX1SAktgRs3T7ApV1rSWayiEkDLmLSJDNZLu1ay9btAyS2BEsEuWuZ99WKyRhgHeCcn8wGw/qbOnAS3jmfOwmP9Td1kNhQDduJcUwjyciS0RJXMMkWkPPUo/z4XFxZRhZII8mEwFCsT+f5xXTE7FAOteduItVaZodyhNPVZDeKccJGkxmsChIMOvTt6aRSzIP+7A9rRKWYp29PJ8GgsyqcVauZSADaj+IDTecWvBlD4e01HKjM07XtOOuuy+A2X0BYmib/8SxfvLWRYm8LdqZaCvkI/SDBci6nld0ze7KCLa4F3gSurR4MB5x1FnMhiCeor9hJiPKmWpbGp3EU2IbJFuTe5XfStbczLxgP7K0IPcCFDWhnJoFuMAek2/oNbWdku/WxHATejT1JPZcPvINysFYiK+gAFkXTK6H+MyhXADeseJ9fmrVDM6X080/+p1M2/yFsD1zjEIauEeMAqNpQE16oaKiqwfjYeLk+fuYl10HDq7DsBTavxs8o6FzFKez/dM3rLx9LjUyVxcb7yVkfzmpXFbACJURHIxgyxkyu1ml6qL0Z4YX4xl7Jfrrgm9Ov9bX/e++x1tHCgkQ11lgELGA4sBp3iHRbH5GDwJPAFLXo6KJnDmTh/aG2w2/3t47VSGQxs1zAE9U2s9pEjx3hXuBloCa7G1rxv8o3f/7SkUz/UFFWMqGRWMpHAqsDbl00KGotIXM7MawF7gKSS5oJJRospI7v+rD96Ikp8aV2EgrkVPW4OnIy6SVL9ZubvZgyaOVyYDfwl2oNqVWiXNEb231oTe+/BrzvK9Gy01MFyoiOKzIEmqsEfjGf/39U1yHgosJFUXhlFMl+z9E/nkvhVNHZsjux+9Caf77RnyzMBaJLmW4RrWAlB3Y4Uh13HLOA4wQjo6O2IRPNxVV4JuG5Et2SSelzjtFLzsZQ0NIZ8/2rx7K9+/paxqbKvyh4Bc4AFQxzau23Dow7FS+nHmfEUz05OqINH8+evXJPJVOuE93XkY4eSziaXcQpB2b+vZNt7+/8IPPl2OxPRMJ4dDsLzIho3hpzamJ6aqJ0ei6qtZAasmZ2OS1RyOMd6egBIzSFVoKj4y1Hnvhv+8cD02ZOkEmgIKITVnXKWDs1ksvNrgbTbRSZ46cypY50aWcllIsyKXvr8GTyi9f6WvePFGVQhO8EPW2NzI+OfV2pF2bDTgbg8D/aJeVUspd1BK3/G24u7/skO3+iYP3h3LdhI/B+AGodUpo8WKwoAAAAAElFTkSuQmCC",
  darkOrange: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAgCAYAAAC/40AfAAAStXpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjapZpplmO5boT/cxVeAkeQWA4H8BzvwMv3B0pV7qou26/tyk5JeXXFAQgEIqgO9h//fsO/8a/2KKG2PkRFIv+qVs2TFyN+/s33mGJ9j+9fKd/30q/XQ/5ej5lLftP3xiHf+39cTz8H+DxNXrW/DDT294316xtav+OP3wb6TlR8Rb6K8x1IvwOV/HkjfQeYn21F0dH/uoVln+fzYyfj8xv84f6ISf88/f537UTvNOYpOVtJJfL4DVbJxX9LKJMXjcdcKjem0t/r9q7/2BIB+VOcfv5TVnR9qfWPN/2SlZ+vfsvWNwJs7bds1fy9pfwWZPn5/MfrIbU/Z+WF/i8z1/F9lX+9nkpKnxX9Fv0X/HvGfXtmF7MKoZbvpn5s8b3ivsUUPvUILE3IjoChwbP/KD+DzW+gcOKOi5+dNGXSdVNNJ810k73nnTZLrNlC7rzIeefyLo7Ss+ZdPH/Vf9LNvWg5ZZDL/dJeS/65lvSm1bjDm20w80ncmhODJT7yj3/CP/3AvV4KBHi81KdPfnP2YLMMz5w/chsZSfcb1PYC/OPn93+e10IGm0fZS0QZen2GWC39FxOUl+jCjY3nTw2mfr4DECKmbiwGBNRE1lJpSVLsOfeUCOQgQZOle80sMpBay4dF5lqKkJuRfWo+0tO7NbfM5cB1yIxMtCLU2SBDk2TV2sBPrwMMzVZaba1J6200bVOKVGki0sVJcfbSa+itS+99dO1zlFFHGzL6GEPH1KwF0mwq2nWo6pzMORl58unJDXOuvMqqq4Ulq6+xdM0NfHbdbcvue2zd8+RTDvxx5PQzjp5pyYCSVWsm1m2Y2rxA7ZZw621Xbr/j6p0/s/ZN699+/kHW0jdr+WXKb+w/s8bV3n8MkZxOmueMhOVQExnvngIAnT1ncaRas2fOcxYV+ists8jmOTvJM0YGq6XcbvqRu5A/GfXM/b/yFnr9JW/5/5q54Kn7h5n7e97+lLXjJLxfxj5V+BiwUH3cM/PgP6r178/h+2IWNXr3IZDKnG1YHtrtFtaVWu1ilevx7tYtr7VXOy3nSum0NHSeHSC4lcbIFUozk32J9iFdrXthMcaFq0z0Wlp6+qg7HfZer+Z0+zpjlQ5fRmKkS8fOua1j1CP7llovW7E816hHdHtUrZ5+oz0IDLDFuIMOT2Rma2CHreke6c5TYFqCY9puXmPuPRcL6KvoarLOvlBpNrRL37lJbySs733aav2UesPNIHA2O7WlZr3tW+ML4QSvXKsuLPpsgL0u/mbyXnZpdPGZjOttnz2khypsW2Jt5Fozqdl8qnedcofdunR20BHbANt15T1WAltjrZ53p6nfQqC6rqBWe6l0nMIi9+69RD0LYHu7WZT7SBuQzttKZNQmaIJGvHZZtrsC2T07siMATFvb7ja2C4/eLpMY6Y3jssO25l3SrxyZyBE7R4kTA+Zia60CIJVPnhkqFFtZ7lbmX7OMuH2OHEEBv42VEN66HZf+st21L32sSZIpaVIuvZie0Ge0B9BFHxzfMMd/8DzkZjNwFFdW4zWFApTWlpP3vCOzxUm1FWKkBtHMW+zI2iReZFFt7DcKsCld21qB8OQjdRDXQhXmKB1CEcC+q2c0bT7SjLbfG228GPk7hRnhmQNmEQOdQj6htHgI3AZ5KV/KSy5Qvz4ukCY1hWWM0YhnSa3Uk9dmzdAdoeYHkiPXuQbNHUoZk0+U1KEXyZnw7UUCFyAmnmlQI1tjE1u3fEp+abX5p+r/Iz2QS1Kc9umzQg1lt3Lhw1NuHXclsLDiGHcfUBnKZe/sIx0kz6JICFA+2cTpDpqVDFCytG0wMyxRxibwdjZ7Il4ytbdVoBED6TSBNCbLX7lBnKTOUXZxF2o2nAngN2KboX6uU13NKlAVjWsOwqVSAwGjKo22ARgudUtcr3jbr7JqqgS73qGbknEAGrMVbrKz7oxe06mx+Z3Ct8DT//JMvxjD+NC4EX461F1OUiEZ9Fo6PQak4+Q9cFXp/RXYwfqdetl701wUChFKMN42b+9HHuVV8vC2TBo2vXVGDSCqz6sQl2sSK9HIcSu0Boa7ZhMwb2bxhfVtCl19V/kBwlpSpmxq7XRkqEtPSbqTM/gr6VupkEZLO4fWYHXTxiKN58CCXNsCME6+O0Pc7LgEgroA87HqGzRqHg7g1iwoZdilXwZ1KQgjzcFdjZZAWs+iOv16vVkgmkBYdJF2PuA6s/DJnibdlxZzJwDhCu6LAGRQmeH6TpWowl4bxmBRWhagC2iAc05T0HOmEgY2Au9Qj3bpoMwJCCe7bsTXYPTvhMNbNy35wNACBQfebVUHW6cb07j9jtu4NhM6gGYFw2/BSEz7shWMncc+X1RAvc6jEiaCB4r2pC2MMTlBMZVELQMZ8sm87CGvc2yZLlbHzL5AGkM370hIm3UtpL4vKf2U9EEeSP1X6XGmaf1u5kU+BYRD0+6xqOhky2zr/PWGv79/S1EEBfVpo592XV3EGVjeB2AddoXuX/mwwVzp5WiI5K2oRm6nfGNeDSKS00DeGClvsFMQXpYCssEzwwNTL5wNayGwm/Z/EJA80jz7ukpsB3THWulMHV13IAfym+m+VAleRFOX4kRD6SEbCCQl4mKfAWCOJhC9AtoeUZMtbl7SD8aBayBoffyKhlwj0/zovihoCM2J6cwrkAYIoUEAvaO8n82lBUATNBjkBuFAz2jX69Gii1xgw/YFTl9mr6KFjXbxEih0lDTYKeQDaGlYWEA21FAdcME9yQnMc3hDivcvCX9w+QmbsVAVDI0MBeQQnLNu/lxhFsL3+SBgK+Gf4ebcDyzS32AR/jFu+gc3v8IG6fcDNwhHF3qHHr2JKxWOxa4GvSBc5MDZFQxAfgK1S3NJHLvz9aTBQRjBdTjkIZooUtwD+YcX9bWmaXD04mOOlQcfkghzo2hSvcz6GCkT/9bCKBEhhWrfyE6KFNm7EVoFtQCBILKAYro1Ge9EBFtVWGDZhCwaHNAQyAnJH8MtiKZVBxYBAYpEVEJZkQkoCMNQb2xFRX4AJ8iqpu7AqLZ9YXR/yB6mA/BBYR6iTfPcvZZ4yvTwcA3VjiY/9MkL6fVUNBu690BZQJXyQOShufFPKAW2dg6qJaPqaRfwIi2p+/pxEpdcokQK3RHJqILUAfKsNV1uRStfGq4e8Or4COhH4vE/IvJ3PCqY/hWNgDH8y2hcU3c+NAb0VY2If0FNd5zlrVtbph0h75BRgNL7LH/ePtT7LAouIZ6E5v/6rFs9Yo8NQaluBzGOrKGMHVkrFJe+bVOGy7B/GAhBBjJg75Wx8G/e6RgXkjmsCy14jXxw+63UNLEr04kNyoc4BNw3rJ0r0a7S3L/ebkgoIU3XOR/oYyHZFn+IkR8FYWQQfYgUa8hjrIJMUtkPsgHxr191N/JPtdzzIlqomkJs0dZIJ0rB1wCVQlNSLeBzyAw6N4vEM1B34oIfH5zBSOXNT4Mp+a8iHItfoMZdELWsAuILvO7QH/VNQo6rWzx9o4niuNx/Alw25XGqqBW8GS0x0TSN1TcuirqCbick1OFedZ+IZm00BUGeI6Iw5+7wwDNekAElOjrPoEAQ7vlaLndsJwZlnb25zTqYKdmUHgoVoW/TbQoQRyzdJ6egYhzH0x7R4sddUrh0GdT7wJTo0UAhkp5zgScViyGnkayJFFkIPW9+h05xySh/5Sdw8JFU/JvgRGjuWkxoyPeWx5SFsobrf+Nz3o0uOrgyBhFBfZHXtly3UTF9g4+Bw4iobQRTCahTcObjlt7co60nhwsZBdPNRKhMbYcFF39nVRsJk77A2qiMd8yPxDQUc8qtLjMhaH6n4s/cxkTEKvwwky/eF/Bx3lD7/INVCN8X0LRRg/vNekelk+FYGNfdY8IvYHUQXnZN7B5cyj2zAWqmX/idg86erDH7wYsiP5GtFcqPFEfCn70MQZ7AFbbod2La6ap4VgiTKoVgGoaku4ZMKOzW+TVv1V7KG4HMipBvtHCASd/Jxc+astMWOkDIOk0ZW1vOVZT5PrWESpfBRY423JcjvphjR0FHIPgorIt1VCrZGzjsbhQQ5EDFYudxaui3LJk1YPxw5fQVGo1+Gp47uF9F+R+dGKUKbcEHMIR1Cdk7Iu02D0X1WK4R4+7apqMdkDdMookuMgfea/phsvh3H8go/AOWFZZiQWWFjHhGiqSCUySO9FC6wXN41dWxHwSYPTG2l6cpDTYLzeNgMRqHoqKfdoJN53Syk04No6vmpGJKrscZchpwv8fe+U9EdomvwN1Pxh3Mi6LVtAFtaQitxVbBbSWOWKFnwA4suZPO5n+75os4exayDhZ83KN+ZnjdpGdaHAvut4Y5n/LGW7RKye3E/CiA5Qt87ANeWC14hAhGfLUIVEg+1oduAjaf1Apo9P/W9KFvcN2jEGpgDBoLPJz/puvRFGyNlWOhEhtxu9DRKNV0ozFB9xP1Y3WUTfFGRM+1om4xKgHeKeGMB2oEFje6CDRa0cBIJz/FchGAmHATTihQBojPgf5160WbqQpsN1IgDWFfup1Yd4KzMXjXpZQlbpWOIE+U1UkKqT+bTyXjre0dZ1U/Tft64hr/65nghzq2nw+q0zs0kw+2aMCBLR3UZZ2IMJQz0sUD0Zz9E5YS4vfmQTy2lwziI7RSITFofBE5qbGwBD/NOE8rUi/gqnk3AjzIJef0w/4+X58ISyh8hDQEQu1npzAGoCHoSE8IzskbcY76Wl9z/8HWH/JLInx7oUFd7APzRdOjJQgM7vYYyUTSucMPiunOIMij04t9FLqfV/81VuGXoH0VLjIL+d/84G/gxPMp3vAuQo6OFxH+Ha5Cd7k5Ue8bNUtwn1txU2cWDOIUJOeC7JSST8MPjXZVVAP9TEmddbQdoQX64PA08TZsxi82SzY2G95A/0CUbjSKwxIiq610mIy9IJmmH7AOQFE9KJQe8pgxyi4EAM6mC1HLSsshbMJO1Pzgjj6DWb906nvgnn7xBgoPQENyHul725zomKKEDXMMs0A/AitvQzdvNDVvmDMo5BCJd6e14c2Vhr4GmYGAzVHUq3+TMEv207ca/HAPoda7Vcyklg77X+9nFfXgehp7dyraEC1HyG8FTlOyOsSRlbGgWSjAFHCnAnfDZ2jq/NqAkGzsQETfUyaHlZXL6ogHrTopSECq09eoP4llyTvWC24H4NTNJhpcpAhXq09Wt+GYbnul7vb+nbF/TL0r9NcFqh8PrYoK2OHRb3QHiysgU2DERaHhACp967hQTKgmcN2JWUreSXNZHUshBZOCLnI7GlCFKArV+U7Vp94l5xB9MgRbH2gYGQOZOj46DQeF3tG9hrDU9mQOThdP8mTNfCrnwJwISKQPnT0uR7VNigXpWiEFP0Lxr98KaVRvvbFK9W99yFLG00LSEBRM6N9hdpSdn1v1xajAaNI5aoM1RvOvbtFmReiHev0we/lXd/QOdgDhk35za4XWdq2Kq0CLNKSaZSMmiFa3b52utEkcBgkaBtPuvCgUnUfhvWgjBioKqFKmzXuYpxTl/eQshPPO2ShJRza2dD8dmfb8nMrEf/mI9cczhuFgqAQhsyhVlS50UbeZhXJw12E90H4zEaXeyEpzm1hL9S8p8IDmB3Uoe0SMkyiamhaFiUZRkxc/jhjIoYNyQNaQfNBIVzUIyF2vZUKndnGxeMRUKB8atHpXwjJENI834Aua3xE9HrDApxJwLZAABnp544Cu6gTzDanTXSRBCgWnZa1TIFQX/aCR3IJnEahlwKxX5PoZ2xzJv1FDSTHR2I/yJ5bIE+PfISQqkGpHdqMYFqq1uu8F/1n8izQPIr5lhztexUKSUDfKYvHn8KA6E7wzR1wtru04SeGJVKUgRZzL9yofVU7H6QEpk7p/0zasYFQpSSG90K2fcl64K5m79bFoTBb91AYHjv+/uSLhYRe6bvajej/vvKkVHJ0TPF4buZAoev8WpEDemJctMADcTzd4GkafL0juiyEKwG0XETEBfR4bioCLBmZlDprvZuGtR/zHJPHinE9Ok5/YQ3yYCfrV8iOC1oAVOgDBDksbjH9wOmwIuBPo5icdgiwS1wbND9YU/UHbRZBMgo0IV1jpSUKhQlaYrnkehdAkrI/jgs7JwVWXutTfHbKGdLO6gSFyCyp2j738tB41BgTSDRFYZZQCTKx0bOZkVEiuHFbhtecqYjkv107p0VeeJ6GFqZ+UMrS5tr5BQKz3toOfxbe3a1dtvW+oRnvdOiOWQK+fRFWJgk9hWwgNBvX6peddODKw713i8VM+1Bw+zzXE80FMMd0LY9XoxN0P/Nty75bP4xRkTPHvFMwzuwKeBW3l38aB4uaPlBEG8s8HGwhv/x9y/hPOIdIfHx3GqQAAAYRpQ0NQSUNDIHByb2ZpbGUAAHicfZE9SMNQFIVPU0tFKh3sUMQhQ3WyIFrEUatQhAqhVmjVweSlf9CkJUlxcRRcCw7+LFYdXJx1dXAVBMEfEFcXJ0UXKfG+pNAixgeX93HeO4f77gOEVpVpZt8EoOmWkUklxVx+VQy+IoAowlQJmZn1OUlKw3N93cPH97s4z/K+9+caVAsmA3wi8SyrGxbxBvH0plXnvE8cYWVZJT4nHjeoQeJHrisuv3EuOSzwzIiRzcwTR4jFUg8rPczKhkacII6pmk75Qs5llfMWZ63aYJ0++QtDBX1lmetUI0hhEUuQIEJBAxVUYSFOu06KiQydJz38w45fIpdCrgoYORZQgwbZ8YP/we/ZmsWpSTcplAQCL7b9MQoEd4F207a/j227fQL4n4ErveuvtYCZT9KbXS12BIS3gYvrrqbsAZc7QPSpLhuyI/mphGIReD+jb8oDQ7fAwJo7t845Th+ALM0qfQMcHAJjJcpe93h3f+/c/r3Tmd8PnXByuOaabnkAAA0aaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA0LjQuMC1FeGl2MiI+CiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpHSU1QPSJodHRwOi8vd3d3LmdpbXAub3JnL3htcC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgeG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOjIxNDZjMzUzLWIxZjItNGVjOC04NzQ3LTIwMGEyYWExM2ViMyIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2NGViNmI2Ni03Y2I2LTRkZGUtYTI3OS01MGY0ZWFiZGFhODAiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1ODRhM2VjZC1kNGFmLTQ3NjItYjA1ZS04ODk2MGQ4ZTk0Y2MiCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJMaW51eCIKICAgR0lNUDpUaW1lU3RhbXA9IjE2ODQ5NDE5MDM3ODI2MTQiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4zMCIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIKICAgeG1wOkNyZWF0b3JUb29sPSJHSU1QIDIuMTAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDoxYzNjOGRkZi1kMjVkLTQ4YzQtYTAwYS0yMmU3ZDYwMzg1YjYiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoTGludXgpIgogICAgICBzdEV2dDp3aGVuPSIyMDIzLTA1LTI0VDE3OjI1OjAzKzAyOjAwIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PuhCAHgAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnBRgPGQOTjc4FAAAFdklEQVRYw82YW2gcZRTHf+eb2dlkc9lsrFYr2notfSgWxKKiog8VvIFI9UFQEaWtYPFJfREfRRSEeqlttViLD/WGisYXrShWpfWC1WpSN5eN3cZumkuTzWY3c/mOD9lI0WSTTXbVA8M8zMz3n//5zvl/5xyhxqb3ewYvaERpAvUAFzCABUIQH6GAHyvKa76tJbbUjMRW4+LbC7GsQbgCWA+sAs4AWoA8MAxkgEMo32LoxDO98oIN/xdk9IGUYEYvRrgduAW4Gogt4NMA+BroQHkfm+qW3aP6n5HRTSYG9hZga5lEwyKWKZVJvQCmQ3bZ4F8no5skAXov8BiwspwXizUL9APPgOyVXTr5r5HRzdKI1TsRngHOqlHuKTCI8hhG3padWqw7GX3IddDwcixvAefXUkTKhH7HcBfifi8vh1E1H1cfGkGYxPI4cM68RGw5zf3y3S7IuedgeZwgTNZ1Z3Sz46LRNcA7Zcmd25yGgPWP/M7q65toTLZSHBvn6OcFDm07n6g0n9oNAxsR54DsjBYs2251QWAbgFuBREX/tF3rc9+zA6xa3U5jSxwxHmpbueyqOOvvOM7rj67g1JfedFTNagngVtR+B0zUK8xiwLqKTmhcE3Dblk4uXbecRDKFmATgIiZBIpni0nXLuW1LJ41rgnmcvG6B59WiyRhgBeDM+UZipWHthnbcmDf7b8Y81m5oJ7GyErZTxjH1JCPzesu4ghtvBpkjH2X6uXFlAVEg9SMjhEAamFsyp4Yjcuks1s6uXdZacuksU8OVZDcC0mW8OpFRQqBruvqdwwpdDh+9cjaF0QHQv/2wRhRGB6afdzkVkKZxtDoyVaqZBKCHEXygcXafjhi63l3G9tIEGzYe4ZKrksSbzmCqMEz6mzE+eedC+juaiUYqhZCPchgkqKB4SzxntqQEO7oceBu4srIzHIitsMTOBOMJ1leCkxAMmEpRWt6Vg8BGTConOxZeSVdfzmwxHmpvRtkJnFmHcuYksBkxH8tO69e1nJEd1sdhP/BBuUippfnA+3jsr5ZI9TnzV33mFcB/DuEi4LpFr/PPZu3LkanES08fOltWnxe2Ba5xCEPXiHEAVG2oMS9UNFTVINOXKdamn3nQdSC8HMMeYPVS+hkFzQdObl9m2Zu7+xt6hkKx5fXktGumdNXyZQUKiPZGkDbGnFxqp+kh9kaUHeUTezHr6WRkxt/oa/toT39Lby6QqMoci4BJDB8vpTtEdlkflf3A08AQ1ejoTM8cyeRnudYD72Zb+qokMhNZLuCJaqtZaqDLLi0i7EHYDVTV7oZW/J9PNf3wanfycLoki5nQSFnKewKrnW5NNMhtKRDlt6EsB+4G4vM2/UrUNd5w5Pl028FfiuJL9SQUyKrqEXXkaNyLF2o3N9vUYKB0AbAduKFSQWqVKFv0+rYfXdbx4aB3qqQLDk8VKCKaUSQNmi0F/ujAwB9RTYeAMwoXabg2QvZ5jl4ym8Ip6FjgDm7/bdl7bw3Ec/lItEJyWyAS0RJWsmC7I9WM45hJHCfo6e21dZlozlju3pjnSnRT0tMXHdFzT8dQ0EJoTr2eSXXs7W/uG/pnwiswBZQw5NXaYw5knJKXVY8p8VSP9vZo3cezp1v2nniDK9FD7V70RMxoaganGJmJT0+0frbtt+RPfVN/EQnLo9sxYEREB6wxxweHhwYL4/mo2kSqi43c5zRH8GS7Fz1shMZQJTg41PzVU7+2fdNZNHlBTgI5ER20qkPG2qGebHZsSTpULzJH8slCe6ywrWTlrGTM3tw9Ef/xjUzLvp6idIlwQtBxa2Sit6+/VCvMuu0MwIE726RBSqlViaDli6Gm4t6e1MQveet3Z4+F9cD7Ewo4WRJBbaaSAAAAAElFTkSuQmCC",
  red: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAgCAYAAAC/40AfAAATbHpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjapZppchuxEUb/4xQ5AvYGjgOgG1W5QY6f10NKtmW5EieiTVLDIQbo5VswCvavf97wD37qyD3UJqPP3iM/ddaZF29GfP2s5znF+jw/P6W8P0u/Hg/5fTxmDvlJ7xNHf5//cTx9DvB6WbxrPw00zvuD/esHs77HH18Gel+o+Ix8FvoeaL4HKvn1QXoPsF7Lin0O+XkJ216v+rGS8fof/Ol+xEReL19/r0L0tHGdkrOVVCLP72CVXPx/CWXxpvGcS+XEVOR5H3mu5SMmBOS7OH3+TGZ0far125N+ycrnuy/ZekeApX3JVs3vU8qXIPfP12+Ph9S+z8oT+p+uXMf7Xf71+NgpvWb0JfpP8K+O+6yZVazaCXV/L+ozak9Srm4u4Zcegal1stOpocGrPyaPweIPpaDxxM3jpJky6bqpJk0r3WTP60mHKdZsIQtvcj65PAdHkTzzKZ6/6o90s5RZtAxyeZ6015I/55Key854wnO1wZU1cWpODJb4yl8/wt9+4V5vBQI8ntSnV35z9mAzDc+cP3MaGUn3HdT2BPjj8fXH81rIYPMoe4tMht6vIXZLP5CgPIkunNh4ffVgEn0PQIi4dGMyqZABspZKSz1FyVlSIpCDBC2m7j2zyUBqLSuTzLWUTm5G9kvzFUnPqbllDgeOA2ZkopVOnw0ytEhWrY36kTqoodVKq6213qSNNtvqpdfeeu/SHRSXFKlBmnQRGTJljTLqaKMPGWPMsWaeBdBss0+ZY865FtdcjLz49uKEtXbeZdfdwu5b9thzr0P5nHra6UfOOPMszVoU/NCuokOnLktGKVm1Zt3Ehk1bl1K7Jdx62+1X7rjzrs+svdP62+MvspbeWctPpvxE+cwaR0U+hkgOJ81zRsJyqImMi6eAgs6eszhSrdkz5zmLE/grLTPJ5jnT5Bkjg9VSbjd95C7kV0Y9c/9X3oLUX/KW/9fMBU/dX2bu97x9lzV1ED5Pxl5d6EGNhe7jnJUH/+jW31/D+83KPiEmlrd0ZremEblUT7eZm0BzexaimmXYgubnuEPvkbQGa9wthiOWrraVZNfSbR0D3dM5e18pXeZJJmnLWKdvldHSuKUOsxOt3bbTboUw2gyslJWdOaVdy9qByFHOHqbkHGo8yhf7pMzaZaS57phW01Jel0mrG5SmjUNddDez7oydWuXyM2lNdiFWXboPJVg7FGLzCt/lNwpH8zahiOZobe1kVcJOl4zlA+HOkZfx6ZCqda7d110dOqk5j555J51FiWZST5Qtdd1klCVRBYFSJPLQBhVUm0uIVsH9rLkAPGR3mNdLnms6F9jxCstcglo/til6U1v7hJm27l3rQ7HE7SzZVqiFqgKlzQ0BSa17KIOX6mWnnHzLOfToTkNLH9lgkXjuufNIsdmoM5nGyaSbACl51ihnS4t7TBrI9uikqdFIpLPGdaGkO4e2QBHMZEe8Ls6U6DWk+dBZ9VLGu98lM11aIjXjakwmrUP6KF24IvLlTbBSMKXAz7ibZFg6JtIZFqmoicKJlpnItETwSSfBphrjGTYkkzzqgArxS9wA7/o/amHMG4VpUQ4naZO6llRb63b19J1i3g9Lqy/ptx4Jf2yej95JmyqnPp40nD1FZ6eEE5GkmCLLXyizGgweEiqMDJ59WrKiWnajjLNcFMFdh/WCApcKnDU3Ymiqex46z4jy0O5rCny1U8sU44naDrlFlpBoiqK2FSlQEkHj0YlVtbmq2OSJIt9n3XKPnkuWEFrHx1cmu67wCdWWb26RPgIq6cbWQSCh7ae1mavXCLiYj//UCeia5L5SWHfOUy1nmsah0qgDFAnlMSvhAGM7iEUB9aZX4xO7Zb2Agc/b+D4UPt78/jq64wBC6Jaup8vuDiT7JCo/slSKKILbA1xMusPOqh2o3McIKmivFJLa3bxx2ChgFek5k49tFcrJazxJPZAlqmxVaMSQfstACssdyhDQIDJr+rfDSzfXCzFsBrte200pvE5xAkmDNjbIohNm5klmgx9YnSeanMqY5A/FTwObIRibOeDRqguEXKfVlYUsDBao9WTlykDd1C2A/6v6HDLrn8L19fWACeBm7jfSqwkmzehsIIaOBraQNtfrp43aAEzqpEvhK1NPFeC4qG2jkWBXunMnuOISRcCYsAdsF3O7fUNnujpInQp4DZ8KwV2FmvtIOsh0MU0/t5EmSrcCsRpAyod4KFVKDYGfrdIxkSyVp42oJ1W+RLmRdmi0Esc0V7UIzJJ//A+4FBq6GJDSNahvqK0ceqdOtLOlCY7I3aUpxTsUdtOZL6m/rVwjKAPk2qwfngswTfY1DlqXBA1y3zIyIc/qRPHoW5SIy37KpWFJjHxD3I6/c2bOA3y2hQ4pYTZgbjokXWhk5NuoOmZiZwI/XVUnUEJFcawCmm1Ta/tw3ZnakHNtNGbUWEmVz6sXlxuq5lNV4lOqIJuQU5QHEMeyooAIrnXphlkdMea0QBdhgMjIKxu4ijyOJsAkNkSA4nW3zegoRhLwGvsiwsZFjaA+vJ+Pgl41LFqKTBzKJzeY4y4K5XoNc7nis0wgQnLKo12glDFaehPgz6/h64EaExPNTwJAe1DE3wFUMBxd4DV7naTKl3PCl5MMxeG/EgQoy39r+w5UIWwAZ7wmNqNo/ZhYKgiEmkMjJViEcWAN4ggPgzAdfloCgu4iHEgRDTcRcXnedsSBlODF7lLlgOpER4KNup9IZKHakS9TXDhct95PHzZaH3cFI3KsEcHSDhw4pxZUZEFXqYrF0L1DQXjKGS3CVVwx8nDWQ8lEU9eXCBiEat99LPSlgWplOVQDS2NDg3WSNSQYde+YyYCuVZNkYNUgND126YEyidh4loQEG2DBs/cx8KWQNz0yTgqCTkMLmclevB/oQSuswMNCWvYAHh277jmLiswGO2w9Q1IplD35KTr5Hkwr71QA1z9KYTfXDe9ie6JJUVGMgMsSH6YhBvcTN5Z+bw/6BkhdiOf4X0Pk+Qpv4YVvn/BmtOy3CPg+A8gw+v/J82EJl0ikfsma0i508WtNQFu6GJ5nsZ7sTacCgBfB1FmObYVEFLW3GkrRWXPP3mc5A+7fEinK4mqRU5D8gGpdNjZaTx7lfU3nAo5S7q6ZuzncQWjEbqGSyCJeBLuCbu5dB2B0NAvwQyBz0dO4KqIKUmzL6q2DRavRClhgVIC4xaAFJtpuxYBysKndvZhDL1fAUIGdSPVI1pj/IDsdOKzaO8oQp+O6V3E/4NI4XnZr1TBg9+zyic6BWbfzLUlOLB6VgvGd9dJlG2R3DQsnLrRb6tTGFEK3xB7SD1RT3S59Z7c2jisR42rokoQEIGggP4WMs4k1IYD3cOfVdnNjhiKwU8dM8YaSfVVYkKt2aOTuqsgBZY7jUazQPnqrocQgNSYPRF9E+SvLGIzVnyRDRzT5U7xUMb2wAFgAhqoHIja8Y7WQRurG2vHdnqeq6N53vShmnb5r4SmYj8L506vjGsLOMErgHKOchXNdCpdq3QKvrjCj24kXD1E11zUiyyQP1MMjC1GiLD4NtFbhbGXGdkY8i7TXDL5BETfhadPCzeugxtwL4lmKYfiQ+XpIzLxwA9hIky+ggMIqYFfDmiPa8AX7XMRUP+GAPciSQmZh4Q3ckRH3wIhZAsCijAbKl3J+pBtLw3pYK7n4IYHuIwk8Qdyjb+veV3i3lQFXjE95i470ifEZ34URpc53BJVKlIXJwbJgCB41Ag71DFpSqxtLXgf2MW3cvBmvhAaOZEiIFY4AVBNM8UITXn7AS1iF7J6pAoWAjmh4y5Wmx51o7qBVgkfol4MYBDQ6qnu60cLlwDyLZYLAnBUqs8u49IqKPjh1RKKDN4iOh8DC90kXJ3xR8Z3IXSKZY8wTHxaiwMkIazyh4r9Gh4PQgzQ5mi1l/HgDodGAEMOgPtzPUKjxDvqs3BfQ2QO0J2IC73XMhu3pL5h3OK0uF1GF9tgFiBzAEbEjPTfS0cXuhVAaV2toiWcgvopYcMpGI0r0rdl00vNRBbx+vXb6+do4CCDx7s8BhYZKAbGVsYEF33o6xfVwbB6PDhm42oxaeA0Pis6BgJjTlTqIdcdjI5CuK9YAEKmrYea3ZUCxeBgkMLVzXT48dD4WLX4TigKZ1x4yfWTZoIw5Yfj9Abj/j9QD9LCQRHR8r8ZAtosh4YsTZzwE6+t04rsoc2+g1h5gIHF4+O1J7Vg+NGbz7SfwOlPzvqVFhJCQ4mnAXHYqSrG5AGNBbEqAGmFR7CdXyA2PXUBbZDh04fz6OMUM3MHoVfGpA62Ch3LlCzVgC7l8h8oDzdHdYxXflJvm2zGM3fYpvodExdcdIZQVxzzLN/gLhzHDXBEgfgFpqgumRYc6Z2AyvCqVChakJ3UFShQaws6WkvrLRGBZ2vdBDT8fmO5ZrS1WV7AY6aEvuGNBCy6dENU+H7cj+IjURXxTlPiK5oBpiACdbw2ydEwhPeXgVeb0ZnPzCSk4aFIe3c7D+pQqdIRsEnklqk/0kTRiCrR5Cwx7NlvcKcK/+C842Hscz4SUBV8uHsfcFaHWDgNiVHyPq2tg2I0GwSGsCArBXY9aaonlIA/89/xSTMxu0YksrZC3USmjxhTd1OydAjy7HAWjs35LiSTJJGK+1fLY/jYha/Vtoc6KLD7NAwjBqov6ivQQKv+1N5Lit2LeX0kyrAOWwx4Y324Y6Ta1Pfe28KB+o20SyxGKged8rR68DLyOIPFZ8CylJuyKu1OIFtC7cUjNvv1wXNFyGgVX0BpryQgwPEYaTYyRPB4XzBaiaPdjDIqGRRW4knDdjsiAkxdzpWuOpxqgQMMzl0uLjOmW/UD7ziKzeymC3sVo9mXbwe1RmQix8c2+EFYJ2pqhsAx6apOdEn2fGXY9rvHJmE1Ae+fyqD0sH6o6dwh1wtUz6c6+XccvEf4MCg1gEJAu+DwazG+DVNf1RCkDYkgs37VXmFBbf21t9YRme7YS1HcXi284Q9kfNGWse323t0VlvTrImQsPsQe6oMLeHd2EbPNN6ub3aUuCjRDEcgcWHxX+kvCkf/xHvW1E1jcoJZxauvcKydiCv48V37kWZQxtw4qJNODPVsIU+R44zQtroi0Be+hQX63ZyRriAqWJJEBGzKI6HJPsdjpG3Vc3onja7pSJW3QaDu/lW8PjGISJQeEi9QZyj2GseK/BcVrkzo6CmB6a4tMCg2mQY5Ir7qkXBGGv51Yy496L2SD5l4UJHQG9D4NFJC5gLAA8HHMB1ULcWPqjb/FcfCK03wHQM64NAO9+x/lQNAHAAX2YIPJ5gjLOmy259gcgyvU7L8idDkJ2yr1iWAUkKo7aIk9uF+QrKQAFiq4u8yDdIZJNQ+Ts+x2oKKSDb5VtVDdyAHQi/ANtRPG4NK/Z8W1ilCdNK4egJtQD80GKITglgrcAvDm7GAgUvenMrdOOvrlEwcpEut/RfSe/eJeHm6vvwhdX3gi1lwnEsNAm/jZX13mIJM+UrhGdBlhhvig38IwcJ8W9zsAUzqpRN4VOZ6jfC6b+sS/Y0+VtHOmH6PwKZYMjbnwus9HtO0/IURgRkxFYTHJapCqYIzWFN4BpySEpeKAeD6PzeaflxfmdVkq7ynBzOtqlqAW/BkrR0Y7mINvwbWv4iO6GSDPJHdmbG+xH+UW+DEnHia4hqdQ2ohfBna6CR8CN+u0CFILsuJOLZ99dv72NlBM1hBDGM8IP5TFZ/QAQhDXKyVAIySckQWg/67gP6hDcqVNQlTt3Z3Bp5Ksj2JAxfs+OKrZqmi8nKzhDDVK6ie+cEli83+7BM4qzhKseI23xey7482t4xHg1VjMBA+zFo89895p+Rfr4Ni6Ek+j4+ayNAovkBd00m7iCQrQSvXB97wCkxqsPopP00DnR7zRQIHs2uowUsjA8dPG/jrjS/UYoEgyM9Xs/FSUpLaAjORmgMNyebyyd3G82egkJ4rfESLTf/Lfie7SAK4GFZyh/GrsDyRW3gxoNiJjVkPK++Ygp9T1h3BB4xirxqpZXj7YAtoUcBcCwBRv9j0xh9EFhGOyOMwoO4rmNW/1GTWx0/FnUAZN0P19SxougYiS7BzkOfe63MH3Nd29lMhC6UvG0g7Pwn4sCXag3v1t6XXfn5RrBnc4hwNv3CiYVAk75nhTtZy6QhgFusIEE1Gf1sTiISULf0Q1Ukd8PtZuzAzk1bA2fbRAJUoZT0iWiKGNFpKKLerkngI3DN5P83tEsCCValn5tCSSoAFZ8NE5iZCGOFvnI2+fc0hSMyOP6hgheBC/JqM0XtzPY4ff3CcRZGFPQp+eT9FGVEXZAx5l6MPfTxBAh6p9mAdsCes1v4slb46vGhDSdrI7iP3whocfnC9FXoxzU/6gk3T51NDqRmqXEDBZpfvMByw0xUJeUSzQ5viPcMHg1uzxlzOnc9szCN1b5NBH44/uD8eVHwoMzBAdw5t/eZ7uSp4CG3yd2DETwEdbr9O8QEP3Wg28roCeRYRkHdKL6HzKxMGDwGRf0vRjBi75j7X6nFNW/ckp20Z7t7ZL6fRp0CBMDCbLfwU4hteMuyDWR35qZvpvj1ZDwnfkxnjWhUnmmRRqK67v2d+On/kdI/wa+GQTprDiGjAAAAYRpQ0NQSUNDIHByb2ZpbGUAAHicfZE9SMNAHMVfU0tFKh0MUsQhQ3WyICriqFUoQoVQK7TqYD76BU0akhQXR8G14ODHYtXBxVlXB1dBEPwAcXVxUnSREv+XFFrEeHDcj3f3HnfvAK5ZVTSrZxzQdNvMpJJCLr8qhF8RQgxR8BiUFMuYE8U0fMfXPQJsvUuwLP9zf45+tWApQEAgnlUM0ybeIJ7etA3G+8S8UpZU4nPiMZMuSPzIdNnjN8YllzmWyZvZzDwxTyyUuljuYqVsasRTxHFV0ymfy3msMt5irFXrSvue7IWRgr6yzHSaw0hhEUsQIUBGHRVUYSNBq06KhQztJ338Q65fJJdMrgoUciygBg2S6wf7g9/dWsXJCS8pkgRCL47zMQKEd4FWw3G+jx2ndQIEn4ErveOvNYGZT9IbHS1+BES3gYvrjibvAZc7QOzJkEzJlYI0uWIReD+jb8oDA7dA35rXW3sfpw9AlrpK3wAHh8BoibLXfd7d293bv2fa/f0ASM5yljz/NiUAAA0aaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA0LjQuMC1FeGl2MiI+CiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpHSU1QPSJodHRwOi8vd3d3LmdpbXAub3JnL3htcC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgeG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOmI5YjA2YTAwLWZkOTQtNDc5MC1hNzIzLTlkMGUwNGRiNTRlNyIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1MTQ3ZGU5Yi1kOTA0LTRlNWYtYjIyYy0wZmMzOGRmMWI3ZGEiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo4YzBjNTI2YS1lYTkyLTQxYWItODM5Yy05OWFhYTM0YjdlYzciCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJMaW51eCIKICAgR0lNUDpUaW1lU3RhbXA9IjE2ODQ5NDE2NDAxNTU0MjYiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4zMCIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIKICAgeG1wOkNyZWF0b3JUb29sPSJHSU1QIDIuMTAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDowMjQ4MDc5ZS1kMTYyLTQxZmItOGViYS1lMzY2NTRiNGRjMjYiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoTGludXgpIgogICAgICBzdEV2dDp3aGVuPSIyMDIzLTA1LTI0VDE3OjIwOjQwKzAyOjAwIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PkaovgIAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnBRgPFCiKn0kIAAAFfUlEQVRYw82YTWxc1RXHf+e+N2/GH+Px2IEEV02AgqIsIkwgoYS2ahepVGCBUOiCRRdsAAnECthErBBCICGFj4gqRQqBRSABUrVm1URtCSATJ5ASZCPHH0kGgx1/xJl5nvH7uIcFY4iIM/GzZyhHenqL994993/u+f/fOUeos+nNnkHCJoQWRD0UFzCARYhQCVB8NFWWTwNbT99SNxC3GZfIXg9sADYDWxCuRekEskARYQplFPgEOAr045ph6bXRzwKM3pEX5mduQLkHuAvYCqSW8GkIfAT0IBwknT8lH87o/w2M3mpSqL0LeLQKIrOMZSpVUC8hpkf6bPiTg9FbpBn0L8ATwLoqL5ZrFjgNPAeyV47p3E8GRjdLE6r3oTwHXF0n7ikwgfAEIvvlqJYbDkY3uw4a3YLyNrC2niJSBXQG4c+Ie0yORnGSj5OnRhzlUJ4ErrkikBAoAjPVe7ik4F6D8iRxlGvoyegmx4X4NwgHgM6a8fUyIfc8doZbf99Ca66N0uwF+v7tc3DnWoJK6gqep1C2g3NEjsdLlm03GXSbAe4GmmvGZ91vA3Y8P8aN6ztoyaYxxsPaNrbcnmbbvV/x9ONdnPnA+w71otaMcDfYPqDUmDQTUgjdNYPQsSHkgYf62di9mmwujzHNgIsxzWRzeTZ2r+aBh/rp2BDWDLLQjSzpf7VMMIpB6QKcy77Tuc6wdVsHbspbfJspj63bOuhcV8u3g9KFJtufWQbHakfLdQUv3YrI4qwQ+e65616Jr6mknE4KJgIGgctLZnEq5vRgAWsXLyKttZweLFCcqiW7cdVP1DgwQoQwUNPJxIDDG7vXMDszBvqjDWvM7MwYb+xew8SAUzNowgCSDEwyNVMJQU8AAdC06DvBtOG/76xirlLi3u0nufn2HJmWTir+FJ9+PMu7B66nr6eVYLpWCgUoJ0DCGoq3wv/MbXkhmlkN7Ad+XTMY4kBTl6XlKnA8IQ4U/xyUx8wlB3ZpKvcC23Hz49K79Ep6GeWM8VB7J8pfgasaUM6cAx5EzPvSZ4OGljNy1AYIh4C/L6lASWYBcBCHQ0mBJOfM94rk+WjwAsKvgN8te51LK7kPpm3zK89OrZH1v4zaQ9c4RJFrxDgAqjbSlBcpGqlqODoyWq5TP1OtnoU9wPqV9DMKWlRnfJ+/6q3XKpmhSRVbXU8uuhb6Hq1eVsBHdDiGQWPMuZV1mpuMB/aPCK8CXcsMjs6pufCm3/7PPZXs8LhKnJBjMTCH4f2VdIfIcRsgcgh4FpgkiY4u9Mwqc4fn2468M58dSQhkIbNcwBPVNrPSRJdjWgb2AK8BidrdSCX4PGw5/re53IlBK8uZ0EhVyodCq/1uXTTIzfrExZ0oq4H7gfQSmv54IMqcfNFv7/0ilkCSg1CgoKon1ZEv017ar9/cbEvGEFeuQ9mF8IdaBamFuBB7I7tKq3r+EXjnK0tPTxUoIzqqyCBooRIGM2NjX8d1HQIuKFys0cYY2eeJ3riYwinorHUndvmr3nt7Pj1eVNEa5LZALKIVrBTAnopVRx3HzOE44dDwsG3IRHPBxrtTnkv8p5yjLzvoLy72oaC+mvOvz+V79pZbRyYvJbwC80AFQ1GtPevAqFPxCuoxL57ql8ND2vDx7MVW2JTOuMQPdxDvSInmF/yU1ZT+Nd92eGcp97+RH4BE1XHHLDAtomPWmK8mpiYn/AvFOCmRGmLTm53WOOKpDhM/YqApQsLe+dYPnym1f9xvTVGQc8C4iE5Y1Ulj7eRQoTC7Ih1qFJiTQc7vwN9ZUbk6Z+ydp6L0Z2+Ws/uGrAyI8I2gF6yR0vDI6Uq9fDbsZACO3NQuGa3kr3XC7H+ClvJeP1/6IrbBqbNno0b4+xbMlmARngcRbAAAAABJRU5ErkJggg==",
  turquoiseBlue: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAgCAYAAAC/40AfAAAQDHpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjapZlrciO5joX/cxWzhCRB8LEckiAjZgez/PnAlD1drrpxu+/YUZJKSmWSwMF5pMP+n/8+4b/4yTHmkLW20kt5+Mk99zR40Z73Z9zH+OT7eH9EPp/FX98P6fP+k3jLD/oc2Mrn+K/34/cJ3qfBK/3Lidr6fDB//aDnz/nbjxN9LiS+Il+FfU7UPyeS9H4QPycY77ae0lv96xbmfp/tayft/Rf84XzVpL5PP/+fK9Uz5TqS0pYoD4+fYkkS/ydBBi+UxySZA6PU9/V9LJ+VUJA/1en7p7Oi40vNfzzol658v/rRrU8F2NqPbuX0OUR+FLl8P//x/RD1z125pf/LlXP7vEq/vr/k2e+KflT/Fv9YO3fP7GLkQqnLZ1NfW7yvOG5yCb90Cyyt0J0ChhrP/tv5bWx+AQV71jP5XbHHRLtOzNHiiCfu+7ziYok57ZAqL1JaSe6bTWrqifXSv+y/8aQqXUwaXVy37VnS91rivWx/VrhXa1zZIoemyMkiX/nHv+GffuEcH4UYvZbjrRXrSsmLzTK8c/7IYXQknk9R9Rb46/fnj/dV6KB6lX1EOqee7ymmxv9jArmNFg5Unt8ZjNU+J6BEXFpZTBQ6QNeiaCzxqSlVCEpSo0GDpfvMTDoQVZOxyJRFCr1pyS/NV2q8hyZNvB14HzKjEyqFOWt0aNCsnBX81NzA0FDRrKpFqzbtOoqUXLSUUouT4qhSc6haS6211V5Hk5abttJqa6230VMXSFN76bW33vsYXHNw5sG3BweMMdOUmaeGWWadbfY5FvBZeekqq662+hqWTAz+sGLVmnUbO26gtPPWXXbdbfc9DlA7Ek4+esqpp51+xnfXPm397fcfdC1+upZup/zA+t013q316xTR6US9ZzQshRzpePUWAOjkPXtazDl557xnT4f+RBOLVO+ZRe8YHcw7Jj3xq3chvR31zv2/+hZq/qVv6T/tXPDW/cPO/d63P3XNnITX7dg7hV7UR5g+Pt9tpDZc7H57Dl8vmBBZjQJKZuNivLe6qJ0KRa10Ri3sSNYUdlTSNhm2fHrW3q2WHUz5Uoy2+qhR1zpd42Kfqyg8pnJK5+GxtfY5jWIPR8pZTsbIJJvx55WD1SrglQsUYzWZesXZ6EkvyWy2BWNz5ii8eI4Oy0Oimkb6skc7bSy6pxpOdJYYfF/3mc9YVbJGen163LX5y4iCvNVAAtgR2sr6lTeca5byylbY04Zy0lkYmkRfF1ReNGUqriVaiyxjp7FhRh2DtvV1qia+03tuAKqzuDlD4XICE9HCqRXrsGVorgIPmcFOOteac6Su7GnsGruyokw9o4BjmR0ARLQ/jwP6BpXm2fXsKYML5BPnaTWtkxc79oIWNTBfe9+FB/A3Oe2s0XJfVYMAPuF6JY3l7goPEzen6iXzT9eoNnwSlc5YYkriFIq5D4N668YUQbg5qBuit6R/55niMfQdTow+0WNvrlaf1sLs3mChUH0c5PChozp06pmlnrJKn4+UbX1r7SOmvPuc0vZs2/wMjDgk0VtYqxjIM1dYscoJtGQYvTb2n5n30Tkf6BursV16Av77ZMB90ucZjDxYsOCHFZuw/1vDvlhJ2YKlPEbd6M9gX8Of00jJTeEY176YG8UDIkBnDqWu7YSyZCM+pjMmOzPXqic9Xsw0s7SV/vW4vs+h3T69/xsRhPcJA/Sdzz51OUPUep69F73eWyzNJidiM5NDYiJEZ04GNnB1WcvGinPN48iEv549+ZStTUt7SN8AY5cIG9bWk7bOPPaUgcRz+LSVmWDI8kBTtZh2O42TplnioNGx7n0YJGe0/MGpMZq1AeLCRxkQIcHZWtMZWkOYa88AP85ZhWvSFmu7zEatE3LewfssC3ZnGhI96iseCHaPafkLlUH/LhpjPVm8LgypZPNX44wGO2V4BWJzCQCLcAzitjMDL/VsLue27FlaJ3tjC3UIVH0aX20MX/5u6a6/UK2/lR05de6JOMTWtzzmBhEZYzQ5Tc+QRtkKC9YEqcF9A/RZKmUGwysy8sNYYWlXNWiILrihT3uAes1rQlP7OTTjHJGzo8IDA+YjV1BReKcFo2UGWgBGbZy/l2nQtwGauIVsUNEpOtFTNdaky7kYApqIyuqMhM7HAEsYYApVU0e+i1uMrCdDT3PpQT+o20OXgEPZwBKiy8REeBwv22wNhA5Bw0S4okzNG35mqDMMaVTl0jZunyl6QV/5IMFkSB8EhX0DGTOBi1E3FHh6YICd/fbZ4/06lbX8tzHBVIELRJmYhTI5dvUigxWcYq4Df0CDx70vPGi03hkp6OEsbTWM9+TQzpH22dKT0T0MjdSiEHJh5OJZggTYdLMzQTrDW3BGMmGpBZcF9X0z4AtKWwK71Mlw8mpfgj5HYVNo7UEJEzPBtxjkTEBt6xiDdAYsVyTggptVFBK7tJCwXhycUQBHmk9VZ/3J+pb3qKMXk1kDsJQHfRGmOO1mD64WS8OJ0Eeqv1D4zfekuw8Alrkkx9LjBMkc3TpyalBHtw5Xm1+VDScVdJByj0tUsFq2crIXUjrAbSZdLdHUDWjevuKdTvvuH+xOA8I2f1EAKCEsU6bqJ4QXzzao7UMTENho75h6mPnDc/jLGx7P0oco6u9EYdiMpB/YXNQAhxc37C0AG5j2d1zgmN99oAv7G39lrE2WwVFQSAFzbnfZdi/BBwI23hOlS9XNbWHOC2yaHOWQ9oTRCrS1eQCsRiZNyb0OeIoHcMQ9FRzlZgfXBoPgG/YqcPO5y4YO8EsTN94fJ4UOxYCqOfjFF1d8ImG042Oa7BbE+CgSfPkaACzizdHSzO8HQQSivWFjk/uYPAm08ML0Oxlj5EZNYNeJky5h4/oWxdnIP68xUhgQCmDb/TYGDPUfczW4nmnWYhgam4adQQ9nq24MODXIPlg1aQgIBmG4KYBBB/XDdGW3ZoYLVazkgYAIVFTlwK4oWesYQAwzSyS9Bwwc9beJo2LIKe9nhuPWn5j7E+S+ARf+NuJ+AI5xvnBboOjArMH78+INjoT6cnMQWNkJokBBi1tjvoBTcpOw0GLGKTvF6zLyB5RSqzEiWyhCQviNkiMvIpQOx4LrwlWnOuDTzs49wpNvcMOgHkfsdhrCByEJeJQAQAYxI/9cPgrQYWbsg7iGRgjlDKlb4Xckeidy0ioTqwt/kXRC58hFGsNjt4ovxYBjL5W8R/hT7XnW99wkrPYXxgYc+FmK293mkftBSbYluHaDfDay1ODagSwdcVET7CMc1zkXWy7L8wYA5IChD6II2pNLesCUUOmHHDST05V6iKiQq8PmoDmMeNcbZK6FWBVCpawscajPgdd3bJw/1UBI8UH1ysPGVCYlDDnj6tmki5t/5Jb7oL554rFh39P35a524lgrMIZUxqLORIcNkO7x/RXcZPyxGhIwZcMpmacKIm3vHoF2AEv6TCwP0XopjZ/uAeBiPC7ChlawzcowIPcoBGrObFFLl9TmbeE0fk8y/Abey4xQX2OPm2TjWefgu434eMCaE7EJlhrXcpAJ5sr1MLB+qkP21oEJngtlRWw20WXjJTHJfIOMRjlLYYc7ERNIxcL2ngjaKRDb3zm4D0JVkQ76ZejoBgasfHm8w+27PrWH/0ZoMvZ9PDrgEzzjEkOQzDnJbkQI1HJBrBNpg1bh54gCP57oSZoZzBG/1hJscm+5OwOcymQAn3kqafWSBWYU7/MR/H/57Gk5ne7UuGEn0+RqeW0SRBrZ8rM2bkQBoHtdbCbaCiHS3GevBXYqChEHkZM98k4io4Fq0ihehV0el5yi7vcsRCzHvmBbM4Oo4a4x9YohJUqwb6FgdoRVVSNIMP8kIi3drSHjMD0erTpCd1qn2+IAyR4Xn+OxoVV4EW9CcmBAS3FzARHEKOWgUXZ3TSn9Bpt/xqxBOeJI1a6CyMAwjRiF3/e/JahO+ALcwOUv1OKf3VvwF9jMhkhgPI3gb9uQQhJJzbXjfvMaxLbtaRxOwNgCb3X4uRYOiz7osgKpTT2ZiC2mA9JthP7l4XQXDvNIZH6Nx/1KvNcgGfl9pfVeY7x3uIN7qsn6VckwqA/DCE/hAwWjS0bT5PMFh6KIU2K5UgGJ/Ix+4YFxAUUpGO0Me16HlBLJ7N7AQusY3EcIWpSY/uKmPCBwIAFCvQYH4Sq0P7IYOMwnxzWcdIWHncQITB62vKWGnQbwwIIh89FHLkkihUyJojCjWwnCoSMnqNp+Ch1HL15exsqP9K8hT6ZgXSU7pmveB8AGGhsxIxlEyHRUR3cGFd8hfjvtNrz92ygnOfjoHMkd29zd1JwEFSO/SCM5lh17sqkGRs7usAhuExZRQktLhdkDmdiGOJg1RK3xBb/1jrvVxQA0D7/QbBloVoU3K/pM/Ohk1Qaj8QVcNmkrI0FV3QSH6Dcw8A5GhK24M4zXqUJ92Tk05ARIVVudK89Xbcltox5yHiNKxriMivWDmO/UTi/bMKIGLoOeM0TEp1z9htwS1HXZ5c5l8EYb+G+mFgEnw/UmWgJenLHN08Coma6DCSK7em/xWlxCM3XiubnDtT08jiIgBFVwljwbIIS6gjMmRtygIiwfowtA/G9kD21jsjGMrXa/fSBQYuxsTByznPXeSirOK3q7VisGrAOqjgQwRMAcYSSn5ERQfKN0QqVcZ5YyKPgX9sls0HlmaeJ8KromfhsYSNjoiZHmlExMo4iwUqrYCl+y3HtnfmNQi9f5yJWlV4OH5YUc0dd7/39TXvB8ovgND7Sdo/e9twbhx/fmZU7YeMcrEsCM0TDfzGyM9AxM+IgMBLI9JsPKaY+TeInkhPeW30IgFsQJbPrUODmW2UTFoTGuACs4sW1K0akJGvg1Cf/+ZtHnmbX67RbAU2uwXvYoDS8GzzKM5LRNYql+H/NQs4gJEjDb88GPp/sXRsyH39RdW+vohMhra6bf0T0EU4pL1EBKRvV8yMCw/e5BHtJwrJAeico3PhZTupL9jk71O511WcC+53vPadEifNmqD/6+Ca1a+B57arkpfxFk/S4oBApPH1aOizMC7lK/D7cCm8Gpmdv8LMsTKPbUoy1mXBbBt/uYUu7kt8X4iEBJVtkKezRr12rliBml/GgfMnphhinBrj0+tkwZfgmFOlagbcwpjomMXOgZY+i+WTBVpb6OMbB3ZnOgIMktAhxTMxLpZXCJvwYdgJdOAiLLEXEflQefJrV5ANNaUX5MRN1kPYPqoWe/TcPEkUmoDPyNRmNehZrh+bo7Yohe/P4KKbNMwW7XxCDD7hYmLI3RhiJ8hjBiC6vitzy3/9nFcwD2X+tecsqjzW1bh3oWs0z623xJIO5TgydMFMUaXh1X4RiCLcheaIZHJKDKqm4NMcBcTmjxGP3GAdIIVtIepjocEsqDaI07Tyi2npk9YovfGDpzY4E8CST/O91aOT5FPS24MRIS9Ze+hF+Ehmaa/4H7fwGCg3GYVGiblAAAAYRpQ0NQSUNDIHByb2ZpbGUAAHicfZE9SMNQFIVPW0tFKx3sUMQhQ3WyICriqFUoQoVQK7TqYPLSP2jSkKS4OAquBQd/FqsOLs66OrgKguAPiKuLk6KLlHhfUmgR44PL+zjvncN99wH+ZpWpZs84oGqWkUklhVx+VQi9IogYIlT9EjP1OVFMw3N93cPH97sEz/K+9+caUAomA3wC8SzTDYt4g3h609I57xNHWVlSiM+JxwxqkPiR67LLb5xLDvt5ZtTIZuaJo8RCqYvlLmZlQyWeIo4rqkb5/pzLCuctzmq1ztp98heGC9rKMtephpHCIpYgQoCMOiqowkKCdo0UExk6T3r4hxy/SC6ZXBUwciygBhWS4wf/g9+zNYuTE25SOAkEX2z7YwQI7QKthm1/H9t26wQIPANXWsdfawIzn6Q3Olr8CIhsAxfXHU3eAy53gNiTLhmSIwWo/MUi8H5G35QHBm+BvjV3bu1znD4AWZpV+gY4OARGS5S97vHu3u65/XunPb8fN2tyj8UDOK0AAA0aaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pgo8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJYTVAgQ29yZSA0LjQuMC1FeGl2MiI+CiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIKICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpHSU1QPSJodHRwOi8vd3d3LmdpbXAub3JnL3htcC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgeG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOjEwNGNlNWFhLTE1YzctNGI4Yi1iOGU1LTFmYWQyNWFiYzBhZCIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpkNDMyZTY1Zi0xOThhLTQxM2EtYWYyMy1jNzhlNzczNGRlN2QiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDoyNzExODVkMi03MWZiLTRhZDMtYTJmMi1iNjM3OWU3MDc1OTEiCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJMaW51eCIKICAgR0lNUDpUaW1lU3RhbXA9IjE2ODQ5NDE4NjYyMzgzMjQiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4zMCIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIKICAgeG1wOkNyZWF0b3JUb29sPSJHSU1QIDIuMTAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo1NGFiYzNkYS1lZWJiLTRlZjctYjdjNS04ZDRjODY5OGVjODMiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoTGludXgpIgogICAgICBzdEV2dDp3aGVuPSIyMDIzLTA1LTI0VDE3OjI0OjI2KzAyOjAwIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/Pj0tlUwAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfnBRgPGBru/VeEAAAABmJLR0QA/wD/AP+gvaeTAAAFO0lEQVRYw9WYe2xTVRzHTx97dYS5B1UHa+/tY12dDoOKWyIGlfgHkCkSNTHGwHxA3NiAP/A5x4CMKEzdYL29YyAyBxKQZbI+NvYIaowaH9Ogi2GRbGjcFrbBNrq2a2/9nq5LCFnbbfSOeZJPTs/t6Tm/7/39zu+cU0IiXc7WSImNX0BsZiVYAhigmah5tHklsZrjSYtJSuZtaeSiiJU3gHUwfC9oARfBIHBP1DzaPH1eRuzmp0E6aTgSNX9EWMwSvOkMGPgG+CpguG8a0H7nA78zkMYqye0V0lYXDSHrYUw7cE5TxM04/b+38+vJ+RPRt0eIjVeAAhhyCQizFDKJEBjndaCY49Di4+CRlzFxfwSE3Ciol9i4DSBujoRUy7HIszFxdwSF3CioBy8qm1g5ufhirHwyJqwHrrDGWTlg8hFL1URN2+EF0XFPkyYuSWwhUVgnT2CygXBG3dFcM7bz1/au1u7OK9/93eWidUlHe1dCc810EsUAsXOPQZCI3rGZ6Wb4EXAEM0SCUFnZduz6T/09l4bHXYOCz+f0+XxeWg+7XYM/4vnKtlqHJHSIOrAHlYMFYmawRNCKycaDGZLVfMRdf/nPDpfXM+abotDnpy93dtzXfNgdZg+im2uimJ6h66UTeIMZsrat1jvkdPRRb/imLt4hl6N3DfqFEIPvOMzDJYspJsWfbUKEyFNttcKoyzkKo4UgYoRRt3OE9guT1br984nsmQ7gCWbIipaj4xeu9v/hFQTPlG7B89+u9v9O+4UQQ8f/BSlaVM8kgBOhji4p9mpvwQ+Wfwddjp6bQw2u8g44HT3535/tTUa/0Eccvg4sFDE1m2PBZkx2LVRqVcLQvG/PDDX1/tVxze38x+UZH6O1He28b764qgwtxOcf327eBGLFE9NikiD3qzDZhVBJgCJH3KubDnkfbD4s5Jw74qM1bcvDnxq8/vHt1SrS9InIJ2m7OQ4UYsKhCB9lJqHj0gPsHJzPvsS9w8rRRPDptI40M8PlH9fOJ5M5K008rsZmIwi5gc4QN9Zja8zn+5epch9PTFepU1iGuVunVqeyS9g0iv8zy96l0WiSjIsXx28iJEJhaONkMGB5YP14bkmI1SzIz1T0pRa9VKnNzCjUMcwWUAS2BtgWYLJN+xTo1OyrOhW7xsAwqnSGkd3i+uGjkT5Xw6DLt3AdEKQNB4YXbdtwQpuVuRtG7pwhxWA7vJgRib0nDuSDvtkIkjYcHE3aVWjRLL9/zyyETPK2Vq3OidAaOhiPDLcbxo3MRIik0eReWPnO15pHHiqbpYhS6hkNw7wAz0To6GM5hAzH3wkDa6b7x4bEwnkUfMnP6idX7Nex7GxElIDNerV6hU6jSdbp9RHck2w0w/FaGGoJm7KtnCfmWNlF1fOrK3Q6bekMRFABO7QM8yxewFLUi+5JSxPpAmcxy0gjt1Rytir4NcHKCfJTH/al5j1j1hr0pWEML55YD+x2GP6cVqNZZjQYEvUsG4vP4v8jKju5L1p6qnytxGKa6qogyOorBpVbXvxMe69xdxABb9I0DAGvIIRWp7NsBsJIoWVZKfaXuf+jMKp2b6z8+Adb4aErNwpCCh5J2pnfoH0ga08g7invBfaQjXjjuQifhyEgLdNolJP5UqR17y+QnSwvk1i565OZK6F8RzubvWwvDH8LvKZnmHXY8HKws+sNLJtI5muJ/7hYElOzJ1V+fN9R7CVDClPJOVXuqo06vS4HQjTwgDKDZRXk/1JiD7wrieFLk6T1lczCXUVK7aPZinS9XrTw+Q+Tql7SUmvGuQAAAABJRU5ErkJggg==",
  defaultOffset: [-25.5, -32]
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Marker);

/***/ }),

/***/ "./src/packages/Formats/GPX.js":
/*!*************************************!*\
  !*** ./src/packages/Formats/GPX.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ol_format_GPX__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ol/format/GPX */ "ol/format/GPX");
/* harmony import */ var ol_format_GPX__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_format_GPX__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_geom_MultiLineString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ol/geom/MultiLineString */ "ol/geom/MultiLineString");
/* harmony import */ var ol_geom_MultiLineString__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_geom_MultiLineString__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ol_geom_LineString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ol/geom/LineString */ "ol/geom/LineString");
/* harmony import */ var ol_geom_LineString__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_geom_LineString__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Styling__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Styling */ "./src/packages/Formats/Styling.js");
/* harmony import */ var _Utils_Parser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Utils/Parser */ "./src/packages/Utils/Parser.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
// import openlayers

// import Geometry


// import local



/**
 * @classdesc
 *
 * Extended Styles GPX format to export (internal use only !)
 *
 * SPEC
 * cf. https://www.topografix.com/gpx.asp
 *
 *
 * @constructor
 * @alias ol.format.GPXExtended
 * @extends {ol.format.GPX}
 * @type {ol.format.GPXExtended}
 * @param {Object} options - Options
 * @param {Object} [options.defaultStyle] - Styles by default
 * @param {String} [options.orderBy] - Sort by key the feature before writing. By default, no sorting
 * @param {Object} [options.extensions] - Add properties to file root
 * @param {function} [options.readExtensions] - Reading extensions (native)
 */
var GPX = /*#__PURE__*/function (_olGPX) {
  /**
   * See {@link ol.format.GPXExtended}
   * @module GPXExtended
   * @alias module:~formats/GPXExtended
   * @param {*} options - options
   * @example
   * import GPXExtended from from "gpf-ext-ol/formats/GPXExtended"
   * ou 
   * import { GPXExtended } from "gpf-ext-ol"
   */
  function GPX(options) {
    var _this;
    _classCallCheck(this, GPX);
    _this = _callSuper(this, GPX, [options]);
    if (!(_this instanceof GPX)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    _this.options = options || {};

    // INFO
    // surcharge de la callback : readExtensions
    if (_this.options.readExtensions && typeof _this.options.readExtensions === "function") {
      var clbk = _this.options.readExtensions; // callback definie par l'utilisateur
      _this.options.readExtensions = function (feature, node) {
        this.readExtensions(feature, node);
        clbk.call(this, feature, node);
      };
    } else {
      _this.options.readExtensions = _this.readExtensions;
    }

    // INFO
    // defaultStyle est un objet de type Style
    if (_this.options.defaultStyle === null || typeof _this.options.defaultStyle === "undefined") {
      _this.options.defaultStyle = {};
    }
    _this.source = null;
    return _possibleConstructorReturn(_this, _this);
  }

  /**
   * Read Extend Styles for Features.
   * This function overloads ol.format.GPX.readFeatures ...
   *
   * @see ol.format.GPX.prototype.readFeatures
   * @param {Document|Node} source - Source.
   * @param {olx.format.ReadOptions=} options - options.
   * @return {Array.<ol.Feature>} Features.
   */
  _inherits(GPX, _olGPX);
  return _createClass(GPX, [{
    key: "readFeatures",
    value: function readFeatures(source, options) {
      // INFO
      // le travail de lecture des extensions du format est porté
      // par la callback des options : readExtensions
      var features = _get(_getPrototypeOf(GPX.prototype), "readFeatures", this).call(this, source, options);

      // String ou Dom
      if (typeof source === "string") {
        this.source = _Utils_Parser__WEBPACK_IMPORTED_MODULE_4__["default"].parse(source);
      } else if (source !== null) {
        this.source = source;
      }

      // INFO
      // on applique les styles par defaut definis avec l'option defaultStyle
      // sauf sur les features qui possèdent des extensions.
      // les features avec extensions sont traité au préalable
      // dans la callback des options : readExtensions
      var self = this;
      features.forEach(function (feature, index, array) {
        feature.setId(index + 1);
        // HACK : enregistrement de la description de la balise 'desc' du format GPX
        var value = feature.getProperties().desc;
        if (value) {
          feature.setProperties({
            description: value
          });
        }
        var featureStyleFunction = feature.getStyleFunction();
        if (!featureStyleFunction) {
          var styleFunction = _Styling__WEBPACK_IMPORTED_MODULE_3__["default"].defineStyleFunctionByDefault(self.options.defaultStyle);
          if (styleFunction) {
            feature.setStyle(styleFunction);
          }
        }
      });
      return features;
    }

    /**
     * Write Extend Styles for Features.
     * This function overloads ol.format.GPX.writeFeatures ...
     *
     * @see ol.format.GPX.prototype.writeFeatures
     * @param {Object[]} features - Features.
     * @param {Object} options - Options.
     *
     * @return {String} Result or null.
     */
  }, {
    key: "writeFeatures",
    value: function writeFeatures(features, options) {
      // INFO
      // il n'est pas possible de surcharger les parsers d'OpenLayers (private),
      // on decide de (re)parser la sortie d'OpenLayers afin d'y placer les balises
      // d'extensions

      // on met à jour les properties de styles
      features.forEach(function (feature, index, array) {
        // HACK : enregistrement de la description dans la balise 'desc' du format GPX
        var value = feature.getProperties().description;
        if (value) {
          feature.setProperties({
            desc: value
          });
        }
        _Styling__WEBPACK_IMPORTED_MODULE_3__["default"].definePropertiesFromStyle(feature);

        // HACK : Le type surfacique n'existe pas au format GPX,
        // on doit la transformer en un lineaire.
        // Par contre, on garde un trace de la transformation :
        // * le style surfacique
        // * le type de geometrie initiale
        var type = feature.getGeometry().getType();
        if (type === "Polygon") {
          // creation d'une copie pour ne pas modifier les features de carte
          var fp = feature.clone();
          fp.set("type", type);
          fp.setGeometry(new (ol_geom_LineString__WEBPACK_IMPORTED_MODULE_2___default())(feature.getGeometry().getCoordinates()));
          features.push(fp);
          // feature à supprimer de l'export
          array.splice(index, 1);
        } else if (type === "MultiPolygon") {
          // creation d'une copie pour ne pas modifier les features de carte
          var fm = feature.clone();
          fm.set("type", type);
          fm.setGeometry(new (ol_geom_MultiLineString__WEBPACK_IMPORTED_MODULE_1___default())(feature.getGeometry().getCoordinates()));
          features.push(fm);
          // feature à supprimer de l'export
          array.splice(index, 1);
        }
      });

      // tri des features en fonction de la balise "number" || "id" || "order"
      if (this.options.orderBy !== undefined) {
        var key = this.options.orderBy;
        if (key) {
          var sortFct = function sortFct(a, b) {
            var cmpA = a.get(key) || 0;
            var cmpB = b.get(key) || 0;
            return cmpA.toString().localeCompare(cmpB.toString(), undefined, {
              numeric: true
            });
          };
          features.sort(sortFct);
        }
      }

      // nodes
      var gpxNode = _get(_getPrototypeOf(GPX.prototype), "writeFeaturesNode", this).call(this, features, options);
      if (gpxNode === null) {
        return null;
      }

      // on ajoute les extensions à la racine pour les metadonnées de calcul
      if (this.options.hasOwnProperty("extensions")) {
        this.writeRootExtensions_(gpxNode, this.options.extensions);
      }

      // INFO
      // à chaque fois qu'un style est trouvé dans un feature,
      // on appelle la fonction d'insertion des balises extensions dans le DOM.
      this.processExtensions_(gpxNode, features, {
        extensions: this.writeExtensions_
      });

      // dom -> string
      var gpxStringExtended = _Utils_Parser__WEBPACK_IMPORTED_MODULE_4__["default"].toString(gpxNode);
      if (!gpxStringExtended) {
        return null;
      }

      // format string
      var gpxStringFormatted = _Utils_Parser__WEBPACK_IMPORTED_MODULE_4__["default"].format(gpxStringExtended);
      if (gpxStringFormatted === "") {
        return null;
      }
      return gpxStringFormatted;
    }

    /**
     * Callback to read extensions from options : readExtensions
     *
     * @param {*} feature - ...
     * @param {*} node - ...
     */
  }, {
    key: "readExtensions",
    value: function readExtensions(feature, node) {
      var _node = node;
      // recherche de la properties de type Node ou Element
      // si le node n'est pas renseigné...
      if (!node) {
        var props = feature.getProperties();
        for (var key in props) {
          if (Object.hasOwnProperty.call(props, key)) {
            var _element = props[key];
            if (_element instanceof Node) {
              _node = _element;
              break;
            }
          }
        }
      }
      if (!_node) {
        // eslint-disable-next-line no-console
        console.warn("node not found !");
        return;
      }

      // ex. de nodes :
      // <extensions>
      //     <marker-size>medium</marker-size>
      //     <marker-symbol></marker-symbol>
      //     <marker-color>#ffffff</marker-color>
      // </extensions>
      for (var index = 0; index < _node.childNodes.length; index++) {
        var element = _node.childNodes[index];
        if (element.nodeType === 1) {
          feature.set(element.nodeName, element.textContent);
        }
      }

      // cas particulier du format GPX :
      // il n'existe pas de surfacique sur ce format, mais il est possible de forcer
      // la transformation en polygone pour des besoins particuliers de visualisation
      _Styling__WEBPACK_IMPORTED_MODULE_3__["default"].APPLY_CONVERT_GEOM_GPX = true;
      var style = _Styling__WEBPACK_IMPORTED_MODULE_3__["default"].defineStyleFromProperties(feature);
      if (style) {
        feature.setStyle(style);
      }
    }

    /**
     * ...
     * @param {*} key ...
     * @returns {Object} json
     * @todo
     */
  }, {
    key: "readRootExtensions",
    value: function readRootExtensions(key) {
      var value = {};
      // Rechercher :
      // <metadata>
      //   <extensions xmlns="http://www.w3.org/1999/xhtml">
      //     <data name="geoportail:compute">{...}</data>
      //   </extensions>
      // </metadata>

      var firstNodeLevelGpx = this.source.childNodes[0]; // gpx
      var searchChildNodesMeta = firstNodeLevelGpx.childNodes; // search metadata
      for (var k = 0; k < searchChildNodesMeta.length; k++) {
        var nodeMeta = searchChildNodesMeta[k];
        if (nodeMeta.nodeName === "metadata") {
          var searchChildNodesExt = nodeMeta.childNodes; // search extensions
          for (var i = 0; i < searchChildNodesExt.length; i++) {
            var nodeExt = searchChildNodesExt[i];
            if (nodeExt.nodeName === "extensions") {
              var searchChildNodesData = nodeExt.childNodes; // search data
              for (var j = 0; j < searchChildNodesData.length; j++) {
                var nodeData = searchChildNodesData[j];
                if (nodeData.nodeName === "data") {
                  var name = nodeData.attributes[0];
                  if (name && name.nodeName === "name") {
                    if (name.nodeValue === key) {
                      value = JSON.parse(nodeData.textContent);
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      }
      return value;
    }

    /**
     * ...
     *
     * @param {*} doc - ...
     * @param {*} extensions - ...
     * @param {Boolean} [xml=false] - write tag xml or json
     */
  }, {
    key: "writeRootExtensions_",
    value: function writeRootExtensions_(doc, extensions, xml) {
      // TODO namespace ?
      var metadata = document.createElement("metadata");
      var extensionsRoot = document.createElement("extensions");
      // INFO
      // convert JSON to XML (dom)
      // * type string :
      // { typestring: "string" } -> <typestring>string</typestring>
      //
      // * type object :
      // { typeobject: { typestring1: "string", typestring2: "string" } }
      // -> <typeobject>
      //      <typestring1>string</typestring1>
      //      <typestring2>string</typestring2>
      //    </typeobject>
      //
      // * type array :
      // { typearray : ["item1", "item2"] }
      // -> <typearray type="array" index=2>
      //      <value>item1</value>
      //      <value>item2</value>
      //    </typearray>
      //
      // * type array of array
      // -> <typearray type="array" index=1>
      //      <value type="array" index=2>
      //          <value>1</value>
      //          <value>2</value>
      //      </value>
      //    </typearray>
      //
      // * type array of object
      // -> <typearray type="array" index=2>
      //      <value>
      //          <typestring1>string</typestring1>
      //          <typestring2>string</typestring2>
      //      </value>
      //      <value>
      //          <typestring1>string</typestring1>
      //          <typestring2>string</typestring2>
      //      </value>
      //    </typearray>
      function toDOM(node, json) {
        for (var key in json) {
          if (Object.hasOwnProperty.call(json, key)) {
            var element = json[key] || ""; // au cas où...
            var tag = document.createElement(key);
            // eslint-disable-next-line valid-typeof
            if (typeof element === "string" || typeof element === "number") {
              tag.innerHTML = element;
              node.appendChild(tag);
            } else if (element instanceof Array) {
              tag.setAttribute("type", "array");
              tag.setAttribute("index", element.length);
              for (var index = 0; index < element.length; index++) {
                var item = element[index] || ""; // au cas où...
                var n = document.createElement("value");
                if (typeof item === "string" || typeof item === "number") {
                  n.innerHTML = item;
                  tag.appendChild(n);
                } else if (item instanceof Array) {
                  n.setAttribute("type", "array");
                  n.setAttribute("index", item.length);
                  for (var i = 0; i < item.length; i++) {
                    var value = item[i] || ""; // au cas où...
                    var k = document.createElement("value");
                    if (typeof value === "string" || typeof value === "number") {
                      k.innerHTML = value;
                      n.appendChild(k);
                    }
                  }
                  tag.appendChild(n);
                } else if (item instanceof Object) {
                  tag.appendChild(toDOM(n, item));
                } else {
                  // "Unknown element !"
                }
              }
              node.appendChild(tag);
            } else if (element instanceof Object) {
              node.appendChild(toDOM(tag, element));
            } else {
              // "Unknown element !"
            }
          }
        }
        return node;
      }
      if (xml) {
        // structure xml
        toDOM(extensionsRoot, extensions);
      } else {
        // structure json par defaut
        // ex.
        // <metadata>
        //   <extensions xmlns="http://www.w3.org/1999/xhtml">
        //     <data name="geoportail:compute">{...}</data>
        //   </extensions>
        // </metadata>
        for (var key in extensions) {
          if (Object.hasOwnProperty.call(extensions, key)) {
            var value = extensions[key];
            var dataElement = document.createElement("data");
            dataElement.setAttribute("name", key);
            var data = document.createTextNode(JSON.stringify(value));
            dataElement.appendChild(data);
            extensionsRoot.appendChild(dataElement);
          }
        }
      }
      metadata.appendChild(extensionsRoot);
      // insertion en 1ere place !
      var firstChild = doc.firstChild;
      doc.insertBefore(metadata, firstChild);
    }

    /**
     * ...
     *
     * @param {Object} feature - ...
     * @param {DOMElement} node - ...
     * @private
     */
  }, {
    key: "writeExtensions_",
    value: function writeExtensions_(feature, node) {
      // creation du DOM
      var extensionsNode = document.createElementNS(node.parentNode.namespaceURI, "extensions");
      _Styling__WEBPACK_IMPORTED_MODULE_3__["default"].getListTags().forEach(function (key) {
        if (feature.get(key)) {
          var extension = document.createElementNS(node.parentNode.namespaceURI, key);
          extension.innerHTML = feature.get(key);
          extensionsNode.appendChild(extension);
        }
      });
      node.appendChild(extensionsNode);
    }

    /**
     * ...
     *
     * @param {DOMElement} doc - ...
     * @param {Object} features - ...
     * @param {Object} actions - ...
     * @private
     */
  }, {
    key: "processExtensions_",
    value: function processExtensions_(doc, features, actions) {
      // INFO
      // OpenLayers ne gère pas tous les tags du format GPX : ex. metadata
      // Liste des tags :
      // * wpt
      // * rte
      // * trk
      // On peut y placer nos balises extensions.

      var index = -1;
      var nodes = doc.childNodes;
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        switch (node.nodeName) {
          case "wpt":
          case "rte":
          case "trk":
            index++;
            var feature = features[index];
            var style = feature.getStyle();
            if (style) {
              var fct = actions.extensions;
              if (fct && typeof fct === "function") {
                fct(feature, node);
              }
            }
            break;
          case "metadata":
            break;
          default:
            // on ne devrait jamais passer à ce niveau !?
            // eslint-disable-next-line no-console
            console.warn("nodename unknown :", node.nodeName);
            break;
        }
      }
    }
  }]);
}((ol_format_GPX__WEBPACK_IMPORTED_MODULE_0___default()));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GPX);

// Expose GPX as ol.source.GPXExtended. (for a build bundle)
if (window.ol && window.ol.format) {
  window.ol.format.GPXExtended = GPX;
}

/***/ }),

/***/ "./src/packages/Formats/GeoJSON.js":
/*!*****************************************!*\
  !*** ./src/packages/Formats/GeoJSON.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ol/format/GeoJSON */ "ol/format/GeoJSON");
/* harmony import */ var ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Styling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Styling */ "./src/packages/Formats/Styling.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
// import openlayers

// import local


/**
 * @classdesc
 *
 * Extended Styles GeoJSON format to export (internal use only !)
 *
 * SPEC
 * cf. https://github.com/mapbox/simplestyle-spec/
 * cf. https://geojson.org/
 *
 *
 * @constructor
 * @alias ol.format.GeoJSONExtended
 * @extends {ol.format.GeoJSON}
 * @type {ol.format.GeoJSONExtended}
 * @param {Object} options - Options
 * @param {Object} [options.defaultStyle] - Styles by default
 * @param {Object} [options.extensions] - Add properties to file root
 */
var GeoJSON = /*#__PURE__*/function (_olGeoJSON) {
  /**
   * See {@link ol.format.GeoJSONExtended}
   * @module GeoJSONExtended
   * @alias module:~formats/GeoJSONExtended
   * @param {*} options - options
   * @example
   * import GeoJSONExtended from "gpf-ext-ol/formats/GeoJSONExtended"
   * ou 
   * import { GeoJSONExtended } from "gpf-ext-ol"
   */
  function GeoJSON(options) {
    var _this;
    _classCallCheck(this, GeoJSON);
    _this = _callSuper(this, GeoJSON, [options]);
    if (!(_this instanceof GeoJSON)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    _this.options = options || {};

    // INFO
    // defaultStyle est un objet de type Style
    if (_this.options.defaultStyle === null || typeof _this.options.defaultStyle === "undefined") {
      _this.options.defaultStyle = {};
    }
    _this.source = null;
    return _possibleConstructorReturn(_this, _this);
  }

  /**
   * Read Extend Styles for Features.
   * This function overloads ol.format.GeoJSON.readFeatures ...
   *
   * @see ol.format.GeoJSON.prototype.readFeatures
   * @param {Object|String} source - Source.
   * @param {olx.format.ReadOptions} [options] - Options.
   * @return {Array.<ol.Feature>} Features.
   */
  _inherits(GeoJSON, _olGeoJSON);
  return _createClass(GeoJSON, [{
    key: "readFeatures",
    value: function readFeatures(source, options) {
      var _this2 = this;
      var features = _get(_getPrototypeOf(GeoJSON.prototype), "readFeatures", this).call(this, source, options);

      // String ou Object
      if (typeof source === "string") {
        this.source = JSON.parse(source);
      } else if (source !== null) {
        this.source = source;
      }
      features.forEach(function (feature) {
        var featureStyleFunction = feature.getStyleFunction();
        // existe t il déjà une fonction de style ?
        // si oui, on l'applique !
        if (featureStyleFunction) {
          var styles = featureStyleFunction.call(_this2, feature, 0);
          if (styles && styles.length !== 0) {
            feature.setStyle(styles[0]);
          }
        } else {
          // à ce niveau, il n'existe pas de styles, donc :
          // soit, on applique les styles par defaut
          // soit, on prend en compte les styles definis dans les properties / tag du fichier
          // les styles définis ecrasent les styles par defaut...
          var style = _Styling__WEBPACK_IMPORTED_MODULE_1__["default"].defineStyleFromProperties(feature);
          if (style) {
            feature.setStyle(style);
          } else {
            // si aucun style disponible, on utilisera le style par defaut defini
            // par l'utilisateur ou l'application
            var styleFunction = _Styling__WEBPACK_IMPORTED_MODULE_1__["default"].defineStyleFunctionByDefault(_this2.options.defaultStyle);
            if (styleFunction) {
              feature.setStyle(styleFunction);
              _Styling__WEBPACK_IMPORTED_MODULE_1__["default"].definePropertiesFromStyle(feature);
            }
          }
        }
      });
      return features;
    }

    /**
     * Write Extend Styles for Features.
     * This function overloads ol.format.GeoJSON.writeFeatures ...
     *
     * @see ol.format.GeoJSON.prototype.writeFeatures
     * @param {Array.<ol.Feature>} features - Features.
     * @param {Object} [options] - Options.
     *
     * @return {String} Result.
     */
  }, {
    key: "writeFeatures",
    value: function writeFeatures(features, options) {
      // on met à jour les properties de styles
      features.forEach(function (feature) {
        _Styling__WEBPACK_IMPORTED_MODULE_1__["default"].definePropertiesFromStyle(feature);
      });
      var geoJSONObject = this.writeFeaturesObject(features, options);

      // ajout des properties à la racine du fichier
      // ex. options : {
      //   extensions : { /* liste des objets à ajouter */ }
      // }
      if (this.options.hasOwnProperty("extensions")) {
        Object.assign(geoJSONObject, this.options.extensions);
      }
      return JSON.stringify(geoJSONObject);
    }

    /**
     * ...
     * @param {*} key ...
     * @returns {Object} json
     */
  }, {
    key: "readRootExtensions",
    value: function readRootExtensions(key) {
      return this.source[key];
    }
  }]);
}((ol_format_GeoJSON__WEBPACK_IMPORTED_MODULE_0___default()));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeoJSON);

// Expose GeoJSON as ol.source.GeoJSONExtended. (for a build bundle)
if (window.ol && window.ol.format) {
  window.ol.format.GeoJSONExtended = GeoJSON;
}

/***/ }),

/***/ "./src/packages/Formats/KML.js":
/*!*************************************!*\
  !*** ./src/packages/Formats/KML.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var ol_format_KML__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ol/format/KML */ "ol/format/KML");
/* harmony import */ var ol_format_KML__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ol_format_KML__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ol/style */ "ol/style");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ol_style__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Styling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Styling */ "./src/packages/Formats/Styling.js");
/* harmony import */ var _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Utils/ColorUtils */ "./src/packages/Utils/ColorUtils.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_Parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Utils/Parser */ "./src/packages/Utils/Parser.js");
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Utils/Helper */ "./src/packages/Utils/Helper.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
// import openlayers


// import local





var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_4__["default"].getLogger("extended KML format");

/**
 * @classdesc
 *
 * Extended Styles KML format to export (internal use only !)
 *
 * INFO
 * only ol.Control is a user-extendable class.
 * Everything else requires integration with the original openlayers source and a new ol.js
 * to be built with your new classes incorporated.
 *
 * SPEC
 * cf. https://developers.google.com/kml/forum/advanced
 *
 * ISSUES
 * cf. https://github.com/openlayers/openlayers/issues/4829
 * cf. https://github.com/openlayers/openlayers/issues/4460
 * cf. https://github.com/openlayers/openlayers/pull/5590
 * cf. https://github.com/openlayers/openlayers/issues/5229
 * cf. https://github.com/openlayers/openlayers/issues/3371
 *
 * @constructor
 * @alias ol.format.KMLExtended
 * @type {ol.format.KMLExtended}
 * @extends {ol.format.KML}
 * @param {Object} options - Options
 * @param {Object} [options.extensions] - Add properties to file root
 */
var KML = /*#__PURE__*/function (_olKML) {
  /**
   * See {@link ol.format.KMLExtended}
   * @module KMLExtended
   * @alias module:~formats/KMLExtended
   * @param {*} options - options
   * @example
   * import KMLExtended from "gpf-ext-ol/formats/KMLExtended"
   * ou 
   * import { KMLExtended } from "gpf-ext-ol"
   */
  function KML(options) {
    var _this;
    _classCallCheck(this, KML);
    _this = _callSuper(this, KML, [options]);
    if (!(_this instanceof KML)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    options = options || {};

    // INFO
    // source DOM (Document ou Node)
    _this.source = null;

    // INFO
    // gestion des extensions
    _this.extensions = options.extensions || null;

    // INFO
    // defaultStyle est un tableau d'objet de type Style
    if (options.defaultStyle && !Array.isArray(options.defaultStyle)) {
      options.defaultStyle = [options.defaultStyle];
    }
    if (options.defaultStyle === null || typeof options.defaultStyle === "undefined") {
      options.defaultStyle = [];
    }
    return _possibleConstructorReturn(_this, _this);
  }

  /**
   *
   * En lecture, on surcharge la méthode readFeatures.
   * ✔️ In : kml string + features du format original
   * ✔️ Out : features étendus avec des styles, et des metadatas (name ou extendData)
   * > on modifie les features du format original avec les fonctionnalités non gérées.
   *
   * En écriture, on surcharge la méthode writeFearures.
   * ✔️ In : kml du format original + features étendus
   * ✔️ Out : kml étendu avec des styles, et des metadatas (name ou extendData)
   * > on modifie le kml généré par le format original avec les fonctionnalités que nous avons ajoutées aux features.
   *
   * Le principe
   * On parse le kml, et on lit (get) ou on ajoute (set) des fonctionnalités.
   *
   * Les getters vont lire le kml (ex. LabelExtendStyle), et ajouter le style ainsi que le nom du label dans le feature original.
   * getLabelIconStyle (appel des 2 fonctions suivantes)
   * getLabelExtendStyle (New)
   * getHotSpotIconStyle (Bug sur la lecture du  hotspot)
   * getExtendData (New)
   *
   * Les setters vont écrire dans le dom du kml original les fonctionnalités ajoutées dans les features.
   * setLabelExtendStyle (New)
   * setHotSpotIconStyle (Bug sur l'écriture du hotspot)
   * setNameData (Bug suppression de cette balise du format par défaut).
   *
   */

  /**
   * Fonction de lecture du KML avec fonction de traitement en fonction du type
   * PlaceMark (Label ou Marker).
   * Les traitements sont de 2 types :
   *  - creation de styles étendus ou correctifs sur le KML
   *  - ajout de styles étendus sur les features
   *
   * @param {DOMElement} kmlNode - kml nodes
   * @param {Object[]} features - features
   * @param {Object} process - process
   *
   * @example
   * // ajoute des fonctionnalités dans le KML
   * _processKml(kmlDoc, {
   *   labelStyle : createStyleLabel,
   *   iconStyle  : createStyleIcon
   * });
   *
   * // lit des fonctionnalités du KML non impl. par OpenLayers
   * _processKml(kmlNode, {
   *   labelStyle : getStyleToFeatureLabel,
   *   iconStyle  : getStyleToFeatureIcon,
   *   extendedData : getExtendedData
   * });
   */
  _inherits(KML, _olKML);
  return _createClass(KML, [{
    key: "_processKml",
    value: function _processKml(kmlNode, features, process) {
      var firstNodeLevel = kmlNode.nodeName === "#document" ? kmlNode.childNodes[0].childNodes : kmlNode.childNodes;

      // Si le DOM contient un seul objet, le noeud est directement un PlaceMark
      // sinon, c'est un ensemble de noeuds PlaceMark contenus dans le noeud Document.
      var nodes = firstNodeLevel;
      for (var ik = 0; ik < firstNodeLevel.length; ik++) {
        var element = firstNodeLevel[ik];
        if (element.nodeName === "Document") {
          nodes = element.childNodes;
          break;
        }
        if (element.nodeName === "Placemark") {
          nodes = [element];
          break;
        }
      }

      // On recherche les PlaceMark de type Point ayant un Style...
      // Le style peut être placé directement dans le PlaceMark
      // ou lié avec un id (share)
      var stylesUrl = {}; // listes des styles
      var index = -1; // index du features...
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        switch (node.nodeName) {
          case "Style":
            // INFO
            // pour le traitement des balises Styles liées avec styleUrl,
            // elles doivent être toujours déclarées avant les PlaceMark !
            // On ne prend en compte que celles qui sont identifiées via un ID !
            var id = node.attributes[0];
            if (id && id.nodeName === "id") {
              var _k = id.nodeValue;
              var _v = node;
              stylesUrl[_k] = _v;
            }
            break;
          case "Placemark":
            index++;
            var types = node.childNodes; // Point, LineString, Polygon, Style, ...
            var point = false;
            var line = false;
            var poly = false;
            var domStyles = null; // dom
            var hdlDomStyle = null; // dom
            var domExtendedData = null; // dom
            var domNameTag = node; // dom
            for (var j = 0; j < types.length; j++) {
              switch (types[j].nodeName) {
                case "Polygon":
                  poly = true;
                  break;
                case "LineString":
                  line = true;
                  break;
                case "Point":
                  point = true;
                  break;
                case "Style":
                  hdlDomStyle = types[j];
                  domStyles = types[j].childNodes; // liste de styles
                  break;
                case "styleUrl":
                  // style avec lien vers...
                  var _idStyle = types[j].textContent.slice(1);
                  if (stylesUrl[_idStyle]) {
                    domStyles = stylesUrl[_idStyle].childNodes;
                  }
                  break;
                case "ExtendedData":
                  domExtendedData = types[j].childNodes;
                  break;
                case "name":
                  domNameTag = null;
                  break;
                default:
                // on ne traite pas les autres informations ...
                // car elles seront gérées par defaut par le format standard...
              }
            }

            // On traite les balises kml:extendedData pour tous les objets !
            if (domExtendedData) {
              logger.log("ExtendedData :", domExtendedData);
              var fctExtend = process.extendedData;
              if (fctExtend && typeof fctExtend === "function") {
                fctExtend(features[index], domExtendedData);
              }
            }

            // On traite la balise kml:name
            if (domNameTag) {
              logger.log("Name :", domNameTag);
              var fctName = process.nameData;
              if (fctName && typeof fctName === "function") {
                fctName(features[index], domNameTag);
              }
            }

            // On a un Marker avec un Style.
            // Il peut être associé avec un Label !
            // Les markers sans styles ne doivent pas être gérées par les styles par defaut
            // car le KML met en place une punaise google !
            if (point && domStyles && domStyles.length !== 0) {
              var labelStyleDom = null;
              var iconStyleDom = null;
              // On recherche le type de Style
              for (var k = 0; k < domStyles.length; k++) {
                switch (domStyles[k].nodeName) {
                  case "LabelStyle":
                    labelStyleDom = domStyles[k];
                    break;
                  case "IconStyle":
                    iconStyleDom = domStyles[k];
                    break;
                  default:
                  // on ne traite pas les autres informations ...
                }
              }

              // Pour un label, il nous faut un titre !
              var labelName = features[index].getProperties().name;
              var labelDescription = features[index].getProperties().description;
              var value = labelName || labelDescription;
              logger.trace(value);

              // C'est uniquement un Label !
              if (!iconStyleDom && labelStyleDom) {
                var fctLabel = process.labelStyle;
                if (fctLabel && typeof fctLabel === "function") {
                  fctLabel(features[index], labelStyleDom);
                }
                // C'est uniquement un marker !
              } else if (iconStyleDom && !labelStyleDom) {
                var fctIcon = process.iconStyle;
                if (fctIcon && typeof fctIcon === "function") {
                  fctIcon(features[index], iconStyleDom);
                }
                // C'est un marker avec un label !
              } else if (iconStyleDom && labelStyleDom) {
                var fctIconLabel = process.iconLabelStyle;
                if (fctIconLabel && typeof fctIconLabel === "function") {
                  fctIconLabel(features[index], iconStyleDom, labelStyleDom);
                }
              } else {
                // ...
              }
            } else {
              var feature = features[index];
              var style = feature.getStyle();
              if (style && typeof style === "function") {
                var fstyles = style.call(this, feature, 0);
                if (fstyles && fstyles.length !== 0) {
                  style = fstyles[0];
                }
              }
              if (poly) {
                var fctPoly = process.polygonStyle;
                if (fctPoly && typeof fctPoly === "function") {
                  fctPoly(features[index], domStyles);
                }
              }
              if (line) {
                var fctLine = process.lineStringStyle;
                if (fctLine && typeof fctLine === "function") {
                  fctLine(features[index], domStyles);
                }
              }

              // INFO
              // On est sur un Point mais sans style dans le DOM.
              // On regarde le style dans le Feature : Icon ou Circle ?
              if (point && style) {
                var image = style.getImage();
                if (image && image instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__.Circle) {
                  var fctCircle = process.circleStyle;
                  if (fctCircle && typeof fctCircle === "function") {
                    fctCircle(features[index], hdlDomStyle);
                  }
                } else if (image && image instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__.Icon) {
                  var fctPoint = process.pointStyle;
                  if (fctPoint && typeof fctPoint === "function") {
                    fctPoint(features[index], hdlDomStyle);
                  }
                } else {
                  // ...
                }
              }
            }
            break;
          default:
            logger.trace("tag is not processing !");
        }
      }
    }

    /**
     * Write Extend for Features.
     * This function overloads ol.format.KML.writeFeatures ...
     *
     * @see ol.format.KML.prototype.writeFeatures
     * @param {Object[]} features - Features.
     * @param {Object} options - Options.
     *
     * @return {String} kml string formatted
     */
  }, {
    key: "writeFeatures",
    value: function writeFeatures(features, options) {
      logger.log("overload : ol.format.KML.writeFeatures");
      var kmlNode = _get(_getPrototypeOf(KML.prototype), "writeFeaturesNode", this).call(this, features, options);
      if (kmlNode === null) {
        return null;
      }

      // on ajoute les extensions à la racine pour les metadonnées de calcul
      if (this.hasOwnProperty("extensions")) {
        this._writeRootExtensions(kmlNode, this.extensions);
      }

      // On ajoute les styles étendus
      var kmlStringExtended = this._writeExtendStylesFeatures(kmlNode, features, options);

      // On realise un formattage du KML
      var kmlStringFormatted = _Utils_Parser__WEBPACK_IMPORTED_MODULE_5__["default"].format(kmlStringExtended);
      if (kmlStringFormatted === "") {
        return null;
      }
      return kmlStringFormatted;
    }
  }, {
    key: "_writeExtendStylesFeatures",
    value:
    /**
     * Write Extended Styles for each features
     *
     * @param {DOMElement} kmlNode - kml nodes
     * @param {Object[]} features - features
     * @param {Object} options - options
     *
     * @returns {String} kml string extended
     *
     * @private
     */
    function _writeExtendStylesFeatures(kmlNode, features, options) {
      // RGB Colors (RRGGBB) To KML Colors (AABBGGRR)
      function __convertRGBColorsToKML(data, opacity) {
        var strColor = data.toString(16);
        if (strColor.charAt(0) === "#") {
          strColor = strColor.slice(1);
        }
        opacity = opacity || 1;
        opacity = parseInt(opacity * 255, 10);
        opacity = opacity.toString(16);
        var color = opacity;
        color = color + strColor.substr(4, 2);
        color = color + strColor.substr(2, 2);
        color = color + strColor.substr(0, 2);
        return color.toLowerCase();
      }

      /**
       * C'est un Label !
       * On va donc y ajouter qq styles sur le Label (police, halo, ...) :
       * Insertion : PlaceMark>Style>LabelStyle
       *
       * @param {Object} feature - feature
       * @param {DOMElement} node - node
       *
       * @example
       *      <LabelStyleSimpleExtensionGroup fontFamily="Arial" haloColor="16777215" haloRadius="2" haloOpacity="1"/>
       */
      var __createExtendedStyleLabel = function __createExtendedStyleLabel(feature, node) {
        logger.trace("label with style :", node);
        if (!feature) {
          return;
        }

        // Si pas de style defini, c'est donc que l'on va utiliser celui par defaut...
        if (feature.getStyle() instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__.Style) {
          var textStyle = feature.getStyle().getText();
          if (!textStyle) {
            return;
          }
          var _fontFamily = "Sans";
          var _fontSize = "16px";
          var _font = textStyle.getFont();
          if (_font) {
            var splits = _font.split(" ", 2);
            _fontSize = splits[0];
            _fontFamily = splits[1];
          }
          var strokeTextStyle = feature.getStyle().getText().getStroke();
          if (!strokeTextStyle) {
            return;
          }
          if (strokeTextStyle instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__.Stroke) {
            var _haloColor = __convertRGBColorsToKML("#FFFFFF"); // Par defaut
            var color = strokeTextStyle.getColor();
            // array ?
            if (Array.isArray(color)) {
              var cf = "rgba(";
              cf += color[0] + ",";
              cf += color[1] + ",";
              cf += color[2] + ",";
              cf += color[3] + ")";
              color = cf;
            }
            if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].isRGB(color)) {
              var colorHex = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].rgbaToHex(color);
              _haloColor = __convertRGBColorsToKML(colorHex.hex, colorHex.opacity);
            } else {
              _haloColor = __convertRGBColorsToKML(color);
            }
            var _haloRadius = strokeTextStyle.getWidth() || "0";
            var _haloOpacity = "1"; // TODO lire param

            if (node && node.getElementsByTagName("LabelStyleSimpleExtensionGroup").length === 0) {
              var labelExtended = document.createElementNS(kmlNode.namespaceURI, "LabelStyleSimpleExtensionGroup");
              labelExtended.setAttribute("fontSize", _fontSize);
              labelExtended.setAttribute("fontFamily", _fontFamily);
              labelExtended.setAttribute("haloColor", _haloColor);
              labelExtended.setAttribute("haloRadius", _haloRadius);
              labelExtended.setAttribute("haloOpacity", _haloOpacity);
              node.appendChild(labelExtended);
            }
          }
          var fImageStyle = feature.getStyle().getImage();
          if (!fImageStyle) {
            return;
          }
          if (fImageStyle instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__.Circle) {
            var strokeColor = null;
            var strokeWidth = null;
            if (fImageStyle.getStroke()) {
              strokeWidth = fImageStyle.getStroke().getWidth();
              strokeColor = fImageStyle.getStroke().getColor();
              // array ?
              if (Array.isArray(strokeColor)) {
                var cfs = "rgba(";
                cfs += strokeColor[0] + ",";
                cfs += strokeColor[1] + ",";
                cfs += strokeColor[2] + ",";
                cfs += strokeColor[3] + ")";
                strokeColor = cfs;
              }
              if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].isRGB(strokeColor)) {
                var strokeColorHex = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].rgbaToHex(strokeColor);
                strokeColor = __convertRGBColorsToKML(strokeColorHex.hex, strokeColorHex.opacity);
              } else {
                strokeColor = __convertRGBColorsToKML(strokeColor);
              }
            }
            var fillColor = null;
            if (fImageStyle.getFill()) {
              fillColor = fImageStyle.getFill().getColor();
              // array ?
              if (Array.isArray(fillColor)) {
                var cff = "rgba(";
                cff += fillColor[0] + ",";
                cff += fillColor[1] + ",";
                cff += fillColor[2] + ",";
                cff += fillColor[3] + ")";
                fillColor = cff;
              }
              if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].isRGB(fillColor)) {
                var fillColorHex = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].rgbaToHex(fillColor);
                fillColor = __convertRGBColorsToKML(fillColorHex.hex, fillColorHex.opacity);
              } else {
                fillColor = __convertRGBColorsToKML(fillColor);
              }
            }
            if (node && node.getElementsByTagName("ObjectSimpleExtensionGroup").length === 0) {
              var iconExtended = document.createElementNS(kmlNode.namespaceURI, "ObjectSimpleExtensionGroup");
              iconExtended.setAttribute("type", "circle"); // FIXME type circle only !
              iconExtended.setAttribute("radius", fImageStyle.getRadius());
              iconExtended.setAttribute("fillColor", fillColor);
              iconExtended.setAttribute("strokeColor", strokeColor);
              iconExtended.setAttribute("strokeWidth", strokeWidth);
              node.appendChild(iconExtended);
            }
          }
        }
      };

      /**
       * C'est un marker !
       * On va donc ajouter la balise hotspot :
       *  Traiter le cas où les unités sont de type
       *   - FRACTION
       *   - PIXELS
       *  Insertion du correctif dans le noeud : <PlaceMark><Style>IconStyle
       *
       * @param {Object} feature - ol feature
       * @param {DOMElement} node - node
       *
       *  @example
       *  <Style><IconStyle>
       *      <hotSpot x="0.5"  y="1" xunits="fraction" yunits="fraction"/>
       *  </IconStyle></Style>
       */
      var __createExtendedStyleIcon = function __createExtendedStyleIcon(feature, node) {
        logger.trace("marker with style (hotspot):", node);
        if (!feature) {
          return;
        }

        // Si pas de style defini, c'est donc que l'on va utiliser celui par defaut...
        if (feature.getStyle() instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__.Style) {
          var fImageStyle = feature.getStyle().getImage();
          if (!fImageStyle) {
            return;
          }
          if (fImageStyle instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__.Icon) {
            var x = 0;
            var y = 0;
            var xunits = "pixels";
            var yunits = "pixels";
            var size = fImageStyle.getSize();
            var anchor = fImageStyle.getAnchor(); // pixels ! but anchor_ in the current unit !

            if (anchor.length) {
              x = anchor[0];
              y = anchor[1];
              if (yunits === "fraction") {
                y = y === 1 ? 0 : 1 - y; // cf. fixme contribution à faire !
              } else {
                y = yunits === "pixels" && y === size[1] ? 0 : size[1] - y; // cf. fixme contribution à faire !
              }
            }
            if (node && node.getElementsByTagName("hotSpot").length === 0) {
              var hotspot = document.createElementNS(kmlNode.namespaceURI, "hotSpot");
              hotspot.setAttribute("x", x);
              hotspot.setAttribute("y", y);
              hotspot.setAttribute("xunits", xunits);
              hotspot.setAttribute("yunits", yunits);
              node.appendChild(hotspot);
            }
          }
        }
      };

      /**
       * ...
       * @param {*} feature - feature
       * @param {DOMElement} node - node
       */
      var __createExtendedStyleToCircle = function __createExtendedStyleToCircle(feature, node) {
        if (!feature) {
          return;
        }

        // Si pas de style defini, c'est donc que l'on va utiliser celui par defaut...
        if (feature.getStyle() instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__.Style) {
          var fImageStyle = feature.getStyle().getImage();
          if (!fImageStyle) {
            return;
          }
          if (fImageStyle instanceof ol_style__WEBPACK_IMPORTED_MODULE_1__.Circle) {
            var strokeColor = null;
            var strokeWidth = null;
            if (fImageStyle.getStroke()) {
              strokeWidth = fImageStyle.getStroke().getWidth();
              strokeColor = fImageStyle.getStroke().getColor();
              // array ?
              if (Array.isArray(strokeColor)) {
                var cf = "rgba(";
                cf += strokeColor[0] + ",";
                cf += strokeColor[1] + ",";
                cf += strokeColor[2] + ",";
                cf += strokeColor[3] + ")";
                strokeColor = cf;
              }
              if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].isRGB(strokeColor)) {
                var colorHex = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].rgbaToHex(strokeColor);
                strokeColor = __convertRGBColorsToKML(colorHex.hex, colorHex.opacity);
              } else {
                strokeColor = __convertRGBColorsToKML(strokeColor);
              }
            }
            var fillColor = null;
            if (fImageStyle.getFill()) {
              fillColor = fImageStyle.getFill().getColor();
              // array ?
              if (Array.isArray(fillColor)) {
                var cfi = "rgba(";
                cfi += fillColor[0] + ",";
                cfi += fillColor[1] + ",";
                cfi += fillColor[2] + ",";
                cfi += fillColor[3] + ")";
                fillColor = cfi;
              }
              if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].isRGB(fillColor)) {
                var fillColorImgHex = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].rgbaToHex(fillColor);
                fillColor = __convertRGBColorsToKML(fillColorImgHex.hex, fillColorImgHex.opacity);
              } else {
                fillColor = __convertRGBColorsToKML(fillColor);
              }
            }
            if (node && node.getElementsByTagName("ObjectSimpleExtensionGroup").length === 0) {
              var labelStyle = document.createElementNS(kmlNode.namespaceURI, "LabelStyle");
              var circleExtended = document.createElementNS(kmlNode.namespaceURI, "ObjectSimpleExtensionGroup");
              circleExtended.setAttribute("type", "circle"); // FIXME type circle only !
              circleExtended.setAttribute("radius", fImageStyle.getRadius());
              circleExtended.setAttribute("fillColor", fillColor);
              circleExtended.setAttribute("strokeColor", strokeColor);
              circleExtended.setAttribute("strokeWidth", strokeWidth);
              labelStyle.appendChild(circleExtended);
              node.appendChild(labelStyle);
            }
          }
        }
      };

      /**
       * ...
       * @param {*} feature - feature
       * @param {DOMElement} node - node
       */
      var __createExtendedStyleToPoint = function __createExtendedStyleToPoint(feature, node) {};

      // TODO
      var __createExtendedStyleToIconLabel = function __createExtendedStyleToIconLabel(feature, nodeIconStyle, nodeLabelStyle) {
        logger.trace("write an icon with a label");
        __createExtendedStyleIcon(feature, nodeIconStyle);
        __createExtendedStyleLabel(feature, nodeLabelStyle);
      };

      // TODO
      var __setNameData = function __setNameData(feature, tags) {
        for (var i = 0; i < tags.length; i++) {
          var tag = tags[i];
          if (tag.nodeName === "name") {
            return;
          }
        }
        var labelName = feature.getProperties().name;
        if (labelName) {
          var name = document.createElement("name");
          name.innerHTML = labelName;
          tags.appendChild(name);
        }
      };

      // TODO
      var _setExtendedDataStyle = function _setExtendedDataStyle(feature, node) {
        if (node && node.length) {
          var removeNodes = [];
          for (var k = 0; k < node.length; k++) {
            var element = node[k];
            if (element.nodeName === "Data") {
              var key = element.getAttribute("name");
              if (_Styling__WEBPACK_IMPORTED_MODULE_2__["default"].getListTags().includes(key)) {
                removeNodes.push(element);
              }
            }
          }
          if (removeNodes && removeNodes.length) {
            removeNodes.forEach(function (e) {
              e.remove();
            });
          }
        }
      };

      // On ajoute les styles étendus dans le DOM
      this._processKml(kmlNode, features, {
        labelStyle: __createExtendedStyleLabel,
        iconStyle: __createExtendedStyleIcon,
        iconLabelStyle: __createExtendedStyleToIconLabel,
        circleStyle: __createExtendedStyleToCircle,
        pointStyle: __createExtendedStyleToPoint,
        nameData: __setNameData,
        extendedData: _setExtendedDataStyle
      });

      // On convertit le DOM en String...
      var kmlStringExtended = _Utils_Parser__WEBPACK_IMPORTED_MODULE_5__["default"].toString(kmlNode);
      if (!kmlStringExtended) {
        return null;
      }
      return kmlStringExtended;
    }
  }, {
    key: "_writeRootExtensions",
    value:
    /**
     * ...
     *
     * @param {*} kmlNode - ...
     * @param {*} extensions - ...
     */
    function _writeRootExtensions(kmlNode, extensions) {
      var extendDataElement = document.createElementNS(kmlNode.namespaceURI, "ExtendedData");
      // on boucle sur toutes les clefs
      for (var key in extensions) {
        if (Object.hasOwnProperty.call(extensions, key)) {
          var value = extensions[key];
          var dataElement = document.createElementNS(kmlNode.namespaceURI, "Data");
          dataElement.setAttribute("name", key);
          var data = document.createTextNode(JSON.stringify(value));
          dataElement.appendChild(data);
          extendDataElement.appendChild(dataElement);
        }
      }
      // insertion en 1ere place !
      var firstChild = kmlNode.firstChild;
      kmlNode.insertBefore(extendDataElement, firstChild);
    }

    /**
     * Read Extend for Features.
     * This function overloads ol.format.KML.readFeatures ...
     *
     * @see ol.format.KML.prototype.readFeatures
     * @param {Document|Node} source - Source.
     * @param {olx.format.ReadOptions=} options - options.
     * @return {Array.<ol.Feature>} Features.
     */
  }, {
    key: "readFeatures",
    value: function readFeatures(source, options) {
      logger.log("overload : ol.format.KML.readFeatures");

      // String ou Dom
      if (typeof source === "string") {
        this.source = _Utils_Parser__WEBPACK_IMPORTED_MODULE_5__["default"].parse(source);
      } else if (source !== null) {
        this.source = source;
      }
      var features = this._readExtendStylesFeatures(source, options);
      logger.trace("Styles étendus", features);

      // On met à jour les attributs de style dans les features
      features.forEach(function (feature) {
        _Styling__WEBPACK_IMPORTED_MODULE_2__["default"].definePropertiesFromStyle(feature);
      });
      return features;
    }
  }, {
    key: "_readExtendStylesFeatures",
    value:
    /**
     * Read Extended Styles for each features
     *
     * @param {(Document|Node|ArrayBuffer|Object|String)} source - source
     * @param {olx.format.ReadOptions=} options - options
     *
     * @returns {Object[]} features
     *
     * @private
     */
    function _readExtendStylesFeatures(source, options) {
      var features = _get(_getPrototypeOf(KML.prototype), "readFeatures", this).call(this, source, options);
      var kmlDoc = null;
      var kmlString = "";
      if (typeof source === "string") {
        kmlString = source;
      } else {
        kmlString = source.documentElement.outerHTML;
      }

      // On 'deformatte' le KML afin d'eviter des pb de parsing...
      kmlString = kmlString.replace(/\n/g, "");
      kmlString = kmlString.replace(/(>)\s*(<)/g, "$1$2");

      // On met en place un Parser sur le KML
      kmlDoc = _Utils_Parser__WEBPACK_IMPORTED_MODULE_5__["default"].parse(kmlString);
      if (kmlDoc === null) {
        // au cas où...
        return features;
      }

      // KML Colors (AABBGGRR) To RGB Colors (RRGGBB)
      function __convertKMLColorsToRGB(data) {
        var color = "";
        color = color + data.substr(6, 2);
        color = color + data.substr(4, 2);
        color = color + data.substr(2, 2);
        var hex = parseInt(color, 16).toString(16);
        var comp = "";
        var len = hex.length || 0;
        for (var i = 0; i < 6 - len; i++) {
          comp += "0";
        }
        hex = "#" + comp + hex;
        return hex;
      }

      /**
       * Gestion des styles étendus sur le Label
       *
       * @param {Object} feature - ol feature
       * @param {DOMElement} node - node
       *
       * @example
       * <Placemark>
       *  <description>Un label</description>
       *  <name>C'est un label étendu !</name>
       *  <Style>
       *    <IconStyle>
       *      <Icon>
       *        <href>data:image/png;base64,...</href>
       *      </Icon>
       *    </IconStyle>
       *    <LabelStyle>
       *      <color>ffffffff</color>
       *      <colorMode>normal</colorMode>
       *      <scale>1.85</scale>
       *      <LabelStyleSimpleExtensionGroup haloColor="16711680" haloRadius="5" haloOpacity="1"/>
       *    </LabelStyle>
       *  </Style>
       *  <Point>
       *    <coordinates>2,48</coordinates>
       *  </Point>
       * </Placemark>
       */
      var __getExtendedStyleToFeatureLabel = function __getExtendedStyleToFeatureLabel(feature, node) {
        logger.trace("label with style :", node);
        if (!feature) {
          return;
        }

        // label
        var _text = feature.getProperties().name;
        var _color = __convertKMLColorsToRGB("ff000000"); // "#000000"
        var _colorHalo = "#FFFFFF";
        var _radiusHalo = 0;
        // var _opacityHalo = 1; // TODO
        var _font = "Sans";
        var _fontSize = "16px";

        // cercle
        var _circleType = null;
        var _circleRadius = 5;
        var _circleFillColor = "#000000";
        var _circleStrokeColor = "#ffffff";
        var _circleStrokeWidth = 1;

        // On recherche les balises du Style
        var bLabelStyleSimpleExtensionGroup = false;
        var bObjectSimpleExtensionGroup = false;
        var nodeStyles = node.childNodes;
        for (var k = 0; k < nodeStyles.length; k++) {
          switch (nodeStyles[k].nodeName) {
            case "scale":
              // TODO
              break;
            case "colorMode":
              // TODO
              break;
            case "color":
              _color = __convertKMLColorsToRGB(nodeStyles[k].textContent);
              break;
            case "LabelStyleSimpleExtensionGroup":
              bLabelStyleSimpleExtensionGroup = true;
              var attributs = nodeStyles[k].attributes;
              for (var l = 0; l < attributs.length; l++) {
                switch (attributs[l].nodeName) {
                  case "fontFamily":
                    _font = attributs[l].nodeValue;
                    break;
                  case "fontSize":
                    _fontSize = attributs[l].nodeValue;
                    break;
                  case "haloColor":
                    _colorHalo = __convertKMLColorsToRGB(attributs[l].nodeValue);
                    break;
                  case "haloRadius":
                    _radiusHalo = parseInt(attributs[l].nodeValue, 10);
                    break;
                  case "haloOpacity":
                    // _opacityHalo = parseFloat(attributs[l].nodeValue);
                    // TODO opacité !
                    // if (_opacityHalo !== 1) {
                    //     _colorHalo = Color.hexToRgba(_colorHalo, _opacityHalo);
                    // }
                    break;
                  default:
                }
              }
              break;
            case "ObjectSimpleExtensionGroup":
              bObjectSimpleExtensionGroup = true;
              var attributsExt = nodeStyles[k].attributes;
              for (var ll = 0; ll < attributsExt.length; ll++) {
                // type="circle" radius="15" fillColor="7f3737a0" strokeColor="cc000000" strokeWidth="2"
                switch (attributsExt[ll].nodeName) {
                  case "type":
                    _circleType = attributsExt[ll].nodeValue;
                    break;
                  case "radius":
                    _circleRadius = parseInt(attributsExt[ll].nodeValue, 10);
                    break;
                  case "fillColor":
                    var fillColorValue = attributsExt[ll].nodeValue;
                    var fillOpacity = Math.round(_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].num(fillColorValue.substr(0, 2)) / 255 * 10) / 10;
                    var fillColorHexa = __convertKMLColorsToRGB(fillColorValue);
                    _circleFillColor = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].hexToRgba(fillColorHexa, fillOpacity);
                    break;
                  case "strokeColor":
                    var strokeColorValue = attributsExt[ll].nodeValue;
                    var strokeOpacity = Math.round(_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].num(strokeColorValue.substr(0, 2)) / 255 * 10) / 10;
                    var strokeColorHexa = __convertKMLColorsToRGB(strokeColorValue);
                    _circleStrokeColor = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_3__["default"].hexToRgba(strokeColorHexa, strokeOpacity);
                    break;
                  case "strokeWidth":
                    _circleStrokeWidth = parseInt(attributsExt[ll].nodeValue, 10);
                    break;
                  default:
                }
              }
              break;
            default:
            // on ne traite pas les autres informations ...
          }
        }
        var StyleInstance = null;
        if (bObjectSimpleExtensionGroup && _circleType === "circle") {
          StyleInstance = new ol_style__WEBPACK_IMPORTED_MODULE_1__.Circle({
            radius: _circleRadius,
            fill: new ol_style__WEBPACK_IMPORTED_MODULE_1__.Fill({
              color: _circleFillColor
            }),
            stroke: new ol_style__WEBPACK_IMPORTED_MODULE_1__.Stroke({
              color: _circleStrokeColor,
              width: _circleStrokeWidth
            })
          });
        } else if (bLabelStyleSimpleExtensionGroup) {
          // INFO
          // on ajoute une image magique 1x1 pixel invisible
          // afin d'eviter l'affichage d'une punaise google !
          StyleInstance = new ol_style__WEBPACK_IMPORTED_MODULE_1__.Icon({
            src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNiYAAAAAkAAxkR2eQAAAAASUVORK5CYII=",
            size: [51, 38],
            anchor: [25.5, 38],
            anchorOrigin: "top-left",
            anchorXUnits: "pixels",
            anchorYUnits: "pixels"
          });
        } else {
          // ...
        }
        // On reconstruit le style !
        feature.setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_1__.Style({
          image: StyleInstance,
          text: new ol_style__WEBPACK_IMPORTED_MODULE_1__.Text({
            font: _fontSize + " " + _font,
            textAlign: "left",
            text: _text,
            // offsetX : 5, // FIXME valeur arbitraire MAIS esthétique !
            fill: new ol_style__WEBPACK_IMPORTED_MODULE_1__.Fill({
              color: _color
            }),
            stroke: new ol_style__WEBPACK_IMPORTED_MODULE_1__.Stroke({
              color: _colorHalo,
              width: _radiusHalo
            })
          })
        }));
      };

      /**
       * Gestion des styles étendus sur un Marker
       *
       * > correctif sur la balise kml:hostSpot
       * - problème avec 'hotspot y === 0' (?)
       *
       * @param {Object} feature - ol feature
       * @param {DOMElement} node - node
       *
       * @example
       * <Placemark>
       *   <Style>
       *     <IconStyle>
       *       <Icon>
       *         <href>data:image/png;base64,...</href>
       *       </Icon>
       *       <hotSpot x="25.5" y="0" xunits="pixels" yunits="pixels"/>
       *     </IconStyle>
       *   </Style>
       *   <Point>
       *     <coordinates>2,48</coordinates>
       *   </Point>
       * </Placemark>
       */
      var __getExtendedStyleToFeatureIcon = function __getExtendedStyleToFeatureIcon(feature, node) {
        logger.trace("hotspot :", node);

        // marker
        var _src = null;
        var _scale = null;
        var _color = __convertKMLColorsToRGB("ffffffff");
        var _bSizeIcon = false;
        var _sizeW = 51;
        var _sizeH = 38;
        var _bHotSpot = false;
        var _anchorX = 25.5;
        var _anchorXUnits = "pixels";
        var _anchorY = 38;
        var _anchorYUnits = "pixels";
        var nodeStyles = node.childNodes;
        var bIconStyle = false;
        for (var k = 0; k < nodeStyles.length; k++) {
          switch (nodeStyles[k].nodeName) {
            case "Icon":
              bIconStyle = true;
              var nodes = nodeStyles[k].childNodes;
              for (var i = 0; i < nodes.length; i++) {
                switch (nodes[i].nodeName) {
                  case "href":
                    _src = nodes[i].textContent;
                    break;
                  case "gx:w":
                    _bSizeIcon = true;
                    _sizeW = parseFloat(nodes[i].textContent);
                    break;
                  case "gx:h":
                    _bSizeIcon = true;
                    _sizeH = parseFloat(nodes[i].textContent);
                    break;
                  default:
                }
              }
              break;
            case "hotSpot":
              _bHotSpot = true;
              var attributs = nodeStyles[k].attributes;
              for (var l = 0; l < attributs.length; l++) {
                switch (attributs[l].nodeName) {
                  case "x":
                    _anchorX = parseFloat(attributs[l].nodeValue);
                    break;
                  case "y":
                    _anchorY = parseFloat(attributs[l].nodeValue);
                    break;
                  case "yunits":
                    _anchorXUnits = attributs[l].nodeValue;
                    break;
                  case "xunits":
                    _anchorYUnits = attributs[l].nodeValue;
                    break;
                  default:
                }
              }
              break;
            case "scale":
              _scale = parseFloat(nodeStyles[k].textContent);
              break;
            case "color":
              _color = __convertKMLColorsToRGB(nodeStyles[k].textContent);
              break;
            default:
            // on ne traite pas les autres informations ...
          }
        }
        var StyleInstance = null;
        if (bIconStyle) {
          // une image magique 1x1 pixel invisible
          var optionsIcon = {
            src: _src || "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNiYAAAAAkAAxkR2eQAAAAASUVORK5CYII=",
            color: _color,
            crossOrigin: "anonymous",
            // cf. https://gis.stackexchange.com/questions/121555/wms-server-with-cors-enabled/147403#147403
            scale: _scale || 1
          };
          if (_bSizeIcon) {
            _Utils_Helper__WEBPACK_IMPORTED_MODULE_6__["default"].mergeParams(optionsIcon, {
              size: [_sizeW, _sizeH]
            });
          }
          if (_bHotSpot) {
            _Utils_Helper__WEBPACK_IMPORTED_MODULE_6__["default"].mergeParams(optionsIcon, {
              anchor: [_anchorX, _anchorY],
              anchorOrigin: "bottom-left",
              anchorXUnits: _anchorXUnits || "pixels",
              anchorYUnits: _anchorYUnits || "pixels"
            });
          }
          StyleInstance = new ol_style__WEBPACK_IMPORTED_MODULE_1__.Icon(optionsIcon);
        }

        // existe il déjà le style du label ?
        var featureStyleFunction = feature.getStyleFunction();
        if (featureStyleFunction) {
          var _styles = featureStyleFunction(feature, 0);
          if (_styles && !Array.isArray(_styles)) {
            _styles = [_styles];
          }
          if (_styles && _styles.length !== 0) {
            var _style = _styles.length === 1 ? _styles[0] : _styles[_styles.length - 1];
            // on écrase l'icone magic du label !
            feature.setStyle(new ol_style__WEBPACK_IMPORTED_MODULE_1__.Style({
              image: StyleInstance,
              text: _style.getText()
            }));
          }
        }
      };

      /**
       * Gestion de la balise kml:ExtendedData
       *
       * @param {Object} feature - ol feature
       * @param {DOMElement[]} extend - extend
       *
       * @example
       * //--> Marker (Point), LineString, Polygon
       * <ExtendedData>
       *    <Data name="attributetitle">
       *        <displayName>title</displayName>
       *        <value>Titre à concatener avec la valeur de la balise "kml:description"</value>
       *    </Data>
       * </ExtendedData>
       * //--> Label
       * <ExtendedData>
       *    <Data name="label">
       *        <value>PARIS</value> // valeur à remplacer dans "kml:name"
       *    </Data>
       *    <Data name="attributetitle">
       *        <displayName>title</displayName>
       *        <value>Titre à concatener avec la valeur de la balise "kml:description"</value>
       *    </Data>
       * </ExtendedData>
       */
      var __getExtendedData = function __getExtendedData(feature, extend) {
        logger.trace("extendData :", extend);
        if (!feature) {
          return;
        }
        var props = {};
        var _fname = feature.get("name") || "";
        var _fdescription = feature.get("description") || "";
        var _ftitle = null;
        for (var i = 0; i < extend.length; i++) {
          var data = extend[i];
          var name = data.attributes[0]; // 1 seul attribut !
          var nodes = data.childNodes;
          if (name.nodeName === "name") {
            switch (name.nodeValue) {
              // compatibilité ancien geoportail !
              case "label":
                _fname = data.textContent;
                props.name = _fname;
                break;
              // compatibilité ancien geoportail !
              case "title":
              case "attributetitle":
                for (var j = 0; j < nodes.length; j++) {
                  if (nodes[j].nodeName === "value") {
                    _ftitle = nodes[j].textContent;
                  }
                }
                break;
              default:
                props[name.nodeValue] = data.textContent;
                break;
            }
          }
        }

        // Modification des properties "name" et "description"
        if (_ftitle) {
          _fdescription = _fdescription ? _ftitle + " : " + _fdescription : _ftitle;
          props.description = _fdescription;
        }
        if (Object.keys(props).length) {
          feature.setProperties(props, true);
        }
      };

      /**
       * TODO
       * ...
       *
       * @param {Object} feature - ol feature
       * @param {DOMElement} nodeIconStyle - icon style
       * @param {DOMElement} nodeLabelStyle - label style
       * @example
       * ...
       */
      var __getExtendedStyleToFeatureIconLabel = function __getExtendedStyleToFeatureIconLabel(feature, nodeIconStyle, nodeLabelStyle) {
        logger.trace("display icon and label");
        __getExtendedStyleToFeatureLabel(feature, nodeLabelStyle);
        __getExtendedStyleToFeatureIcon(feature, nodeIconStyle);
      };

      // TODO...
      var __getStyleToDefaultFeature = function __getStyleToDefaultFeature(feature, node) {};

      // On lit les styles étendus et on les ajoute aux features
      this._processKml(kmlDoc, features, {
        lineStringStyle: __getStyleToDefaultFeature,
        polygonStyle: __getStyleToDefaultFeature,
        pointStyle: __getStyleToDefaultFeature,
        labelStyle: this.showPointNames_ ? __getExtendedStyleToFeatureLabel : null,
        iconStyle: __getExtendedStyleToFeatureIcon,
        iconLabelStyle: this.showPointNames_ ? __getExtendedStyleToFeatureIconLabel : __getExtendedStyleToFeatureIcon,
        extendedData: __getExtendedData
      });
      return features;
    }
  }, {
    key: "readRootExtensions",
    value:
    /**
     * ...
     * @param {*} key ...
     * @returns {Object} json
     */
    function readRootExtensions(key) {
      var value = {};
      // Rechercher le tag avec la clef : geoportail:compute
      // <ExtendedData>
      //   <Data name="geoportail:compute">{...}</Data>
      // </ExtendedData>
      var firstNodeLevelKml = this.source.nodeName === "#document" ? this.source.childNodes[0] : this.source;
      var childNodesLevel = firstNodeLevelKml.childNodes;
      for (var i = 0; i < childNodesLevel.length; i++) {
        var node1 = childNodesLevel[i];
        if (node1.nodeName === "ExtendedData") {
          var childNodesExtended = node1.childNodes;
          for (var j = 0; j < childNodesExtended.length; j++) {
            var node2 = childNodesExtended[j];
            if (node2.nodeName === "Data") {
              var name = node2.attributes[0];
              if (name && name.nodeName === "name") {
                if (name.nodeValue === key) {
                  value = JSON.parse(node2.textContent);
                  break;
                }
              }
            }
          }
        }
      }
      return value;
    }
  }]);
}((ol_format_KML__WEBPACK_IMPORTED_MODULE_0___default()));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KML);

// Expose KML as ol.source.KMLExtended. (for a build bundle)
if (window.ol && window.ol.format) {
  window.ol.format.KMLExtended = KML;
}

/***/ }),

/***/ "./src/packages/Formats/Styling.js":
/*!*****************************************!*\
  !*** ./src/packages/Formats/Styling.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/ColorUtils */ "./src/packages/Utils/ColorUtils.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
/* harmony import */ var _Controls_Utils_Markers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Controls/Utils/Markers */ "./src/packages/Controls/Utils/Markers.js");
/* harmony import */ var ol_Feature__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ol/Feature */ "ol/Feature");
/* harmony import */ var ol_Feature__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_Feature__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_style_Style__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ol/style/Style */ "ol/style/Style");
/* harmony import */ var ol_style_Style__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_style_Style__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ol_style_Circle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ol/style/Circle */ "ol/style/Circle");
/* harmony import */ var ol_style_Circle__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ol_style_Circle__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var ol_style_Icon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ol/style/Icon */ "ol/style/Icon");
/* harmony import */ var ol_style_Icon__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ol_style_Icon__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var ol_style_Fill__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ol/style/Fill */ "ol/style/Fill");
/* harmony import */ var ol_style_Fill__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(ol_style_Fill__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var ol_style_Stroke__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ol/style/Stroke */ "ol/style/Stroke");
/* harmony import */ var ol_style_Stroke__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(ol_style_Stroke__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var ol_style_Text__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ol/style/Text */ "ol/style/Text");
/* harmony import */ var ol_style_Text__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(ol_style_Text__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var ol_geom_Polygon__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ol/geom/Polygon */ "ol/geom/Polygon");
/* harmony import */ var ol_geom_Polygon__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(ol_geom_Polygon__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var ol_geom_MultiPolygon__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ol/geom/MultiPolygon */ "ol/geom/MultiPolygon");
/* harmony import */ var ol_geom_MultiPolygon__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(ol_geom_MultiPolygon__WEBPACK_IMPORTED_MODULE_11__);



// import ol

// import Style






// import geom


var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_1__["default"].getLogger("styling");
(ol_Feature__WEBPACK_IMPORTED_MODULE_3___default().prototype).setPropertyFill = function () {
  var style = this.getStyle();
  if (!style) {
    return;
  }
  if (Array.isArray(style) && style.length === 0) {
    return;
  }
  var fill = style.getFill();
  if (fill) {
    var colorFill = fill.getColor();
    // array
    if (Array.isArray(colorFill)) {
      var cf = "rgba(";
      cf += colorFill[0] + ",";
      cf += colorFill[1] + ",";
      cf += colorFill[2] + ",";
      cf += colorFill[3] + ")";
      colorFill = cf;
    }
    if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].isRGB(colorFill)) {
      var oColorFill = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].rgbaToHex(colorFill);
      this.set("fill", oColorFill.hex);
      this.set("fill-opacity", oColorFill.opacity);
    } else {
      this.set("fill", colorFill);
      this.set("fill-opacity", 1);
    }
  }
};
(ol_Feature__WEBPACK_IMPORTED_MODULE_3___default().prototype).setPropertyStroke = function () {
  var style = this.getStyle();
  if (!style) {
    return;
  }
  if (Array.isArray(style) && style.length === 0) {
    return;
  }
  var stroke = style.getStroke();
  if (stroke) {
    var colorStroke = stroke.getColor();
    // array
    if (Array.isArray(colorStroke)) {
      var cs = "rgba(";
      cs += colorStroke[0] + ",";
      cs += colorStroke[1] + ",";
      cs += colorStroke[2] + ",";
      cs += colorStroke[3] + ")";
      colorStroke = cs;
    }
    if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].isRGB(colorStroke)) {
      var oColorStroke = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].rgbaToHex(colorStroke);
      this.set("stroke", oColorStroke.hex);
      this.set("stroke-opacity", oColorStroke.opacity);
    } else {
      this.set("stroke", colorStroke);
      this.set("stroke-opacity", 1);
    }
    this.set("stroke-width", stroke.getWidth());
  }
};
(ol_Feature__WEBPACK_IMPORTED_MODULE_3___default().prototype).setPropertyLabel = function () {
  var style = this.getStyle();
  if (!style) {
    return;
  }
  if (Array.isArray(style) && style.length === 0) {
    return;
  }
  var isName = this.get("name") !== undefined;
  var label = style.getText();
  if (label && isName) {
    var fill = style.getText().getFill();
    if (fill) {
      var colorFill = fill.getColor();
      // array
      if (Array.isArray(colorFill)) {
        var cf = "rgba(";
        cf += colorFill[0] + ",";
        cf += colorFill[1] + ",";
        cf += colorFill[2] + ",";
        cf += colorFill[3] + ")";
        colorFill = cf;
      }
      if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].isRGB(colorFill)) {
        var oColorFill = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].rgbaToHex(colorFill);
        this.set("label-fill", oColorFill.hex);
        this.set("label-fill-opacity", oColorFill.opacity);
      } else {
        this.set("label-fill", colorFill);
        this.set("label-fill-opacity", 1);
      }
    }
    var stroke = style.getText().getStroke();
    if (stroke) {
      var colorStroke = stroke.getColor();
      // array
      if (Array.isArray(colorStroke)) {
        var cs = "rgba(";
        cs += colorStroke[0] + ",";
        cs += colorStroke[1] + ",";
        cs += colorStroke[2] + ",";
        cs += colorStroke[3] + ")";
        colorStroke = cs;
      }
      if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].isRGB(colorStroke)) {
        var oColorStroke = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].rgbaToHex(colorStroke);
        this.set("label-stroke", oColorStroke.hex);
        this.set("label-stroke-opacity", oColorStroke.opacity);
      } else {
        this.set("label-stroke", colorStroke);
        this.set("label-stroke-opacity", 1);
      }
      this.set("label-stroke-width", stroke.getWidth());
    }
    this.set("label-font", style.getText().getFont() || Styling.DEFAULT_TEXT.font);
    this.set("label-textAlign", style.getText().getTextAlign() || Styling.DEFAULT_TEXT.textAlign);
  }
};
(ol_Feature__WEBPACK_IMPORTED_MODULE_3___default().prototype).setPropertyMarker = function () {
  var style = this.getStyle();
  if (!style) {
    return;
  }
  if (Array.isArray(style) && style.length === 0) {
    return;
  }
  var image = style.getImage();
  if (image) {
    // si le tag image est seul...
    // c'est soit un marker ou soit un cercle !
    if (image instanceof (ol_style_Icon__WEBPACK_IMPORTED_MODULE_6___default())) {
      var color = image.getColor();
      // array
      if (Array.isArray(color)) {
        var c = "rgba(";
        c += color[0] + ",";
        c += color[1] + ",";
        c += color[2] + ",";
        c += color[3] + ")";
        color = c;
      }
      // feature.set("marker-color", ""); // par defaut
      if (color) {
        var colorIcon = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].rgbaToHex(color);
        this.set("marker-color", colorIcon.hex);
      }
      var scaleIcon = image.getScale();
      switch (Math.round(scaleIcon * 2) / 2) {
        case 0:
        case 0.5:
          this.set("marker-size", "small");
          break;
        case 1:
          this.set("marker-size", "medium");
          break;
        case 1.5:
        case 2:
          this.set("marker-size", "large");
          break;
        default:
          // this.set("marker-size", ""); // par defaut
          break;
      }
      // feature.set("marker-symbol", ""); // par defaut
      var srcImage = image.getSrc();
      if (srcImage) {
        this.set("marker-symbol", srcImage);
      }
      // INFO
      // cas particulier où un objet est transformé :
      //  * un cercle est transformé en icone
      //  > les attributs du cercle sont à supprimer !
      this.unset("circle-fill");
      this.unset("circle-fill-opacity");
      this.unset("circle-stroke");
      this.unset("circle-stroke-width");
      this.unset("circle-stroke-opacity");
      this.unset("circle-radius");
    } else {
      var fillImg = image.getFill();
      if (fillImg) {
        var colorFillImg = fillImg.getColor();
        // array
        if (Array.isArray(colorFillImg)) {
          var cfi = "rgba(";
          cfi += colorFillImg[0] + ",";
          cfi += colorFillImg[1] + ",";
          cfi += colorFillImg[2] + ",";
          cfi += colorFillImg[3] + ")";
          colorFillImg = cfi;
        }
        if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].isRGB(colorFillImg)) {
          var oColorFillImg = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].rgbaToHex(colorFillImg);
          this.set("circle-fill", oColorFillImg.hex);
          this.set("circle-fill-opacity", oColorFillImg.opacity);
        } else {
          this.set("circle-fill", colorFillImg);
          this.set("circle-fill-opacity", 1);
        }
      }
      var strokeImg = image.getStroke();
      if (strokeImg) {
        var colorStrokeImg = strokeImg.getColor();
        // array
        if (Array.isArray(colorStrokeImg)) {
          var csi = "rgba(";
          csi += colorStrokeImg[0] + ",";
          csi += colorStrokeImg[1] + ",";
          csi += colorStrokeImg[2] + ",";
          csi += colorStrokeImg[3] + ")";
          colorStrokeImg = csi;
        }
        if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].isRGB(colorStrokeImg)) {
          var oColorStrokeImg = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].rgbaToHex(colorStrokeImg);
          this.set("circle-stroke", oColorStrokeImg.hex);
          this.set("circle-stroke-opacity", oColorStrokeImg.opacity);
        } else {
          this.set("circle-stroke", colorStrokeImg);
          this.set("circle-stroke-opacity", 1);
        }
        this.set("circle-stroke-width", strokeImg.getWidth());
      }
      var radius = image.getRadius();
      this.set("circle-radius", radius);
    }
  }
};

/**
 * @module Styling
 * @alias Gp.Styling
 * @private
 * @todo ...
 * @description
 * A simple specification for styling GeoJSON / GPX / KML data.
 *
 * @see ol.format.GeoJSONExtended
 * @see ol.format.KMLExtended
 * @see ol.format.GPXExtended
 *
 * @example
 * feature.getStyle(); // null
 * feature.getProperties(); // {"stroke": "#ff0000", "stroke-width": 2}
 * Styling.defineStyleFromProperties(feature);
 * feature.getStyle(); // [Object Style]
 *
 * feature.getStyle(); // [Object Style]
 * feature.getProperties(); // {}
 * Styling.definePropertiesFromStyle(feature);
 * feature.getProperties(); // {"stroke": "#ff0000", "stroke-width": 2}
 *
 * var style = feature.getStyle(); // [Object Style]
 * var tag = Styling.setTag(style, "GPX");
 *
 * ex. output GeoJSON:
 * ```json
 *  "properties": {
 *   "stroke": "#ff0000",
 *   "stroke-width": 2
 *  }
 * ```
 */
var Styling = {
  /**
   * Options to convert geometry
   */
  APPLY_CONVERT_GEOM_GPX: true,
  /**
   * Default icon style options
   */
  DEFAULT_ICON: {
    src: _Controls_Utils_Markers__WEBPACK_IMPORTED_MODULE_2__["default"]["lightOrange"],
    anchor: [0.5, 1],
    scale: 1
  },
  /**
   * Default circle style options
   */
  DEFAULT_CIRCLE: {
    radius: 10,
    fill: {
      opacity: 1,
      color: [0, 0, 0, 1]
    },
    stroke: {
      width: 1,
      opacity: 1,
      color: [0, 0, 0, 1]
    }
  },
  /**
   * Default stroke style options
   */
  DEFAULT_STROKE: {
    width: 5,
    opacity: 1,
    color: [250, 250, 250, 1]
  },
  /**
   * Default fill style options
   */
  DEFAULT_FILL: {
    opacity: 1,
    color: [0, 0, 0, 1]
  },
  /**
   * Default text style options
   * @see https://openlayers.org/en/v6.15.1/apidoc/module-ol_style_Text-Text.html
   */
  DEFAULT_TEXT: {
    font: "16px sans",
    textAlign: "left",
    stroke: {
      color: [250, 250, 250, 1],
      width: 5,
      opactity: 1
    },
    fill: {
      opacity: 1,
      color: [0, 0, 0, 1]
    }
    // offsetX
    // offsetY
    // placement
    // scale
    // rotation
    // justify
    // padding
  },
  /**
   * All styling tags
   * @function getListTags
   * @returns {Array} all styling tags
   * @example
   * "type", // type de geometrie
   * "fill",
   * "fill-opacity",
   * "stroke",
   * "stroke-opacity",
   * "stroke-width",
   * "circle-fill",
   * "circle-fill-opacity",
   * "circle-stroke",
   * "circle-stroke-opacity",
   * "circle-stroke-width",
   * "circle-radius",
   * "marker-symbol",
   * "marker-color",
   * "marker-size"
   */
  getListTags: function getListTags() {
    return ["type", "fill", "fill-opacity", "stroke", "stroke-opacity", "stroke-width", "circle-fill", "circle-fill-opacity", "circle-stroke", "circle-stroke-opacity", "circle-stroke-width", "circle-radius", "marker-symbol", "marker-color", "marker-size", "label-fill", "label-fill-opacity", "label-stroke", "label-stroke-width", "label-stroke-opacity", "label-font", "label-textAlign"];
  },
  /**
   * Transform feature properties to a native style
   *
   * @function defineStyleFromProperties
   * @param {*} feature - ...
   * @returns {*} style - ...
   * @public
   *
   * @description
   * A la lecture du format :
   * > tag styling ---> feature properties ---> feature style
   *
   * Les balises de 'styling' du fichier sont ajoutées dans les properties de chaque features
   * (opération native sous OpenLayers):
   *
   * Ex. avec le format GeoJSON :
   * ```json
   * "properties": {
   *    "stroke": "#000000",      -> feature.get("stroke");
   *    "stroke-width": 13,       -> feature.get("stroke-width");
   *    "stroke-opacity": 0.8,    -> feature.get("stroke-opacity");
   *    "fill": "#a03737",        -> feature.get("fill");
   *    "fill-opacity": 0.5       -> feature.get("fill-opacity");
   * }
   * ```
   *
   * Ensuite, les properties des features sont transformées dans le style natif :
   *
   * ```js
   * // Ex.
   * feature.setStyle(new Style({
   *  fill : new FillStyle({
   *      color : Color.hexToRgba(feature.get("fill"), feature.get("fill-opacity") || 1)
   *  }),
   *  stroke : new StrokeStyle({
   *      color : Color.hexToRgba(feature.get("stroke"), feature.get("stroke-opacity"))
   *      width : feature.get("stroke-width")
   *  })
   * }));
   * ```
   */
  defineStyleFromProperties: function defineStyleFromProperties(feature) {
    // style
    var style = null;

    // les options de styles définis dans le format
    var options = {};

    // properties :
    // "marker-size" -> icon
    // "marker-symbol" -> icon
    // "marker-color" -> icon
    var marker = null;
    if (feature.get("marker-color") || feature.get("marker-size") || feature.get("marker-symbol")) {
      marker = {};
      // icone par defaut
      marker["src"] = this.DEFAULT_ICON.src;
      marker["anchor"] = this.DEFAULT_ICON.anchor;
      var symbolMarker = feature.get("marker-symbol");
      if (symbolMarker) {
        if (symbolMarker.search("data:image/png;base64") !== -1) {
          // icone du portail
          marker["src"] = symbolMarker;
        } else {
          // TODO
          // utiliser les symboles de Maki
          // (cf. https://labs.mapbox.com/maki-icons/)
        }
      }
      var colorMarker = feature.get("marker-color");
      if (_Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].isHex(colorMarker)) {
        marker["color"] = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].hexToRgba(colorMarker, 1);
      }
      var size = feature.get("marker-size");
      if (size) {
        switch (size) {
          case "small":
            marker["scale"] = 0.5;
            break;
          case "medium":
            marker["scale"] = 1;
            break;
          case "large":
            marker["scale"] = 1.5;
            break;
          default:
            marker["scale"] = this.DEFAULT_ICON.scale;
            break;
        }
      }
    }

    // properties :
    // "stroke" -> line / polygon
    // "stroke-opacity" -> line / polygon
    // "stroke-width" -> line / polygon
    var stroke = null;
    if (feature.get("stroke") || feature.get("stroke-opacity") || feature.get("stroke-width")) {
      stroke = {};
      stroke["color"] = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].hexToRgba(feature.get("stroke"), +feature.get("stroke-opacity") || this.DEFAULT_STROKE.opacity);
      stroke["width"] = +feature.get("stroke-width") || this.DEFAULT_STROKE.width;
    }

    // properties :
    // "fill" -> polygon
    // "fill-opacity" -> polygon
    var fill = null;
    if (feature.get("fill") || feature.get("fill-opacity")) {
      fill = {};
      fill["color"] = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].hexToRgba(feature.get("fill"), +feature.get("fill-opacity") || this.DEFAULT_FILL.opacity);
    }

    // properties :
    // "label-fill",
    // "label-fill-opacity",
    // "label-stroke",
    // "label-stroke-width",
    // "label-stroke-opacity",
    // "label-font",
    // "label-textAlign"
    // "name" -> text
    var labelStroke = null;
    var labelFill = null;
    var isLabel = feature.get("name") !== "";
    if (isLabel) {
      if (feature.get("label-fill") || feature.get("label-fill-opacity")) {
        labelFill = {};
        labelFill["color"] = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].hexToRgba(feature.get("label-fill"), +feature.get("label-fill-opacity") || this.DEFAULT_TEXT.fill.opacity);
      }
      if (feature.get("label-stroke") || feature.get("label-stroke-opacity") || feature.get("label-stroke-width")) {
        labelStroke = {};
        labelStroke["color"] = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].hexToRgba(feature.get("label-stroke"), +feature.get("label-stroke-opacity") || this.DEFAULT_TEXT.stroke.opacity);
        labelStroke["width"] = +feature.get("label-stroke-width") || this.DEFAULT_TEXT.stroke.width;
      }
    }

    // properties :
    // "circle-fill"
    // "circle-stroke"
    // "circle-stroke-width"
    // "circle-radius"
    var circleRadius = feature.get("circle-radius") || this.DEFAULT_CIRCLE.radius;
    var circleStroke = null;
    if (feature.get("circle-stroke") || feature.get("circle-stroke-opacity") || feature.get("circle-stroke-width")) {
      circleStroke = {};
      circleStroke["color"] = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].hexToRgba(feature.get("circle-stroke"), +feature.get("circle-stroke-opacity") || this.DEFAULT_CIRCLE.stroke.opacity);
      circleStroke["width"] = +feature.get("circle-stroke-width") || this.DEFAULT_CIRCLE.stroke.width;
    }
    var circleFill = null;
    if (feature.get("circle-fill") || feature.get("circle-fill-opacity")) {
      circleFill = {};
      circleFill["color"] = _Utils_ColorUtils__WEBPACK_IMPORTED_MODULE_0__["default"].hexToRgba(feature.get("circle-fill"), +feature.get("circle-fill-opacity") || this.DEFAULT_CIRCLE.fill.opacity);
    }

    // options du Style en fonction du type de geometrie
    var type = feature.getGeometry().getType();
    switch (type) {
      case "Circle":
      case "Point":
      case "MultiPoint":
        // Cercle
        var isCircle = false;
        var optionsCircle = {};
        if (circleStroke) {
          optionsCircle["stroke"] = new (ol_style_Stroke__WEBPACK_IMPORTED_MODULE_8___default())(circleStroke);
        }
        if (circleFill) {
          optionsCircle["fill"] = new (ol_style_Fill__WEBPACK_IMPORTED_MODULE_7___default())(circleFill);
        }
        if (Object.keys(optionsCircle).length !== 0) {
          isCircle = true;
          optionsCircle["radius"] = +circleRadius; // Conversion en nombre
          options["image"] = new (ol_style_Circle__WEBPACK_IMPORTED_MODULE_5___default())(optionsCircle);
        }
        // Ponctuel
        if (marker) {
          options["image"] = new (ol_style_Icon__WEBPACK_IMPORTED_MODULE_6___default())(marker);
        }
        // Label
        if (isLabel) {
          var optionsText = {};
          if (labelStroke) {
            optionsText["stroke"] = new (ol_style_Stroke__WEBPACK_IMPORTED_MODULE_8___default())(labelStroke);
          }
          if (labelFill) {
            optionsText["fill"] = new (ol_style_Fill__WEBPACK_IMPORTED_MODULE_7___default())(labelFill);
          }
          if (Object.keys(optionsText).length !== 0) {
            optionsText["text"] = feature.get("name");
            optionsText["textAlign"] = feature.get("label-textAlign") || this.DEFAULT_TEXT.textAlign;
            optionsText["font"] = feature.get("label-font") || this.DEFAULT_TEXT.font;
            options["text"] = new (ol_style_Text__WEBPACK_IMPORTED_MODULE_9___default())(Object.assign({}, this.DEFAULT_TEXT, optionsText));
          } else {
            // on applique un style par defaut sur le label
            // pour un marker ou un cercle
            if (marker || isCircle) {
              var styleText = new (ol_style_Text__WEBPACK_IMPORTED_MODULE_9___default())(Object.assign({}, this.DEFAULT_TEXT, {
                fill: new (ol_style_Fill__WEBPACK_IMPORTED_MODULE_7___default())(this.DEFAULT_TEXT.fill),
                stroke: new (ol_style_Stroke__WEBPACK_IMPORTED_MODULE_8___default())(this.DEFAULT_TEXT.stroke)
              }));
              if (styleText) {
                var cloneStyleText = styleText.clone();
                cloneStyleText.setText(feature.get("name"));
                options["text"] = cloneStyleText;
              }
            }
          }
        }
        break;
      case "Polygon":
      case "MultiPolygon":
        if (stroke) {
          options["stroke"] = new (ol_style_Stroke__WEBPACK_IMPORTED_MODULE_8___default())(stroke);
        }
        if (fill) {
          options["fill"] = new (ol_style_Fill__WEBPACK_IMPORTED_MODULE_7___default())(fill);
        }
        break;
      case "LineString":
      case "MultiLineString":
        if (stroke) {
          options["stroke"] = new (ol_style_Stroke__WEBPACK_IMPORTED_MODULE_8___default())(stroke);
        }
        if (this.APPLY_CONVERT_GEOM_GPX && fill) {
          // INFO
          // Lors d'une transformation de type de geometrie, le type est renseigné.
          // Pour le format GPX,
          // -> on transforme une surface vers ligne lors de l'écriture
          // -> on transforme une ligne vers une surface lors de la lecture si le type est précisé !
          var initType = feature.get("type");
          if (initType && (initType === "Polygon" || initType === "MultiPolygon")) {
            options["fill"] = new (ol_style_Fill__WEBPACK_IMPORTED_MODULE_7___default())(fill);
            var f = feature.clone();
            var ClassPoly = type === "LineString" ? (ol_geom_Polygon__WEBPACK_IMPORTED_MODULE_10___default()) : (ol_geom_MultiPolygon__WEBPACK_IMPORTED_MODULE_11___default());
            feature.setGeometry(new ClassPoly([f.getGeometry().getCoordinates()]));
          }
        }
        break;
      default:
        break;
    }

    // si aucun style disponible, on utilisera le style par defaut defini
    // par l'utilisateur ou l'application
    if (Object.keys(options).length !== 0) {
      style = new (ol_style_Style__WEBPACK_IMPORTED_MODULE_4___default())(options);
    }
    return style;
  },
  /**
   * Define a default style function to apply to a feature
   *
   * @function defineStyleFunctionByDefault
   * @param {Object} defaultStyle - ...
   * @returns {Function} style function
   * @public
   *
   * @description
   * ...
   */
  defineStyleFunctionByDefault: function defineStyleFunctionByDefault(defaultStyle) {
    if (!defaultStyle) {
      return [];
    }
    if (Object.keys(defaultStyle).length === 0) {
      return [];
    }

    // les styles par defaut
    var styleFunction = function styleFunction(feature, resolution) {
      var style = null;
      var type = feature.getGeometry().getType();
      switch (type) {
        case "Point":
        case "MultiPoint":
          // on n'a aucune information sur le type de style à appliquer sur un "Point" :
          // * label ou
          // * marker ou
          // * marker avec label
          // donc, c'est en fonction des styles par defaut...
          var opts = {};
          if (defaultStyle.getImage()) {
            opts["image"] = defaultStyle.getImage();
          }
          if (defaultStyle.getText() && feature.get("name")) {
            var styleText = defaultStyle.getText().clone();
            styleText.setText(feature.get("name"));
            opts["text"] = styleText;
          }
          style = new (ol_style_Style__WEBPACK_IMPORTED_MODULE_4___default())(opts);
          break;
        case "Circle":
          var optsc = {};
          var optsCircle = {};
          if (defaultStyle.getFill()) {
            optsCircle.fill = defaultStyle.getFill();
          }
          if (defaultStyle.getStroke()) {
            optsCircle.stroke = defaultStyle.getStroke();
          }
          if (defaultStyle.getText() && feature.get("name")) {
            var styleTextCircle = defaultStyle.getText().clone();
            styleTextCircle.setText(feature.get("name"));
            optsc.text = styleTextCircle;
          }
          if (Object.keys(optsCircle).length !== 0) {
            // FIXME param radius ?
            optsCircle.radius = 3;
            optsc.image = new (ol_style_Circle__WEBPACK_IMPORTED_MODULE_5___default())(optsCircle);
          }
          style = new (ol_style_Style__WEBPACK_IMPORTED_MODULE_4___default())(optsc);
          break;
        case "Polygon":
        case "MultiPolygon":
          var optsp = {};
          if (defaultStyle.getFill()) {
            optsp.fill = defaultStyle.getFill();
          }
          if (defaultStyle.getStroke()) {
            optsp.stroke = defaultStyle.getStroke();
          }
          style = new (ol_style_Style__WEBPACK_IMPORTED_MODULE_4___default())(optsp);
          break;
        case "LineString":
        case "LinearRing":
        case "MultiLineString":
          var optsl = {};
          if (defaultStyle.getStroke()) {
            optsl.stroke = defaultStyle.getStroke();
          }
          style = new (ol_style_Style__WEBPACK_IMPORTED_MODULE_4___default())(optsl);
          break;
      }
      return [style];
    };
    return styleFunction;
  },
  /**
   * Transform a native style to feature properties by type of geometry
   *
   * @todo not yet implemented !
   * @param {*} feature - feature
   */
  definePropertiesFromStyleByType: function definePropertiesFromStyleByType(feature) {
    var geomType = feature.getGeometry().getType();
    switch (geomType) {
      case "Point":
      case "MultiPoint":
        feature.setPropertyMarker();
        feature.setPropertyLabel();
        break;
      case "LineString":
      case "MultiLineString":
        feature.setPropertyStroke();
        break;
      case "Polygon":
      case "MultiPolygon":
        feature.setPropertyStroke();
        feature.setPropertyFill();
        break;
      default:
        break;
    }
  },
  /**
   * Transform a native style to feature properties
   *
   * @function definePropertiesFromStyle
   * @param {*} feature - ...
   * @public
   *
   * @description
   * A l'écriture du format.
   * > feature style --> feature properties --> tag styling
   *
   * Le style natif est récupéré pour chaque feature :
   *
   * ```js
   * // Ex.
   * var style = feature.getStyle();
   * ```
   *
   * Ensuite, le style natif est transformé en properties pour chaque feature :
   *
   * ```js
   * // Ex.
   * var stroke = style.getStroke();
   * var oColorStroke = Color.rgbaToHex(stroke.getColor());
   * feature.set("stroke", oColorStroke.hex); // #000000
   * feature.set("stroke-opacity", oColorStroke.opacity); // 0.8
   * ```
   *
   * Et, chaque properties des features sont ecrites dans le format du fichier
   * (opération native sous OpenLayers) :
   *
   * Ex. avec le format GeoJSON :
   * ```json
   * "properties": {
   *    "stroke": "#000000",
   *    "stroke-opacity": 0.8
   * }
   * ```
   */
  definePropertiesFromStyle: function definePropertiesFromStyle(feature) {
    var style = feature.getStyle() || feature.getStyleFunction();
    if (style) {
      // style ajouté via une fonction, pour les styles par defaut par ex.
      if (typeof style === "function") {
        var styles = style.call(this, feature, 0);
        if (styles && styles.length !== 0) {
          style = Array.isArray(styles) ? styles[0] : styles;
          feature.setStyle(style);
        } else {
          // au cas où...
          return;
        }
      }
      this.definePropertiesFromStyleByType(feature);
    }
  },
  /**
   * Transform a native style to tags 'styling' into the format
   *
   * @function defineTagFromStyle
   * @param {*} style - ...
   * @param {String} format - ...
   * @returns {String} tags stringify into the format (json / xml)
   * @todo
   * @public
   *
   * @description
   * A partir d'un style natif, on le transforme en balise de 'styling' dans le format demandé,
   * que l'on peut ensuite inserer dans le fichier.
   * > style ---> tag styling
   *
   */
  defineTagFromStyle: function defineTagFromStyle(style, format) {
    logger.trace("todo...");
    return null;
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Styling);

/***/ }),

/***/ "./src/packages/Utils/ColorUtils.js":
/*!******************************************!*\
  !*** ./src/packages/Utils/ColorUtils.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ColorUtils
 * @alias module:~utils/ColorUtils
 * @description
 * ...
 *
 * @example
 * import ColorUtils from "gpf-ext-ol/utils/ColorUtils"
 * ou 
 * import {ColorUtils} from "gpf-ext-ol
 * 
 * ColorUtils.hex();
 * ColorUtils.num();
 * ColorUtils.arrayTorgba();
 * ColorUtils.arrayToHex();
 * ColorUtils.rgbaToHex();
 * ColorUtils.hexToRgba();
 * ColorUtils.isHex();
 * ColorUtils.isRGB();
 */
var ColorUtils = {
  /**
   * Number to hex conversion
   *
   * @param {Number} number - 0-255
   * @returns {String} hex value
   */
  hex: function hex(number) {
    if (number > 255) {
      throw new Error("'" + number + "'' is greater than 255(0xff);");
    }
    var str = Number(number).toString(16);
    return ("0" + str).slice(-2);
  },
  /**
   * Hexa to number conversion
   *
   * @param {*} hexa 00-FF
   * @returns {Number} number value
   */
  num: function num(hexa) {
    return parseInt(hexa, 16);
  },
  /**
   * Converts an array ([255,255,255,1]) to rgba string
   *
   * @function arrayToRgba
   * @param {Array} values - array of values
   * @returns {String} A color of RGB or RGBA format
   */
  arrayToRgba: function arrayToRgba(values) {
    if (!Array.isArray(values)) {
      throw new Error("Not an array !");
    }
    var red = values[0];
    var green = values[1];
    var blue = values[2];
    var alpha = values[3] || 1;
    var result = "rgba(" + red + ", " + green + ", " + blue + ", " + parseFloat(alpha) + ")";
    return result;
  },
  /**
   * Converts an array ([255,255,255,1]) to #RRGGBBAA
   *
   * @function arrayToHex
   * @param {Array} values - array of values
   * @returns {Object}  hex and opacity formated values
   */
  arrayToHex: function arrayToHex(values) {
    if (!Array.isArray(values)) {
      throw new Error("Not an array !");
    }
    var red = values[0];
    var green = values[1];
    var blue = values[2];
    var alpha = values[3];
    var elems = [this.hex(red), this.hex(green), this.hex(blue)];
    var result = {};
    result.hex = "#" + elems.join("");
    if (alpha) {
      // elems.push(hex(alpha));
      result.opacity = parseFloat(alpha);
    }
    return result;
  },
  /**
   * Converts rgba string to #RRGGBBAA
   * (Code adapted from : https://gist.github.com/mstssk/afda4ce9e5c335fd79cd)
   *
   * @function rgbaToHex
   * @param {String} rgba - A color of RGB or RGBA format.
   * @returns {Object} hex and opacity formated values
   */
  rgbaToHex: function rgbaToHex(rgba) {
    var regex = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(0?.?\d+)\s*)?\)/;
    var parsed = regex.exec(rgba);
    if (!parsed) {
      throw new Error("Invalid format: " + rgba);
    }
    var red = parsed[1];
    var green = parsed[2];
    var blue = parsed[3];
    var alpha = parsed[4];
    var elems = [this.hex(red), this.hex(green), this.hex(blue)];
    var result = {};
    result.hex = "#" + elems.join("");
    if (alpha) {
      // elems.push(hex(alpha));
      result.opacity = parseFloat(alpha);
    }
    return result;
  },
  /**
   * Converts hex color and opacity value to rgba string.
   * (Code adapted from : http://stackoverflow.com/a/5624139)
   *
   * @function hexToRgba
   * @param {String} hex - A color value on RGB format (hexa).
   * @param {Number} opacity - A opacity value.
   * @returns {String} A color of RGB or RGBA format
   */
  hexToRgba: function hexToRgba(hex, opacity) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    if (!hex) {
      throw new Error("Invalid format");
    }
    hex = hex.replace(shorthandRegex, function (m, r, g, b) {
      return r + r + g + g + b + b;
    });
    var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    rgb = rgb ? {
      r: parseInt(rgb[1], 16),
      g: parseInt(rgb[2], 16),
      b: parseInt(rgb[3], 16)
    } : null;
    var result = rgb ? "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", " + opacity + ")" : null;
    return result;
  },
  /**
   * Determine if value is a correct hexa color.
   * @param {*} value - hex color (#FFFFFF)
   * @returns {Boolean} True if value is a hexa color
   */
  isHex: function isHex(value) {
    if (!value) {
      return false;
    }
    if (value.charAt(0) !== "#") {
      return false;
    }
    var regex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
    var parsed = regex.exec(value);
    if (!parsed) {
      return false;
    }
    return true;
  },
  /**
   * Determine if value is a correct rgba color.
   * @param {*} value - rgba color (rgba(125,125,125,1))
   * @returns {Boolean} True if value is a rgba color
   */
  isRGB: function isRGB(value) {
    if (!value) {
      return false;
    }
    var regex = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(0?.?\d+)\s*)?\)/;
    var parsed = regex.exec(value);
    if (!parsed) {
      return false;
    }
    return true;
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ColorUtils);

/***/ }),

/***/ "./src/packages/Utils/Draggable.js":
/*!*****************************************!*\
  !*** ./src/packages/Utils/Draggable.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");

var logger = _LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("draggable");

/**
 * @module Draggable
 * @alias module:~utils/Draggable
 * @fixme conflit entre la position et le mode draggable
 * @private
 * @description
 * ...
 *
 * @example
 * dragElement();
 */
var Draggable = {
  /**
  * A draggable HTML element with JavaScript and CSS.
  *
  * @function dragElement
  * @param {DOMElement} element - element
  * @param {DOMElement} header - header (optional)
  * @param {DOMElement} container - container (optional)
  * @see https://www.w3schools.com/howto/howto_js_draggable.asp
  * @see https://stackoverflow.com/questions/52231588/how-to-constrain-div-drag-space-no-jquery
  * @example
  *   // CSS :
  *       // #element { position: absolute; }
  *   // HTML :
  *       // <div id="container">
  *       //   <div id="element">
  *       //     <div id="header"/>
  *       //      <div/> ...
  *       //     </div>
  *       //   </div>
  *       // </div>
  *   // JS :
  *       var element = document.getElementById("element");
  *       Draggable.dragElement(element, header, container);
  */
  dragElement: function dragElement(element, header, container) {
    var offsetX, offsetY;
    var isDragReady = false;
    var dragoffset = {
      x: 0,
      y: 0
    };
    if (header) {
      header.addEventListener("mousedown", dragMouseDown, true);
    } else {
      element.addEventListener("mousedown", dragMouseDown, true);
    }

    // TODO mettre en place les contraintes
    // var constraints = {};
    // if (container) {
    //     constraints = {
    //         width : container.clientWidth,
    //         height : container.clientHeight,
    //         top : container.offsetTop,
    //         left : container.offsetLeft
    //     };
    // }

    function dragMouseDown(e) {
      e = e || window.event;
      e.preventDefault();
      isDragReady = true;

      // get the mouse cursor position at startup
      e._pageX = e._pageX || e.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);
      e._pageY = e._pageY || e.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);
      dragoffset.x = e._pageX - element.offsetLeft;
      dragoffset.y = e._pageY - element.offsetTop;
      document.addEventListener("mouseup", closeDragElement, true);
      document.addEventListener("mousemove", elementDrag, true);
    }
    function closeDragElement() {
      /* stop moving when mouse button is released: */
      isDragReady = false;
      document.removeEventListener("mouseup", closeDragElement, true);
      document.removeEventListener("mousemove", elementDrag, true);
    }
    function elementDrag(e) {
      e = e || window.event;
      // e.preventDefault();

      // cf. https://jsfiddle.net/nbbg08mg/2/
      if (isDragReady) {
        e._pageX = e._pageX || e.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);
        e._pageY = e._pageY || e.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);
        var parentLeft = container ? container.offsetLeft : element.parentElement.offsetLeft;
        var parentTop = container ? container.offsetTop : element.parentElement.parentElement.offsetTop; // hack pas jolie !
        logger.trace("parent offset", parentLeft, parentTop);

        // left/right constraint
        if (e._pageX - dragoffset.x < 0 - parentLeft) {
          offsetX = 0 - parentLeft;
        } else if (e._pageX - dragoffset.x + element.clientWidth > document.body.clientWidth) {
          offsetX = document.body.clientWidth - element.clientWidth;
        } else {
          offsetX = e._pageX - dragoffset.x;
        }
        logger.trace("left/right constraint", offsetX);

        // top/bottom constraint
        if (e._pageY - dragoffset.y < 0 - parentTop) {
          offsetY = 0 - parentTop;
        } else if (e._pageY - dragoffset.y + element.clientHeight > document.body.clientHeight) {
          offsetY = document.body.clientHeight - element.clientHeight;
        } else {
          offsetY = e._pageY - dragoffset.y;
        }
        logger.trace("top/bottom constraint", offsetY);

        // set the element's new position:
        element.style.top = offsetY + "px";
        element.style.bottom = "unset";
        element.style.left = offsetX + "px";
        element.style.right = "unset";
      }
    }
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Draggable);

/***/ }),

/***/ "./src/packages/Utils/GeocodeUtils.js":
/*!********************************************!*\
  !*** ./src/packages/Utils/GeocodeUtils.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module GeocodeUtils
 * @alias module:~utils/GeocodeUtils
 * @private
 * @description
 * ...
 *
 * @example
 * getGeocodedLocationFreeform();
 * getSuggestedLocationFreeform();
 */
var GeocodeUtils = {
  /**
   * Return the freeform of a structured geocoded item
   *
   * @param {Object} geocodedLocation - Geocoded location
   * @returns {String} freeform string
   */
  getGeocodedLocationFreeform: function getGeocodedLocationFreeform(geocodedLocation) {
    var attributes = geocodedLocation.placeAttributes;
    if (attributes.label) {
      return attributes.label;
    } else if (geocodedLocation.type === "PositionOfInterest") {
      var resultToReturn = attributes.toponym;
      if (attributes.category && Array.isArray(attributes.category) && attributes.category.length >= 2 && attributes.category[0] === "administratif") {
        // gestion particulière des territoires administratifs
        resultToReturn = resultToReturn + ", " + attributes.category[1];
      } else {
        // gestion standard des POI non adminsitratifs
        if (attributes.postcode) {
          resultToReturn = resultToReturn + ", " + attributes.postcode[0];
          if (attributes.city) {
            resultToReturn = resultToReturn + " " + attributes.city[0];
          }
        }
      }
      return resultToReturn;
    } else if (geocodedLocation.type === "StreetAddress") {
      return (attributes.housenumber ? attributes.housenumber + " " : "") + attributes.street + " " + (attributes.postcode ? attributes.postcode + ", " : "") + attributes.city;
    } else if (geocodedLocation.type === "CadastralParcel") {
      return attributes.id;
    } else {
      return "...";
    }
  },
  /**
   * Return the freeform of a structured suggested item
   *
   * @param {Object} suggestedLocation - Suggested location
   * @returns {String} freeform string
   */
  getSuggestedLocationFreeform: function getSuggestedLocationFreeform(suggestedLocation) {
    if (suggestedLocation.fullText) {
      return suggestedLocation.fullText;
    } else {
      var values = [];
      values.push(suggestedLocation.street || "");
      values.push(suggestedLocation.postalCode || "");
      values.push(suggestedLocation.commune || "");
      if (suggestedLocation.type === "PositionOfInterest") {
        values.push(suggestedLocation.poi || "");
        values.push(suggestedLocation.kind || "");
      }
      return values.join(" - ");
    }
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeocodeUtils);

/***/ }),

/***/ "./src/packages/Utils/Helper.js":
/*!**************************************!*\
  !*** ./src/packages/Utils/Helper.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/**
* @module Helper
* @alias module:~utils/HelperUtils
* @description
* ...
*
* @example
* import HelperUtils from "gpf-ext-ol/utils/HelperUtils"
* ou 
* import {HelperUtils} from "gpf-ext-ol
* 
* HelperUtils.detectSupport();
* HelperUtils.assign();
* HelperUtils.mergeParams();
*/
var Helper = {
  /**
   * this method is called by the constructor.
   * this information is useful to switch to touch mode.
   * Detection : test for desktop or tactile
   *
   * @function detectSupport
   * @returns {Boolean} isDesktop - true for desktop userAgent, false for mobile
   */
  detectSupport: function detectSupport() {
    var isDesktop = true;
    var userAgent = window.navigator.userAgent.toLowerCase();
    if (userAgent.indexOf("iphone") !== -1 || userAgent.indexOf("ipod") !== -1 || userAgent.indexOf("ipad") !== -1 || userAgent.indexOf("android") !== -1 || userAgent.indexOf("mobile") !== -1 || userAgent.indexOf("blackberry") !== -1 || userAgent.indexOf("tablet") !== -1 || userAgent.indexOf("phone") !== -1 || userAgent.indexOf("touch") !== -1) {
      isDesktop = false;
    }
    if (userAgent.indexOf("msie") !== -1 || userAgent.indexOf("trident") !== -1) {
      isDesktop = true;
    }
    return isDesktop;
  },
  /**
   *  Copies all source object members to dest
   *
   * @function assign
   * @param {Object} dest - destination object where properties and method will be copied
   * @param {Object} source - source object from which properties and method will be copied
   * @returns {Object} dest
   */
  assign: function assign(dest, source) {
    dest = dest || {};
    for (var prop in source) {
      if (source.hasOwnProperty(prop)) {
        dest[prop] = source[prop];
      }
    }
    return dest;
  },
  /**
   * Merge two objects parameters (deeper than assign)
   *
   * @function mergeParams
   * @param {Object} dest     - destination object where properties and method will be merge
   * @param {Object} source   - source object from which properties and method will be merge
   * @param {Boolean} replace - replace destination value by source if exists or not (true by default)
   */
  mergeParams: function mergeParams(dest, source, replace) {
    if (!dest || !source) {
      return;
    }
    if (typeof replace === "undefined") {
      replace = true;
    }
    for (var param in source) {
      if (source.hasOwnProperty(param)) {
        if (_typeof(source[param]) === "object") {
          if (dest.hasOwnProperty(param)) {
            this.mergeParams(dest[param], source[param], replace);
          } else {
            dest[param] = source[param];
          }
        } else {
          if (dest.hasOwnProperty(param)) {
            if (replace) {
              dest[param] = source[param];
            }
          } else {
            dest[param] = source[param];
          }
        }
      }
    }
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Helper);

/***/ }),

/***/ "./src/packages/Utils/LoggerByDefault.js":
/*!***********************************************!*\
  !*** ./src/packages/Utils/LoggerByDefault.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! loglevel */ "./node_modules/loglevel/lib/loglevel.js");
/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);


/**
 * @module LoggerByDefault
 * @alias module:~utils/Logger
 * @description
 * ...
 *
 * @example
 * import Logger from "gpf-ext-ol/utils/LoggerByDefault"
 * ou 
 * import {Logger} from "gpf-ext-ol
 * 
 * Logger.getLogger();
 * Logger.disableAll();
 * Logger.enableAll();
 */
var LoggerByDefault = {
  /**
   * creation d'un logger statique
   *
   * @function getLogger
   * @param {String} [name="default"] - the logger name
   * @returns {Object} logger
   */
  getLogger: function getLogger(name) {
    // on définit process si non défini dans l'environnement
    if (typeof process === "undefined") {
      var process = {};
      process.env = {
        VERBOSE: false
      };
    }
    process.env.VERBOSE ? loglevel__WEBPACK_IMPORTED_MODULE_0__.enableAll() : loglevel__WEBPACK_IMPORTED_MODULE_0__.disableAll();
    var logname = name || "default";
    return loglevel__WEBPACK_IMPORTED_MODULE_0__.getLogger(logname);
  },
  /**
   * desactive tous les loggers
   * @function disableAll
   */
  disableAll: function disableAll() {
    var loggers = loglevel__WEBPACK_IMPORTED_MODULE_0__.getLoggers();
    for (var key in loggers) {
      if (Object.hasOwnProperty.call(loggers, key)) {
        var logger = loggers[key];
        logger.disableAll();
      }
    }
  },
  /**
   * active tous les loggers
   * @function enableAll
   */
  enableAll: function enableAll() {
    var loggers = loglevel__WEBPACK_IMPORTED_MODULE_0__.getLoggers();
    for (var key in loggers) {
      if (Object.hasOwnProperty.call(loggers, key)) {
        var logger = loggers[key];
        logger.enableAll();
      }
    }
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LoggerByDefault);

/***/ }),

/***/ "./src/packages/Utils/Parser.js":
/*!**************************************!*\
  !*** ./src/packages/Utils/Parser.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }

var logger = _LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("parser");

/**
* @module Parser
* @alias module:~utils/Parser
* @description
* ...
*
* @example
* parse();
* toString();
*/
var Parser = {
  /**
   * ...
   *
   * @param {String} xml - XML string
   * @returns {DOMElement} doc
   */
  parse: function parse(xml) {
    var doc = null;
    var parser = null;
    var scope = typeof window !== "undefined" ? window : null;
    if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && window === null) {
      // code for nodejs
      var DOMParser = (__webpack_require__(/*! xmldom */ "xmldom").DOMParser);
      parser = new DOMParser();
      doc = parser.parseFromString(xml, "text/xml");
    } else if (scope.DOMParser) {
      // code for modern browsers
      parser = new scope.DOMParser();
      doc = parser.parseFromString(xml, "text/xml");
    } else if (scope.ActiveXObject) {
      // code for old IE browsers
      doc = new scope.ActiveXObject("Microsoft.XMLDOM");
      doc.async = false;
      doc.loadXML(xml);
    } else {
      logger.log("Incompatible environment for DOM Parser !");
    }
    var errorNode = doc.querySelector("parsererror");
    if (errorNode) {
      // INFO parsing failed
      // eslint-disable-next-line no-console
      console.error(errorNode);
      return null;
    }
    logger.trace(doc);
    return doc;
  },
  /**
   * ...
   *
   * @param {DOMElement} doc - doc
   * @returns {String} XML string
   */
  toString: function toString(doc) {
    // TODO
    // try catch pour les exceptions !
    // cf. https://developer.mozilla.org/en-US/docs/Web/API/XMLSerializer/serializeToString
    var oSerializer = new XMLSerializer();
    var xml = oSerializer.serializeToString(doc);
    logger.trace(xml);
    return xml;
  },
  /**
   * ...
   * cf. https://stackoverflow.com/questions/376373/pretty-printing-xml-with-javascript/
   *
   * @param {String} xml - XML string
   * @returns {String} XML string formatted
   */
  format: function format(xml) {
    var reg = /(>)\s*(<)(\/*)/g; // updated Mar 30, 2015
    var wsexp = / *(.*) +\n/g;
    var contexp = /(<.+>)(.+\n)/g;
    xml = xml.replace(reg, "$1\n$2$3").replace(wsexp, "$1\n").replace(contexp, "$1\n$2");
    var formatted = "";
    var lines = xml.split("\n");
    var indent = 0;
    var lastType = "other";
    // 4 types of tags - single, closing, opening, other (text, doctype, comment) - 4*4 = 16 transitions
    var transitions = {
      "single->single": 0,
      "single->closing": -1,
      "single->opening": 0,
      "single->other": 0,
      "closing->single": 0,
      "closing->closing": -1,
      "closing->opening": 0,
      "closing->other": 0,
      "opening->single": 1,
      "opening->closing": 0,
      "opening->opening": 1,
      "opening->other": 1,
      "other->single": 0,
      "other->closing": -1,
      "other->opening": 0,
      "other->other": 0
    };
    for (var i = 0; i < lines.length; i++) {
      var ln = lines[i];
      var single = Boolean(ln.match(/<.+\/>/)); // is this line a single tag? ex. <br />
      var closing = Boolean(ln.match(/<\/.+>/)); // is this a closing tag? ex. </a>
      var opening = Boolean(ln.match(/<[^!].*>/)); // is this even a tag (that's not <!something>)
      var type = single ? "single" : closing ? "closing" : opening ? "opening" : "other";
      var fromTo = lastType + "->" + type;
      lastType = type;
      var padding = "";
      indent += transitions[fromTo];
      for (var j = 0; j < indent; j++) {
        padding += "\t";
      }
      if (fromTo === "opening->closing") {
        formatted = formatted.substr(0, formatted.length - 1) + ln + "\n"; // substr removes line break (\n) from prev loop
      } else {
        formatted += padding + ln + "\n";
      }
    }
    logger.trace(formatted);
    return formatted;
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Parser);

/***/ }),

/***/ "./src/packages/Utils/ProxyUtils.js":
/*!******************************************!*\
  !*** ./src/packages/Utils/ProxyUtils.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");


/**
* @module ProxyUtils
* @alias module:~utils/ProxyUtils
* @description
* ...
*
* @example
* proxifyUrl();
*/
var ProxyUtils = {
  /**
   * Ajoute un proxy aux url des couches vecteurs si besoin.
   *
   * @function proxifyUrl
   * @param {String} url - Url to proxify.
   * @param {Object} [proxyOptions] - Object defining proxy options.
   * @param {String} proxyOptions.proxyUrl - Proxy URL.
   * @param {Array.<String>} [proxyOptions.noProxyDomains] - Proxy will not be used for this list of domain names.
   *
   * @returns {String} proxy url
   */
  proxifyUrl: function proxifyUrl(url, proxyOptions) {
    // logger

    var logger = _LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("proxifyUrl");
    if (!proxyOptions || !proxyOptions.hasOwnProperty("proxyUrl") || proxyOptions.proxyUrl === null || proxyOptions.proxyUrl.trim().length === 0) {
      return url;
    }
    // on regarde si l'url nest pas dans les domaines sans proxy
    if (proxyOptions.noProxyDomains && Array.isArray(proxyOptions.noProxyDomains) && proxyOptions.noProxyDomains.length > 0) {
      for (var i in proxyOptions.noProxyDomains) {
        logger.trace("[ProxyUtils] proxifyUrl : analyzing " + proxyOptions.noProxyDomains[i]);
        if (url.indexOf(proxyOptions.noProxyDomains[i]) !== -1) {
          logger.info("[ProxyUtils] proxifyUrl : " + url + " found in noProxyDomains list (" + proxyOptions.noProxyDomains[i] + ").");
          return url;
        }
      }
    }
    return proxyOptions.proxyUrl + encodeURIComponent(url);
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ProxyUtils);

/***/ }),

/***/ "./src/packages/Utils/SelectorID.js":
/*!******************************************!*\
  !*** ./src/packages/Utils/SelectorID.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module SelectorID
 * @alias module:~utils/SelectorID
 * @private
 * @description
 * formalisme d'un tag ID :
 * -> NAME(_ORDER)-1460636385836
 *
 * @example
 * Ex.
 *   GProutePoints-1460636385836
 *   GProutePoint_10-1460636385836
 */
var SelectorID = {
  /**
   * Construction d'un identifiant statique basé sur le timestamp,
   * et qui s'incremente de +1 à chaque appel
   * @function generate
   */
  generate: function () {
    var timestamp = Math.floor(Date.now());
    return function () {
      return timestamp++;
    };
  }(),
  /**
   * nom du tag
   * @function name
   * @param {String} id - the id
   * @returns {String} index
   */
  name: function name(id) {
    var name = null;
    var i = id.lastIndexOf("-");
    if (i === -1) {
      name = id;
    } else {
      name = id.substring(0, i);
    }
    return name;
  },
  /**
   * numero d'identifiant du tag
   *
   * @function index
   * @param {String} id - the id
   * @returns {String} index
   */
  index: function index(id) {
    var index = null;
    var name = this.name(id);
    // if (name !== id) {
    var i = name.lastIndexOf("_");
    if (i !== -1) {
      index = name.substring(i + 1);
    }
    // }

    return index;
  },
  /**
   * uuid du tag
   *
   * @function uuid
   * @param {String} id - the id
   * @returns {String} uuid
   */
  uuid: function uuid(id) {
    var uuid = null;
    var i = id.lastIndexOf("-");
    if (i !== -1) {
      uuid = parseInt(id.substring(i + 1), 10);
    }
    return uuid;
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SelectorID);

/***/ }),

/***/ "./node_modules/es6-promise/dist/es6-promise.js":
/*!******************************************************!*\
  !*** ./node_modules/es6-promise/dist/es6-promise.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.8+1e68dce6
 */

(function (global, factory) {
	 true ? module.exports = factory() :
	0;
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && "function" === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    var then$$1 = void 0;
    try {
      then$$1 = value.then;
    } catch (error) {
      reject(promise, error);
      return;
    }
    handleMaybeThenable(promise, value, then$$1);
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = true;

  if (hasCallback) {
    try {
      value = callback(detail);
    } catch (e) {
      succeeded = false;
      error = e;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (succeeded === false) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = void 0;
      var error = void 0;
      var didError = false;
      try {
        _then = entry.then;
      } catch (e) {
        didError = true;
        error = e;
      }

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        if (didError) {
          reject(promise, error);
        } else {
          handleMaybeThenable(promise, entry, _then);
        }
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    if (isFunction(callback)) {
      return promise.then(function (value) {
        return constructor.resolve(callback()).then(function () {
          return value;
        });
      }, function (reason) {
        return constructor.resolve(callback()).then(function () {
          throw reason;
        });
      });
    }

    return promise.then(callback, callback);
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof __webpack_require__.g !== 'undefined') {
    local = __webpack_require__.g;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));



//# sourceMappingURL=es6-promise.map


/***/ }),

/***/ "./node_modules/eventbusjs/lib/eventbus.min.js":
/*!*****************************************************!*\
  !*** ./node_modules/eventbusjs/lib/eventbus.min.js ***!
  \*****************************************************/
/***/ (function(module) {

(function(root,factory){if(true)module.exports=factory();else {}})(this,function(){var EventBusClass={};EventBusClass=function(){this.listeners={}};EventBusClass.prototype={addEventListener:function(type,callback,scope){var args=[];var numOfArgs=arguments.length;for(var i=0;i<numOfArgs;i++){args.push(arguments[i])}args=args.length>3?args.splice(3,args.length-1):[];if(typeof this.listeners[type]!="undefined"){this.listeners[type].push({scope:scope,callback:callback,args:args})}else{this.listeners[type]=[{scope:scope,callback:callback,args:args}]}},removeEventListener:function(type,callback,scope){if(typeof this.listeners[type]!="undefined"){var numOfCallbacks=this.listeners[type].length;var newArray=[];for(var i=0;i<numOfCallbacks;i++){var listener=this.listeners[type][i];if(listener.scope==scope&&listener.callback==callback){}else{newArray.push(listener)}}this.listeners[type]=newArray}},hasEventListener:function(type,callback,scope){if(typeof this.listeners[type]!="undefined"){var numOfCallbacks=this.listeners[type].length;if(callback===undefined&&scope===undefined){return numOfCallbacks>0}for(var i=0;i<numOfCallbacks;i++){var listener=this.listeners[type][i];if((scope?listener.scope==scope:true)&&listener.callback==callback){return true}}}return false},dispatch:function(type,target){var event={type:type,target:target};var args=[];var numOfArgs=arguments.length;for(var i=0;i<numOfArgs;i++){args.push(arguments[i])}args=args.length>2?args.splice(2,args.length-1):[];args=[event].concat(args);if(typeof this.listeners[type]!="undefined"){var listeners=this.listeners[type].slice();var numOfCallbacks=listeners.length;for(var i=0;i<numOfCallbacks;i++){var listener=listeners[i];if(listener&&listener.callback){var concatArgs=args.concat(listener.args);listener.callback.apply(listener.scope,concatArgs)}}}},getEvents:function(){var str="";for(var type in this.listeners){var numOfCallbacks=this.listeners[type].length;for(var i=0;i<numOfCallbacks;i++){var listener=this.listeners[type][i];str+=listener.scope&&listener.scope.className?listener.scope.className:"anonymous";str+=" listen for '"+type+"'\n"}}return str}};var EventBus=new EventBusClass;return EventBus});

/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js":
/*!**************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Errors raised by API for one among three reasons : wrong API usage, underlying service error or unknown reason.
 *
 * @property {String} message - Error message
 * @property {Number} status - Error status : when {@link Gp.Error.TYPE_SRVERR}, gives the [HTTP status of the underlying web service response]{@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes} ; -1 otherwise.
 * @property {String} type - Error type ({@link Gp.Error.TYPE_SRVERR}, {@link Gp.Error.TYPE_USEERR} or {@link Gp.Error.TYPE_UNKERR}).
 *
 * @namespace
 * @alias Gp.Error
 * @param {Object|String} error - Options for creating error object. Can be a String (message) or an Object.
 * @param {String} error.message - Error message to return to user.
 * @param {enum} [error.type=TYPE_UNKERR] - Error type
 * @param {status} [error.status=-1] - Error status : when {@link Gp.Error.TYPE_SRVERR}, gives the [HTTP status of the underlying web service response]{@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes}.
 *
 */
function ErrorService (error) {
    if (!(this instanceof ErrorService)) {
        throw new TypeError("ErrorService constructor cannot be called as a function.");
    }

    var e = error;
    if (typeof error === "string" || error instanceof String) {
        this.message = error;
        this.status = -1;
        this.type = ErrorService.TYPE_UNKERR;
    } else {
        this.message = e.message || "undefined!?";
        this.type = e.type;
        this.status = e.status || -1;
    }

    this.name = "ErrorService";
    this.stack = (new Error()).stack;
}

/**
 * Error raised when underlying geoportal service answers on error.
 *
 * @type {String}
 * @constant
 * @static
 */
ErrorService.TYPE_SRVERR = "SERVICE_ERROR";
/**
 * Error raised when funcion use is inappropriate
 *
 * @type {String}
 * @constant
 * @static
 */
ErrorService.TYPE_USEERR = "USAGE_ERROR";
/**
 * Error raised when API can't perform the job for a reason other than the two other ones.
 *
 * @type {String}
 * @constant
 * @static
 */
ErrorService.TYPE_UNKERR = "UNKNOWN_ERROR";

/**
 * @lends module:ErrorService
 */
ErrorService.prototype = Object.create(Error.prototype, {
    constructor : {
        value : ErrorService,
        writable : true,
        configurable : true
    }
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ErrorService);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Formats/WPS.js":
/*!**************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Formats/WPS.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");


/**
 * @classdesc
 * Standard WPS
 *
 * @constructor
 * @alias Gp.Formats.WPS
 * @param {Object} options - options
 * @param {Object}   options.data - objet
 * @param {String}   options.method - POST|GET
 * @param {String}   options.param.service - "WPS"
 * @param {String}   options.param.version - "1.0.0"
 * @param {String}   options.param.identifier - "gs:WPSElevation|gs:WPSLineElevation"
 * @param {String}   options.param.rawdataoutput - "result"
 * @param {String}   options.param.request - "Execute"
 * @param {Function} options.onsuccess - function callback success (TODO)
 * @param {Function} options.onerror   - function callback error   (TODO)
 * @private
 */
function WPS (options) {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur WPS()]");

    if (!(this instanceof WPS)) {
        throw new TypeError("WPS constructor cannot be called as a function.");
    }

    this.options = options || {};

    /**
     * Objet DATA
     */
    this.DataObject = this.options.data;

    if (!this.DataObject) {
        throw new TypeError("This data object is not defined !");
    }

    /**
     * param service.
     * Par defaut, "WPS".
     */
    this.paramservice = this.options.param.service || "WPS";

    /**
     * param version.
     * Par defaut, "1.0.0".
     */
    this.paramversion = this.options.param.version || "1.0.0";

    /**
     * param identifier
     * Par defaut, "gs:WPS"
     */
    this.paramidentifier = this.options.param.identifier || "gs:WPS";

    /**
     * param rawdataoutput
     * Par defaut, "result".
     */
    this.paramrawdataoutput = this.options.param.rawdataoutput || "result";

    /**
     * param request
     * Par defaut, "Execute".
     */
    this.paramrequest = this.options.param.request || "Execute";

    /**
     * methode.
     * Par defaut, "GET".
     */
    this.method = this.options.method || "GET";
}

WPS.prototype = {

    /**
     * @lends module:WPS#
     */

    /**
     * request
     * @type {String}
     */
    requestString : null,

    /**
     * Constructeur (alias)
     */
    constructor : WPS,

    /**
     * Template de la requête.
     */
    template : {
        get : {
            value : "service=__SERVICE__" +
                "&version=__VERSION__" +
                "&rawdataoutput=__RAWDATAOUTPUT__" +
                "&identifier=__IDENTIFIER__" +
                "&request=__REQUEST__" +
                "&datainputs=<!-- __DATAINPUTS__ -->",

            input : "__KEY__=__DATA__"

        },
        post : {

            value : "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
                "<wps:__REQUEST__ version=\"__VERSION__\" service=\"__SERVICE__\" " +
                "__NAMESPACE__ __SCHEMALOCATION__>" +
                "<ows:Identifier>__IDENTIFIER__</ows:Identifier>" +
                "<wps:DataInputs>" +
                "<!-- __DATAINPUTS__ -->" +
                "</wps:DataInputs>" +
                "<wps:ResponseForm>" +
                "<wps:RawDataOutput>" +
                "<ows:Identifier>__RAWDATAOUTPUT__</ows:Identifier>" +
                "</wps:RawDataOutput>" +
                "</wps:ResponseForm>" +
                "</wps:__REQUEST__>",

            input : "<wps:Input>" +
                "<ows:Identifier>__KEY__</ows:Identifier>" +
                "<wps:Data>" +
                "<wps:LiteralData>__DATA__</wps:LiteralData>" +
                "</wps:Data>" +
                "</wps:Input>"
        }
    },

    /**
     * Namespace par defaut de la requete POST.
     *
     * @returns {String} namespace
     */
    namespaceByDefault : function () {
        var ns = [
            "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"",
            "xmlns=\"http://www.opengis.net/wps/1.0.0\"",
            "xmlns:wfs=\"http://www.opengis.net/wfs\"",
            "xmlns:wps=\"http://www.opengis.net/wps/1.0.0\"",
            "xmlns:ows=\"http://www.opengis.net/ows/1.1\"",
            "xmlns:gml=\"http://www.opengis.net/gml\"",
            "xmlns:ogc=\"http://www.opengis.net/ogc\"",
            "xmlns:wcs=\"http://www.opengis.net/wcs/1.1.1\"",
            "xmlns:xlink=\"http://www.w3.org/1999/xlink\""
        ];

        return ns.join(" ");
    },

    /**
     * Schemalocation par defaut.
     *
     * @returns {String} schemaLocation
     */
    schemaLocationByDefault : function () {
        return "xsi:schemaLocation=\"http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd\"";
    },

    /**
     * Construction de la requête.
     *
     * @example
     * // GET  out :
     * //  service=__SERVICE__
     * //  &version=__VERSION__
     * //  &rawdataoutput=__RAWDATAOUTPUT__
     * //  &identifier=__IDENTIFIER__
     * //  &request=__REQUEST__
     * //  &datainputs="__DATAINPUTS__"
     * //  avec __DATAINPUTS__ = __KEY__=__DATA__;...
     *
     * // POST out :
     * //      <?xml version=\"1.0\" encoding=\"UTF-8\"?>
     * //      <wps:__REQUEST__ version=\"__VERSION__\" service=\"__SERVICE__\"
     * //         __NAMESPACE__ __SCHEMALOCATION__>
     * //          <ows:Identifier>__IDENTIFIER__</ows:Identifier>
     * //          <wps:DataInputs>
     * //              <!-- __DATAINPUTS__ -->
     * //          </wps:DataInputs>
     * //          <wps:ResponseForm>
     * //              <wps:RawDataOutput>
     * //              <ows:Identifier>__RAWDATAOUTPUT__</ows:Identifier>
     * //              </wps:RawDataOutput>
     * //          </wps:ResponseForm>
     * //      </wps:__REQUEST__>",
     * //      avec __DATAINPUTS__
     * //             <wps:Input>
     * //                  <ows:Identifier>__KEY__</ows:Identifier>
     * //                  <wps:Data>
     * //                    <wps:LiteralData>__DATA__</wps:LiteralData>
     * //                  </wps:Data>
     * //              </wps:Input>
     *
     * @returns {Boolean} validation de la construction de la requete
     */
    processRequestString : function () {
        this.logger.trace("WPS::processRequestString ()");

        var template = "";
        if (this.method === "POST") {
            template = this.template.post.value;
        } else if (this.method === "GET") {
            template = this.template.get.value;
        } else {
            this.logger.error("No other method supported by the service !");
            return false;
        }

        template = template.replace(/__SERVICE__/g, this.paramservice);
        template = template.replace(/__VERSION__/g, this.paramversion);
        template = template.replace(/__RAWDATAOUTPUT__/g, this.paramrawdataoutput);
        template = template.replace(/__IDENTIFIER__/g, this.paramidentifier);
        template = template.replace(/__REQUEST__/g, this.paramrequest);

        // ajout +
        if (this.method === "POST") {
            template = template.replace(/__NAMESPACE__/g, this.namespaceByDefault);
            template = template.replace(/__SCHEMALOCATION__/g, this.schemaLocationByDefault);
        }

        // ajout des datainputs
        template = template.replace(/<!-- __DATAINPUTS__ -->/g, this.__addDataInputs());

        if (!template) {
            this.logger.warn("traduction tmpl : empty request !?");
            return false;
        }

        this.requestString = template;
        this.logger.trace("traduction tmpl", template);

        return true;
    },

    /**
     * Ajout des données
     *
     * @returns {String} Données concaténées dans une chaine
     */
    __addDataInputs : function () {
        this.logger.trace("WPS::__addDataInputs ()");

        // c'est un peu grossier...
        var tmpl = this.method === "GET" ? this.template.get.input : this.template.post.input;
        var sep = this.method === "GET" ? ";" : "";

        var result = "";
        var that = this;
        var map = this.DataObject.getData();
        for (var i = 0; i < map.length; i++) {
            // FIXME closure ?
            (function (j) {
                if (sep) {
                    sep = (j === map.length - 1) ? "" : ";";
                }
                result = result.concat(that.__addDataInput(tmpl, map[j].k, map[j].v), sep);
            })(i);
        }

        return result;
    },

    /**
     * Ajout d'une donnée.
     *
     * @param {String} tmpl - template
     * @param {String} key - clef
     * @param {String} data - valeur
     * @returns {String} chaine avec les substitutions clef/valeur
     */
    __addDataInput : function (tmpl, key, data) {
        var tmp = tmpl;
        tmp = tmp.replace(/__KEY__/g, key);
        tmp = tmp.replace(/__DATA__/g, data);
        return tmp;
    },

    /**
     * Definir le mode de requête
     *
     * @param {String} method - GET|POST
     */
    setMethod : function (method) {
        if (method === "GET" || method === "POST") {
            this.method = method;
        } else {
            this.logger.warn("support only GET and POST method !");
        }
    },

    /**
     * Retourne le mode de requete (GET|POST).
     *
     * @returns {AltiRequest.options.mode|String} methode (GET|POST)
     */
    getMethod : function () {
        return this.method;
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WPS);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Formats/XML.js":
/*!**************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Formats/XML.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* global require */


// import __xmldom from "xmldom";

/**
 * @classdesc
 *
 * Classe permettant d'écrire ou de lire du XML, sous forme de document DOM,
 * éventuellement selon des clés de lecture (readers) ou d'écriture (writers) spécifiques.
 *
 * @constructor
 * @alias Gp.Formats.XML
 *
 * @param {Object} [options] - options du format XML
 *
 * @param {Object} [options.reader] - Instance d'un Reader de service (AltiResponseReader, GeocodeRequestReader, etc.)
 *      utile pour interpréter le XML lorsque sa structure est connue.
 *      Ce reader doit comporter au moins une fonction statique read (root) permettant d'initialiser la lecture.
 *
 * @param {Object} [options.writers] - writers
 *
 * @param {String} [options.xmlString] - chaîne de caractère contenant du XML à interpréter.
 *
 * @private
 */
function XML (options) {
    if (!(this instanceof XML)) {
        throw new TypeError("XML constructor cannot be called as a function.");
    }

    // FIXME : notion de singleton

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur XML ()]");

    /**
     * Chaîne de caractères contenant le texte XML
     * @type {String}
     */
    this.xmlString = null;

    /**
     * DOM Element correspondant à la structure du XML.
     * @type {DOMElement}
     */
    this.xmlDoc = null;

    /**
     * Objet contenant des fonctions de lecture des différentes balises XML.
     * @type {Object}
     */
    this.reader = null;

    // traitement des paramètres d'options s'il y en a
    if (options) {
        if (options.xmlString && typeof options.xmlString === "string") {
            this.xmlString = options.xmlString;
            // Si une chaine de caractère a été passée en entrée : on la transforme aussi en XML document
            this.xmlDoc = __getXMLDOC(options.xmlString);
        }
        if (options.reader) {
            this.setReader(options.reader);
        }
    }
}

XML.prototype = {

    /**
     * @lends module:XML
     */

    /*
     * Constructeur (alias)
     */
    constructor : XML,

    /**
     * Méthode permettant de récupérer la chaîne de caractères associée au format XML
     *
     * @returns {String} xmlString - la chaîne de caractères correspondant au format XML
     */
    getXMLString : function () {
        return this.xmlString;
    },

    /**
     * Méthode permettant d'attribuer une chaîne de caractères au format XML (attribut xmlString).
     * La méthode va aussi transformer cette chaîne de caractères en document XML,
     * afin de remplir l'attribut xmlDoc.
     *
     * @param {String} xmlString - la chaîne de caractères correspondant au format XML
     */
    setXMLString : function (xmlString) {
        if (xmlString && typeof xmlString === "string") {
            this.xmlString = xmlString;
            this.xmlDoc = __getXMLDOC(xmlString);
        }
    },

    /**
     * Méthode permettant de récupérer les readers associés au format XML, s'ils ont été définis
     *
     * @return {Object} readers - les readers associés au format XML, s'ils existent,
     *      sous forme d'une collection de fonctions
     */
    getReader : function () {
        return this.reader;
    },

    /**
     * Méthode permettant d'attribuer des readers, sous la forme d'un objet de fonctions (node, data),
     *      lorsqu'ils n'ont pas été définis lors de l'instanciation par exemple (new XML (options)).
     *
     * @param {Object} reader - Instance d'un Reader de service (AltiResponseReader, GeocodeRequestReader, etc.)
     *      utile pour interpréter le XML lorsque sa structure est connue.
     *      Ce reader doit comporter au moins une fonction statique read (root) permettant d'initialiser la lecture.
     */
    setReader : function (reader) {
        if (reader && reader.read && typeof reader.read === "function") {
            this.reader = reader;
        }
    },

    /**
     * Méthode permettant de récupérer le document XML associé au format, s'il existe.
     *
     * @return {DOMElement} xmlDoc - le document XML (DOM document node) s'il existe
     */
    getXMLDoc : function () {
        return this.xmlDoc;
    },

    /**
     * Setter
     */
    setXMLDoc : function (doc) {
        this.xmlDoc = doc;
    },
    /**
     * Méthode initialisant la lecture du XML, à partir d'un XML Document :
     *      création d'un objet JavaScript contenant les informations du XML,
     *      sauf dans le cas où il n'existe pas de XML Document à interpréter (retourne un objet vide).
     *
     * @return {Object} [parserOutput] - un objet JavaScript contenant les informations du XML :
     * - soit toutes les informations si aucun reader n'a été spécifié à la création du format
     * - soit les informations spécifiées dans le reader.
     */
    parse : function () {
        // build xml document from xmlString
        if (!this.xmlDoc && this.xmlString) {
            this.xmlDoc = __getXMLDOC(this.xmlString);
        }
        if (this.xmlDoc) {
            var root = __getRootNode(this.xmlDoc);
            if (root) {
                var parserOutput;
                // call reader if exists
                if (this.reader && this.reader.read) {
                    parserOutput = this.reader.read(root);
                } else {
                    parserOutput = {};
                    parserOutput[root.nodeName] = __readDefault(root);
                }
                return parserOutput;
            } else {
                return {};
            }
        }
    }

};

/**
 * Méthode de la classe (privée) permettant de créer un XML Document à partir d'une chaîne de caractères XML,
 *      en utilisant DOMParser () lorsque c'est possible.
 *      For more information, see: https://dvcs.w3.org/hg/innerhtml/raw-file/tip/index.html#the-domparser-interface
 *
 * @private
 * @memberof XML
 * @method __getXMLDOC
 * @param {String} xmlString - xml string to be converted into DOM element
 * @return {DOMElement} - the corresponding XML Document
 */
function __getXMLDOC (xmlString) {
    if (typeof window === "undefined") {
        // env. nodejs
        var DOMParser = (__webpack_require__(/*! @xmldom/xmldom */ "./node_modules/@xmldom/xmldom/lib/index.js").DOMParser); // __xmldom.DOMParser;
        return new DOMParser().parseFromString(xmlString, "text/xml");
    } else {
        // env. browser

        var parser;
        var xmlDoc;
        var errorMsg = "Erreur lors du parsing de la réponse du service : XML non conforme";

        if (window.ActiveXObject) {
            // Internet Explorer < 9
            xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
            xmlDoc.async = false;
            xmlDoc.loadXML(xmlString);
            var parseError = xmlDoc.parseError;
            if (parseError.errorCode) {
                if (parseError.line && parseError.linepos) {
                    errorMsg += "( ligne " + parseError.line + ", colonne " + parseError.linepos;
                }
                if (parseError.reason) {
                    errorMsg += ":  " + parseError.reason + ")";
                }
                throw new Error(errorMsg);
            }
            return xmlDoc;
        } else if (window.DOMParser) {
            // les autres (Chrome, Mozilla, IE >= 9)
            parser = new window.DOMParser();
            try {
                xmlDoc = parser.parseFromString(xmlString, "text/xml");
            } catch (e) {
                // Internet Explorer browser raises exception if xmlString is not valid XML
                if (e.message === "SyntaxError") {
                    throw new Error(errorMsg);
                } else {
                    throw new Error("Erreur lors du parsing de la réponse du service : " + e.message);
                }
            }
            // look for parsing error in case no exception was raised
            if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
                var parsererror = xmlDoc.getElementsByTagName("parsererror");
                for (var i = 0; i < parsererror.length; i++) {
                    var content = parsererror[i].innerHTML;
                    // except in case parsererror is just because of huge xml, but parsing is done.
                    if (content.indexOf("Huge input lookup") === -1) {
                        errorMsg += "(" + content + ")";
                        throw new Error(errorMsg);
                    }
                }
            } else if (!xmlDoc.documentElement) { // may happen in chrome browser
                throw new Error(errorMsg);
            }
            return xmlDoc;
        } else {
            // FIXME
            throw new Error("Incompatible DOM Parser pour ce navigateur !");
        }
    }
}

/**
 * Méthode de la classe (privée) permettant de récupérer le noeud racine du document,
 *      à partir d'un document node (nodeType=9), puis lecture de ce noeud (readNode)
 *
 * @private
 * @memberof XML
 * @method __getRootNode
 * @param {DOMElement} [xmlDoc] - a Document Node
 * @return {DOMElement} root - the document root node
 */
function __getRootNode (xmlDoc) {
    var root;
    if (xmlDoc.nodeType === 9) {
        // INFO : nodeType 9 represents the entire document (the root-node of the DOM tree)
        root = xmlDoc.documentElement;
    } else if (xmlDoc.nodeType === 1) {
        root = xmlDoc;
    }
    return root;
}

/**
 * Méthode de la classe (privée) permettant de lire automatiquement un noeud XML,
 *      lorsqu'aucun reader spécifique n'a été spécifié (parser brut)
 *
 * @private
 * @memberof XML
 * @method readDefault
 * @param {DOMElement} node - a DOM element node
 * @example final data object looks like :
 *          data = {
 *              attributeName: attributeValue,
 *              childName: {
 *                  attributeName: attributeValue,
 *                  attributeName: attributeValue,
 *                  childName: {
 *                      "textContent": textContent
 *                  },
 *                  childName: {
 *                      childName: {
 *                          attributeName:attributeValue
 *                      }
 *                  }
 *              }
 *          }
 */
function __readDefault (node) {
    var data = {};

    // if element node has attributes, set their values to data
    if (node.attributes.length > 0) {
        var dataAttributes = __getAttributes(node);
        data["attributes"] = dataAttributes;
    }

    // if element node has childNodes, read them and set them to data
    if (node.hasChildNodes()) {
        var childData = {};
        var child;
        var children = node.childNodes;

        for (var i = 0; i < children.length; i++) {
            child = children[i];

            if (child.nodeType === 3) { // TEXT_NODE
                data["textContent"] = child.nodeValue;
            } else if (child.nodeType === 1) {
                childData = __readDefault(child);

                if (!data[child.nodeName]) {
                    // store childData in an object
                    data[child.nodeName] = childData;
                } else {
                    // in case several childNodes has the same name : store them in an array.
                    // if data[nodeName] already exists but is not an array
                    if (!Array.isArray(data[child.nodeName])) {
                        var old = data[child.nodeName];
                        data[child.nodeName] = [];
                        data[child.nodeName].push(old);
                    }
                    data[child.nodeName].push(childData);
                }
            }
            // TODO : manage other node types (4=CDATA, etc)
        }
    }

    return data;
}

/**
 * Méthode de la classe (privée) permettant de récupérer les attributs d'un noeud élément
 *
 * @private
 * @memberof XML
 * @method __getAttributes
 * @param {DOMElement} node - noeud contenant l'attribut recherché
 * @return {Object} nodeAttributes - objet contenant les noms et valeurs des différents attributs
 */
function __getAttributes (node) {
    if (node.attributes.length > 0) {
        var nodeAttributes = {};
        var attributes = node.attributes;
        for (var i = 0; i < attributes.length; i++) {
            var attribute = attributes[i];
            nodeAttributes[attribute.nodeName] = attribute.nodeValue;
        }
        return nodeAttributes;
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (XML);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Gp.js":
/*!*****************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Gp.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   servicesDate: () => (/* binding */ servicesDate),
/* harmony export */   servicesVersion: () => (/* binding */ servicesVersion)
/* harmony export */ });
/* harmony import */ var _Services_Services__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Services/Services */ "./node_modules/geoportal-access-lib/src/Services/Services.js");
/* harmony import */ var _Services_DefaultUrlService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Services/DefaultUrlService */ "./node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js");
/* harmony import */ var _Services_Alti_Response_model_AltiResponse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Services/Alti/Response/model/AltiResponse */ "./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/AltiResponse.js");
/* harmony import */ var _Services_Alti_Response_model_Elevation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Services/Alti/Response/model/Elevation */ "./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/Elevation.js");
/* harmony import */ var _Services_AutoComplete_Response_model_AutoCompleteResponse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Services/AutoComplete/Response/model/AutoCompleteResponse */ "./node_modules/geoportal-access-lib/src/Services/AutoComplete/Response/model/AutoCompleteResponse.js");
/* harmony import */ var _Services_AutoComplete_Response_model_SuggestedLocation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Services/AutoComplete/Response/model/SuggestedLocation */ "./node_modules/geoportal-access-lib/src/Services/AutoComplete/Response/model/SuggestedLocation.js");
/* harmony import */ var _Services_ProcessIsoCurve_Response_model_ProcessIsoCurveResponse__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Services/ProcessIsoCurve/Response/model/ProcessIsoCurveResponse */ "./node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/Response/model/ProcessIsoCurveResponse.js");
/* harmony import */ var _Services_Route_Response_model_RouteResponse__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Services/Route/Response/model/RouteResponse */ "./node_modules/geoportal-access-lib/src/Services/Route/Response/model/RouteResponse.js");
/* harmony import */ var _Services_Route_Response_model_RouteInstruction__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Services/Route/Response/model/RouteInstruction */ "./node_modules/geoportal-access-lib/src/Services/Route/Response/model/RouteInstruction.js");
/* harmony import */ var _Services_Config_Config__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Services/Config/Config */ "./node_modules/geoportal-access-lib/src/Services/Config/Config.js");
/* harmony import */ var _Protocols_XHR__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Protocols/XHR */ "./node_modules/geoportal-access-lib/src/Protocols/XHR.js");
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Exceptions/ErrorService */ "./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js");
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Utils/Helper */ "./node_modules/geoportal-access-lib/src/Utils/Helper.js");
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../package.json */ "./node_modules/geoportal-access-lib/package.json");
/**
* Global variable Gp.
*
* @module Gp
* @alias Gp
* @description
*
* This is the global variable that is exposed in the browser environment.
* Content is composed of constructor, functions and properties...
*
* > {@link Gp.Error Error()}
*     - .TYPE_SRVERR : "SERVICE_ERROR"
*     - .TYPE_UNKERR : "UNKNOWN_ERROR"
*     - .TYPE_USEERR : "USAGE_ERROR"
*
* > {@link module:Helper Helper}
*     - .indent()
*     - .normalyzeParameters()
*     - .normalyzeUrl()
*
* > {@link module:XHR Protocols.XHR}
*     - .call()
*
* > {@link module:Services Services (objects)}
*     - .Alti
*         - {@link Gp.Services.Alti.Elevation .Elevation()}
*     - {@link Gp.Services.AltiResponse .AltiResponse()}
*     - .AutoComplete
*         - {@link Gp.Services.AutoComplete.SuggestedLocation .SuggestedLocation()}
*     - {@link Gp.Services.AutoCompleteResponse .AutoCompleteResponse()}
*     - {@link Gp.Services.Config .Config()}
*     - {@link Gp.Services.DefaultUrl .DefaultUrl()}
*     - {@link Gp.Services.GeocodeResponse .GeocodeResponse()}
*     - {@link Gp.Services.GetConfigResponse .GetConfigResponse()}
*     - {@link Gp.Services.IsoCurveResponse .IsoCurveResponse()}
*     - .Route
*         - {@link Gp.Services.Route.RouteInstruction .RouteInstruction()}
*     - {@link Gp.Services.RouteResponse .RouteResponse()}
*
* > Services (factory)
*     - {@link module:Services~autoComplete .autoComplete()}
*     - {@link module:Services~geocode .geocode()}
*     - {@link module:Services~getAltitude .getAltitude()}
*     - {@link module:Services~getConfig .getConfig()}
*     - {@link module:Services~isoCurve .isoCurve()}
*     - {@link module:Services~reverseGeocode .reverseGeocode()}
*     - {@link module:Services~route .route()}
*
* > servicesDate : "YYYY-MM-DD"
*
* > servicesVersion : "X.X.X"
*
*/

















/** Version */
const servicesVersion = _package_json__WEBPACK_IMPORTED_MODULE_13__.version;
/** Publication date */
const servicesDate = _package_json__WEBPACK_IMPORTED_MODULE_13__.date;

// on declare les ns dans root global
var Gp = {};

Gp.servicesVersion = servicesVersion;
Gp.servicesDate = servicesDate;

// Export Protocols
Gp.Protocols = {};
Gp.Protocols.XHR = _Protocols_XHR__WEBPACK_IMPORTED_MODULE_10__["default"];
// Export services
Gp.Services = _Services_Services__WEBPACK_IMPORTED_MODULE_0__["default"];
// Export DefaultUrls
Gp.Services.DefaultUrl = _Services_DefaultUrlService__WEBPACK_IMPORTED_MODULE_1__["default"];
// Export Alti
Gp.Services.AltiResponse = _Services_Alti_Response_model_AltiResponse__WEBPACK_IMPORTED_MODULE_2__["default"];
Gp.Services.Alti = {};
Gp.Services.Alti.Elevation = _Services_Alti_Response_model_Elevation__WEBPACK_IMPORTED_MODULE_3__["default"];
// Export Autocomplete
Gp.Services.AutoCompleteResponse = _Services_AutoComplete_Response_model_AutoCompleteResponse__WEBPACK_IMPORTED_MODULE_4__["default"];
Gp.Services.AutoComplete = {};
Gp.Services.AutoComplete.SuggestedLocation = _Services_AutoComplete_Response_model_SuggestedLocation__WEBPACK_IMPORTED_MODULE_5__["default"];
// Export Config
Gp.Services.Config = _Services_Config_Config__WEBPACK_IMPORTED_MODULE_9__["default"];
// Export IsoCurve
Gp.Services.IsoCurveResponse = _Services_ProcessIsoCurve_Response_model_ProcessIsoCurveResponse__WEBPACK_IMPORTED_MODULE_6__["default"];
// Export Route
Gp.Services.RouteResponse = _Services_Route_Response_model_RouteResponse__WEBPACK_IMPORTED_MODULE_7__["default"];
Gp.Services.Route = {};
Gp.Services.Route.RouteInstruction = _Services_Route_Response_model_RouteInstruction__WEBPACK_IMPORTED_MODULE_8__["default"];
// Export Erreurs et Outils
Gp.Error = _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_11__["default"];
Gp.Helper = _Utils_Helper__WEBPACK_IMPORTED_MODULE_12__["default"];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Gp);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Protocols/JSONP.js":
/*!******************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Protocols/JSONP.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/**
 * JSONP : Implémentation du protocole JSONP de la plateforme Géoportail
 *
 * @module JSONP
 * @private
 * @alias Gp.Protocols.JSONP
 */


// cf. https://github.com/sobstel/jsonp.js
var JSONP = {

    /**
     * Construction d'un identifiant statique basé sur le timestamp,
     * et qui s'incremente de +1 à chaque appel
     */
    uuid : (function () {
        var id = Math.floor(Date.now());
        return function () {
            return id++;
        };
    })(),

    /**
     * Cette fonction réalise l'appel du service fourni via le paramètre "options.url"
     * en mettant en œuvre le protocole JSONP.
     *
     * @method call
     * @static
     * @param {Object} options - parametres d'invocation du service en JSONP
     * @param {String} options.url - URL du service à invoquer (indépendamment du protocole JSONP).
     *  Cette URL contient déjà les paramètres du service.
     *  Si le paramètre dédié à la mise en oeuvre du protocole JSONP (callback=xxx) n'est pas présent, il est rajouté par la fonction ;
     *  sa valeur est déterminée en fonction du paramètre callbackName.
     * @param {Number} [options.timeOut = 0] - Nombre de ms au bout duquel on considère que le service n'a pas répondu.
     *  Une valeur de 0 pour ce paramètre permet de désactiver la gestion du timeOut.
     * @param {String} [options.callbackSuffix = null] - Suffixe de la fonction de callback à rajouter sur l'URL.
     *  Si aucun suffixe n'est spécifié (cas par défaut), on utilisera l'identifiant this.uuid () comme suffixe. Ex: "callback1458574396582 ()"
     * @param {String} [options.callbackName = gp.protocol.jsonp] - Valeur du paramètre callback à rajouter sur l'URL.
     *  Si l'URL fournie contient déjà le paramètre callback, le paramètre callbackName ne sera pas pris en compte.
     *  La fonction de callback est créée dynamiquement par la fonction JSONP ;
     *  elle a deux fonctions :
     *    elle annule la condition de timeOut
     *    puis appelle la fonction fournie par l'utilisateur via le paramètre onResponse.
     * @param {Function} options.onResponse - Nom de la fonction qui sera appelée lors de la réception des résultats du service.
     *  Ce paramètre sera ignoré si l'URL contient déjà le paramètre callback.
     *  La fonction de rappel appelée sera alors celle ayant pour nom la valeur de ce paramètre.
     * @param {Function} [options.onTimeOut] - Nom de la fonction qui sera appelée en cas de non réponse du service.
     *  Le temps au bout duquel on considère que le service n'a pas répondu est déterminé par le paramètre timeOut.
     *  @example
     *  var options = {
     *      url : 'http://localhost/some/test.json&callback=myResults',
     *      timeOut : 100,
     *      callbackName : 'myResults',
     *      callbackSuffix : "",
     *      onResponse : function (response) {
     *          console.log('results : ', response);
     *      },
     *
     *   };
     *   JSONP.call(options);
     */
    call : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("JSONP");
        logger.trace("[JSONP::call ()]");

        // analyse parametres

        if (!options) {
            logger.error("missing parameter : options !");
            throw new Error("missing parameter : options !");
        }

        if (!options.url) {
            logger.error("missing parameter : options.url !");
            throw new Error("missing parameter : options.url !");
        }

        if (!options.timeOut) {
            logger.info("setting 'options.timeOut' default value");
            options.timeOut = 0;
        }

        // FIXME si un callback coté client a été mis en place,
        // cette condition sur cette methode n'a pas de sens !?
        if (!options.onResponse) {
            logger.error("missing parameter : options.onResponse !");
            throw new Error("missing parameter : options.onResponse !");
            // FIXME doit on definir un callback interne par defaut !?
            // options.onResponse = function (data) {
            //    console.log("response callback (inner) : ", data);
            // };
        }

        // ID du callback à utiliser : null ou string.
        // si l'utilisateur a spécifié un suffixe pour le callback, on le récupère comme un ID (ex: options.callbackSuffix = "")
        // sinon, on utilise un timestamp : this.uuid ()
        var callbackId = (typeof options.callbackSuffix === "string") ? options.callbackSuffix : this.uuid();

        // on recherche le parametre callback et son nom de fonction dans l'url
        var urlHasCallbackKey = false;
        var urlHasCallbackName = false;

        var idx = options.url.indexOf("callback=");

        if (idx !== -1) {
            urlHasCallbackKey = true;
            // extraction callbackName de l'url : entre "callback=" et "&" ou fin de ligne
            var j = options.url.indexOf("&", idx);
            if (j === -1) {
                j = options.url.length;
            }

            // on ecrase le parametre options.callbackName s'il avait été défini
            var callbackName = options.url.substring(idx + 9, j);

            if (callbackName) {
                urlHasCallbackName = true;
                options.callbackName = callbackName;
                logger.info("setting 'options.callbackName' value (" + options.callbackName + ") from 'options.url' parameter");
            }
        }

        // on ajoute le parametre callback dans l'URL s'il n'existe pas
        if (!urlHasCallbackKey) {
            // gestion des autres param. et "?"
            var k = options.url.indexOf("?");
            if (k === -1) {
                // aucun param., ni de '?'
                options.url = options.url + "?" + "callback=";
            } else if (k === options.url.length) {
                // uniquement le '?'
                options.url = options.url + "callback=";
            } else {
                // le '?' et les param. existent
                options.url = options.url + "&" + "callback=";
            }
            logger.info("setting callback default key in 'options.url' : " + options.url);
        }

        // utilisation de la fonction callback coté client ?
        var HasCallbackName = options.callbackName ? true : urlHasCallbackName;

        // on ajoute le nom de la fonction callback dans l'URL si elle n'existe pas
        if (!urlHasCallbackName) {
            // fonction callback par defaut
            if (!options.callbackName) {
                logger.info("setting 'options.callbackName' default value");
                options.callbackName = "callback"; // ou "gp.protocol.jsonp" ?
                // info : si on ne veut pas gerer d'ID dans le callback,
                // options.callbackSuffix = ""
                if (callbackId || callbackId === "") {
                    options.callbackName += callbackId;
                }
            }
            options.url = options.url.replace("callback=", "callback=" + options.callbackName);
            logger.info("setting callback function name in 'options.url' : " + options.url);
        }

        // timeOut par defaut
        if (!options.onTimeOut) {
            logger.info("setting 'options.onTimeOut' default value");
            /** callback timeout par defaut */
            options.onTimeOut = function (/* error */) {
                console.log("TimeOut while invoking url : " + options.url);
            };
        }

        if (!HasCallbackName) {
            var self = this;

            // event du timeout
            var onTimeOutTrigger = null;

            // declenche le timeout si > à 0 !
            if (options.timeOut > 0) {
                onTimeOutTrigger = window.setTimeout(
                    function () {
                        /** fonction de reponse du service */
                        window[options.callbackName] = function () {};
                        options.onTimeOut();
                        self._deleteScript(callbackId);
                    }, options.timeOut);
            }

            // FIXME le nom de la fonction n'accepte pas de namespace !
            // ex. Gp.Function.callback
            /**
            * fonction de reponse du service
            * @param {Object} data - data
            * @private
            */
            window[options.callbackName] = function (data) {
                window.clearTimeout(onTimeOutTrigger);
                options.onResponse(data);
                self._deleteScript(callbackId);
            };
        }

        this._createScript(callbackId, options.url);
    },

    /**
    * create Script
    * @param {String} callbackId - callback Id
    * @param {String} url - url
    * @private
    */
    _createScript : function (callbackId, url) {
        var scriptu;
        var scripto = document.getElementById("results" + callbackId);

        scriptu = document.createElement("script");
        scriptu.setAttribute("type", "text/javascript");
        scriptu.setAttribute("src", url);
        scriptu.setAttribute("charset", "UTF-8");
        scriptu.setAttribute("id", "results" + callbackId);
        scriptu.setAttribute("async", "true"); // FIXME async ?
        // head ou body ou autres ?
        var node = document.documentElement || document.getElementsByTagName("head")[0];
        if (scripto === null) {
            node.appendChild(scriptu);
        } else {
            // s'il existe déjà, on le remplace !
            node.replaceChild(scriptu, scripto);
        }
    },

    /**
    * delete Script
    * @param {String} callbackId - callback Id
    * @private
    */
    _deleteScript : function (callbackId) {
        var script = document.getElementById("results" + callbackId);
        if (script) {
            var node = script.parentNode || document.documentElement;
            if (!node) {
                return;
            }
            node.removeChild(script);
        }
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (JSONP);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Protocols/Protocol.js":
/*!*********************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Protocols/Protocol.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/Helper */ "./node_modules/geoportal-access-lib/src/Utils/Helper.js");
/* harmony import */ var _XHR__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./XHR */ "./node_modules/geoportal-access-lib/src/Protocols/XHR.js");
/* harmony import */ var _JSONP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./JSONP */ "./node_modules/geoportal-access-lib/src/Protocols/JSONP.js");
/**
 * Interface de dialogue avec les webservices
 *
 * @module Protocols
 * @private
 * @alias Gp.Protocols
 */




var Protocol = {

    /**
     * Interface unique d"envoi d"une requête.
     *
     * @method send
     * @static
     * @param {Object} options - options generales
     * @param {String} options.url      - url du service
     * @param {String} options.method   - GET, POST, PUT, DELETE
     * @param {String} options.protocol - XHR | JSONP
     * @param {String} options.format   - format de la reponse du service : json, xml ou null (brute)...
     * @param {String} options.wrap     - encapsuler la reponse du service dans du JSON : true|false (true par defaut sur le protocole JSONP)
     * @param {String} options.callbackSuffix - suffixe de la fonction de callback (JSONP uniquement) (ex: si callbackSuffix="", la fonction s'appellera "callback")
     * @param {String} options.timeOut  - 0 ms
     * @param {Boolean} options.nocache  - true|false
     * @param {Object|String} options.data        - content (post) ou param (get)
     * @param {Object|String} options.headers     - (post) ex. referer
     * @param {Object|String} options.content - (post) ex. "application/json"
     * @param {String} options.scope       - this (TODO)
     * @param {Function} options.onResponse - callback
     * @param {Function} options.onFailure - callback
     * @param {Function} options.onTimeOut - callback
     * @param {String} options.proxyUrl -  (TODO)
     */
    send : function (options) {
        // INFO
        // "output" - param est interne à la classe "Protocol" (parametrable via "wrap"), et à ajouter à l"url
        //      ce param est independant du service car il est géré par le filtre LUA :
        //          ex. json|xml (json par defaut).
        //          Ce param. permet d"encapsuler du XML dans du JSON :
        //              {http : {status:200, error:null},xml :"réponse du service"}
        //          Utile pour les services qui ne repondent que du XML (ex. Geocodage)
        //
        // |-------------------------------------------------|
        // |      \service |      |     |                    |
        // | output\ format| json | xml |     remarques      |
        // |--------\------|------|-----|--------------------|
        // |    json       | json | json| json/xml encapsulé |
        // |    xml        | json | xml | param inactif      |
        // |-------------------------------------------------|
        // ex. le service demande une reponse native au "format" json et avec un "output" json.
        // on a donc une reponse json encapsulé dans un json : ce qu'on ne souhaite pas !
        // dans ce cas on ne renseigne pas output=json

        // INFO
        // "wrap" - choix d"encapsuler ou non les reponses dans du JSON.
        //      Par defaut, on encapsule uniquement les reponses sur le protocole JSONP (et qui sont en xml) !

        // INFO
        // "callback" - param est interne à la classe "Protocol" (non parametrable), et à ajouter à l"url
        //      ce param est independant du service car il est géré aussi par le filtre LUA :
        //          ex. callback|null
        //          Ce param. permet de renvoyer une reponse javascript :
        //              callback ({http : {status:200, error:null},xml :"réponse du service"})
        //          Ce param. est non renseigné par defaut car pour du JSONP, on utilise le
        //          le protocol JSONP, et ce dernier implemente déjà le callback !

        // settings par defaut
        var settings = options || {
            method : "GET",
            // protocol : "JSONP",
            protocol : "XHR",
            timeOut : 0,
            format : null,
            wrap : true,
            nocache : true,
            output : "json",
            callback : null,
            callbackSuffix : null
        };

        // on determine l'environnement d'execution : browser ou non ?
        // et on stoppe pour nodeJS... sur un protocole JSONP !
        if (typeof window === "undefined" && options.protocol === "JSONP") {
            console.log("Value (s) for parameter (s) 'protocol=JSONP (instead use XHR)' not supported to NodeJS");
            return;
        }

        if (options.protocol === "XHR" || options.format === "json") {
            settings.wrap = false;
        } else if (options.protocol === "JSONP" && options.format === "xml") {
            settings.wrap = true;
        }

        settings.callback = null; // FIXME non géré !?
        settings.output = settings.wrap ? "json" : null;

        // on encapsule les reponses dans un objet JSON
        if (settings.wrap) {
            var params = {};
            params.output = settings.output;
            params.callback = settings.callback;
            delete params.callback; // FIXME non géré !?
            settings.url = _Utils_Helper__WEBPACK_IMPORTED_MODULE_0__["default"].normalyzeUrl(options.url, params);
        }

        // choix de l"implementation :
        // XHR ou JSONP
        switch (settings.protocol) {
            case "XHR":
                // on normalise l'url (gestion du cache)
                if (options.method === "GET" && options.nocache) {
                    settings.url = _Utils_Helper__WEBPACK_IMPORTED_MODULE_0__["default"].normalyzeUrl(settings.url, {
                        t : new Date().getTime()
                    });
                }
                // appel du service en XHR
                _XHR__WEBPACK_IMPORTED_MODULE_1__["default"].call(settings);
                break;
            case "JSONP":

                // on normalise l'url si les params. sont renseignés dans la string|object "data"
                if (settings.data) {
                    settings.url = _Utils_Helper__WEBPACK_IMPORTED_MODULE_0__["default"].normalyzeUrl(settings.url, settings.data);
                }

                // appel du service en JSONP
                _JSONP__WEBPACK_IMPORTED_MODULE_2__["default"].call(settings);
                break;
            default:
                throw new Error("protocol not supported (XHR|JSONP) !");
        }
    }

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Protocol);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Protocols/XHR.js":
/*!****************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Protocols/XHR.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils/Helper */ "./node_modules/geoportal-access-lib/src/Utils/Helper.js");
/* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! es6-promise */ "./node_modules/es6-promise/dist/es6-promise.js");
/* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(es6_promise__WEBPACK_IMPORTED_MODULE_2__);
/* global Promise, require, XDomainRequest */




// import __request from "request";
// import __xmldom from "xmldom";

/**
 * Ajax Request (use of Promises)
 *
 * @module XHR
 * @alias Gp.Protocols.XHR
 * @see dependance 'es6-promise'
 */

// cf. https://xhr.spec.whatwg.org/
// cf. https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest

var XHR = {

    /**
     * Interface unique d'envoi d'une requête.
     *
     * @method call
     * @static
     * @param {Object} settings - options generales
     * @param {String} settings.url    - url du service
     * @param {String} settings.method - GET, POST, PUT, DELETE
     * @param {String} settings.format - format de la reponse du service : json, xml ou null (brute)
     * @param {String} settings.data   - content (post) ou param (get)
     * @param {String} settings.proxy  - proxy url
     * @param {Object|String} settings.headers - (post) ex. referer
     * @param {Object|String} settings.content - (post) ex. 'application/json'
     * @param {String} settings.timeOut - timeout = 0 par defaut
     * @param {String} settings.scope - this
     * @param {Function} settings.onResponse - callback
     * @param {Function} settings.onFailure  - callback
     */
    call : function (settings) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("XHR");
        logger.trace("[XHR::call()]");

        // FIXME
        // To polyfill the global environment
        es6_promise__WEBPACK_IMPORTED_MODULE_2___default().polyfill();

        // test sur les settings obligatoires
        if (!settings.url) {
            throw new Error("missing parameter : url is not defined !");
        }

        if (!settings.method) {
            throw new Error("missing parameter : method is not defined !");
        }

        if (!settings.format) {
            settings.format = "text"; // reponse brute !
        }

        var options = {};
        options.url = settings.url;
        options.data = settings.data ? settings.data : null;
        options.method = settings.method;
        options.timeOut = settings.timeOut || 0;
        options.scope = settings.scope || this;
        options.proxy = settings.proxy || null;
        options.content = settings.content || null;
        options.headers = settings.headers || {
            referer : "http://localhost"
        };

        // test sur les valeurs de 'settings.method'
        switch (settings.method) {
            case "DELETE":
            case "GET":
                break;
            case "PUT":
            case "POST":
                // on force sur ces params spécifiques au mode POST
                options.content = settings.content ? settings.content : "application/x-www-form-urlencoded"; // FIXME en attente des services : bascule en "application/xml" ou "application/json"
                options.headers = settings.headers ? settings.headers : { referer : "http://localhost" }; // FIXME parametrable...
                break;
            case "HEAD":
            case "OPTIONS":
                throw new Error("HTTP method not yet supported !");
            default:
                throw new Error("HTTP method unknown !");
        }

        // test sur les valeurs de 'settings.format'
        switch (settings.format) {
            case "text":
                this.__call(options)
                    .then(function (response) {
                        logger.trace(response);
                        settings.onResponse.call(this, response);
                    })
                    .catch(function (error) {
                        settings.onFailure.call(this, error);
                    });
                break;
            case "json":
                this.__callJSON(options)
                    .then(function (response) {
                        logger.trace(response);
                        settings.onResponse.call(this, response);
                    })
                    .catch(function (error) {
                        settings.onFailure.call(this, error);
                    });
                break;
            case "xml":
                this.__callXML(options)
                    .then(function (response) {
                        logger.trace(response);
                        settings.onResponse.call(this, response);
                    })
                    .catch(function (error) {
                        settings.onFailure.call(this, error);
                    });
                break;
            default:
                throw new Error("This output Format is not yet supported !");
        }
    },

    /**
     * Requete
     *
     * @method __call
     * @private
     * @param  {Object} options - options
     * @return {Object} promise
     */
    __call : function (options) {
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("XHR");
        logger.trace("[XHR::__call()]");

        var promise = new Promise(
            function (resolve, reject) {
                // traitement du corps de la requête
                var corps = (options.method === "POST" || options.method === "PUT") ? 1 : 0;

                // seulement si options.data n'est pas vide (peut être un objet ou une chaine de caractères)
                if (options.data && ((typeof options.data === "object" && Object.keys(options.data).length) || (typeof options.data === "string" && options.data.length)) && !corps) {
                    options.url = _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__["default"].normalyzeUrl(options.url, options.data);
                }

                logger.trace("URL = ", options.url);

                var hXHR = null;

                // test on env. nodejs or browser
                if (typeof window === "undefined") {
                    var nodefetch = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/browser.js");

                    var opts = {
                        headers : {
                            Referer : "https://localhost"
                        }
                    };

                    if (options.data && typeof options.data === "string" && corps) {
                        opts = {
                            method : options.method,
                            body : options.data,
                            headers : {
                                "Content-Type" : options.content,
                                Referer : "https://localhost"
                            }
                        };
                    }

                    return nodefetch(options.url, opts)
                        .then(function (response) {
                            if (response.ok) { // res.status >= 200 && res.status < 300
                                resolve(response.text());
                            } else {
                                var message = "Errors Occured on Http Request (status : '" + response.statusText + "' | url : '" + response.url + "')";
                                var status = response.status;
                                reject({
                                    message : message,
                                    status : status
                                });
                            }
                        })
                        .catch(function (e) {
                            reject({
                                message : e,
                                status : -1
                            });
                        });
                } else {
                    if (window.XMLHttpRequest) {
                        logger.trace("XMLHttpRequest");

                        hXHR = new XMLHttpRequest();
                        hXHR.open(options.method, options.url, true); // async
                        hXHR.overrideMimeType = options.content;

                        // gestion du timeout
                        var onTimeOutTrigger = null;
                        if (options.timeOut > 0) {
                            // FIXME le timeout interne ne me permet pas de declencher le bon message...
                            // hXHR.timeout = options.timeOut;
                            logger.trace("XHR - TimeOut actif !");
                            /**
                             * Description
                             *
                             * @method onTimeOutTrigger
                             * @private
                             */
                            onTimeOutTrigger = window.setTimeout(
                                function () {
                                    var message = "TimeOut Occured on Http Request with XMLHttpRequest !";
                                    reject({
                                        message : message,
                                        status : -1
                                    });
                                }, options.timeOut);
                        }

                        if (corps) {
                            // headers, data, content of data
                            // cf. https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#dom-xmlhttprequest-setrequestheader
                            logger.trace("data = ", options.data);
                            hXHR.setRequestHeader("Content-type", options.content);
                            // FIXME refused to set unsafe header content-length javascript
                            // hXHR.setRequestHeader ("Content-length", options.data.length);
                            // hXHR.setRequestHeader ("Referer", options.headers.referer);
                        }

                        /**
                         * On Error
                         * FIXME ne se declenche pas !?
                         *
                         * @param {Object} e - Event
                         * @method onerror
                         * @private
                         */
                        hXHR.onerror = function (e) {
                            console.log(e);
                            reject(new Error("Errors Occured on Http Request with XMLHttpRequest !"));
                        };

                        /**
                         * On Timeout
                         * FIXME ne se declenche pas !?
                         *
                         * @param {Object} e - Event
                         * @method ontimeout
                         * @private
                         */
                        hXHR.ontimeout = function (e) {
                            console.log(e);
                            reject(new Error("TimeOut Occured on Http Request with XMLHttpRequest !"));
                        };

                        /**
                         * Description
                         *
                         * @method onreadystatechange
                         * @private
                         */
                        hXHR.onreadystatechange = function (e) {
                            if (hXHR.readyState === 4) { // DONE
                                if (hXHR.status === 200) {
                                    window.clearTimeout(onTimeOutTrigger);
                                    resolve(hXHR.response);
                                } else {
                                    var message = "Errors Occured on Http Request (status : '" + e.target.statusText + "' | url : '" + e.target.responseURL + "' | response : '" + e.target.response + "')";
                                    var status = e.target.status;
                                    reject({
                                        message : message,
                                        status : status
                                    });
                                }
                            }
                        };

                        // gestion du content data
                        var data4xhr = (options.data && corps) ? options.data : null;

                        hXHR.send(data4xhr);
                    } else if (window.XDomainRequest) {
                        // worked in Internet Explorer 8–10 only !
                        logger.trace("XDomainRequest");

                        hXHR = new XDomainRequest();
                        hXHR.open(options.method, options.url);

                        hXHR.overrideMimeType = options.content;

                        if (options.timeOut > 0) {
                            hXHR.timeout = options.timeout;
                            logger.trace("XHR - TimeOut actif !");
                        }

                        if (corps) {
                            // headers, data, content of data
                            // cf. https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#dom-xmlhttprequest-setrequestheader
                            hXHR.setRequestHeader("Content-type", options.content);
                            // FIXME refused to set unsafe header content-length javascript
                            // hXHR.setRequestHeader ("Content-length", options.data.length);
                            // hXHR.setRequestHeader ("Referer", options.headers.referer);
                        }

                        /**
                         * Description
                         *
                         * @method onerror
                         * @private
                         */
                        hXHR.onerror = function () {
                            reject(new Error("Errors Occured on Http Request with XMLHttpRequest !"));
                        };

                        /**
                         * Description
                         *
                         * @method ontimeout
                         * @private
                         */
                        hXHR.ontimeout = function () {
                            reject(new Error("TimeOut Occured on Http Request with XMLHttpRequest !"));
                        };

                        /**
                         * On Load
                         *
                         * @method onload
                         * @private
                         */
                        hXHR.onload = function (e) {
                            if (hXHR.status === 200) {
                                resolve(hXHR.responseText);
                            } else {
                                var message = "Errors Occured on Http Request (status : '" + e.target.statusText + "' | url : '" + e.target.responseURL + "')";
                                var status = e.target.status;
                                reject({
                                    message : message,
                                    status : status
                                });
                            }
                        };

                        var data4xdr = (options.data && corps) ? options.data : null;

                        hXHR.send(data4xdr);
                    } else {
                        throw new Error("CORS not supported");
                    }
                }
            }
        );

        return promise;
    },

    /**
     * Requete avec parser JSON
     *
     * @method __callJSON
     * @private
     * @param  {Object} options - options
     * @return {Object} promise
     */
    __callJSON : function (options) {
        return this.__call(options)
            .then(JSON.parse)
            .catch(function (error) {
                console.log("_callJSON failed on : ", options.url, error);
                // FIXME pas d'exception, laissons le fil se derouler...
                // throw error;
            });
    },

    /**
     * Requete avec parser XML
     *
     * @method __callXML
     * @private
     * @param  {Object} options - options
     * @return {Object} promise
     */
    __callXML : function (options) {
        return this.__call(options)
            .then(function (response) {
                var xmlDoc;

                // test on env. nodejs or browser
                if (typeof window === "undefined") {
                    var DOMParser = (__webpack_require__(/*! @xmldom/xmldom */ "./node_modules/@xmldom/xmldom/lib/index.js").DOMParser); // __xmldom.DOMParser
                    xmlDoc = new DOMParser().parseFromString(response, "text/xml");
                } else {
                    if (window.DOMParser) {
                        var parser = new window.DOMParser();
                        xmlDoc = parser.parseFromString(response, "text/xml");
                    } else { // IE
                        xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
                        xmlDoc.async = false;
                        xmlDoc.loadXML(response);
                    }
                }

                return xmlDoc;
            })
            .catch(function (error) {
                console.log("__callXML failed on : ", options.url, error);
                // FIXME pas d'exception, laissons le fil se derouler...
                // throw error;
            });
    }

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (XHR);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Alti.js":
/*!*********************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Alti.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Utils/MessagesResources */ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js");
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Exceptions/ErrorService */ "./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js");
/* harmony import */ var _CommonService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CommonService */ "./node_modules/geoportal-access-lib/src/Services/CommonService.js");
/* harmony import */ var _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../DefaultUrlService */ "./node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js");
/* harmony import */ var _Request_AltiRequestFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Request/AltiRequestFactory */ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestFactory.js");
/* harmony import */ var _Response_AltiResponseFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Response/AltiResponseFactory */ "./node_modules/geoportal-access-lib/src/Services/Alti/Response/AltiResponseFactory.js");









/**
 * @classdesc
 *
 * Appel du service d'altimétrie du Géoportail
 *
 * @todo gestion du parma. output et callback
 * @todo outputFormat (REST) et format (WPS)
 * @todo La reponse JSON peut encapsuler un XML !
 *
 * @constructor
 * @extends {Gp.Services.CommonService}
 * @alias Gp.Services.Alti
 * @param {Object} options - options spécifiques au service (+ les options heritées)
 *
 * @param {Array.<Object>} options.positions - Tableau ({lon:float,lat:float}) contenant les coordonnées des points (CRS:84)
 *      dont on veut connaître les altitudes (ou à partir desquelles on va calculer le profil).
 *      Chaque élément du tableau est un objet JavaScript avec deux attributs : lon et lat, qui sont des flottants.
 *      Minimum 2 éléments si on souhaite calculer un profil altimétrique (ElevationLine).
 *      Maximum 50 éléments.
 *
 * @param {String} options.outputFormat - Le format de la réponse du service alti : 'xml' ou 'json'.
 *      Ce paramètre déterminera l'extension '.xml' ou '.json' du service dans le cas de l'API REST,
 *      ou la valeur du paramètre 'format' dans le cas de la norme WPS.
 *      Nécessaire si serverUrl est renseigné, et qu'on souhaite passer par l'API REST,
 *      pour connaître le format dans lequel sera fournie la réponse (pour son traitement).
 *      Non nécessaire pour la norme WPS. Par défaut, ce paramètre vaut 'json'.
 *
 * @param {Number} [options.sampling] - Nombre de points à utiliser pour déterminer le tracé d'un profil altimétrique, compris entre 2 et 5000.
 *      A spécifier lorsqu'on souhaite accéder à cette fonctionnalité.
 *      Dans ce cas, les points fournis en entrée (au minimum de deux) servent à déterminer l'axe planimétrique
 *      le long duquel le profil doit être calculé.
 *      Si le paramètre sampling n'est pas spécifié ou moins de deux points sont fournis,
 *      c'est le service Elevation qui sera interrogé (altitudes simples calculées pour les points fournis).
 *      Une valeur de sampling strictement inférieure à 2 déclenchera un échantillonnage avec la valeur par défaut du service (3 points).
 *
 * @param {String} [options.api] - Manière d'accéder au service : 'REST' (via l'API REST) ou 'WPS' (via la norme WPS).
 *      Par défaut, on utilise l'API REST.
 *
 * @param {Boolean} [options.zonly] - Permet de ne récupérer que les altitudes en sortie s'il vaut 'true'.
 *      Vaut 'false' par défaut.
 *
 * @param {String} [options.resource] - Resource utilisée pour réaliser le calcul.
 *
 * @example
 *   var options = {
 *      apiKey : null,
 *      serverUrl : 'http://localhost/service/',
 *      protocol : 'JSONP', // JSONP|XHR
 *      proxyURL : null,
 *      httpMethod : 'GET', // GET|POST
 *      timeOut : 10000, // ms
 *      rawResponse : false, // true|false
 *      scope : null, // this
 *      onSuccess : function (response) {},
 *      onFailure : function (error) {},
 *      // spécifique au service
 *      positions : [{lon:, lat:}, {lon:, lat:}],
 *      outputFormat : 'json' // json|xml
 *      sampling : 3,
 *      api : 'REST', // REST|WPS
 *      zonly : false // false|true,
 *      resource : "resource-par-defaut"
 *   };
 *
 */
function Alti (options) {
    if (!(this instanceof Alti)) {
        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("CLASS_CONSTRUCTOR", "Alti"));
    }

    /**
     * Nom de la classe (heritage)
     * FIXME instance ou classe ?
     */
    this.CLASSNAME = "Alti";

    // appel du constructeur par heritage
    _CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].apply(this, arguments);

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("Gp.Services.Alti");
    this.logger.trace("[Constructeur Alti (options)]");

    // #####################
    // analyse des options
    // #####################

    if (!options.positions) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "positions"));
    }

    if (options.positions.length === 0) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_EMPTY", "positions"));
    }

    // ajout des options spécifiques au service
    this.options.positions = options.positions;

    // format de réponse du service : "json" ou "xml" (valeur par défaut), en minuscule !
    this.options.outputFormat = (typeof options.outputFormat === "string") ? options.outputFormat.toLowerCase() : "xml";

    // ressource utilisée pour le calcul altimétrique
    this.options.resource = options.resource || "ign_rge_alti_wld";

    // sampling
    this.options.sampling = options.sampling || null;

    // type d'api utilisé pour requeter le service, en majuscule !
    this.options.api = (typeof options.api === "string") ? options.api.toUpperCase() : "REST";

    // l'api ne peut être interrogée qu'en GET.
    if (this.options.api === "REST") {
        this.options.httpMethod = "GET";
    }

    // param. zonly
    this.options.zonly = options.zonly || false;

    // param. measures
    this.options.measures = options.measures || false;

    // gestion de l'url du service par defaut
    // si l'url n'est pas renseignée, il faut utiliser les urls par defaut
    // en fonction du type d'api, REST ou WPS, du format de reponse demandé (outputFormat)
    // ainsi que sur le type de service (profil ou elevation)
    if (!this.options.serverUrl) {
        var lstUrlByDefault = _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__["default"].Alti.newUrl();
        var urlFound = null;
        switch (this.options.api) {
            case "WPS":
                urlFound = lstUrlByDefault.wps;
                break;
            case "REST":
                var key = (options.sampling ? "profil" : "elevation") + "-" + this.options.outputFormat;
                urlFound = lstUrlByDefault[key];
                break;
            default:
                throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_UNKNOWN", "api"));
        }

        if (!urlFound) {
            throw new Error("Url by default not found !");
        }
        this.options.serverUrl = urlFound;
        this.logger.trace("Server URL by default : " + this.options.serverUrl);
    }

    // gestion du type de service
    // si l'extension de l'url est .json ou .xml, on surcharge le format de sortie (outputFormat)
    var idx = this.options.serverUrl.lastIndexOf(".");
    if (idx !== -1) {
        var extension = this.options.serverUrl.substring(idx + 1);
        if (extension && extension.length < 5) { // FIXME extension de moins de 4 car. ...
            this.logger.trace("Server Extension URL : " + extension);
            switch (extension.toLowerCase()) {
                case "json":
                case "xml":
                    this.options.outputFormat = extension.toLowerCase();
                    break;
                default:
                    throw new Error("type of service : unknown or unsupported (json or xml) !");
            }
        }
    }
}

/**
 * @lends module:Alti#
 */
Alti.prototype = Object.create(_CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].prototype, {
    // todo
    // getter/setter
});

/**
 * Constructeur (alias)
 */
Alti.prototype.constructor = Alti;

/**
 * Création de la requête (overwrite)
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
Alti.prototype.buildRequest = function (error, success) {
    // utilisation en mode callback
    var options = {
        httpMethod : this.options.httpMethod,
        // callback
        onSuccess : function (result) {
            // sauvegarde de la requete !
            this.request = result;
            success.call(this, this.request);
        },
        onError : error,
        scope : this,
        // spécifique au service :
        resource : this.options.resource,
        positions : this.options.positions,
        outputFormat : this.options.outputFormat,
        sampling : this.options.sampling,
        api : this.options.api,
        zonly : this.options.zonly,
        measures : this.options.measures
    };

    _Request_AltiRequestFactory__WEBPACK_IMPORTED_MODULE_5__["default"].build(options);
};

/**
 * Analyse de la reponse (overwrite)
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
Alti.prototype.analyzeResponse = function (error, success) {
    // INFO
    // Factory pour masquer la complexité du retour du service qui renvoie soit
    //  - une 'string' qui contient du XML ou JSON natif en mode XHR
    //  - un objet JSON qui est natif ou encapsulé

    if (this.response) {
        var options = {
            response : this.response,
            outputFormat : this.options.outputFormat, // utile pour parser la string en mode XHR : JSON ou XML !
            rawResponse : this.options.rawResponse,
            onError : error,
            onSuccess : success,
            scope : this
        };

        _Response_AltiResponseFactory__WEBPACK_IMPORTED_MODULE_6__["default"].build(options);
    } else {
        error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Alti);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Formats/AltiResponseReader.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Formats/AltiResponseReader.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Response_model_AltiResponse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Response/model/AltiResponse */ "./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/AltiResponse.js");
/* harmony import */ var _Response_model_Elevation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Response/model/Elevation */ "./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/Elevation.js");
/* harmony import */ var _Response_model_Measure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Response/model/Measure */ "./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/Measure.js");

/**
 * Fonction retournant un objet contenant des clés de lecture (readers)
 *      qui permettent de parser des réponses XML du service Altimétrique du Géoportail
 *      (calcul altimétrique simple ou profil altimétrique d'une courbe),
 *      lorsque le paramètre output = xml,
 *      afin de récupérer les élévations retournées.
 *
 * @module AltiResponseReader
 * @alias Gp.Services.Alti.Formats.AltiResponseReader
 * @private
 */

// import Logger from "../../../Utils/LoggerByDefault";




/**
 *
 * Objet AltiResponseReader
 *
 * @member {Object} AltiResponseReader
 *
 * @property {Object} AltiResponseReader.READERS - Objet contenant des fonctions de lecture, appelées "readers"
 *      dont chaque clé correspond au nom d'un tag du XML que l'on souhaite lire
 *      et la valeur associée est une fonction (node, data)
 *      où node est un noeud du document DOM
 *      et data est un objet où l'on stocke les informations lues dans le XML.
 *
 * @property {Method} AltiResponseReader.READERS.elevations -  Lecture d'un noeud "elevations" de la réponse XML
 *      du service alti, correspondant logiquement à la racine du document
 *      (contient un ou plusieurs childNodes correspondant chacun à une élévation retournée)
 *
 * @property {Method} AltiResponseReader.READERS.elevation - Lecture d'un noeud "elevation" de la réponse xml du service alti.
 *      (contient un ou 4 childNode (s) correspondant à l'altitude (z) et éventuellement lat, lon, et acc)
 *
 * @property {Method} AltiResponseReader.READERS.lat - Lecture d'un noeud "lat" de la réponse xml du service alti.
 *      (contient une valeur de latitude, qui est un flottant)
 *
 * @property {Method} AltiResponseReader.READERS.lon - Lecture d'un noeud "lon" de la réponse xml du service alti.
 *      (contient une valeur de longitude, qui est un flottant)
 *
 * @property {Method} AltiResponseReader.READERS.z - Lecture d'un noeud "z" de la réponse xml du service alti.
 *      (contient une valeur d'altitude, qui est un flottant)
 *
 * @property {Method} AltiResponseReader.READERS.acc - Lecture d'un noeud "acc" de la réponse xml du service alti.
 *      (contient une valeur de précision, qui est un flottant)
 *
 * @property {Method} AltiResponseReader.READERS.measures - Lecture d'un noeud "measures" de la réponse xml du service alti.
 *      (contient une valeur de précision, qui est un flottant)
 *
 * @property {Method} AltiResponseReader.READERS.source_name - Lecture d'un noeud "source_name" de la réponse xml du service alti.
 *      (pour remplir l'éventuel objet measure)
 *
 * @property {Method} AltiResponseReader.READERS.source_mesure - Lecture d'un noeud "source_mesure" de la réponse xml du service alti.
 *      (pour remplir l'éventuel objet measure)
 *
 * @property {Method} AltiResponseReader.READERS.exceptionreport - Lecture d'un noeud "ExceptionReport" de la réponse xml du service alti.
 *
 * @property {Method} AltiResponseReader.READERS.exception - Lecture d'un noeud "Exception" de la réponse xml du service alti.
 *
 * @property {Method} AltiResponseReader.read - Méthode permettant de lancer la lecture d'une réponse XML du service altimétrique,
 *      à l'aide des readers de la classe.
 *
 */
var AltiResponseReader = {};

AltiResponseReader.READERS = {

    /**
     * Lecture d'un noeud "elevations" de la réponse XML du service alti, correspondant logiquement à la racine du document
     *      (contient un ou plusieurs childNodes correspondant chacun à une élévation retournée)
     *
     * @param {DOMElement} root - racine de la réponse XML
     * @static
     * @memberof AltiResponseReader
     * @returns {Object} Retourne un objet de type AltiResponse
     */
    elevations : function (root) {
        // INFO : on passe en paramètre l'objet en entrée elevations, vide, à remplir.
        var altiResponse = new _Response_model_AltiResponse__WEBPACK_IMPORTED_MODULE_0__["default"]();

        if (root.hasChildNodes()) {
            var children = root.childNodes;
            var child;
            var elevation;

            for (var i = 0; i < children.length; i++) {
                child = children[i];

                if (AltiResponseReader.READERS[child.nodeName]) {
                    elevation = AltiResponseReader.READERS[child.nodeName](child);
                    altiResponse.elevations.push(elevation);
                }
            }
        }

        return altiResponse;
    },

    /**
     * Lecture d'un noeud "elevation" de la réponse xml du service alti.
     *      (contient un ou 5 childNode (s) correspondant à l'altitude (z) et éventuellement lat, lon, acc et measures)
     *
     * @param {DOMElement} node - noeud elevation à lire pour récupérer les informations de l'élévation retournée (z [, lon, lat, acc, measures])
     * @return {Array} elevationResponse - format de la réponse en sortie, instance de AltiResponse
     * @static
     * @memberof AltiResponseReader
     */
    elevation : function (node) {
        var elevation = new _Response_model_Elevation__WEBPACK_IMPORTED_MODULE_1__["default"]();

        if (node.hasChildNodes()) {
            var children = node.childNodes;
            var child;
            for (var i = 0; i < children.length; i++) {
                child = children[i];
                if (AltiResponseReader.READERS[child.nodeName]) {
                    // INFO : on passe en paramètre l'objet en entrée elevation, vide, à remplir.
                    AltiResponseReader.READERS[child.nodeName](child, elevation);
                }
            }
        }
        return elevation;
    },

    /**
     * Lecture d'un noeud "lat" de la réponse xml du service alti.
     *      (contient une valeur de latitude, qui est un flottant)
     *
     * @param {DOMElement} node - noeud à lire pour récupérer la latitude
     * @param {Object} elevation - objet dans lequel stocker la latitude retournée
     * @static
     * @memberof AltiResponseReader
     */
    lat : function (node, elevation) {
        var textNode = node.firstChild;
        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE
            elevation.lat = parseFloat(textNode.nodeValue);
        } else {
            throw new Error("Erreur dans la lecture de la réponse du service : latitude attendue mais absente");
        }
    },

    /**
     * Lecture d'un noeud "lon" de la réponse xml du service alti.
     *      (contient une valeur de longitude, qui est un flottant)
     *
     * @param {DOMElement} node - noeud à lire pour récupérer la longitude
     * @param {Object} elevation - objet dans lequel stocker la longitude retournée
     * @static
     * @memberof AltiResponseReader
     */
    lon : function (node, elevation) {
        var textNode = node.firstChild;
        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE
            elevation.lon = parseFloat(textNode.nodeValue);
        } else {
            throw new Error("Erreur dans la lecture de la réponse du service : longitude attendue mais absente");
        }
    },

    /**
     * Lecture d'un noeud "z" de la réponse xml du service alti.
     *      (contient une valeur d'altitude, qui est un flottant)
     *
     * @param {DOMElement} node - noeud à lire pour récupérer l'altitude
     * @param {Object} elevationObject - objet dans lequel stocker l'altitude retournée : elevation ou measure
     * @static
     * @memberof AltiResponseReader
     */
    z : function (node, elevationObject) {
        var textNode = node.firstChild;
        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE
            if (elevationObject) {
                elevationObject.z = parseFloat(textNode.nodeValue);
            } else {
                elevationObject = new _Response_model_Elevation__WEBPACK_IMPORTED_MODULE_1__["default"]();
                elevationObject.z = parseFloat(textNode.nodeValue);
                return elevationObject;
            }
        } else {
            throw new Error("Erreur dans la lecture de la réponse du service : altitude attendue mais absente");
        }
    },

    /**
     * Lecture d'un noeud "acc" de la réponse xml du service alti.
     *      (contient une valeur de précision, qui est un flottant)
     *
     * @param {DOMElement} node - noeud à lire pour récupérer la précision
     * @param {Object} elevationObject - objet dans lequel stocker la précision retournée : elevation ou measure
     * @static
     * @memberof AltiResponseReader
     */
    acc : function (node, elevationObject) {
        var textNode = node.firstChild;
        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE
            elevationObject.acc = parseFloat(textNode.nodeValue);
        } else {
            throw new Error("Erreur dans la lecture de la réponse du service : précision (acc) attendue mais absente");
        }
    },

    /**
     * Lecture d'un noeud "source_name" de la réponse xml du service alti.
     *      (contient le nom de la source, qui est un string)
     *
     * @param {DOMElement} node - noeud à lire pour récupérer la précision
     * @param {Object} measure - objet dans lequel stocker le nom de la source retourné
     * @static
     * @memberof AltiResponseReader
     */
    source_name : function (node, measure) {
        var textNode = node.firstChild;
        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE
            measure.source_name = textNode.nodeValue;
        } else {
            throw new Error("Erreur dans la lecture de la réponse du service : source_name attendue mais absente");
        }
    },

    /**
     * Lecture d'un noeud "source_measure" de la réponse xml du service alti.
     *      (contient le nom de la mesure, qui est un string)
     *
     * @param {DOMElement} node - noeud à lire pour récupérer la précision
     * @param {Object} measure - objet dans lequel stocker le nom de la source retourné
     * @static
     * @memberof AltiResponseReader
     */
    source_measure : function (node, measure) {
        var textNode = node.firstChild;
        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE
            measure.source_measure = textNode.nodeValue;
        } else {
            throw new Error("Erreur dans la lecture de la réponse du service : source_measure attendue mais absente");
        }
    },

    /**
     * Lecture d'un noeud "measures" et de ses enfants "measure" de la réponse xml du service alti.
     *      (contient une valeur de précision, qui est un flottant)
     *
     * @param {DOMElement} node - noeud à lire pour récupérer la précision
     * @param {Object} elevation - objet dans lequel stocker la précision retournée
     * @static
     * @memberof AltiResponseReader
     */
    measures : function (node, elevation) {
        elevation.measures = [];
        var measure;
        if (node.hasChildNodes()) {
            var children = node.childNodes;
            var measureNode;
            var measureChildren;
            for (var i = 0; i < children.length; i++) {
                measure = new _Response_model_Measure__WEBPACK_IMPORTED_MODULE_2__["default"]();
                measureNode = children[i];
                measureChildren = measureNode.childNodes;
                for (var j = 0; j < measureChildren.length; j++) {
                    if (AltiResponseReader.READERS[measureChildren[j].nodeName]) {
                        // INFO : on passe en paramètre l'objet en entrée elevation, vide, à remplir.
                        AltiResponseReader.READERS[measureChildren[j].nodeName](measureChildren[j], measure);
                    } else {
                        throw new Error("Erreur dans la lecture de la réponse du service : measures attendues mais absentes");
                    }
                }
                elevation.measures.push(measure);
            }
        }
    },

    /**
     * Lecture d'un noeud "ExceptionReport" de la réponse xml du service alti.
     *
     * @param {DOMElement} node - noeud à lire pour récupérer l'exception
     * @return {Object} exceptionReport - objet contenant l'exception
     * @static
     * @memberof AltiResponseReader
     */
    exceptionreport : function (node) {
        var response = {};

        if (node.hasChildNodes()) {
            var children = node.childNodes;
            var child;
            for (var i = 0; i < children.length; i++) {
                child = children[i];
                if (child.nodeName === "Exception") {
                    response.exceptionReport = AltiResponseReader.READERS.exception(child);
                }
            }
        }

        return response;
    },

    /**
     * Lecture d'un noeud "Exception" de la réponse xml du service alti.
     *
     * @param {DOMElement} node - noeud à lire pour récupérer l'exception
     * @return {Object} exceptionReport - objet contenant l'exception, avec deux attributs :
     *      {String} exceptionReport.exceptionCode - qui contient l'identifiant du code de l'exception
     *      {String} exceptionReport.exception - qui contient le message de l'exception
     * @static
     * @memberof AltiResponseReader
     */
    exception : function (node) {
        var exceptionReport = {};

        // get exception code
        var exceptionCode = node.getAttribute("exceptionCode");
        if (exceptionCode) {
            exceptionReport.exceptionCode = exceptionCode;
        }

        // get exception message
        var textNode = node.firstChild;
        if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE
            exceptionReport.exception = textNode.nodeValue;
        }

        return exceptionReport;
    },

    /**
     * Lecture d'un noeud "Error" de la réponse xml du service alti.
     *
     * @param {DOMElement} node - noeud à lire pour récupérer l'exception
     * @return {Object} error - objet contenant l'exception
     * @static
     */
    error : function (node) {
        var response = {
            error : {}
        };
        // get error code and description
        if (node.hasChildNodes()) {
            var children = node.childNodes;
            var child;
            for (var i = 0; i < children.length; i++) {
                child = children[i];
                var textNode;
                // get error code
                if (child.nodeType === 1 && child.nodeName === "code") { // 1 === node.ELEMENT_NODE
                    textNode = child.firstChild;
                    if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE
                        response.error.code = textNode.nodeValue;
                    }
                }
                // get error description
                if (child.nodeType === 1 && child.nodeName === "description") { // 1 === node.ELEMENT_NODE
                    textNode = child.firstChild;
                    if (textNode && textNode.nodeType === 3) { // 3 === node.TEXT_NODE
                        response.error.description = textNode.nodeValue;
                    }
                }
            }
        }
        return response;
    }

};

/**
 * Méthode permettant de lancer la lecture d'une réponse XML du service altimétrique,
 *      à l'aide des readers de la classe.
 *
 * @method AltiResponseReader.read
 * @param {DOMElement} root - racine de la réponse XML à lire
 * @static
 * @memberof AltiResponseReader
 */
AltiResponseReader.read = function (root) {
    if (root.nodeName === "elevations") {
        var altiResponse = AltiResponseReader.READERS.elevations(root);
        return altiResponse;
    } else if (root.nodeName === "ExceptionReport") {
        var exceptionReport = AltiResponseReader.READERS.exceptionreport(root);
        return exceptionReport;
    } else if (root.nodeName === "error") {
        var error = AltiResponseReader.READERS.error(root);
        return error;
    } else {
        throw new Error("Erreur lors de la lecture de la réponse : elle n'est pas au format attendu.");
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AltiResponseReader);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestFactory.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestFactory.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Exceptions/ErrorService */ "./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js");
/* harmony import */ var _AltiRequestREST__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AltiRequestREST */ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestREST.js");
/* harmony import */ var _AltiRequestWPS__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AltiRequestWPS */ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestWPS.js");
/**
 * Creation d'une requête en REST ou WPS
 * (Factory)
 *
 * @module AltiRequestFactory
 * @alias Gp.Services.Alti.Request.AltiRequestFactory
 * @private
 */





var AltiRequestFactory = {

    /**
     * interface unique
     *
     * @method build
     * @static
     * @param {Object} options - options definies dans le composant Alti
     *
     * @example
     *   var options = {
     *      httpMethod : 'GET', // GET|POST
     *      onSuccess : function (response) {},
     *      onError : function (error) {},
     *      scope : this,
     *      positions : [{lon:, lat:}, {lon:, lat:}],
     *      outputFormat : 'json' // json|xml
     *      sampling : 3,
     *      api : 'REST', // REST|WPS
     *      zonly : false // false|true
     *   };
     *
     */
    build : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("AltiRequestFactory");
        logger.trace(["AltiRequestFactory::build()"]);

        var request = null;

        // on factorise les options par groupe;
        // - global,
        // - param, les params pour les data inputs
        // - wps, les param du service
        // - callback

        var settings = {
            // ajout des valeurs par defaut spécifiques au service
            type : options.sampling ? "Profil" : "Elevation",
            method : options.httpMethod,
            param : {
                positions : null,
                delimiter : null, // FIXME par defaut, on ne le met pas en place car ça fait planter la requête !?
                indent : null, // par defaut
                crs : null, // par defaut
                format : null, // (only to POST)
                sampling : null, // (only use by Profil)
                zonly : null, // (only use by Elevation)
                measures : null // (only use by Elevation)
            }
        };

        // surcharge des valeurs obligatoires
        settings.param.positions = options.positions;
        settings.param.format = options.outputFormat;
        settings.param.sampling = options.sampling;
        settings.param.zonly = options.zonly;
        settings.param.measures = options.measures;
        settings.param.resource = options.resource;

        // gestion des callback
        var bOnError = !!(options.onError !== null && typeof options.onError === "function"); // cast variable to boolean
        var bOnSuccess = !!(options.onSuccess !== null && typeof options.onSuccess === "function");

        var message = null;
        switch (options.api) {
            case "REST":
                // FIXME les exceptions ne sont pas 'catchées' sur le constructeur !
                var myReq = new _AltiRequestREST__WEBPACK_IMPORTED_MODULE_2__["default"](settings);
                if (!myReq.processRequestString()) {
                    message = "Error in process request (rest) !";
                    if (bOnError) {
                        options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"](message));
                        return;
                    }
                    throw new Error(message);
                }
                request = myReq.requestString;
                break;
            case "WPS":
                // ajout des valeurs par defaut spécifiques au service WPS
                settings.wps = {
                    service : null, // par defaut
                    version : null, // par defaut
                    identifier : null, // par defaut
                    rawdataoutput : null, // par defaut
                    request : null // par defaut
                };

                request = _AltiRequestWPS__WEBPACK_IMPORTED_MODULE_3__["default"].build(settings);
                if (!request) {
                    message = "Error in process request (wps) !";
                    if (bOnError) {
                        options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"](message));
                        return;
                    }
                    throw new Error(message);
                }
                break;
            default:
                message = "Type of API is not supported by service (REST or WPS) !";
                if (bOnError) {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"](message));
                    return;
                }
                throw new Error(message);
        }

        if (bOnSuccess) {
            options.onSuccess.call(options.scope, request);
        }

        return request;
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AltiRequestFactory);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestREST.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestREST.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Utils/MessagesResources */ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js");
/* harmony import */ var _model_AltiElevationRequest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./model/AltiElevationRequest */ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiElevationRequest.js");
/* harmony import */ var _model_AltiProfilRequest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model/AltiProfilRequest */ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiProfilRequest.js");
/* jshint multistr : true */






/**
 * @classdesc
 * Classe de gestion des requêtes de type REST sur le service altimetrique.
 *
 * @todo Le service Alti n'implemente pas le POST !?
 * @constructor
 * @alias Gp.Services.Alti.Request.AltiRequestREST
 * @param {Object} options - options
 * @param {Object}   options.param.positions - tableau de coordonnées lon/lat
 * @param {String}   options.param.delimiter - '|'
 * @param {Boolean}  options.param.indent - false|true
 * @param {String}   options.param.crs - 'CRS:84'
 * @param {String}   options.param.sampling - 3
 * @param {String}   options.param.resource - 'rge_alti_corse2a_float32_zip_lamb93'
 * @param {Boolean}  options.param.zonly - false|true
 * @param {Boolean}  options.param.measures - false|true
 * @param {String}   options.param.format - "JSON|XML"
 * @param {String}   options.type - "Profil|Elevation"
 * @param {String}   options.method - GET|POST
 *
 * @example
 *      var options = {
 *           type : 'Profil', // Elevation
 *           method : 'GET',  // par defaut
 *           param : {
 *               positions : [
 *                   {lon:'1.11', lat:'1.11'},
 *                   {lon:'1.10', lat:'1.10'},
 *                   {lon:'1.12', lat:'1.12'}
 *               ],
 *               delimiter : ";",         // par defaut
 *               indent    : true,        // par defaut
 *               crs       : 'EPSG:4326', // par defaut
 *               format    : 'json',      // par defaut (only to POST)
 *               sampling  : 3 ,          // par defaut (only use by Profil)
 *               zonly     : false        // par defaut (only use by Elevation)
 *               measures  : false        // par defaut (only use by Elevation)
 *           }
 *      };
 *
 *      var result;
 *      try {
 *          var obj = new AltiRequestREST (options);
 *          if (! obj.processRequestString ()) {
 *              throw new Error("Request empty !?")
 *          }
 *          result = obj.requestString;
 *      } catch (e) {
 *          // exceptions...
 *      }
 * @private
 */
function AltiRequestREST (options) {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("AltiRequestREST");
    this.logger.trace("[Constructeur AltiRequestREST ()]");

    if (!(this instanceof AltiRequestREST)) {
        throw new TypeError("AltiRequestREST constructor cannot be called as a function.");
    }

    this.options = options || {};

    // existance des options
    if (!this.options) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_EMPTY", "options"));
    }

    // type de requete : Altitude ou Profil
    // (param. à determiner en fonction des parametres d'entrée)
    if (!this.options.type) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_EMPTY", "type (Elevation or Profil)"));
    }

    // construction du modele de requête
    // (test du type d'objet candidat)
    this.DataObject = null;
    switch (this.options.type) {
        case "Elevation":
            this.DataObject = new _model_AltiElevationRequest__WEBPACK_IMPORTED_MODULE_2__["default"](this.options.param);
            break;
        case "Profil":
            this.DataObject = new _model_AltiProfilRequest__WEBPACK_IMPORTED_MODULE_3__["default"](this.options.param);
            break;
        default:
            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_TYPE", "type (Elevation or Profil)"));
    }

    /**
     * methode.
     * Par defaut, "GET".
     */
    this.method = this.options.method || "GET";
}

AltiRequestREST.prototype = {

    /**
     * request
     * @type {String}
     */
    requestString : null,

    /**
     * Constructeur (alias)
     */
    constructor : AltiRequestREST,

    /**
     * Template de la requête.
     */
    template : {
        get : {
            // FIXME on retire le param 'delimiter' : &delimiter='__DELIMITER__'
            value : "lon=__LON__&lat=__LAT__&indent=__INDENT__&crs='__CRS__'&resource=__RESOURCE__&measures=__MEASURES__",
            input : {
                point : "&zonly=__ZONLY__",
                profil : "&sampling=__SAMPLING__"
            }
        },
        post : {
            // FIXME on retire le param 'delimiter' : delimiter='__DELIMITER__'\n\
            value : "lon=__LON__\n" +
                "lat=__LAT__\n" +
                "indent=__INDENT__\n" +
                "crs='__CRS__'\n" +
                "resource='__RESOURCE__'\n" +
                "measures='__MEASURES__'\n",
            input : {
                point : "zonly=__ZONLY__\n",
                profil : "sampling=__SAMPLING__"
            }
        }
    },

    /**
     * Construction de la requête.
     *
     * @example
     * // GET  out : lon=0.2367,2.1570&lat=48.0551,46.6077&delimiter=,&indent=true&zonly=true&crs='CRS:84'
     * // POST out : Not yet supported method POST !
     * @returns {String}
     */
    processRequestString : function () {
        this.logger.trace("AltiRequestREST::processRequestString ()");

        var template = "";
        if (this.method === "POST") {
            template = this.template.post.value;
        } else if (this.method === "GET") {
            template = this.template.get.value;
        }

        template = template.replace(/__LON__/g, this.DataObject.getLon());
        template = template.replace(/__LAT__/g, this.DataObject.getLat());
        // FIXME on retire le param 'delimiter'
        // template = template.replace(/__DELIMITER__/g, this.DataObject.delimiter);
        template = template.replace(/__INDENT__/g, this.DataObject.indent);
        template = template.replace(/__CRS__/g, this.DataObject.crs);
        template = template.replace(/__RESOURCE__/g, this.DataObject.resource);
        template = template.replace(/__MEASURES__/g, this.DataObject.measures);

        // ajout +
        template = template + this.__addDataInputs();
        this.logger.trace("traduction tmpl", template);

        // sauvegarde
        this.requestString = template;

        return this.requestString;
    },

    /**
     * Ajout de parametres spécifiques (ex. zonly)
     *
     * @returns {String}
     */
    __addDataInputs : function () {
        this.logger.trace("AltiRequestREST::addDataInput ()");

        var myTemplate;
        if (this.method === "POST") {
            myTemplate = this.template.post;
        } else if (this.method === "GET") {
            myTemplate = this.template.get;
        } else {
            throw new Error("No other HTTP method supported by the service !");
        }

        var tmpl = null;
        if (this.DataObject.CLASSNAME === "AltiElevationRequest") {
            tmpl = myTemplate.input.point;
            return tmpl.replace(/__ZONLY__/g, this.DataObject.zonly.toString());
        } else if (this.DataObject.CLASSNAME === "AltiProfilRequest") {
            tmpl = myTemplate.input.profil;
            return tmpl.replace(/__SAMPLING__/g, this.DataObject.sampling);
        } else {
            throw new Error("No other object supported than elevation or profil !?");
        }
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AltiRequestREST);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestWPS.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Request/AltiRequestWPS.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Utils/MessagesResources */ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js");
/* harmony import */ var _Formats_WPS__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../Formats/WPS */ "./node_modules/geoportal-access-lib/src/Formats/WPS.js");
/* harmony import */ var _model_AltiElevationRequest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model/AltiElevationRequest */ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiElevationRequest.js");
/* harmony import */ var _model_AltiProfilRequest__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./model/AltiProfilRequest */ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiProfilRequest.js");
/**
 * Classe d'interface des requêtes de type WPS sur le service altimetrique.
 * (Factory)
 *
 * @module Gp.Services.Alti.Request.AltiRequestWPS
 * @alias Gp.Services.Alti.Request.AltiRequestWPS
 * @private
 */






var AltiRequestWPS = {

    /**
     * Interface unique de construction de la requête.
     *
     * @method build
     * @param {Object} options - options
     * @param {Object}   options.param.positions - tableau de coordonnées lon/lat
     * @param {String}   options.param.delimiter - '|'
     * @param {Boolean}  options.param.indent - false|true
     * @param {String}   options.param.crs - 'CRS:84'
     * @param {String}   options.param.sampling - 3
     * @param {Boolean}  options.param.zonly - false|true
     * @param {String}   options.param.format - "JSON|XML" (only to POST)
     * @param {String}   options.wps.service - "WPS"
     * @param {String}   options.wps.version - "1.0.0"
     * @param {String}   options.wps.identifier - "gs:WPSElevation|gs:WPSLineElevation"
     * @param {String}   options.wps.rawdataoutput - "result"
     * @param {String}   options.wps.request - "Execute"
     * @param {String}   options.type - "Profil|Elevation"
     * @param {String}   options.method - GET|POST
     * @example
     *      var options = {
     *           type : 'Profil', // Elevation
     *           method : 'GET',  // par defaut
     *           param : {
     *               positions : [
     *                   {lon:'1.11', lat:'1.11'},
     *                   {lon:'1.10', lat:'1.10'},
     *                   {lon:'1.12', lat:'1.12'}
     *               ],
     *               delimiter : ";",         // par defaut
     *               indent    : true,        // par defaut
     *               crs       : 'EPSG:4326', // par defaut
     *               format    : 'json',      // par defaut (only to POST)
     *               sampling  : 3 ,          // par defaut (only use by Profil)
     *               zonly     : false,       // par defaut (only use by Elevation)
     *           },
     *           wps : {
     *                 service : 'WPS',         // par defaut
     *                 version : '1.0.0',       // par defaut
     *                 identifier : 'gs:WPS',   // par defaut, Elevation = gs:WPSElevation, Profil = gs:WPSLineElevation
     *                 rawdataoutput : 'result',// par defaut
     *                 request : 'Execute'      // par defaut
     *           }
     *       };
     */
    build : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("AltiRequestWPS");
        logger.trace(["AltiRequestWPS::build()"]);

        // existance des options
        if (!options) {
            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_EMPTY", "options"));
        }

        // type de requete : Altitude ou Profil
        // (param. à determiner en fonction des parametres d'entrée)
        if (!options.type) {
            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_EMPTY", "type (Elevation or Profil)"));
        }

        // construction du modele de requête
        // (test du type d'objet candidat)
        var DataObject = null;
        switch (options.type) {
            case "Elevation":
                // surcharge
                options.wps.identifier = "gs:WPSElevation";
                DataObject = new _model_AltiElevationRequest__WEBPACK_IMPORTED_MODULE_3__["default"](options.param);
                break;
            case "Profil":
                // surcharge
                options.wps.identifier = "gs:WPSLineElevation";
                DataObject = new _model_AltiProfilRequest__WEBPACK_IMPORTED_MODULE_4__["default"](options.param);
                break;
            default:
                throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_TYPE", "type (Elevation or Profil)"));
        }

        // construction de la requête WPS
        var settings = {
            data : DataObject,
            method : options.method,
            param : options.wps
        };

        var rqstWPS = new _Formats_WPS__WEBPACK_IMPORTED_MODULE_2__["default"](settings);

        if (!rqstWPS.processRequestString()) {
            throw new Error("Enable to process request !");
        }

        return rqstWPS.requestString;
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AltiRequestWPS);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiElevationRequest.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiElevationRequest.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _AltiRequest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AltiRequest */ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiRequest.js");




/**
 * @classdesc
 *
 * Classe de gestion des param. des requêtes de type POINT du service altimetrique.
 *
 * @constructor
 * @alias Gp.Services.Alti.Request.AltiElevationRequest
 * @param {Object} options - options
 * @param {Boolean}  options.zonly - false|true
 *
 * @private
 */
function AltiElevationRequest (options) {
    if (!(this instanceof AltiElevationRequest)) {
        throw new TypeError("AltiElevationRequest constructor cannot be called as a function.");
    }

    /**
     * Nom de la classe (heritage)
     */
    this.CLASSNAME = "AltiElevationRequest";

    // appel du constructeur par heritage
    _AltiRequest__WEBPACK_IMPORTED_MODULE_1__["default"].apply(this, arguments);

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur AltiElevationRequest ()]");

    /**
     * Z uniquement.
     * true|false
     */
    this.zonly = this.options.zonly || false; // test des options héritées !
}

/**
 * @lends module:AltiElevationRequest#
 */

AltiElevationRequest.prototype = Object.create(_AltiRequest__WEBPACK_IMPORTED_MODULE_1__["default"].prototype, {

    /**
     * Setter/getter pour "zonly"
     */
    zonly : {
        /** getter */
        get : function () {
            return this._zonly;
        },
        /** setter */
        set : function (z) {
            this._zonly = z;
        }
    }

});

/**
 * Constructeur (alias)
 */
AltiElevationRequest.prototype.constructor = AltiElevationRequest;

/**
 * Tableau de clefs/valeurs pour param.
 *
 * @returns {Array}
 */
AltiElevationRequest.prototype.getData = function () {
    // par glop..., appel de AltiRequest::getData () !
    var map = [];
    map.push({
        k : "lon",
        v : this.getLon()
    });
    map.push({
        k : "lat",
        v : this.getLat()
    });
    // map.push({k : "delimiter", v : this.delimiter}); // FIXME on retire le param "delimiter"
    map.push({
        k : "indent",
        v : this.indent
    });
    map.push({
        k : "crs",
        v : this.crs
    });
    map.push({
        k : "zonly",
        v : this.zonly
    });
    map.push({
        k : "format",
        v : this.format
    });
    map.push({
        k : "resource",
        v : this.resource
    });

    return map;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AltiElevationRequest);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiProfilRequest.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiProfilRequest.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _AltiRequest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AltiRequest */ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiRequest.js");




/**
 * @classdesc
 * Classe de gestion des param. des requêtes de type PROFIL du service altimetrique.
 *
 * @constructor
 * @alias Gp.Services.Alti.Request.AltiProfilRequest
 * @param {Object}   options - options
 * @param {String}   options.sampling - 3
 *
 * @private
 */
function AltiProfilRequest (options) {
    if (!(this instanceof AltiProfilRequest)) {
        throw new TypeError("AltiProfilRequest constructor cannot be called as a function.");
    }

    /**
     * Nom de la classe (heritage)
     */
    this.CLASSNAME = "AltiProfilRequest";

    // appel du constructeur par heritage
    _AltiRequest__WEBPACK_IMPORTED_MODULE_1__["default"].apply(this, arguments);

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur AltiProfilRequest ()]");

    /**
     * Sampling
     * Par defaut, 3
     */
    this.sampling = this.options.sampling || 3; // test des options héritées !
}

/**
 * @lends module:AltiProfilRequest#
 */

AltiProfilRequest.prototype = Object.create(_AltiRequest__WEBPACK_IMPORTED_MODULE_1__["default"].prototype, {

    /**
     * Setter/getter pour "sampling"
     */
    sampling : {
        /** getter */
        get : function () {
            return this._sampling;
        },
        /** setter */
        set : function (value) {
            this._sampling = value;
        }
    }
});

/**
 * Constructeur (alias)
 */
AltiProfilRequest.prototype.constructor = AltiProfilRequest;

/**
 * Tableau de clefs/valeurs pour param.
 *
 * @returns {Object[]}
 */
AltiProfilRequest.prototype.getData = function () {
    // par glop..., appel de AltiRequest::getData () !
    var map = [];
    map.push({
        k : "lon",
        v : this.getLon()
    });
    map.push({
        k : "lat",
        v : this.getLat()
    });
    // map.push({k : "delimiter", v : this.delimiter}); // FIXME on retire le param "delimiter"
    map.push({
        k : "indent",
        v : this.indent
    });
    map.push({
        k : "crs",
        v : this.crs
    });
    map.push({
        k : "sampling",
        v : this.sampling
    });
    map.push({
        k : "format",
        v : this.format
    });
    map.push({
        k : "resource",
        v : this.resource
    });

    return map;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AltiProfilRequest);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiRequest.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Request/model/AltiRequest.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");



/**
 * @classdesc
 * Classe de gestion des param. des requêtes du service altimetrique.
 *
 * @constructor
 * @alias Gp.Services.Alti.Request.AltiRequest
 * @param {Object} options - options
 * @param {Object}   options.positions - tableau de coordonnées lon/lat
 * @param {String}   options.delimiter - "|"
 * @param {Boolean}  options.indent - false|true
 * @param {String}   options.crs - "CRS:84"
 * @param {String}   options.format - "JSON|XML"
 *
 * @private
 */
function AltiRequest (options) {
    if (!(this instanceof AltiRequest)) {
        throw new TypeError("AltiRequest constructor cannot be called as a function.");
    }

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur AltiRequest ()]");

    /**
     * Options en paramêtres du constructeur.
     */
    this.options = options || {};

    /**
     * Liste des coordonnées.
     * @example
     * var c = [{lon : "", lat : ""}, {lon : "", lat : ""}];
     */
    this.positions = this.options.positions || [];

    /**
     * Caractère de séparation.
     * Par defaut, "|".
     */
    this.delimiter = this.options.delimiter || "|";

    /**
     * Indentation.
     * true|false
     */
    this.indent = this.options.indent || false;

    /**
     * Projection.
     * Par defaut, CRS:84.
     */
    this.crs = this.options.crs || "CRS:84";

    /**
     * format de sortie.
     * Par defaut, "json".
     */
    this.format = this.options.format || "json";

    /*
     * Ressource utilisée
    */
    this.resource = this.options.resource;

    /**
     * Réponse détaillée (source & accuracy)
     * true|false
    */
    this.measures = this.options.measures || false;
}

/**
 * CLASSNAME
 */
AltiRequest.CLASSNAME = "AltiRequest";

AltiRequest.prototype = {

    /**
     * @lends module:AltiRequest#
     */

    /**
     * Constructeur (alias)
     */
    constructor : AltiRequest,

    /**
     * Ajout d"une liste de coordonnées.
     *
     * @param {Object[]} lstPosition - liste de positions
     * @example
     * obj.setPositions ([{lon : "0.15", lat : "0.15"}, {lon : "1.15", lat : "1.15"}]);
     */
    setPositions : function (lstPosition) {
        var positions = [];
        for (var i = 0; i < lstPosition.length; i++) {
            var o = lstPosition[i];
            if (o.lon && o.lat) {
                positions.push(o);
            }
        }

        this.positions = positions;
    },

    /**
     * Liste des coordonnées.
     *
     * @param {Int} pos - position
     * @returns {positions}
     * @example
     * obj.getPositions ();  // [{lon : "", lat : ""}, {lon : "", lat : ""}]
     * obj.getPositions (0); // [{lon : "", lat : ""}]
     */
    getPositions : function (pos) {
        // FIXME test if not a number !?
        if (!pos) {
            return this.positions;
        }

        var index = this.positions.length - 1;
        if (pos > index || pos < index) {
            this.logger.warn("index out of range !");
            return this.positions;
        }

        return this.positions[pos];
    },

    /**
     * Ajout d"une liste de coordonnées.
     *
     * @param {Object[]} lstPosition - liste de positions
     * @example
     * obj.addPositions ([{lon : "0.15", lat : "0.15"}, {lon : "1.15", lat : "1.15"}]);
     */
    addPositions : function (lstPosition) {
        for (var i = 0; i < lstPosition.length; i++) {
            var o = lstPosition[i];
            if (o.lon && o.lat) {
                this.positions.push(lstPosition[i]);
            }
        }
    },

    /**
     * Retourne la liste des longitudes avec un caractère de séparation.
     *
     * @returns {String} - une liste de longitudes
     * @example
     * // out : 0.2367|2.1570|43.789|...
     */
    getLon : function () {
        var lstLon = [];
        for (var i = 0; i < this.positions.length; i++) {
            lstLon.push(this.positions[i].lon);
        }
        this.logger.trace(lstLon);
        return lstLon.join(this.delimiter);
    },

    /**
     * Retourne la liste des lattitudes avec un caractère de séparation.
     *
     * @returns {String} - une liste de lattitudes
     * @example
     * // out : 0.2367|2.1570|43.789|...
     */
    getLat : function () {
        var lstLat = [];
        for (var i = 0; i < this.positions.length; i++) {
            lstLat.push(this.positions[i].lat);
        }
        this.logger.trace(lstLat);
        return lstLat.join(this.delimiter);
    }

};

/**
 * Tableau de clefs/valeurs pour param.
 *
 * @returns {Object[]}
 */
AltiRequest.prototype.getData = function () {
    var map = [];

    map.push({
        k : "lon",
        v : this.getLon()
    });
    map.push({
        k : "lat",
        v : this.getLat()
    });
    map.push({
        k : "delimiter",
        v : this.delimiter
    });
    map.push({
        k : "indent",
        v : this.indent
    });
    map.push({
        k : "crs",
        v : this.crs
    });
    map.push({
        k : "format",
        v : this.format
    });

    return map;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AltiRequest);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Response/AltiResponseFactory.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Response/AltiResponseFactory.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Utils/MessagesResources */ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js");
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../Exceptions/ErrorService */ "./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js");
/* harmony import */ var _Formats_XML__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../Formats/XML */ "./node_modules/geoportal-access-lib/src/Formats/XML.js");
/* harmony import */ var _Formats_AltiResponseReader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Formats/AltiResponseReader */ "./node_modules/geoportal-access-lib/src/Services/Alti/Formats/AltiResponseReader.js");
/* harmony import */ var _model_AltiResponse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./model/AltiResponse */ "./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/AltiResponse.js");
/* harmony import */ var _model_Elevation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./model/Elevation */ "./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/Elevation.js");
/**
 * Factory pour générer une reponse JSON à partir d'un XML ou d'un JSON
 * (Factory)
 *
 * @module AltiResponseFactory
 * @private
 * @alias Gp.Services.Alti.Response.AltiResponseFactory
 */








var AltiResponseFactory = {

    /**
     * interface unique
     *
     * @method build
     * @static
     * @param {Object} options - options definies dans le composant Alti
     *
     * @example
     *   var options = {
     *      response :
     *      outputFormat :
     *      rawResponse :
     *      scope :
     *      onSuccess :
     *      onError :
     *   };
     *
     */
    build : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("AltiResponseFactory");
        logger.trace(["AltiResponseFactory::build()"]);

        var data = null;

        if (options.response) {
            if (options.rawResponse) {
                logger.trace("analyze response : raw");
                data = options.response;
            } else {
                switch (options.outputFormat) {
                    case "xml":
                        logger.trace("analyze response : xml");

                        try {
                            var p = new _Formats_XML__WEBPACK_IMPORTED_MODULE_3__["default"]({
                                reader : _Formats_AltiResponseReader__WEBPACK_IMPORTED_MODULE_4__["default"]
                            });

                            if (typeof options.response === "string") {
                                p.setXMLString(options.response);
                            } else {
                                p.setXMLDoc(options.response);
                            }

                            data = p.parse();

                            if (!data) {
                                throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION_2"));
                            }
                        } catch (e) {
                            var message = e.message;
                            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                                message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", message),
                                status : 200,
                                type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_SRVERR
                            }));
                            return;
                        }

                        break;

                    case "json":
                        logger.trace("analyze response : json");
                        logger.trace("analyze response : ", typeof options.response);

                        var JSONResponse = null;
                        if (typeof options.response === "string") {
                            JSONResponse = JSON.parse(options.response);
                        } else {
                            JSONResponse = options.response;
                        }

                        // le service renvoie t il une erreur ?
                        if (JSONResponse && JSONResponse.error) {
                            // ex. {"error": {"code": "BAD_PARAMETER","description": "The values () cannot be parsed as a valid longitude (double value such as -180 < lat < 180)."}}
                            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                                message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", JSONResponse.error.description),
                                status : 200,
                                type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_SRVERR
                            }));
                            return;
                        }

                        // analyse de la reponse
                        if (JSONResponse) {
                            var elevations = JSONResponse.elevations;
                            var altiResponse = new _model_AltiResponse__WEBPACK_IMPORTED_MODULE_5__["default"]();
                            var elevation;
                            if (Array.isArray(elevations) && elevations.length) {
                                for (var i = 0; i < elevations.length; i++) {
                                    elevation = new _model_Elevation__WEBPACK_IMPORTED_MODULE_6__["default"]();

                                    if (typeof elevations[i] === "object") {
                                        // elevations[i] est un objet elevation
                                        if (elevations[i].lon) {
                                            elevation.lon = elevations[i].lon;
                                        }
                                        if (elevations[i].lat) {
                                            elevation.lat = elevations[i].lat;
                                        }
                                        if (elevations[i].z) {
                                            elevation.z = elevations[i].z;
                                        }
                                        if (elevations[i].acc) {
                                            elevation.acc = elevations[i].acc;
                                        }
                                        if (elevations[i].measures) {
                                            elevation.measures = elevations[i].measures;
                                        }
                                    } else if (typeof elevations[i] === "number") {
                                        // elevations[i] est un nombre, dans le cas de zonly=true notamment
                                        elevation.z = elevations[i];
                                    }

                                    if (Array.isArray(altiResponse.elevations)) {
                                        altiResponse.elevations.push(elevation);
                                    }
                                }
                            }
                            data = altiResponse;
                        }

                        if (!data) {
                            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                                message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_ANALYSE_2"),
                                type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_UNKERR,
                                status : -1
                            }));
                            return;
                        }
                        break;

                    default:
                        options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                            message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_FORMAT_2"),
                            type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_UNKERR,
                            status : -1
                        }));
                        return;
                }

                // Si la réponse contenait une exception renvoyée par le service
                if (data.exceptionReport) {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", data.exceptionReport),
                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_SRVERR,
                        status : 200
                    }));
                    return;
                } else if (data.error) {
                    var errorMess = data.error.description;
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", errorMess),
                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_SRVERR,
                        status : 200
                    }));
                    return;
                }
            }
        } else {
            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
            return;
        }

        options.onSuccess.call(options.scope, data);
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AltiResponseFactory);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/AltiResponse.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/AltiResponse.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Response object for {@link module:Services~getAltitude Gp.Services.getAltitude ()} invocation when successful. Received as the argument of onSuccess callback function.
 *
 * @property {Array.<Gp.Services.Alti.Elevation>} elevations - Elevations array.
 *
 * @namespace
 * @alias Gp.Services.AltiResponse
 */
function AltiResponse () {
    if (!(this instanceof AltiResponse)) {
        throw new TypeError("AltiResponse constructor cannot be called as a function.");
    }

    this.elevations = [];
}

AltiResponse.prototype = {

    constructor : AltiResponse

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AltiResponse);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/Elevation.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/Elevation.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/**
 * Single elevation object returned by underlying web service. Contains at least, one elevation (z). May also contain point coordinates and elevation accuracy if "zonly" parameter wasn't set to true.
 *
 * @property {Float} lat - Point latitude. (only if zonly=false)
 * @property {Float} lon - Point longitude. (only if zonly=false)
 * @property {Float} z - Point elevation.
 * @property {Float} acc - Accuracy of elevation for this point. (only if zonly=false)
 *
 * @namespace
 * @alias Gp.Services.Alti.Elevation
 */
function Elevation () {
    if (!(this instanceof Elevation)) {
        throw new TypeError("Elevation constructor cannot be called as a function.");
    }

    this.z = null;
}

Elevation.prototype = {

    constructor : Elevation

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Elevation);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/Measure.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Alti/Response/model/Measure.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/**
 * Single measure object returned by underlying web service if measures = true and zonly = false
 *
 * @property {String} source_name - Name of the source
 * @property {String} source_measure - Name of the measure
 * @property {Float} z - Point elevation.
 * @property {Float} acc - Accuracy of elevation for this point. (only if zonly=false)
 *
 * @namespace
 * @alias Gp.Services.Alti.Measure
 */
function Measure () {
    if (!(this instanceof Measure)) {
        throw new TypeError("Measure constructor cannot be called as a function.");
    }

    this.source_name = null;
    this.source_measure = null;
    this.z = null;
    this.acc = null;
}

Measure.prototype = {

    constructor : Measure

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Measure);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/AutoComplete/AutoComplete.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/AutoComplete/AutoComplete.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CommonService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../CommonService */ "./node_modules/geoportal-access-lib/src/Services/CommonService.js");
/* harmony import */ var _DefaultUrlService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DefaultUrlService */ "./node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js");
/* harmony import */ var _Response_AutoCompleteResponseFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Response/AutoCompleteResponseFactory */ "./node_modules/geoportal-access-lib/src/Services/AutoComplete/Response/AutoCompleteResponseFactory.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Utils/MessagesResources */ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js");
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../Utils/Helper */ "./node_modules/geoportal-access-lib/src/Utils/Helper.js");
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../Exceptions/ErrorService */ "./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js");








/**
 * @classdesc
 * Appel du service d'autocomplétion du Géoportail :
 * envoi de la requête construite selon les paramètres en options,
 * éventuellement parsing et analyse  de la réponse,
 * retour d'une réponse en paramètre de la fonction onSuccess.
 * @constructor
 * @extends {Gp.Services.CommonService}
 * @alias Gp.Services.AutoComplete
 *
 * @param {Object} options - options spécifiques au service (+ les options heritées)
 *
 * @param {String} options.text - La chaîne de caractère à compléter.
 *      Cette chaîne n'est pas "URL encodée".
 *      C'est l'API qui s'occupe de l'encoder pour l'inclure dans la requête.
 *
 * @param {Array.<String>} [options.type = ["StreetAddress"]] - Type de l'objet recherché.
 *      Le service d'autocomplétion du Géoportail permet de rechercher des toponymes 'PositionOfInterest' et/ou des adresses postales 'StreetAddress'.
 *      D'autres types pourront être rajoutés selon l'évolution du service.
 *      Par défaut, type = ['StreetAddress'].
 *
 * @param {String} [options.territory] - Limitation de la zone de recherche de localisants.
 *      Le service d'autocomplétion du Géoportail permet de limiter la recherche à la métropole et la Corse : options.territory = 'METROPOLE',
 *      DOMS TOMS : options.territory = 'DOMTOM', ou à un département : options.territory = '31'
 *      Pas de valeur par défaut.
 *      La valeur par défaut est donc celle du service.
 *      Le service d'autocomplétion du Géoportail renvoie toutes les informations quand aucun territoire n'est spécifié.
 *
 * @param {Number} [options.maximumResponses = 10] - Nombre de réponses maximal que l'on souhaite recevoir.
 *      Pas de valeur par défaut.
 *      La valeur par défaut sera donc celle du service : 10.
 *
 * @example
 *   var options = {
 *      // options communes aux services
 *      apiKey : null,
 *      serverUrl : 'http://localhost/service/',
 *      protocol : 'JSONP', // JSONP|XHR
 *      proxyURL : null,
 *      httpMethod : 'GET', // GET|POST
 *      timeOut : 10000, // ms
 *      rawResponse : false, // true|false
 *      scope : null, // this
 *      onSuccess : function (response) {},
 *      onFailure : function (error) {},
 *      // spécifique au service
 *      text : "",
 *      type : "StreetAddress",
 *      territory : 'METROPOLE',
 *      maximumResponses : 10
 *   };
 */
function AutoComplete (options_) {
    if (!(this instanceof AutoComplete)) {
        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_4__["default"].getMessage("CLASS_CONSTRUCTOR", "AutoComplete"));
    }

    /**
     * Nom de la classe (heritage)
     * FIXME instance ou classe ?
     */
    this.CLASSNAME = "AutoComplete";

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_3__["default"].getLogger("Gp.Services.AutoComplete");
    this.logger.trace("[Constructeur AutoComplete (options)]");

    var options = this.patchOptionConvertor(options_);

    if (!options.serverUrl) {
        options.serverUrl = _DefaultUrlService__WEBPACK_IMPORTED_MODULE_1__["default"].AutoComplete.newUrl();
    }

    // appel du constructeur par heritage
    _CommonService__WEBPACK_IMPORTED_MODULE_0__["default"].apply(this, arguments);

    if (!options.text) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_4__["default"].getMessage("PARAM_MISSING", "text"));
    }

    // ajout des options spécifiques au service
    this.options.text = options.text;

    // on definit des parametres par defaut
    if (!options.type) {
        options.type = ["StreetAddress,PositionOfInterest"];
    }

    this.options.type = options.type;
    this.options.territory = options.terr || "";
    this.options.maximumResponses = options.maximumResponses || 10;

    // INFO
    // le service ne repond pas en mode POST (405 Method Not Allowed)
    if (this.options.protocol === "XHR" && this.options.httpMethod === "POST") {
        this.logger.warn("Le service ne gére pas le mode d'interrogation en POST, on bascule sur du GET !");
        this.options.httpMethod = "GET"; // on surcharge !
    }

    // attributs d'instances

    /**
     * Format forcé de la réponse du service : "json"
     * sauf si l'on souhaite une reponse brute (options.rawResponse)
     */
    this.options.outputFormat = (this.options.rawResponse) ? "" : "json";
}

/**
 * @lends module:AutoComplete#
 */

AutoComplete.prototype = Object.create(_CommonService__WEBPACK_IMPORTED_MODULE_0__["default"].prototype, {
    // todo
    // getter/setter
});

/*
 * Constructeur (alias)
 */
AutoComplete.prototype.constructor = AutoComplete;

/**
 * Patch pour la convertion des options vers le nouveau formalisme.
 *
 * @param {Object} options_ - options du service
 * @return {Object} - options
 */
AutoComplete.prototype.patchOptionConvertor = function (options_) {
    const options = options_;

    if (options.filterOptions) {
        this.logger.warn("The parameter 'filterOptions' is deprecated");

        if (options.filterOptions.type) {
            this.logger.warn("The parameter 'filterOptions.type' is deprecated");
            if (!options.type) {
                options.type = options.filterOptions.type;
            }
        }

        if (options.filterOptions.territory) {
            this.logger.warn("The parameter 'filterOptions.territory' is deprecated");
            if (!options.terr) {
                options.terr = options.filterOptions.territory;
            }
        }

        delete options.filterOptions;
    }

    return options;
};

/**
 * (overwrite)
 * Création de la requête
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
AutoComplete.prototype.buildRequest = function (error, success) {
    // ex.
    // http://wxs.ign.fr/CLEF/ols/apis/completion?
    // text=Brie-Comt&
    // type=StreetAddress,PositionOfInterest&
    // territory=METROPOLE&
    // maximumResponses=10

    // traitement des param KPV sous forme de tableau
    var territory = "";
    if (this.options.territory) {
        territory = this.options.territory;
    }

    var type = "";
    if (this.options.type) {
        type = this.options.type.join(",");
    }

    // normalisation de la requete avec param KPV
    this.request = _Utils_Helper__WEBPACK_IMPORTED_MODULE_5__["default"].normalyzeParameters({
        text : encodeURIComponent(this.options.text),
        type : type,
        terr : territory,
        maximumResponses : this.options.maximumResponses
    });

    (!this.request)
        ? error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_6__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_4__["default"].getMessage("SERVICE_REQUEST_BUILD")))
        : success.call(this, this.request);
};

/**
 * (overwrite)
 * Analyse de la reponse
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback de succès de l'analyse de la réponse
 */
AutoComplete.prototype.analyzeResponse = function (error, success) {
    if (this.response) {
        var options = {
            response : this.response,
            rawResponse : this.options.rawResponse,
            onSuccess : success,
            onError : error,
            scope : this
        };

        _Response_AutoCompleteResponseFactory__WEBPACK_IMPORTED_MODULE_2__["default"].build(options);
    } else {
        error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_6__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_4__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AutoComplete);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/AutoComplete/Response/AutoCompleteResponseFactory.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/AutoComplete/Response/AutoCompleteResponseFactory.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Utils/MessagesResources */ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js");
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../Exceptions/ErrorService */ "./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js");
/* harmony import */ var _model_AutoCompleteResponse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model/AutoCompleteResponse */ "./node_modules/geoportal-access-lib/src/Services/AutoComplete/Response/model/AutoCompleteResponse.js");
/* harmony import */ var _model_SuggestedLocation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./model/SuggestedLocation */ "./node_modules/geoportal-access-lib/src/Services/AutoComplete/Response/model/SuggestedLocation.js");
/**
 * Factory pour générer une reponse JSON à partir d'un XML ou d'un JSON
 * (Factory)
 *
 * @module AutoCompleteResponseFactory
 * @private
 * @alias Gp.Services.AutoComplete.Response.AutoCompleteResponseFactory
 */






var AutoCompleteResponseFactory = {

    /**
     * interface unique
     *
     * @method build
     * @static
     * @param {Object} options - options definies dans le composant Alti
     *
     * @example
     *   var options = {
     *      response :
     *      outputFormat :
     *      rawResponse :
     *      scope :
     *      onSuccess :
     *      onError :
     *   };
     *
     */
    build : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("AutoCompleteResponseFactory");
        logger.trace(["AutoCompleteResponseFactory::build()"]);

        var data = null;

        if (options.response) {
            if (options.rawResponse) {
                logger.trace("analyze response : raw");
                data = options.response;
            } else {
                var JSONResponse = null;
                if (typeof options.response === "string") {
                    JSONResponse = JSON.parse(options.response);
                } else {
                    JSONResponse = options.response;
                }

                // analyse de la réponse
                if (JSONResponse) {
                    // le service renvoie t il une erreur ?
                    if (JSONResponse.error) {
                        // ex. ?
                        options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                            message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", JSONResponse.error.description),
                            status : JSONResponse.error.code,
                            type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_SRVERR
                        }));
                        return;
                    }

                    // création de l'objet réponse
                    data = new _model_AutoCompleteResponse__WEBPACK_IMPORTED_MODULE_3__["default"]();

                    // boucle sur les résultats de l'autocomplétion
                    if (JSONResponse.results && Array.isArray(JSONResponse.results)) {
                        var suggestedLocation = null;

                        for (var i = 0; i < JSONResponse.results.length; i++) {
                            var result = JSONResponse.results[i];
                            suggestedLocation = new _model_SuggestedLocation__WEBPACK_IMPORTED_MODULE_4__["default"]();

                            if (result) {
                                if (result.country === "StreetAddress") {
                                    suggestedLocation.street = result.street;
                                    suggestedLocation.type = "StreetAddress";
                                } else if (result.country === "PositionOfInterest") {
                                    suggestedLocation.poi = result.street;
                                    suggestedLocation.type = "PositionOfInterest";
                                    suggestedLocation.poiType = result.poiType;
                                }

                                if (suggestedLocation.position) {
                                    suggestedLocation.position.x = result.x;
                                    suggestedLocation.position.y = result.y;
                                }

                                suggestedLocation.kind = result.kind;
                                suggestedLocation.commune = result.city;
                                suggestedLocation.fullText = result.fulltext;
                                suggestedLocation.postalCode = result.zipcode;
                                suggestedLocation.classification = result.classification;
                            }
                            // Ajout du résultat au tableau reverseGeocodedLocations de geocodedLocation
                            data.suggestedLocations.push(suggestedLocation);
                        }
                    } else {
                        options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_FORMAT_3")));
                        return;
                    }

                    if (!data.suggestedLocations.length) {
                        options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_FORMAT_3")));
                        return;
                    }
                }

                if (!data) {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_ANALYSE_2"),
                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_UNKERR,
                        status : -1
                    }));
                    return;
                }

                // Si la réponse contenait une exception renvoyée par le service
                if (data.exceptionReport) {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", data.exceptionReport),
                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_SRVERR,
                        status : 200
                    }));
                    return;
                }
            }
        } else {
            // si la réponse (xmlString) est vide, on appelle le callback d'erreur
            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
            return;
        }

        // si tout s'est bien passé, on appelle le callback de succès
        options.onSuccess.call(options.scope, data);
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AutoCompleteResponseFactory);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/AutoComplete/Response/model/AutoCompleteResponse.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/AutoComplete/Response/model/AutoCompleteResponse.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Response object for {@link module:Services~autoComplete Gp.Services.autoComplete ()} invocation when successful. Received as the argument of onSuccess callback function.
 *
 * @property {Array.<Gp.Services.AutoComplete.SuggestedLocation>} suggestedLocations - SuggestedLocations array.
 *
 * @namespace
 * @alias Gp.Services.AutoCompleteResponse
 */
function AutoCompleteResponse () {
    if (!(this instanceof AutoCompleteResponse)) {
        throw new TypeError("AutoCompleteResponse constructor cannot be called as a function.");
    }

    this.suggestedLocations = [];
}

AutoCompleteResponse.prototype = {

    constructor : AutoCompleteResponse

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AutoCompleteResponse);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/AutoComplete/Response/model/SuggestedLocation.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/AutoComplete/Response/model/SuggestedLocation.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/**
 * Single SuggestedLocation Object returned by underlying web service.
 * Each suggested location represents a street address ("StreetAddress") or a place name ("PositionOfInterest").
 *
 * @property {String} type - Suggested location type : "StreetAddress" ou "PositionOfInterest"
 * @property {Gp.Point} position - Position of the suggested location given in requested coordinates system.
 * @property {String} commune - Suggested municipality
 * @property {String} fullText - Full text representation of the suggested location.
 * @property {String} postalCode - Suggested location postcode
 * @property {Integer} classification - Number used to classify the importance of the place where is the suggested location from 1 (most important) to 7 (less important).
 * @property {String} street - Street name of the suggested location ("StreetAddress" only).
 * @property {String} kind - Nature of the suggested location : "prefecture", "monument", "commune", ... for instance ("PositionOfInterest" only).
 *
 * @namespace
 * @alias Gp.Services.AutoComplete.SuggestedLocation
 */
function SuggestedLocation () {
    if (!(this instanceof SuggestedLocation)) {
        throw new TypeError("SuggestedLocation constructor cannot be called as a function.");
    }

    /* REPONSE :
        {
           "status" : "OK",
           "results" : [
              {
                 "country":"PositionOfInterest",
                 "x":-1.559185,
                 "y":47.952603,
                 "city":"Brie",
                 "zipcode":"35150",
                 "street":"corbe",
                 "kind":"Lieu-dit habité",
                 "fulltext":"corbe, 35150 Brie",
                 "classification":6
              },
              {
                 "country":"StreetAddress",
                 "x":1.538295,
                 "y":43.19646,
                 "city":"Brie",
                 "zipcode":"09700",
                 "street":"courreste",
                 "kind":"",
                 "fulltext":"courreste, 09700 Brie",
                 "classification":7
              }
           ]
        }
    */

    /* REPONSE EN ERREUR
        {
            status : "ERROR",
            results : [ ]
        }
    */

    /**
     * Suggested location type : "StreetAddress" ou "PositionOfInterest"
     * @type {String}
     */
    this.type = null;

    /**
     * Position of the suggested location given in requested coordinates system.
     * @type {Gp.Point}
     */
    this.position = {
        x : null,
        y : null
    };

    /**
     * Suggested municipality
     * @type {String}
     */
    this.commune = null;

    /**
     * Full text representation of the suggested location.
     * @type {String}
     */
    this.fullText = null;

    /**
     * Suggested location postcode
     * @type {Number}
     */
    this.postalCode = null;

    /**
     * Number used to classify the importance of the place where is the suggested location from 1 (most important) to 7 (less important).
     * @type {Integer}
     */
    this.classification = null;

    /**
     * Street name of the suggested location ("StreetAddress" only).
     * @type {String}
     */
    this.street = null;

    /**
     * Place name of the suggested location ("PositionOfInterest" only).
     * @type {String}
     */
    this.poi = null;

    /**
     * Nature of the suggested location : "prefecture", "monument", "commune", ... for instance ("PositionOfInterest" only).
     * @type {String}
     */
    this.kind = null;
}

SuggestedLocation.prototype = {

    constructor : SuggestedLocation
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SuggestedLocation);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/CommonService.js":
/*!*************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/CommonService.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils/Helper */ "./node_modules/geoportal-access-lib/src/Utils/Helper.js");
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Utils/MessagesResources */ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js");
/* harmony import */ var _Protocols_Protocol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Protocols/Protocol */ "./node_modules/geoportal-access-lib/src/Protocols/Protocol.js");
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Exceptions/ErrorService */ "./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js");
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../package.json */ "./node_modules/geoportal-access-lib/package.json");





// import DefaultUrlService from "./DefaultUrlService";
// package.json (extract version)


/**
 * @classdesc
 * Composant Service
 *
 * @constructor
 * @alias Gp.Services.CommonService
 * @param {Object} options - options communes à tous les services
 *
 * @param {String} [options.serverUrl] - URL d'accès au service. Par défaut "https://data.geopf.fr/SERVICE/".
 *      Permet de forcer l'utilisation d'un service équivalent déployé derrière une éventuelle autre URL d'accès.
 *      Si ce paramètre est renseigné alors, le paramètre par défaut est ignoré.
 *
 * @param {String} [options.protocol] - Le protocole à utiliser pour récupérer les informations du service :
 *      peut valoir 'JSONP' ou 'XHR'.
 *      Par défaut, c'est le protocole XHR qui sera utilisé.
 *      Attention, le protocole JSONP n'est pas valide dans un environnement NodeJS (Utilisation du mode XHR).
 *
 * @param {Boolean} [options.ssl] - Indique si l'on souhaite intérroger les services en https.
 *      Ce paramètre ne fonctionne que pour une utilisation hors navigateur (ex. NodeJS).
 *      Sur un navigateur, le protocole est automatiquement extrait de l'url du site...
 *      Par défaut, on utilise le protocole http (ssl=false).
 *
 * @param {String} [options.proxyURL] - Le proxy à utiliser pour pallier au problème de cross-domain dans le cas d'une requête XHR.
 *      Utile si le paramètre 'protocol' vaut 'XHR', il ne sera pas pris en compte si protocol vaut JSONP.
 *
 * @param {String} [options.callbackSuffix] - Suffixe de la fonction de callback à utiliser, dans le cas du protocole JSONP.
 *      Par défaut, la fonction de callback portera un nom du type "callback"+ID, où ID est soit un identifiant unique généré à chaque requête,
 *      soit le paramètre callbackSuffix s'il est spécifié. Par exemple, si callbackSuffix="_2", la fonction sera "callback_2 ()".
 *      Utile pour utiliser une réponse déjà encapsulée dans une fonction de callback, dont le nom est connu
 *      Utile seulement si le paramètre 'protocol' vaut 'JSONP', il ne sera pas pris en compte si protocol vaut 'XHR'.
 *
 * @param {String} [options.httpMethod] - La méthode HTTP
 *      à utiliser dans le cas d'une requête XHR : peut valoir 'GET' ou 'POST'.
 *      Non pris en compte si 'protocol' vaut JSONP qui fonctionne obligatoirement en GET.
 *      Par défaut, c'est la méthode GET qui est utilisée.
 *
 * @param {String} [options.contentType] - Content-Type de la requete
 *      à utiliser dans le cas d'une requête XHR en mode POST.
 *      Non pris en compte si 'protocol' vaut JSONP et/ou la méthode HTTP vaut GET.
 *      Par défaut, c'est la méthode GET qui est utilisée donc on n'utilise pas de Content-Type.
 *
 * @param {Number} [options.timeOut] - Délai d'attente maximal (en ms) de la réponse du service (à partir de l'envoi de la requête).
 *      Par défaut, aucun timeOut n'est pris en compte (timeoutDelay= 0).
 *
 * @param {Boolean} [options.rawResponse] - Indique si l'on souhaite que la réponse du service ne soit pas parsée par l'API avant d'être restituée.
 *      (Cf. paramètre « onSuccess » pour plus de détails).
 *
 * @param {Function} [options.onSuccess] - Fonction appelée lorsque le service répond correctement à la requête
 *      (code HTTP 200, sans message d'erreur).
 *      Cette fonction prend en paramètre la réponse du service,
 *      soit sous la forme d'un Object Javascript formaté par le parseur dédié à la syntaxe du service (comportement par défaut) ;
 *      soit brute au format String non prétraité si le paramètre « rawResponse » a été précisé avec la valeur « true ».
 *
 * @param {Function} [options.onFailure] - Fonction appelée lorsque le service ne répond pas correctement
 *      (code HTTP de retour différent de 200 ou pas de réponse).
 *
 * @param {Function} [options.onBeforeParse] - Fonction appelée avant le parsing de la réponse
 *      Permet de modifier la réponse avant parsing et la fonction doit retourner une String.
 *      Cette fonction prend en paramètre la réponse telle que renvoyée par le service
 *      (cad au format json ou xml).
 *      Pour le JSONP, si le paramètre "rawResponse" a été précisé avec la valeur "true",
 *      la fonction prend en paramètre un Object JavaScript contenant la réponse XML.
 *
 * @example
 *   var options = {
 *      serverUrl : 'http://localhost/service/',
 *      protocol : 'JSONP', // JSONP|XHR
 *      ssl : false,
 *      proxyURL : null,
 *      callbackName : null,
 *      httpMethod : 'GET', // GET|POST
 *      timeOut : 10000, // ms
 *      rawResponse : false, // true|false
 *      scope : null, // this
 *      onSuccess : function (response) {},
 *      onFailure : function (error) {},
 *      onBeforeParse : function (rawResponse) {}
 *   };
 */
function CommonService (options) {
    if (!(this instanceof CommonService)) {
        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__["default"].getMessage("CLASS_CONSTRUCTOR"));
    }

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("CommonService");
    this.logger.trace("[Constructeur CommonService (options)]");

    // #####################
    // récupération des options par défaut pour les paramètres optionnels
    // #####################

    /**
     * Options du service
     * @type {Object}
     */
    this.options = {
        // protocol : "JSONP",
        protocol : "XHR",
        ssl : true,
        proxyURL : "",
        // callbackName : "",
        callbackSuffix : null,
        httpMethod : "GET",
        timeOut : 0,
        rawResponse : false,
        scope : this,
        /**
        * callback par defaut pour la reponse
        * @param {Object} response - response
        * @private
        */
        onSuccess : function (response) {
            console.log("onSuccess - la reponse est la suivante : ", response);
        },
        /**
        * callback par defaut pour les erreurs
        * @param {Object} error - error
        * @private
        */
        onFailure : function (error) {
            if (error.status === 200 || !error.status) {
                console.log("onFailure : ", error.message);
            } else {
                console.log("onFailure - Erreur (", error.status, ") : ", error.message);
            }
        }
    };

    // et on ajoute les options en paramètre aux options par défaut
    for (var opt in options) {
        if (options.hasOwnProperty(opt)) {
            this.options[opt] = options[opt];
        }
    }

    // #####################
    // analyse des options
    // #####################

    // modification de la fonction de callback onSuccess dans le cas où la réponse brute est demandée
    if (this.options.rawResponse && !this.options.onSuccess) {
        /**
        * callback par defaut pour la reponse
        * @param {Object} response - response
        * @private
        */
        this.options.onSuccess = function (response) {
            console.log("onSuccess - la réponse brute du service est la suivante : ", response);
        };
    }

    // gestion du callback onSuccess
    var bOnSuccess = !!(this.options.onSuccess !== null && typeof this.options.onSuccess === "function");
    if (!bOnSuccess) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__["default"].getMessage("PARAM_MISSING", "onSuccess()"));
    }

    // gestion de la methode HTTP
    this.options.httpMethod = (typeof options.httpMethod === "string") ? options.httpMethod.toUpperCase() : "GET";

    switch (this.options.httpMethod) {
        case "POST":
        case "GET":
            break;
        case "PUT":
        case "DELETE":
        case "HEAD":
        case "OPTIONS":
            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__["default"].getMessage("PARAM_NOT_SUPPORT", "httpMethod"));
        default:
            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__["default"].getMessage("PARAM_UNKNOWN", "httpMethod"));
    }

    // gestion du protocole
    // this.options.protocol = (typeof options.protocol === "string" ) ? options.protocol.toUpperCase() : "JSONP";
    this.options.protocol = (typeof options.protocol === "string") ? options.protocol.toUpperCase() : "XHR";

    switch (this.options.protocol) {
        case "JSONP":
        case "XHR":
            break;
        default:
            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__["default"].getMessage("PARAM_UNKNOWN", "protocol"));
    }

    // on determine l'environnement d'execution : browser ou non ?
    // et on lance une exception sur l'utilisation du protocole JSONP pour nodeJS...
    if (typeof window === "undefined" && this.options.protocol === "JSONP") {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_2__["default"].getMessage("PARAM_NOT_SUPPORT_NODEJS", "protocol=JSONP (instead use XHR)"));
    }

    // le protocole JSONP ne fonctionne qu'en GET.
    if (this.options.protocol === "JSONP") {
        this.options.httpMethod = "GET";
    }

    // gestion du cache
    this.options.nocache = options.nocache || false;

    // #####################
    // attributs d'instances
    // #####################

    /**
     * Format de réponse du service
     */
    this.options.outputFormat = null;
    /**
     * Requête envoyée au service
     */
    this.request = null;
    /**
     * Reponse du service
     */
    this.response = null;
}

/**
 * @lends module:CommonService
 */
CommonService.prototype = {

    /*
     * Constructeur (alias)
     */
    constructor : CommonService,

    /**
     * Appel du service Géoportail
     */
    call : function () {
        /* jshint validthis : true */
        this.logger.trace("CommonService::call ()");

        var context = this;
        /** fonction d'execution */
        function run () {
            this.logger.trace("CommonService::run ()");
            this.buildRequest.call(context, onError, onBuildRequest);
        }

        run.call(context);

        // callback de fin de construction de la requête
        function onBuildRequest (result) {
            this.logger.trace("CommonService::onBuildRequest : ", result);
            this.callService.call(context, onError, onCallService);
        }

        // callback de fin d'appel au service
        function onCallService (result) {
            this.logger.trace("CommonService::onCallService : ", result);
            this.analyzeResponse.call(context, onError, onAnalyzeResponse);
        }

        // callback de fin de lecture de la reponse
        function onAnalyzeResponse (result) {
            this.logger.trace("CommonService::onAnalyzeResponse : ", result);
            if (result) {
                this.options.onSuccess.call(this, result);
            } else {
                return onError.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__["default"]("Analyse de la reponse en échec !?"));
            }
        }

        // callback de gestion des erreurs : renvoit un objet de type ErrorService
        function onError (error) {
            this.logger.trace("CommonService::onError()");
            // error : l'objet est du type ErrorService ou Error
            var e = error;
            if (!(e instanceof _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__["default"])) {
                e = new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__["default"](error.message);
            }
            this.options.onFailure.call(this, e);
        }
    },

    /**
     * Création de la requête
     * @param {Function} error - callback
     * @param {Function} success - callback
     */
    buildRequest : function (error, success) {
        // INFO
        this.logger.error("overwritten method !");
        // retourne l'objet 'this.request'
        if (error) {
            error.call(this, "This method must be overwritten !");
        }
        success.call(this, "This method must be overwritten !");
    },

    /**
     * Appel du service
     * @param {Function} error - callback
     * @param {Function} success - callback
     */
    callService : function (error, success) {
        // INFO
        // retourne l'objet 'this.response'

        // NOTES
        //  Pour le mode XHR, on recupère une reponse sous forme d'un json ou xml (#document).
        //  Pour le mode JSONP, on a toujours un objet JSON mais sous 2 formes :
        //      - natif
        //      - XML encapsulé :
        //          {http : {status:200, error:null},xml :'réponse du service'}
        //          {http : {status:400, error:'reponse du service'},xml :null}
        //  En XHR, la reponse est directement sauvegardée dans 'this.response'.
        //  Par contre, en JSONP, on doit analyser la reponse (status ou non vide),
        //  et ne renvoyer que le contenu (xml ou l'objet)

        // gestion de la proxification du service
        var strUrlProxified = null;
        var strData = this.request;

        // a t on mis en place un proxy ?
        // la proxyfication est valable uniquement en mode XHR !
        var bUrlProxified = !!(this.options.proxyURL && this.options.protocol === "XHR");

        // rajout de l'option gpbibaccess
        // INFO : acces au numero de version de package.conf aprés compilation !
        var requestMetaOptions = {
            "gp-access-lib" : _package_json__WEBPACK_IMPORTED_MODULE_5__.version
        };

        if (this.options.apiKey) {
            requestMetaOptions.apiKey = this.options.apiKey;
        }

        this.options.serverUrl = _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__["default"].normalyzeUrl(this.options.serverUrl, requestMetaOptions, false);

        // si le proxy est renseigné, on proxifie l'url du service
        if (bUrlProxified) {
            if (this.options.httpMethod === "GET") {
                strUrlProxified = this.options.proxyURL + _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__["default"].normalyzeUrl(this.options.serverUrl, this.request, true);
                strData = null;
            }

            if (this.options.httpMethod === "POST") {
                strUrlProxified = this.options.proxyURL + _Utils_Helper__WEBPACK_IMPORTED_MODULE_1__["default"].normalyzeUrl(this.options.serverUrl, null, true);
                strData = this.request;
            }
        }

        // contexte du composant spécifique !
        var self = this;

        var options = {
            url : strUrlProxified || this.options.serverUrl,
            method : this.options.httpMethod,
            protocol : this.options.protocol,
            timeOut : this.options.timeOut || 0,
            format : this.options.outputFormat, // ceci declenche le parsing de la reponse du service, mais on souhaite toujours une reponse brute (string) !
            nocache : this.options.nocache || false, // ceci permet d'ajouter un timestamp dans la requête
            wrap : this.options.protocol !== "XHR", // ceci declenche l'encapsulation de la reponse XML du service dans du JSON, mais pas en mode XHR !
            callbackSuffix : this.options.callbackSuffix,
            // callbackName : this.options.callbackName || null,
            data : strData,
            headers : null, // TODO...
            content : this.options.contentType || "application/xml",
            scope : this.options.scope || this,
            // callback de reponse
            onResponse : function (response) {
                self.logger.trace("callService::onResponse()");

                // le contenu de la reponse à renvoyer !
                var content = null;

                // XHR : on renvoie toujours la reponse brute du service (json ou xml)
                // au parser du composant...
                if (self.options.protocol === "XHR") {
                    self.logger.trace("Response XHR", response);
                    content = response; // par defaut, la reponse du service  !
                }

                // JSONP : on pre-analyse la reponse brute du service (encapsuler ou pas)
                // avant de l'envoyer au parser du composant...
                if (self.options.protocol === "JSONP") {
                    self.logger.trace("Response JSON", response);
                    if (response) {
                        if (response.http) {
                            // reponse encapsulée :
                            // ex. reponse du service en xml
                            // > {http : {status:200, error:null},xml :'réponse du service'}
                            if (response.http.status !== 200) {
                                error.call(self, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__["default"]({
                                    status : response.http.status,
                                    message : response.http.error,
                                    type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__["default"].TYPE_SRVERR
                                }));
                                return;
                            } else {
                                content = response.xml; // par defaut !
                                if (self.options.rawResponse) {
                                    content = response;
                                }
                            }
                        } else {
                            // reponse non encapsulée :
                            // ex. reponse du service en json ou xml
                            content = response;
                        }
                    } else {
                        error.call(self, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__["default"]("Le contenu de la reponse est vide !?"));
                        return;
                    }
                }

                // si on souhaite parser la reponse du service
                if (typeof self.options.onBeforeParse === "function") {
                    var newResponse = self.options.onBeforeParse(content);
                    if (typeof newResponse === "string") {
                        // la reponse parsée par l'utilisateur est retournée sous
                        // forme de string !
                        content = newResponse;
                    }
                }
                // sauvegarde de la reponse dans l'objet parent (CommonService)
                self.response = content;
                // on renvoie la reponse...
                success.call(self, content);
            },
            // callback des erreurs
            onFailure : function (e) {
                self.logger.trace("callService::onFailure()");
                // on est forcement sur une erreur levée par un service !
                e.type = _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__["default"].TYPE_SRVERR;
                error.call(self, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__["default"](e));
            },
            // callback de timeOut
            onTimeOut : function () {
                self.logger.trace("callService::onTimeOut()");
                error.call(self, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_4__["default"]("TimeOut!"));
            }
        };

        _Protocols_Protocol__WEBPACK_IMPORTED_MODULE_3__["default"].send(options);
    },

    /**
     * Analyse de la réponse
     * @param {Function} error - callback
     * @param {Function} success - callback
     */
    analyzeResponse : function (error, success) {
        // INFO
        this.logger.error("overwritten method !");
        // retourne l'objet spécifique au type de composant (json)
        if (error) {
            error.call(this, "This method must be overwritten !");
        }
        success.call(this, "This method must be overwritten !");
    }

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CommonService);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Config/Config.js":
/*!*************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Config/Config.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Utils/MessagesResources */ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js");
/* harmony import */ var _CommonService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CommonService */ "./node_modules/geoportal-access-lib/src/Services/CommonService.js");
/* harmony import */ var _DefaultUrlService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../DefaultUrlService */ "./node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js");
/* harmony import */ var _ConfigInterface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ConfigInterface */ "./node_modules/geoportal-access-lib/src/Services/Config/ConfigInterface.js");






/**
 * @classdesc
 *
 * Recupération de la configuration de clés Géoportail sous forme de JSON
 *
 * @constructor
 * @extends {Gp.Services.CommonService}
 * @alias Gp.Services.Config
 * @param {Object} options - options spécifiques au service (+ les options heritées)
 * @param {Sting} options.apiKey - clé(s) dont on veut obtenir la configuration. Si plusieurs clés, séparer chacune par une virgule
 * @param {Boolean} [options.sync=false] - force le mode synchrone
 * @param {String} options.customConfigFile - chemin vers un fichier de configuration personnalisé. Surcharge le paramètre apiKey.
 *
 * @example
 *   var options = {
 *      apiKey : "cartes,ortho",
 *      sync : false,
 *      onSuccess : function (response) {},
 *      onFailure : function (error) {},
 *   };
 *
 */
function Config (options) {
    if (!(this instanceof Config)) {
        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("CLASS_CONSTRUCTOR", "Config"));
    }

    /**
     * Nom de la classe (heritage)
     */
    this.CLASSNAME = "Config";

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("Gp.Config");
    this.logger.trace("[Constructeur Config (options)]");

    // #####################
    // analyse des options
    // #####################

    // gestion du callback onSuccess
    var bOnSuccess = !!(options.onSuccess !== null && typeof options.onSuccess === "function");
    if (!bOnSuccess) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "onSuccess()"));
    }
    if (!options.apiKey && !options.customConfigFile) {
        // si pas de thème spécifié, on récupère toutes les ressources possibles dans l'objet Config
        options.apiKey = "full";
    }
    this.options = {};
    this.options.onSuccess = options.onSuccess;
    this.options.onFailure = options.onFailure;

    // mode sync
    this.options.sync = options.sync || false;

    // gestion d'un tableau d'url des fichiers de configuration
    this.options.listConfigUrls = (options.customConfigFile)
        ? [options.customConfigFile]
        : !Array.isArray(options.apiKey)
            ? _DefaultUrlService__WEBPACK_IMPORTED_MODULE_3__["default"].Config.url(options.apiKey.split(","))
            : _DefaultUrlService__WEBPACK_IMPORTED_MODULE_3__["default"].Config.url(options.apiKey);
}

/**
 * @lends module:Config#
 */
Config.prototype = Object.create(_CommonService__WEBPACK_IMPORTED_MODULE_2__["default"].prototype, {
    // todo
    // getter/setter
});

/**
 * Constructeur (alias)
 */
Config.prototype.constructor = Config;

/**
 * Création de la requête
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 * @overload
 */
Config.prototype.buildRequest = function (error, success) {
    // liste des urls des fichiers de configuration en JSON
    this.listConfigUrls = this.options.listConfigUrls;

    if (!this.listConfigUrls) {
        error.call(this, new Error("url by default not found !"));
        return;
    }

    // INFO :
    // il n'y a pas de construction de requête,
    // on passe directement à l'appel des requêtes
    success.call(this, this.listConfigUrls);
};

/**
 * Récupération des configuration
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 * @overload
 */
Config.prototype.callService = function (error, success) {
    if (this.options.sync) {
        __callServiceSync.call(this, error, success);
    } else {
        __callService.call(this, error, success);
    }
};

/**
 * Requêtes en mode asynchrone
 *
 * @param {*} error
 * @param {*} success
 * @private
 */
var __callService = function (error, success) {
    // liste des resultats au format JSON
    this.listConfigResults = [];

    // test on env. nodejs or browser
    let Fetch = null;
    if (typeof window === "undefined") {
        var nodefetch = __webpack_require__(/*! node-fetch */ "./node_modules/node-fetch/browser.js");
        Fetch = nodefetch;
    } else {
        Fetch = window.fetch;
    }

    // the factory of fetch !
    var fetchFactory = (url) => {
        return Fetch(url, { credentials : "same-origin" })
            .then((response) => {
                if (response.ok) {
                    return response.json()
                        .then((json) => {
                            // TODO :
                            // tester le contenu !
                            return json;
                        })
                        .catch((error) => {
                            throw new Error("Exception Json : " + error);
                        });
                } else {
                    throw new Error("Exception HTTP : " + response.status + " (status code) !");
                }
            })
            .catch((error) => {
                return new Promise((resolve, reject) => {
                    // eslint-disable-line no-unused-vars
                    reject(error);
                });
            });
    };

    // construction des promises fetch
    var promises = [];
    for (let index = 0; index < this.listConfigUrls.length; index++) {
        const url = this.listConfigUrls[index];
        promises.push(fetchFactory(url));
    }

    Promise.all(promises)
        .then((results) => {
            if (!results) {
                throw new Error("results config empty !?");
            }
            results.forEach((result) => {
                // TODO :
                // verification des resultats
                this.listConfigResults.push(result);
            });
        })
        .then(() => {
            success.call(this, this.listConfigResults);
        })
        .catch((e) => {
            // TODO :
            // construction d'un message
            error.call(this, e);
        });
};

/**
 * Requêtes en mode synchrone
 *
 * @param {*} error
 * @param {*} success
 * @private
 */
var __callServiceSync = function (error, success) {
    // liste des resultats au format JSON
    this.listConfigResults = [];

    // FIXME :
    // boucle synchrone !
    for (var i = 0; i < this.listConfigUrls.length; i++) {
        const url = this.listConfigUrls[i];
        // TODO :
        // prévoir le CORS, headers, ...
        const request = new XMLHttpRequest();
        request.open("GET", url, false);
        request.send(null);
        if (request.status === 200) {
            // TODO :
            // tester la reponse !
            var response = JSON.parse(request.responseText);
            this.listConfigResults.push(response);
        }
    }
    // callback
    if (this.listConfigResults.length !== 0) {
        success.call(this, this.listConfigResults);
    } else {
        error.call(this, new Error("..."));
    }
};

/**
 * Analyse et mise en forme de la réponse en fusionnant les configurations
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 * @overload
 */
Config.prototype.analyzeResponse = function (error, success) {
    // fonction de merge des objects JSON
    var mergeConfig = function (objects) {
        // objet fusion des couches
        var allLayersConfig = {};
        // objet fusion des clés
        var allKeysConfig = {};
        // objet fusion des TMS
        var allTMSConfig = {};

        // on fusionne les résultat
        for (var i = 0; i < objects.length; i++) {
            if (!objects[i].generalOptions || !objects[i].layers) {
                return;
            }
            allKeysConfig = {
                ...allKeysConfig,
                ...objects[i].generalOptions.apiKeys
            };
            allLayersConfig = {
                ...allLayersConfig,
                ...objects[i].layers
            };
            allTMSConfig = {
                ...allTMSConfig,
                ...objects[i].tileMatrixSets
            };
        }

        var mergedConfig = {
            generalOptions : {
                apiKeys : allKeysConfig
            },
            layers : allLayersConfig,
            tileMatrixSets : allTMSConfig
        };
        return mergedConfig;
    };

    // fusion des configurations JSON
    var ConfigJSON = mergeConfig(this.listConfigResults);
    if (!ConfigJSON) {
        error.call(this, new Error("configuration structure not conforme !"));
        return;
    }

    // creation des interfaces
    var IConfig = new _ConfigInterface__WEBPACK_IMPORTED_MODULE_4__["default"]();
    // ajout des interfaces avec la configuration JSON
    Object.assign(IConfig, ConfigJSON);

    // définition de la variable globale Gp.Config
    var scope = typeof window !== "undefined" ? window : {};
    if (!scope.Gp) {
        scope.Gp = {};
    }

    // enregistrement
    if (scope.Gp.Config) {
        Object.assign(scope.Gp.Config, IConfig);
        // dans le doute..., ceinture et bretelles !
        for (var property in IConfig) {
            scope.Gp.Config[property] = IConfig[property];
        }
    } else {
        scope.Gp.Config = IConfig;
    }

    // INFO :
    // il n'y a pas d'analyse des résultats,
    // on passe directement à l'appel de la callback utilisateur
    success.call(this, scope.Gp.Config);
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Config);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Config/ConfigInterface.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Config/ConfigInterface.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/**
 * Response object for {@link module:Services~getConfig Gp.Services.getConfig ()} invocation when successful. Received as the argument of onSuccess callback function.
 *
 * @property {Object} generalOptions - General properties for default map configuration resources.
 * @property {Object} generalOptions.apiKeys - Object that associates apiKey (s) with an array of resources IDs availables with that key.
 * @property {String} generalOptions.title - Underlying web service Title.
 * @property {String} generalOptions.defaultGMLGFIStyle - XSL URL used by default to translate an XML GetFeatureInfo response into an HTML array.
 * @property {String} generalOptions.theme - default theme (FIXME : for what ?)
 * @property {Array.<Float>} generalOptions.wgs84Resolutions - geographical resolutions Array for each [zoom level of the Geoportal platform]{@link http://api.ign.fr/tech-docs-js/webmaster/layers.html#Geoportal_resolutions} from 0 to 21. Expressed in degrees/pixel.
 * @property {Object} layers - Associative array mapping resources availables IDs (keys) with their properties (values given as {@link Gp.Services.Config.Layer}).
 * @property {Object} tileMatrixSets - Associative Array mapping TileMatrixSets IDs (keys) availables with their properties (values given as {@link Gp.Services.Config.TileMatrixSet}).
 *
 * @namespace
 * @alias Gp.Services.GetConfigInterface
 */
function ConfigInterface () {
    if (!(this instanceof ConfigInterface)) {
        throw new TypeError("ConfigInterface constructor cannot be called as a function.");
    }

    this.generalOptions = {
        apiKeys : {},
        title : null,
        defaultGMLGFIStyle : null,
        theme : null,
        wgs84Resolutions : []
    };

    this.layers = {};

    this.tileMatrixSets = {};
}

ConfigInterface.prototype = {

    /*
     * Constructor (alias)
     */
    constructor : ConfigInterface,

    /**
     * Check if config is loaded for a given key
     *
     * @param {String} apiKey - Access key to Geoportal platform
     * @returns {Boolean} isKeyConfLoaded - true if config of the key is already loaded, false otherwise
     */
    isKeyConfLoaded : function (apiKey) {
        if (!apiKey) {
            return;
        }
        if (this.generalOptions.apiKeys[apiKey]) {
            return true;
        }
        return false;
    },

    /**
     * Returns an array of Geoportal layers identifiers, corresponding to an API contract key.
     *
     * @param {String} apiKey - Access key to Geoportal platform
     * @returns {Array} apiKeys - Array of geoportal layers identifiers
     */
    getLayersId : function (apiKey) {
        return this.generalOptions.apiKeys[apiKey];
    },

    /**
     * Returns the id of a Geoportal layer with its name and its service.
     *
     * @param {String} layerName - name of the layer (ex. "ORTHOIMAGERY.ORTHOPHOTOS")
     * @param {String} service   - name of the service (ex. "WMS" ou "WMTS")
     * @returns {String} Id of the layer (ex. "ORTHOIMAGERY.ORTHOPHOTOS$GEOPORTAIL:OGC:WMTS")
     */
    getLayerId : function (layerName, service) {
        if (!layerName || !service) {
            return;
        }
        var layerId = null;

        // layer
        // key : [layerName]$[contexte]:OGC:[service]
        // ex : "ORTHOIMAGERY.ORTHOPHOTOS$GEOPORTAIL:OGC:WMTS"

        // service
        // key : [layerName]$[contexte];[service]
        // ex : PositionOfInterest$OGC:OPENLS;ReverseGeocode

        if (this.layers) {
            var layers = this.layers;
            for (var key in layers) {
                if (layers.hasOwnProperty(key)) {
                    var parts = key.split("$");
                    if (layerName === parts[0]) {
                        if (parts[1]) {
                            var servicePartsLayer = parts[1].split(":");
                            var servicePartsService = parts[1].split(";");

                            if (servicePartsService[1] === service.toUpperCase()) {
                                layerId = key;
                                break;
                            }
                            if (servicePartsLayer[2] === service.toUpperCase()) {
                                layerId = key;
                                break;
                            }
                        }
                    }
                }
            }
        }
        if (!layerId) {
            return;
        }
        return layerId;
    },

    /**
     * Returns an associative array of Geoportal layers configurations, corresponding to an API contract key.
     * If no key is specified, all layers from configuration are returned.
     *
     * @param {String} apiKey - Access key to Geoportal platform
     * @returns {Object} layers - Object which properties are layers identifiers.
     */
    getLayersConf : function (apiKey) {
        var layers = {};
        var layersIdArray = this.getLayersId(apiKey);
        if (layersIdArray) {
            for (var i = 0; i < layersIdArray.length; i++) {
                var lyrId = layersIdArray[i];
                layers[lyrId] = this.layers[lyrId];
            }
        }
        return layers;
    },

    /**
     * Returns a geoportal layer configuration, given its identifier
     *
     * @param {String} layerId - Geoportal layer identifier (e.g. "GEOGRAPHICALGRIDSYSTEMS.MAPS$GEOPORTAIL:OGC:WMTS")
     * @return {Object} layer - Layer configuration
     */
    getLayerConf : function (layerId) {
        if (!this.layers) {
            return;
        }
        return this.layers[layerId];
    },

    /**
     * Get all parameters needed to display a WMS or WMTS layer given its name, its service and its key
     *
     * @param {String} layerName - name of the layer (ex. "ORTHOIMAGERY.ORTHOPHOTOS")
     * @param {String} service   - name of the service (ex. "WMS" ou "WMTS")
     * @param {String} [apiKey]  - Contract API key
     * @returns {Object} params  - params of the service (WMS or WMTS) for the given layer
     * @returns {String} params.url        - Url of the service to reach to display the layer
     * @returns {String} params.version    - Version of the service
     * @returns {String} params.styles     - Default style of the layer
     * @returns {String} params.format     - Default format of the layer
     * @returns {String} params.projection - Default projection of the layer
     * @returns {Number} params.minScale   - Min scale denominator of the layer
     * @returns {Number} params.maxScale   - Max scale denominator of the layer
     * @returns {Gp.BBox} params.extent    - Extent of the layer, in the projection of the layer
     * @returns {Array} params.legends     - Array of legends associated to the layer
     * @returns {Array} params.title       - Name of the layer, readable by a human
     * @returns {Array} params.description - Description of the layer
     * @returns {String} params.[TMSLink]          - Id of the Tile Matrix Set (TMS), in the case of WMTS layer
     * @returns {Gp.Point} params.[matrixOrigin]   - Originof the tile matrix (top left corner), in the case of WMTS layer
     * @returns {Array} params.[nativeResolutions] - Array with the resolution of each level of the tile matrix set, in the case of WMTS layer
     * @returns {Array} params.[matrixIds]         - Array with the ID of each level of the tile matrix set, in the case of WMTS layer
     */
    getLayerParams : function (layerName, service) {
        var params = {};

        if ((service === "WMS" || Object.keys(this.tileMatrixSets).length !== 0) && Object.keys(this.layers).length !== 0) {
            // get the layerId of the layer
            var layerId = this.getLayerId(layerName, service);

            if (layerId) {
                // get the layer Conf Object
                var layerConf = this.getLayerConf(layerId);

                var keys = this.getLayerKey(layerId);
                if (keys.length === 0) {
                    return;
                }

                // get services params
                for (var i = 0; i < keys.length; i++) {
                    // only one serverUrl is saved in Gp.Config : with multiKeys, we have to retrieve the key used in the serverUrl property
                    if (layerConf.serviceParams.serverUrl[keys[i]]) {
                        params.url = layerConf.serviceParams.serverUrl[keys[i]];
                    }
                }

                const wmsTypeRegex = /\/v\//;
                // WMS vector style always empty (not in getCap)
                if (wmsTypeRegex.test(params.url)) {
                    params.styles = " ";
                } else {
                    // WMS raster style is defined in getCap
                    params.styles = layerConf.styles[0].name;
                }

                params.version = layerConf.serviceParams.version;
                params.format = layerConf.formats[0].name;
                params.projection = layerConf.defaultProjection;

                // get layer info and constraints
                params.minScale = layerConf.globalConstraint.minScaleDenominator;
                params.maxScale = layerConf.globalConstraint.maxScaleDenominator;
                params.extent = layerConf.globalConstraint.bbox;
                params.legends = layerConf.legends;
                params.title = layerConf.title;
                params.description = layerConf.description;

                if (service === "WMS") {
                    params.metadata = layerConf.metadata;
                }

                // Informations  non disponibles avec les getCap
                // params.metadata = layerConf.getMetadata();
                // params.originators = layerConf.getOriginators();
                // params.quicklookUrl = layerConf.getQuicklookUrl();

                // WMTS : get the tileMatrixSetLimits
                if (layerConf.wmtsOptions) {
                    params.tileMatrixSetLimits = layerConf.wmtsOptions.tileMatrixSetLimits;
                    var TMSLink = layerConf.wmtsOptions.tileMatrixSetLink;
                    if (TMSLink) {
                        params.TMSLink = TMSLink;
                        var tmsConf = this.getTMSConf(TMSLink);
                        // Get matrix origin : Gp.Point = Object{x:Float, y:Float}
                        // params.matrixOrigin = tmsConf.getTopLeftCorner();
                        params.matrixIds = Object.keys(tmsConf.tileMatrices);
                        params.tileMatrices = tmsConf.tileMatrices;
                        // by default, pseudo mercator resolutions
                        params.nativeResolutions = tmsConf.nativeResolutions || this.getTMSConf("PM").nativeResolutions;
                    }
                }
            }
        }
        return params;
    },

    /**
     * Get the contract key(s) associated to a given layer.
     *
     * @param {String} layerId - Geoportal layer identifier (e.g. "GEOGRAPHICALGRIDSYSTEMS.MAPS$GEOPORTAIL:OGC:WMTS")
     * @return {Array} layerKey - array of key(s) associated to the given layer
     */
    getLayerKey : function (layerId) {
        var layerKey = [];
        if (this.generalOptions && this.generalOptions.apiKeys && Object.keys(this.generalOptions.apiKeys).length !== 0) {
            var resourcesByKey = this.generalOptions.apiKeys;
            for (var key in resourcesByKey) {
                var resourcesArray = resourcesByKey[key];
                resourcesArray.forEach(function (arrayLayerId) {
                    if (arrayLayerId === layerId) {
                        layerKey.push(key);
                    }
                });
            }
        }
        return layerKey;
    },

    /**
     * Returns an associative array of Tile Matrix Sets configurations.
     *
     * @return {Object} tileMatrixSets - Object which properties are TMS identifiers
     *
     */
    getTileMatrixSets : function () {
        return this.tileMatrixSets;
    },

    /**
     * Returns a Tile Matrix Sets configuration, given its identifier.
     *
     * @param {String} tmsID - Tile Matrix Set identifier (e.g. : "PM")
     * @return {Object} tileMatrixSet - Tile Matrix Set configuration
     */
    getTMSConf : function (tmsID) {
        if (!this.tileMatrixSets) {
            return;
        }
        return this.tileMatrixSets[tmsID];
    },

    /**
     * Get global constraints for a given Layer : extent, minScale, maxScale, projection
     *
     * @param {String} layerId - Geoportal layer identifier (e.g. "GEOGRAPHICALGRIDSYSTEMS.MAPS$GEOPORTAIL:OGC:WMTS")
     * @returns {Object} params - layer constraints
     * @returns {String} params.projection - default layer projection
     * @returns {Number} params.minScale   - layer min scale denominator
     * @returns {Number} params.maxScale   - layer max scale denominator
     * @returns {Gp.BBox} params.extent    - layer extent expressed in the layer projection
     */
    getGlobalConstraints : function (layerId) {
        var params = {};

        if (layerId) {
            // get layer configuration object
            var layerConf = this.getLayerConf(layerId);
            params.projection = layerConf.defaultProjection;
            params.minScale = layerConf.globalConstraint.minScaleDenominator;
            params.maxScale = layerConf.globalConstraint.maxScaleDenominator;
            params.extent = layerConf.globalConstraint.bbox;
        }

        return params;
    }

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConfigInterface);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// cette classe contient les URLs par defaut des services.
//  DefaultUrlService.Alti.url(key)[elevation-json]
//  DefaultUrlService.Alti.url(key)[elevation-xml]
//  DefaultUrlService.Alti.url(key)[profil-json]
//  DefaultUrlService.Alti.url(key)[profil-xml]
//  DefaultUrlService.ProcessIsoCurve.url(key)
//  DefaultUrlService.AutoComplete.url(key)
//  DefaultUrlService.ReverseGeocode.url(key)
//  DefaultUrlService.Geocode.url(key)
//  DefaultUrlService.Route.url(key)

// Example :
//
// DefaultUrlService.Alti.url('alti')[elevation-json]
//  output {String} -> http://wxs.ign.fr/calcul/alti/rest/elevation.json
//
// DefaultUrlService.Alti.url('calcul')
// output {Object|String}
// -> http://wxs.ign.fr/calcul/alti/rest/elevation.json
// -> http://wxs.ign.fr/calcul/alti/rest/elevation.xml
// -> http://wxs.ign.fr/calcul/alti/rest/elevationLine.json
// -> http://wxs.ign.fr/calcul/alti/rest/elevationLine.xml
//
// ssl by default.
//
// Force to not do ssl :
// DefaultUrlService.ssl = false;
//
// DefaultUrlService.AutoComplete.url('calcul')
// output {Object|String}
// -> https://wxs.ign.fr/calcul/ols/apis/completion

/**
 * Default Geoportal web services URLs access.
 *
 * @namespace
 * @alias Gp.Services.DefaultUrl
 */
var DefaultUrlService = {

    /** if set true, require the use of https protocol */
    ssl : true,

    /**
    * base new-url of geoplateforme services (ssl protocol management)
    * @param {String} path - path
    * @returns {String} url
    */
    newUrl : function (path) {
        var NEW_GPF_HOSTNAME = "data.geopf.fr";

        // comportement par défaut => https
        // sinon, il est fixé par l'option 'ssl' (false => http)
        var _protocol;
        if (DefaultUrlService.ssl === false) {
            _protocol = "http://";
        } else {
            _protocol = "https://";
        }

        return _protocol + NEW_GPF_HOSTNAME + path;
    },

    /**
     * Elevation web service access
     *
     * @member {Object}
     * @property {Function} url (key) - Returns elevation service default urls with or without geoportal access key given as a parameter. The result is a javascript object with different urls given used protocols ("elevation-json", "elevation-xml", "profil-json" or "profil-xml").
     */
    Alti : {
        new_key : {
            // rest
            "elevation-json" : "/altimetrie/1.0/calcul/alti/rest/elevation.json",
            "elevation-xml" : "/altimetrie/1.0/calcul/alti/rest/elevation.xml",
            "profil-json" : "/altimetrie/1.0/calcul/alti/rest/elevationLine.json",
            "profil-xml" : "/altimetrie/1.0/calcul/alti/rest/elevationLine.xml"
        },

        /**
        * newurl from geoplateforme service
        * @param {String} key - key
        * @returns {String} url
        */
        newUrl : function () {
            return {
                // rest
                "elevation-json" : DefaultUrlService.newUrl(this.new_key["elevation-json"]),
                "elevation-xml" : DefaultUrlService.newUrl(this.new_key["elevation-xml"]),
                "profil-json" : DefaultUrlService.newUrl(this.new_key["profil-json"]),
                "profil-xml" : DefaultUrlService.newUrl(this.new_key["profil-xml"])
            };
        }
    },
    /**
     * IsoCurve web service access
     *
     * @member {Object}
     * @property {Function} url (key) - Returns isocurve service default urls with or without geoportal access key given as a parameter. The result is a javascript object with different urls given used protocols ("iso-json" or "iso-xml").
     */
    ProcessIsoCurve : {

        new_key : "/navigation/isochrone",

        /**
        * url from geoplateforme service
        * @returns {String} url
        */
        newUrl : function () {
            return DefaultUrlService.newUrl(this.new_key);
        }
    },
    /**
     * Config web service access
     *
     * @member {Object}
     * @property {Function} url (key) - Returns config service default urls with or without geoportal access key given as a parameter.
     */
    Config : {
        _key : "https://raw.githubusercontent.com/IGNF/geoportal-configuration/new-url/dist/",
        /**
        * url
        * @param {String} key - key
        * @returns {String} url
        */
        url : function (key) {
            // key must be an array of one or several keys
            if (!Array.isArray(key)) {
                key = key.split(",");
            }
            // not homogeneous with others geoportal services URLs
            var url = [];
            for (var i = 0; i < key.length; i++) {
                url[i] = this._key + key[i] + "Config.json";
            }
            return url;
        }
    },
    /**
     * Autocompletion web service access
     *
     * @member {Object}
     * @property {Function} url (key) - Returns autocomplete service default urls with or without geoportal access key given as a parameter. The result is a String.
     */
    AutoComplete : {
        new_key : "/geocodage/completion",

        /**
        * url from geoplateforme service
        * @returns {String} url
        */
        newUrl : function () {
            return DefaultUrlService.newUrl(this.new_key);
        }
    },
    /**
     * Reverse geocoding web service access
     *
     * @member {Object}
     * @property {Function} url (key) - Returns reverse geocoding service default urls with or without geoportal access key given as a parameter. The result is a String.
     */
    ReverseGeocode : {
        new_key : "/geocodage/reverse",

        /**
        * url from geoplateforme service
        * @returns {String} url
        */
        newUrl : function () {
            return DefaultUrlService.newUrl(this.new_key);
        }
    },
    /**
     * Geocoding web service access
     *
     * @member {Object}
     * @property {Function} url (key) - Returns geocoding service default urls with or without geoportal access key given as a parameter. The result is a String.
     */
    Geocode : {
        new_key : "/geocodage/search",

        /**
        * url from geoplateforme service
        * @returns {String} url
        */
        newUrl : function () {
            return DefaultUrlService.newUrl(this.new_key);
        }
    },
    /**
     * Routing web service access
     *
     * @member {Object}
     * @property {Function} url (key) - Returns routing service default urls with or without geoportal access key given as a parameter. The result is a javascript object with different urls given used protocols.
     */
    Route : {
        new_key : "/navigation/itineraire",

        /**
        * url from geoplateforme service
        * @returns {String} url
        */
        newUrl : function () {
            return DefaultUrlService.newUrl(this.new_key);
        }
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DefaultUrlService);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Geocode/Formats/GeocodeResponseParser.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Geocode/Formats/GeocodeResponseParser.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/MessagesResources */ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js");
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Exceptions/ErrorService */ "./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js");
/* harmony import */ var _Response_model_GeocodeResponse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Response/model/GeocodeResponse */ "./node_modules/geoportal-access-lib/src/Services/Geocode/Response/model/GeocodeResponse.js");
/* harmony import */ var _Response_model_GeocodedLocation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Response/model/GeocodedLocation */ "./node_modules/geoportal-access-lib/src/Services/Geocode/Response/model/GeocodedLocation.js");
// import Logger from "../../../Utils/LoggerByDefault";





/**
 * Fonction retournant un objet contenant des clés de lecture (readers)
 *      qui permettent de parser des réponses XML du service de géocodage direct du Géoportail
 *      afin de récupérer les résultats retournés.
 * @module GeocodeResponseParser
 * @alias Gp.Services.Geocode.Formats.GeocodeResponseParser
 * @private
 */

/**
 * @classdesc
 *
 * Classe permettant de parser une réponse GeoJSON
 *
 * @constructor
 * @alias Gp.Formats.GeocodeResponseParser
 *
 * @private
 */
function GeocodeResponseParser () {
    if (!(this instanceof GeocodeResponseParser)) {
        throw new TypeError("GeocodeResponseParser constructor cannot be called as a function.");
    }
}

GeocodeResponseParser.prototype = {

    /**
     * @lends module:GeocodeResponseParser
     */

    /*
     * Constructeur (alias)
     */
    constructor : GeocodeResponseParser,

    /**
     * Méthode permettant de lancer la lecture d'une réponse GeoJSON,
     *
     * @param {String} json - réponse au format GeoJSON
     * @return {Object} geocodeResponse|exceptionReport : l'objet contenant les informations de la réponse GeoJSON,
     *      sous la forme d'un objet GeocodeResponse, ou un objet littéral exceptionReport si le service a renvoyé une exception.
     */
    parse : function (json) {
        var geocodeResponse = new _Response_model_GeocodeResponse__WEBPACK_IMPORTED_MODULE_2__["default"]();

        const obj = JSON.parse(json);

        if (obj.type === "FeatureCollection") {
            for (var i = 0; i < obj.features.length; ++i) {
                _parseFeature(obj.features[i], geocodeResponse);
            }
        } else if (obj.type === "Feature") {
            _parseFeature(obj, geocodeResponse);
        } else if (obj.type === "SERVICE_ERROR") {
            return _parseError(obj);
        } else {
            var mess = _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_0__["default"].getMessage("SERVICE_RESPONSE_ANALYSE", obj.type);
            throw new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"]({
                message : mess,
                type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"].TYPE_UNKERR,
                status : 200
            });
        }

        return geocodeResponse;
    }
};

/**
 * Méthode permettant de parser un feature
 *
 * @private
 *
 * @param {Object} feature
 * @param {Object} geocodeResponse
 *
 * @memberof GeocodeResponseParser
 * @return {Object} objet GeocodedLocation
 */
function _parseFeature (feature, geocodeResponse) {
    var location = new _Response_model_GeocodedLocation__WEBPACK_IMPORTED_MODULE_3__["default"]();
    if (feature.geometry && feature.geometry.type === "Point") {
        location.position = {
            lon : feature.geometry.coordinates[0],
            lat : feature.geometry.coordinates[1]
        };
    }
    if (feature.properties) {
        for (var prop in feature.properties) {
            if (prop === "score") {
                location.accuracy = feature.properties[prop];
            } else if (prop === "_type") {
                if (feature.properties[prop] === "address") {
                    location.type = "StreetAddress";
                } else if (feature.properties[prop] === "poi") {
                    location.type = "PositionOfInterest";
                } else if (feature.properties[prop] === "parcel" || feature.properties[prop] === "cadastral") {
                    location.type = "CadastralParcel";
                }
            } else {
                location.placeAttributes[prop] = feature.properties[prop];
            }
        }
        if (feature.properties._type === "address") {
            location.matchType = feature.properties.number !== undefined && feature.properties.number !== null ? "street number" : "street";
        }
    }
    geocodeResponse.locations.push(location);
}

/**
 * Méthode permettant de parser une erreur
 *
 * @private
 *
 * @param {Object} error
 *
 * @memberof GeocodeResponseParser
 * @return {Object}
 */
function _parseError (error) {
    return {
        exceptionReport : error
    };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeocodeResponseParser);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Geocode/Geocode.js":
/*!***************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Geocode/Geocode.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Utils/MessagesResources */ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js");
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Exceptions/ErrorService */ "./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js");
/* harmony import */ var _CommonService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CommonService */ "./node_modules/geoportal-access-lib/src/Services/CommonService.js");
/* harmony import */ var _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../DefaultUrlService */ "./node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js");
/* harmony import */ var _Request_GeocodeRequestFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Request/GeocodeRequestFactory */ "./node_modules/geoportal-access-lib/src/Services/Geocode/Request/GeocodeRequestFactory.js");
/* harmony import */ var _Response_GeocodeResponseFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Response/GeocodeResponseFactory */ "./node_modules/geoportal-access-lib/src/Services/Geocode/Response/GeocodeResponseFactory.js");








/**
 * @classdesc
 * Appel du service de géocodage direct du Géoportail :
 *     envoi de la requête construite selon les paramètres en options,
 *     éventuellement parsing et analyse  de la réponse,
 *     retour d'une réponse en paramètre de la fonction onSuccess.
 *
 *
 * @constructor
 * @extends {Gp.Services.CommonService}
 * @alias Gp.Services.Geocode
 *
 * @param {Object} options - options spécifiques au service (+ les options heritées)
 *
 * @param {String|Object} options.query - Nom de l'adresse, du toponyme, de l'unité administrative ou de la parcelle cadastrale recherchée.
 *
 * @param {Object} [options.filters] - Les propriétés possibles de cet objet sont décrites ci-après.
 * @param {String} [options.filters.[prop]] - Critère supplémentaire pour filtrer la recherche sous la forme
 *      d'un couple clé/valeur à définir selon les possibilités du serveur ajouté à la requête.
 *      Le service de géocodage du Géoportail permet de filtrer les adresses postales avec les propriétés :
 *          "postalCode", "inseeCode", "city".
 *      Il permet également de filtrer les toponymes avec les propriétés :
 *          "postalCode", "inseeCode", "type".
 *      Enfin, il permet de filtrer les parcelles cadastrales avec les propriétés :
 *          "codeDepartement", "codeCommune", "nomCommune", "codeCommuneAbs", "codeArrondissement", "section", "numero", "feuille".
 *
 * @param {String} [options.index = "StreetAddress"] - Type de l'objet recherché.
 *      Le service de géocodage du Géoportail permet de rechercher des 'PositionOfInterest' pour des toponymes, des 'StreetAddress'
 *      pour des adresses postales ou des 'CadastralParcel' pour des parcelles cadastrales.
 *      L'index 'location' regroupe les indexes 'StreetAddress' et 'PositionOfInterest'.
 *      D'autres types pourront être rajoutés selon l'évolution du service.
 *      Par défaut, index = 'StreetAddress'.
 *
 * @param {Object} options.position - Position du point de référence pour le calcul de proximité exprimée dans le système de référence spécifié par le srs.
 *      @param {Float} options.position.lon - Longitude du point de référence pour le calcul de proximité.
 *      @param {Float} options.position.lat - Latitude du point de référence pour le calcul de proximité.
 *
 * @param {Number} [options.maximumResponses] - Nombre de réponses maximal que l'on souhaite recevoir.
 *      Pas de valeur par défaut.
 *      Si le serveur consulté est celui du Géoportail, la valeur par défaut sera donc celle du service : 20.
 *
 * @param {Boolean} [options.returnTrueGeometry = false] - Booléen indiquant si l'on souhaite récupérer la géométrie vraie des objects géolocalisés.
 *      false par défaut.
 *
 *
 * @example
 *   var options = {
 *      apiKey : null,
 *      serverUrl : 'http://localhost/service/',
 *      proxyURL : null,
 *      timeOut : 10000, // ms
 *      rawResponse : false, // true|false
 *      scope : null, // this
 *      onSuccess : function (response) {},
 *      onFailure : function (error) {},
 *      // spécifique au service
 *      position : {lon:, lat:},
 *      index : 'StreetAddress',
 *      query : '10 rue du pont Machin-ville'
 *      (...)
 *   };
 */
function Geocode (options_) {
    if (!(this instanceof Geocode)) {
        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("CLASS_CONSTRUCTOR", "Geocode"));
    }

    /**
     * Nom de la classe (heritage)
     * FIXME instance ou classe ?
     */
    this.CLASSNAME = "Geocode";

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("Gp.Services.Geocode");
    this.logger.trace("[Constructeur Geocode (options)]");

    var options = this.patchOptionConvertor(options_);
    if (!options.serverUrl) {
        options.serverUrl = _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__["default"].Geocode.newUrl();
    }

    // appel du constructeur par heritage
    _CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].apply(this, [options]);

    if (!options.hasOwnProperty("query")) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "query"));
    }

    // ajout des options spécifiques au service
    this.options.query = options.query;

    // on definit l'index par defaut
    if (!options.index) {
        this.options.index = options.index = "StreetAddress";
    }

    if (options.filters) {
        var filter = Object.keys(options.filters);
        for (var i = 0; i < filter.length; i++) {
            var key = filter[i];
            // on supprime les filtres vides
            if (typeof options.filters[key] === "undefined" ||
                (typeof options.filters[key] === "object" && Object.keys(options.filters[key]).length === 0) ||
                (typeof options.filters[key] === "string" && options.filters[key].length === 0) ||
                (Array.isArray(options.filters[key]) && options.filters[key].length === 0)
            ) {
                delete this.options.filters[key];
            }
        }
    }

    this.options.index = options.index || "StreetAddress";
    this.options.maximumResponses = options.maximumResponses || 20;
}

/**
 * @lends module:Geocode#
 */
Geocode.prototype = Object.create(_CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].prototype, {
    // todo
    // getter/setter
});

/*
 * Constructeur (alias)
 */
Geocode.prototype.constructor = Geocode;

/**
 * Patch pour la convertion des options vers le nouveau formalisme.
 *
 * @param {Object} options_ - options du service
 * @return {Object} - options
 */
Geocode.prototype.patchOptionConvertor = function (options_) {
    const options = options_;

    if (options.hasOwnProperty("location")) {
        this.logger.warn("The parameter 'location' is deprecated");

        if (!options.query) {
            options.query = options.location;
        }
        delete options.location;
    }

    if (options.filterOptions) {
        this.logger.warn("The parameter 'filterOptions' is deprecated");

        if (!options.filters) {
            options.filters = options.filterOptions;

            if (options.filters.type) {
                this.logger.warn("The parameter 'filterOptions.type' is deprecated");
                if (!options.index) {
                    if (Array.isArray(options.filters.type) && options.filters.type.length > 0) {
                        options.index = options.filters.type[0];
                    } else {
                        options.index = options.filters.type;
                    }
                }
                delete options.filters.type;
            }

            if (options.filters.bbox) {
                this.logger.warn("The parameter 'filterOptions.bbox' is deprecated");
                delete options.filters.bbox;
            }
        }
        delete options.filterOptions;
    }

    if (options.position) {
        if (options.position.x) {
            this.logger.warn("The parameter 'position.x' is deprecated");

            if (!options.position.lon) {
                options.position.lon = options.position.x;
            }
            delete options.position.x;
        }

        if (options.position.y) {
            this.logger.warn("The parameter 'position.y' is deprecated");

            if (!options.position.lat) {
                options.position.lat = options.position.y;
            }
            delete options.position.y;
        }
    }

    if (options.returnFreeForm) {
        this.logger.warn("The parameter 'returnFreeForm' is deprecated");
        delete options.returnFreeForm;
    }

    if (options.srs) {
        this.logger.warn("The parameter 'srs' is deprecated");
        delete options.srs;
    }

    return options;
};

/**
 * Création de la requête (overwrite)
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
Geocode.prototype.buildRequest = function (error, success) {
    var options = {
        httpMethod : this.options.httpMethod,
        // options specifiques du service
        geocodeMethod : "search",
        query : this.options.query,
        index : this.options.index,
        returnTrueGeometry : this.options.returnTrueGeometry,
        position : this.options.position,
        maxResp : this.options.maximumResponses,
        filters : this.options.filters
    };

    this.request = _Request_GeocodeRequestFactory__WEBPACK_IMPORTED_MODULE_5__["default"].build(options);

    // on teste si la requete a bien été construite !
    (!this.request)
        ? error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_REQUEST_BUILD")))
        : success.call(this, this.request);
};

/**
 * Analyse de la reponse (overwrite)
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
Geocode.prototype.analyzeResponse = function (error, success) {
    /* INFO :
         Etape 1 : Création de la requête (URL)
            -> stockage de la requête dans this.request
         Etape 2 : Envoi de la requête
            -> appel du protocol XHR, et envoi (par ex send ())
            -> récupération de la réponse JSON dans la fonction onSuccess () (this.response)
            -> si code HTTP 200 et pas de message d'erreur : etape 3
            -> si code HTTP != 200 : lancement de la fonction de callback onFailure avec le message d'erreur
         Etape 3 : Analyse de la réponse JSON (si rawResponse === false )
            -> appel du parser pour récupérer le document
         Etape 4 : Lancement de la fonction de callback onSuccess avec la réponse :
            -> JSON (si rawResponse === true)
            -> ou geocodedLocations
    */

    if (this.response) {
        var options = {
            response : this.response,
            rawResponse : this.options.rawResponse,
            onError : error,
            onSuccess : success,
            scope : this
        };

        _Response_GeocodeResponseFactory__WEBPACK_IMPORTED_MODULE_6__["default"].build(options);
    } else {
        error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Geocode);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Geocode/Request/GeocodeRequestFactory.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Geocode/Request/GeocodeRequestFactory.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _GeocodeRequestREST__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GeocodeRequestREST */ "./node_modules/geoportal-access-lib/src/Services/Geocode/Request/GeocodeRequestREST.js");



/**
 * Creation d'une requête
 * (Factory)
 *
 * @module GeocodeRequestFactory
 * @alias Gp.Services.Geocode.Request.GeocodeRequestFactory
 * @private
 */
var GeocodeRequestFactory = {

    /**
     * interface unique
     *
     * @method build
     * @static
     * @param {Object} options - options definies dans le composant Geocode
     *
     * @example
     *   var options = {
     *      // options specifiques du service
     *      geocodeMethod:
     *      query:
     *      filters:
     *      maximumResponses:
     *   };
     *   var result = GeocodeRequestFactory.build(options);
     *   if (!result) {
     *       // error...
     *   }
     * @returns {String} request
     */
    build : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("GeocodeRequestFactory");
        logger.trace(["GeocodeRequestFactory::build()"]);

        var settings = options || {};

        var myReq = new _GeocodeRequestREST__WEBPACK_IMPORTED_MODULE_1__["default"](settings);
        if (!myReq.processRequestString()) {
            throw new Error("Error process request (rest) !");
        }
        var request = myReq.requestString;

        logger.trace(request);

        return request;
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeocodeRequestFactory);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Geocode/Request/GeocodeRequestREST.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Geocode/Request/GeocodeRequestREST.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Utils/MessagesResources */ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js");
/* harmony import */ var _model_GeocodeParamREST__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./model/GeocodeParamREST */ "./node_modules/geoportal-access-lib/src/Services/Geocode/Request/model/GeocodeParamREST.js");





/**
 * @classdesc
 * Classe de gestion des requêtes de type REST sur le service de calcul d'itineraire
 * (uniquement en GET)
 *
 * @constructor
 * @alias Gp.Services.Geocode.Request.GeocodeRequestREST
 * @param {Object} options - options definies dans le composant Route
 *
 * @example
 * var options = {
 *      (...)
 * };
 *
 * @private
 */
function GeocodeRequestREST (options) {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("GeocodeRequestREST");
    this.logger.trace("[Constructeur GeocodeRequestREST ()]");

    if (!(this instanceof GeocodeRequestREST)) {
        throw new TypeError("GeocodeRequestREST constructor cannot be called as a function.");
    }

    // existance des options
    if (!options) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_EMPTY", "options"));
    }

    /** liste des options */
    this.settings = options;
}

GeocodeRequestREST.prototype = {

    /**
     * @lends module:GeocodeRequestREST#
     */

    /**
     * request
     * @type {String}
     */
    requestString : null,

    /**
     * Constructeur (alias)
     */
    constructor : GeocodeRequestREST,

    /**
     * Construction de la requête.
     *
     * @returns {String} request
     */
    processRequestString : function () {
        var request = "";

        // Mapping des options avec le service de l'API REST
        const oParams = new _model_GeocodeParamREST__WEBPACK_IMPORTED_MODULE_2__["default"](this.settings);

        const params = oParams.getParams();
        for (var i = 0; i < params.length; i++) {
            var o = params[i];
            if (request) {
                request += "&";
            }
            request += o.k + "=" + o.v;
        }

        if (!this.settings.geocodeMethod || (this.settings.geocodeMethod !== "search" && this.settings.geocodeMethod !== "reverse")) {
            throw new Error("Error geocodeMethod not valid");
        }

        this.requestString = "?" + request;
        this.logger.trace(this.requestString);

        return this.requestString;
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeocodeRequestREST);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Geocode/Request/model/GeocodeParamREST.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Geocode/Request/model/GeocodeParamREST.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");



/**
 * @classdesc
 * Classe de gestion des param. des requêtes du service de calcul d'itineraire (REST).
 *      Permet le mapping avec les options du service.
 * @constructor
 * @alias Gp.Services.Route.Request.RouteParamREST
 * @param {Object} options - options
 *
 * @private
 */
function GeocodeParamREST (options) {
    if (!(this instanceof GeocodeParamREST)) {
        throw new TypeError("GeocodeParamREST constructor cannot be called as a function.");
    }

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur GeocodeParamREST ()]");

    /**
     * Options en paramêtres du constructeur.
     */
    this.options = options || {};

    // methode de geocodage
    if (!this.options.geocodeMethod || (this.options.geocodeMethod !== "search" && this.options.geocodeMethod !== "reverse")) {
        throw new Error("Error geocodeMethod not valid");
    }
    this.geocodeMethod = this.options.geocodeMethod;

    // mapping des options avec l'API REST
    this.query = (typeof this.options !== "undefined") ? this.options.query : null;

    this.searchGeometry = this.options.searchGeometry || null;

    this.index = this.options.index || null;

    this.lon = this.options.position && this.options.position.lon ? this.options.position.lon : null;

    this.lat = this.options.position && this.options.position.lat ? this.options.position.lat : null;

    this.maxResp = this.options.maxResp || null;

    this.returnTrueGeometry = this.options.returnTrueGeometry || null;

    this.filters = this.options.filters || {};
}

/**
 * CLASSNAME
 */
GeocodeParamREST.CLASSNAME = "GeocodeParamREST";

GeocodeParamREST.prototype = {

    /**
     * @lends module:GeocodeParamREST#
     */

    /**
     * Constructeur (alias)
     */
    constructor : GeocodeParamREST,

    /**
     * Retourne les filtres
     * @returns {String} les filtres
     */
    getFilters : function () {
        var filters = {};
        for (var prop in this.filters) {
            if (this.filters.hasOwnProperty(prop)) {
                filters[prop] = this.filters[prop];
            }
        }
        return filters;
    },

    /**
     * Retourne l'index
     * @returns {String} l'index
     */
    getIndex : function () {
        if (this.index === undefined) {
            return null;
        }
        if (this.index === "StreetAddress") {
            return "address";
        } else if (this.index === "CadastralParcel") {
            return "parcel";
        } else if (this.index === "PositionOfInterest") {
            return "poi";
        } else if (this.index === "location") {
            return "location";
        }
        return this.index;
    },

    /**
     * Retourne la géométrie de recherche
     * @returns {String} la géométrie de recherche au format json
     */
    getSearchGeometry : function () {
        return JSON.stringify(this.searchGeometry);
    }
};

/**
 * Tableau de clefs/valeurs pour param.
 *
 * @returns {Array} liste de paramêtres
 */
GeocodeParamREST.prototype.getParams = function () {
    var map = [];

    if (this.geocodeMethod === "search") {
        map.push({
            k : "q",
            v : this.query
        });
    }

    if (this.index) {
        map.push({
            k : "index",
            v : this.getIndex()
        });
    }

    if (this.geocodeMethod === "reverse" && this.searchGeometry) {
        map.push({
            k : "searchgeom",
            v : this.getSearchGeometry()
        });
    }

    if (this.lon && this.lat) {
        map.push({
            k : "lon",
            v : this.lon
        });
        map.push({
            k : "lat",
            v : this.lat
        });
    }

    if (this.maxResp) {
        map.push({
            k : "limit",
            v : this.maxResp
        });
    }

    if (this.returnTrueGeometry) {
        map.push({
            k : "returntruegeometry",
            v : this.returnTrueGeometry
        });
    }

    const filters = this.getFilters();
    for (var key in filters) {
        map.push({
            k : key,
            v : filters[key]
        });
    }

    return map;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeocodeParamREST);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Geocode/Response/GeocodeResponseFactory.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Geocode/Response/GeocodeResponseFactory.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Exceptions/ErrorService */ "./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js");
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Utils/MessagesResources */ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js");
/* harmony import */ var _Formats_GeocodeResponseParser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Formats/GeocodeResponseParser */ "./node_modules/geoportal-access-lib/src/Services/Geocode/Formats/GeocodeResponseParser.js");
/**
 * Factory pour générer une reponse JSON à partir d'un XML
 * (Factory)
 *
 * @module GeocodeResponseFactory
 * @alias Gp.Services.Geocode.Response.GeocodeResponseFactory
 * @private
 */
// import Logger from "../../../Utils/LoggerByDefault";




var GeocodeReponseFactory = {

    /**
     * interface unique
     *
     * @method build
     * @static
     * @param {Object} options - options definies dans le composant Geocode
     *
     * @example
     *   var options = {
     *      response :
     *      rawResponse :
     *      scope :
     *      onSuccess :
     *      onError :
     *   };
     *
     */
    build : function (options) {
        // data de type GeocodeResponse
        var data = null;

        if (options.response) {
            if (options.rawResponse) {
                data = options.response;
            } else {
                try {
                    const parser = new _Formats_GeocodeResponseParser__WEBPACK_IMPORTED_MODULE_2__["default"]();
                    data = parser.parse(options.response);

                    if (!data) {
                        throw new Error("L'analyse de la réponse du service !?");
                    }
                } catch (e) {
                    var message = e.message;
                    if (typeof options.response === "string") {
                        message += "('" + options.response + "')";
                    } else {
                        message += "('" + options.response.documentElement.innerHTML + "')";
                    }
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__["default"]({
                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_ANALYSE", message),
                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__["default"].TYPE_UNKERR,
                        status : -1
                    }));
                    return;
                }

                // Si la réponse contenait une exception renvoyée par le service
                if (data.exceptionReport) {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__["default"]({
                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", data.exceptionReport),
                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__["default"].TYPE_SRVERR,
                        status : 200 // FIXME : 200 ?
                    }));
                    return;
                }
            }
        } else {
            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__["default"]({
                message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY"),
                type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_0__["default"].TYPE_SRVERR,
                status : -1 // FIXME : status response
            }));
            return;
        }

        options.onSuccess.call(options.scope, data);
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeocodeReponseFactory);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Geocode/Response/model/GeocodeResponse.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Geocode/Response/model/GeocodeResponse.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/**
 * Response object for {@link module:Services~geocode Gp.Services.geocode ()} or {@link module:Services~reverseGeocode Gp.Services.reverseGeocode ()} invocation when successful. Received as the argument of onSuccess callback function.
 *
 * @property {Array.<Gp.Services.Geocode.GeocodedLocation>} locations - locations array.
 *
 * @namespace
 * @alias Gp.Services.GeocodeResponse
 */
function GeocodeResponse () {
    if (!(this instanceof GeocodeResponse)) {
        throw new TypeError("GeocodeResponse constructor cannot be called as a function.");
    }

    this.locations = [];
}

GeocodeResponse.prototype = {

    constructor : GeocodeResponse

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeocodeResponse);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Geocode/Response/model/GeocodedLocation.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Geocode/Response/model/GeocodedLocation.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/**
 * Single location object returned by the underlying geocoding web service.
 *
 * @property {Gp.Point} position - Position of the location given in the requested coordinates system.
 * @property {String} type - location type "StreetAddress" (for an address), "PositionOfInterest" (for a place name) or "CadastralParcel" (for cadastral parcel).
 * @property {String} matchType - how geocoding is performed : "street number" (exact address), "street enhanced" (street number calculated by interpolation), "street" (only the street), "city" (only the city).
 * @property {Float} accuracy - Accuracy of the response towards the requested location between 0 (unaccurate) and 1 (exact match).
 * @property {Object} placeAttributes - Associative array matching the following attributes with their values given by the underlying web service :
 *
 * *Common attributes : *
 *
 * - **trueGeometry** - the 'real life' geometry if different from 'Point' type.
 *
 * *if type === "StreetAddress" :*
 *
 * - **number** - Street number.
 * - **postalCode** - PostCode
 * - **street** - Street name
 * - **city** - City
 * - **houseNumberInfos** - additional street number information
 * - **inseeCode** - INSEE Code
 *
 *
 * *if type === "PositionOfInterest" :*
 *
 * - **type** - Place name type
 * - **postalCode** - PostCode
 * - **toponyme** - Toponyme
 * - **extraFields** - additional place name properties
 * - **inseeCode** - INSEE Code
 *
 *
 * *si type = "CadastralParcel" :*
 *
 * - **codeCommuneAbs** - when a parcel comes from a city that was absorbed by another, code of that old city. "000" otherwise.
 * - **codeArrondissement** - arrondissement
 * - **identifiant** - cadastral parcel code
 * - **feuille** - Parcel Sheet (eg. "1").
 * - **numero** - Parcel Number (eg. "0041")
 * - **section** - Parcel Section (eg. "0D").
 * - **nomCommune** - Parcel municipality name.
 * - **codeCommune** - Parcel municipality.
 * - **codeDepartement** - Parcel Department.
 *
 * @namespace
 * @alias Gp.Services.Geocode.GeocodedLocation
 */
function GeocodedLocation () {
    if (!(this instanceof GeocodedLocation)) {
        throw new TypeError("GeocodedLocation constructor cannot be called as a function.");
    }

    this.position = null;

    this.matchType = null;

    this.placeAttributes = {};

    this.type = null;

    this.accuracy = null;

    /**
     * Nom de la classe : "GeocodedLocation"
     * @type {String}
     */
    this.CLASSNAME = "GeocodedLocation";
}

GeocodedLocation.prototype = {

    constructor : GeocodedLocation

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeocodedLocation);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Geocode/ReverseGeocode.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Geocode/ReverseGeocode.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Utils/MessagesResources */ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js");
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Exceptions/ErrorService */ "./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js");
/* harmony import */ var _CommonService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CommonService */ "./node_modules/geoportal-access-lib/src/Services/CommonService.js");
/* harmony import */ var _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../DefaultUrlService */ "./node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js");
/* harmony import */ var _Request_GeocodeRequestFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Request/GeocodeRequestFactory */ "./node_modules/geoportal-access-lib/src/Services/Geocode/Request/GeocodeRequestFactory.js");
/* harmony import */ var _Response_GeocodeResponseFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Response/GeocodeResponseFactory */ "./node_modules/geoportal-access-lib/src/Services/Geocode/Response/GeocodeResponseFactory.js");








/**
 * @classdesc
 * Appel du service de géocodage inverse du Géoportail :
 *     envoi de la requête construite selon les paramètres en options,
 *     éventuellement parsing et analyse  de la réponse,
 *     retour d'une réponse en paramètre de la fonction onSuccess.
 * @constructor
 * @extends {Gp.Services.CommonService}
 * @alias Gp.Services.ReverseGeocode
 *
 * @param {Object} options - options spécifiques au service (+ les options heritées)
 *
 * @param {Object} options.position - Position du point de référence pour le calcul de proximité exprimée dans le système de référence spécifié par le srs.
 *      @param {Float} options.position.lon - Longitude du point de référence pour le calcul de proximité.
 *      @param {Float} options.position.lat - Latitude du point de référence pour le calcul de proximité.
 *
 * @param {Object} [options.filters] - Les propriétés possibles de cet objet.
 * @param {String} [options.filters.[proprietes du filtre]] - Critère supplémentaire pour filtrer la recherche sous la forme
 *      d'un couple clé/valeur à définir selon les possibilités du serveur ajouté à la requête.
 *      Le service de géocodage du Géoportail permet de filtrer les adresses postales avec les propriétés :
 *          "postalCode", "inseeCode", "city".
 *      Il permet également de filtrer les toponymes avec les propriétés :
 *          "postalCode", "inseeCode", "type".
 *      Enfin, il permet de filtrer les parcelles cadastrales avec les propriétés :
 *          "codeDepartement", "codeCommune", "nomCommune", "codeCommuneAbs", "codeArrondissement", "section", "numero", "feuille".
 *
 * @param {Object} [options.searchGeometry] - Emprise dans laquelle on souhaite effectuer la recherche.
 *      Les propriétés possibles de cet objet sont décrites ci-après.
 *      @param {String} options.searchGeometry.type   - Type de géometrie (Point|Circle|Linestring|Polygon)
 *      @param {Array.<Float>|Array.Array.<Float>} options.searchGeometry.coordinates - Coordonnées des points constituant la géométrie.
 *      @param {Float} options.searchGeometry.radius    - Rayon. Paramètre applicable uniquement pour le type 'Circle'.
 *
 * @param {String} [options.index = "StreetAddress"] - Type de l'objet recherché.
 *      Le service de géocodage du Géoportail permet de rechercher des 'PositionOfInterest' pour des toponymes, des 'StreetAddress'
 *      pour des adresses postales ou des 'CadastralParcel' pour des parcelles cadastrales. L'index 'location' permet une recherche
 *      multi-indexes en regroupant les indexes 'PositionOfInterest' et 'StreetAddress'.
 *      D'autres types pourront être rajoutés selon l'évolution du service.
 *      Par défaut, index = 'StreetAddress'.
 *
 * @param {Number} [options.maximumResponses] - Nombre de réponses maximal que l'on souhaite recevoir.
 *      Pas de valeur par défaut. Si le serveur consulté est celui du Géoportail, la valeur par défaut sera donc celle du service : 20s.
 *
 * @param {Boolean} [options.returnTrueGeometry] - Booléen indiquant si l'on souhaite récupérer la géométrie vraie des objects géolocalisés.
 *      false par défaut.
 *
 * @example
 *   var options = {
 *      apiKey : null,
 *      serverUrl : 'http://localhost/service/',
 *      proxyURL : null,
 *      timeOut : 10000, // ms
 *      rawResponse : false, // true|false
 *      scope : null, // this
 *      onSuccess : function (response) {},
 *      onFailure : function (error) {},
 *      // spécifique au service
 *      index : 'StreetAddress',
 *      searchGeometry : {
 *          type : Circle,
 *          coordinates : [48, 2],
 *          radius : 100
 *      },
 *      position : {lon:2 , lat:48.5},
 *      maximumResponses : 25,
 *   };
 *
 */
function ReverseGeocode (options_) {
    if (!(this instanceof ReverseGeocode)) {
        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("CLASS_CONSTRUCTOR", "ReverseGeocode"));
    }

    /**
     * Nom de la classe (heritage)
     * FIXME instance ou classe ?
     */
    this.CLASSNAME = "ReverseGeocode";

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("Gp.Services.ReverseGeocode");
    this.logger.trace("[Constructeur ReverseGeocode (options)]");

    var options = this.patchOptionConvertor(options_);
    if (!options.serverUrl) {
        options.serverUrl = _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__["default"].ReverseGeocode.newUrl();
    }

    // appel du constructeur par heritage
    _CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].apply(this, [options]);

    if (!options.searchGeometry) {
        if (!options.position) {
            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "searchGeometry"));
        }
    } else {
        this.options.searchGeometry = options.searchGeometry;
    }

    // on definit l'index par defaut
    if (!options.index) {
        this.options.index = options.index = "StreetAddress";
    }

    if (options.filters) {
        var filter = Object.keys(options.filters);
        for (var i = 0; i < filter.length; i++) {
            var key = filter[i];
            // on supprime les filtres vides
            if (typeof options.filters[key] === "undefined" ||
                (typeof options.filters[key] === "object" && Object.keys(options.filters[key]).length === 0) ||
                (typeof options.filters[key] === "string" && options.filters[key].length === 0) ||
                (Array.isArray(options.filters[key]) && options.filters[key].length === 0)
            ) {
                delete this.options.filters[key];
            }
        }
    }

    this.options.position = options.position;
    this.options.index = options.index || "StreetAddress";
    this.options.maximumResponses = options.maximumResponses || 20;
}

/**
 * @lends module:ReverseGeocode#
 */
ReverseGeocode.prototype = Object.create(_CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].prototype, {
    // todo
    // getter/setter
});

/*
 * Constructeur (alias)
 */
ReverseGeocode.prototype.constructor = ReverseGeocode;

/**
 * Patch pour la convertion des options vers le nouveau formalisme.
 *
 * @param {Object} options_ - options du service
 * @return {Object} - options
 */
ReverseGeocode.prototype.patchOptionConvertor = function (options_) {
    var options = options_;

    if (options.filterOptions) {
        this.logger.warn("The parameter 'filterOptions' is deprecated");

        if (options.filterOptions.type) {
            this.logger.warn("The parameter 'filterOptions.type' is deprecated");
            if (!options.index) {
                if (Array.isArray(options.filterOptions.type) && options.filterOptions.type.length > 0) {
                    options.index = options.filterOptions.type[0];
                } else {
                    options.index = options.filterOptions.type;
                }
            }
            delete options.filterOptions.type;
        }

        if (options.filterOptions.bbox) {
            this.logger.warn("The parameter 'filterOptions.bbox' is deprecated");
            if (!options.searchGeometry) {
                // convertir la geometrie
                options.searchGeometry = this.bbox2Json(options.filterOptions.bbox);
            }
            delete options.filterOptions.bbox;
        }

        if (options.filterOptions.circle) {
            this.logger.warn("The parameter 'filterOptions.circle' is deprecated");
            if (!options.searchGeometry) {
                // convertir la geometrie
                options.searchGeometry = this.circle2Json(options.filterOptions.circle);
            }
            delete options.filterOptions.circle;
        }

        if (options.filterOptions.polygon) {
            this.logger.warn("The parameter 'filterOptions.polygon' is deprecated");
            if (!options.searchGeometry) {
                // convertir la geometrie
                options.searchGeometry = this.polygon2Json(options.filterOptions.polygon);
            }
            delete options.filterOptions.polygon;
        }

        if (!options.filters && Object.keys(options.filterOptions).length > 0) {
            options.filters = options.filterOptions;
        }

        delete options.filterOptions;
    }

    if (options.position) {
        if (options.position.x) {
            this.logger.warn("The parameter 'position.x' is deprecated");

            if (!options.position.lon) {
                options.position.lon = options.position.x;
            }
            delete options.position.x;
        }

        if (options.position.y) {
            this.logger.warn("The parameter 'position.y' is deprecated");

            if (!options.position.lat) {
                options.position.lat = options.position.y;
            }
            delete options.position.y;
        }
    }

    if (options.srs) {
        this.logger.warn("The parameter 'srs' is deprecated");
        delete options.srs;
    }

    return options;
};

/**
 * (overwrite)
 * Création de la requête
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
ReverseGeocode.prototype.buildRequest = function (error, success) {
    var options = {
        httpMethod : this.options.httpMethod,
        // options specifiques du service
        geocodeMethod : "reverse",
        searchGeometry : this.options.searchGeometry,
        index : this.options.index,
        position : this.options.position,
        returnTrueGeometry : this.options.returnTrueGeometry,
        maxResp : this.options.maximumResponses,
        filters : this.options.filters
    };

    this.request = _Request_GeocodeRequestFactory__WEBPACK_IMPORTED_MODULE_5__["default"].build(options);

    // on teste si la requete a bien été construite !
    (!this.request)
        ? error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_REQUEST_BUILD")))
        : success.call(this, this.request);
};

/**
 * (overwrite)
 * Analyse de la reponse
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
ReverseGeocode.prototype.analyzeResponse = function (error, success) {
    if (this.response) {
        var options = {
            response : this.response,
            rawResponse : this.options.rawResponse,
            onError : error,
            onSuccess : success,
            scope : this
        };

        _Response_GeocodeResponseFactory__WEBPACK_IMPORTED_MODULE_6__["default"].build(options);
    } else {
        error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
    }
};

/**
 * Patch pour la convertion des options vers le nouveau formalisme.
 *
 * @param {Array} bbox - bbox
 * @return {Object} - geometrie au format json
 */
ReverseGeocode.prototype.bbox2Json = function (bbox) {
    return {
        type : "Polygon",
        coordinates : [[
            [bbox.left, bbox.top],
            [bbox.right, bbox.top],
            [bbox.right, bbox.bottom],
            [bbox.left, bbox.bottom],
            [bbox.left, bbox.top]
        ]]
    };
};

/**
 * Patch pour la convertion des options vers le nouveau formalisme.
 *
 * @param {Object} circle - circle
 * @return {Object} - geometrie au format json
 */
ReverseGeocode.prototype.circle2Json = function (circle) {
    return {
        type : "Circle",
        radius : circle.radius,
        coordinates : [circle.x, circle.y]
    };
};

/**
 * Patch pour la convertion des options vers le nouveau formalisme.
 *
 * @param {Array} polygon - polygon
 * @return {Object} - geometrie au format json
 */
ReverseGeocode.prototype.polygon2Json = function (polygon) {
    var jsonGeom = {
        type : "Polygon",
        coordinates : [[]]
    };

    for (var i = 0; i < polygon.length; ++i) {
        jsonGeom.coordinates[0].push([polygon[i].x, polygon[i].y]);
    }

    return jsonGeom;
};

/**
 * Codes EPSG géographiques (lat/lon). Utiles car les coordonnées doivent être inversées.
 */
ReverseGeocode.geoEPSG = ["EPSG:4326"];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ReverseGeocode);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/ProcessIsoCurve.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/ProcessIsoCurve.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Utils/MessagesResources */ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js");
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Exceptions/ErrorService */ "./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js");
/* harmony import */ var _CommonService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CommonService */ "./node_modules/geoportal-access-lib/src/Services/CommonService.js");
/* harmony import */ var _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../DefaultUrlService */ "./node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js");
/* harmony import */ var _Request_ProcessIsoCurveRequest__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Request/ProcessIsoCurveRequest */ "./node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/Request/ProcessIsoCurveRequest.js");
/* harmony import */ var _Response_ProcessIsoCurveResponseFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Response/ProcessIsoCurveResponseFactory */ "./node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/Response/ProcessIsoCurveResponseFactory.js");









/**
 * @classdesc
 * Appel du service d'isochrone/distance du Géoportail :
 *     envoi de la requête construite selon les paramètres en options,
 *     éventuellement parsing et analyse  de la réponse,
 *     retour d'une réponse en paramètre de la fonction onSuccess.
 * @constructor
 * @extends {Gp.Services.CommonService}
 * @alias Gp.Services.ProcessIsoCurve
 * @param {Object} options - options spécifiques au service (+ les options heritées)
 *
 * @param {String} options.resource - La ressource utilisée pour le calcul : bdtopo-valhalla (par défaut) ou bdtopo-pgr.
 *
 * @param {String} options.outputFormat - Le format de la réponse du service iso : 'json' uniquement et par défaut.
 *
 * @param {Object} options.position - Point de départ du calcul.
 *      Coordonnées exprimées en longitudes, latitudes (EPSG:4326)
 *      @param {Float} options.position.x - Abcisse du point de départ du calcul d'isochrone/distance.
 *      @param {Float} options.position.y - Ordonnée du point de départ du calcul d'isochrone/distance.
 *
 * @param {String} options.srs - Projection.
 *      Système de coordonnées dans lequel les coordonnées du point « location » sont exprimées et
 *      dans lequel la géométrie de la courbe résultante sera exprimée.
 *      Par défaut, le système de coordonnées utilisé sera « EPSG:4326 ».
 *
 * @param {String} [options.graph = "voiture"] - Nom du graphe à utiliser pour le calcul (« Pieton » ou « Voiture »).
 *      La valeur par défaut est : «voiture»
 *
 * @param {Array.<String>} [options.exclusions] - DEPRECATED: Ce paramètre est conservé pour une rétrocompatibilité de l'api. Le nouveau paramètre à utiliser est options.constraints.
 *      Critères d'exclusions à appliquer pour le calcul.
 *      On précise ici le type de tronçons que l'on ne veut pas que l'isochrone/distance emprunte
 *      (valeurs possibles : « toll » (éviter les péages), « bridge », « tunnel »).
 *
 * @param {Object[]} [options.constraints] - Critères de contraintes à appliquer sur un itinéraire. Les valeurs disponibles dépendent de la ressource utilisée. Il est donc utile de regarder le getCapabilities.
 *      @param {String} [options.constraints.constraintType] - Type de la contrainte. Généralement "banned".
 *      @param {String} [options.constraints.key] - Clé de la contrainte. Généralement "wayType".
 *      @param {String} [options.constraints.operator] - Opérateur de la contrainte. Généralement "=".
 *      @param {String} [options.constraints.value] - Valeur de la contrainte. Généralement "autoroute".
 *
 * @param {String} [options.method = "time"] - Méthode utilisée pour le calcul de la courbe iso.
 *      Les valeurs possible sont "time" pour un calcul d'isochrone, "distance" pour un calcul d'isodistance.
 *      Pas de valeur spécifié équivaut à un calcul d'isochrone.
 *
 * @param {String} [options.distanceUnit = "m"] - Indique si la distance doit être exprimée en km ou m dans la réponse ("m" or "km").
 *
 * @param {String} [options.timeUnit = "second"] - Indique si la durée doit être exprimée en seconde, minute ou heure dans la réponse ("standard", "second", "minute", "hour"). Il peut-être formatté hh:mm::ss avec la valeur standard.
 *
 * @param {Float} options.time - Durée maximum (exprimée en secondes) à utiliser pour le calcul de la courbe à partir du ou jusqu'au point « location ».
 *      Ce paramètre doit être renseigné si l'option "méthod" a la valeur "time".
 *      Si l'option method n'est pas renseignée, ce paramètre doit être renseigné.
 *
 * @param {Float} options.distance - Distance maximum (exprimée en metres) à utiliser pour le calcul de la courbe à partir du ou j'usqu'au point « location ».
 *      Ce paramètre doit être renseigné si l'option "méthod" a la valeur "DISTANCE".
 *      Si l'option "method" n'est pas renseignée, ce paramètre sera ignoré.
 *
 * @param {Boolean} [options.reverse = false] - Indique si la géométrie résultante doit être lissée (« true ») pour ne pas avoir d'effet d'escalier.
 *      Par défaut, la valeur « false » est appliquée.
 *
 * @param {Boolean} [options.smoothing = false] - Indique si la géométrie résultante doit être lissée (« true ») pour ne pas avoir d'effet d'escalier.
 *      Par défaut, la valeur « false » est appliquée.
 *
 * @param {Boolean} [options.holes = false] - Indique si la géométrie résultante (surface) doit être retournée avec des trous (« true »).
 *      Par défaut, la valeur « false » est appliquée.
 *
 * @example
 *   var options = {
 *      // options communes aux services
 *      apiKey : null,
 *      serverUrl : 'http://localhost/service/',
 *      protocol : 'JSONP', // JSONP|XHR
 *      proxyURL : null,
 *      httpMethod : 'GET', // GET|POST
 *      timeOut : 10000, // ms
 *      rawResponse : false, // true|false
 *      scope : null, // this
 *      onSuccess : function (response) {},
 *      onFailure : function (error) {},
 *      // spécifique au service
 *      position : {
 *           x : 2.3242664298058053,
 *           y : 48.86118017324745
 *      },
 *      resource : bdtopo-valhalla,
 *      distance : 200,
 *      [time : ]
 *      method : "distance",
 *      graph : "voiture",
 *      reverse : false
 *  };
 */

function ProcessIsoCurve (options) {
    if (!(this instanceof ProcessIsoCurve)) {
        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("CLASS_CONSTRUCTOR", "ProcessIsoCurve"));
    }

    /**
     * Nom de la classe (heritage)
     * FIXME instance ou classe ?
     */
    this.CLASSNAME = "ProcessIsoCurve";

    // appel du constructeur par heritage
    _CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].apply(this, arguments);

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("Gp.Services.ProcessIsoCurve");
    this.logger.trace("[Constructeur ProcessIsoCurve (options)]");

    if (!options.position) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "position"));
    }

    // on lance une exception afin d'eviter au service de le faire...
    if (options.position.x === null) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "position.x"));
    }

    if (options.position.y === null) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "position.y"));
    }

    if (!options.time && !options.distance) {
        throw new Error("Parameter (s) 'distance' missing. Parameter time to calculate an isochrone, parameter distance for an isodistance");
    }

    // si on a que le paramètre "distance" en entrée, on calcule une isodistance.
    // Le paramètre "méthode" doit pour avoir une réponse du service, être passé à "distance"
    if (!options.time && options.distance) {
        this.options.method = "distance";
        // on supprime l'éventuel attribut time, résidu d'un appel antérieur
        if (this.options.time) {
            delete this.options.time;
        }
    }

    // si on a que le paramètre "time" en entrée, on calcule une isochrone.
    // Le paramètre "méthode" doit pour avoir une réponse du service, être passé à "time"
    if (options.time && !options.distance) {
        this.options.method = "time";
        // on supprime l'éventuel attribut time, résidu d'un appel antérieur
        if (this.options.distance) {
            delete this.options.distance;
        }
    }

    // au cas où on a ni l'un, ni l'autre...
    this.options.method = this.options.method || "time";

    // options par defaut du service
    // TODO: modifier la ressource lors de la mise en production du service
    this.options.resource = options.resource || "bdtopo-valhalla";
    this.options.exclusions = options.exclusions || [];
    this.options.reverse = options.reverse || false;
    this.options.srs = options.srs || "EPSG:4326";
    this.options.distanceUnit = options.distanceUnit || "m";
    this.options.timeUnit = options.timeUnit || "second";

    // options depreciees
    if (options.smoothing) {
        this.logger.warn("options.smoothing is DEPRECATED");
    }
    this.options.smoothing = false;
    if (options.holes) {
        this.logger.warn("options.holes is DEPRECATED");
    }
    this.options.holes = false;

    // Gestion du graphe
    if (options.graph) {
        if (options.graph === "Voiture") {
            this.options.graph = "car";
        }
        if (options.graph === "Pieton") {
            this.options.graph = "pedestrian";
        }
    } else {
        this.options.graph = "car";
    }

    // Gestions des contraintes
    this.options.constraints = [];
    if (options.constraints) {
        if (Array.isArray(options.constraints)) {
            for (var k = 0; k < options.constraints.length; k++) {
                this.options.constraints.push(options.constraints[k]);
            }
        } else {
            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_TYPE", "constraints"));
        }
    }

    // Gestion de l'ancien paramètre exclusions
    var constraintTunnel = {};
    var constraintPont = {};
    var constraintAutoroute = {};
    if (options.exclusions) {
        if (options.exclusions.length !== 0) {
            this.logger.warn("options.exclusions is DEPRECATED !!");
            for (var c = 0; c < options.exclusions.length; c++) {
                if (typeof options.exclusions[c] === "string") {
                    options.exclusions[c] = options.exclusions[c].toLowerCase();
                } else {
                    // on ne crée pas une erreur pour rétro-compatibilité avec les anciennes versions
                    continue;
                }
                if (options.exclusions[c] === "toll") {
                    constraintAutoroute.constraintType = "banned";
                    constraintAutoroute.key = "wayType";
                    constraintAutoroute.operator = "=";
                    constraintAutoroute.value = "autoroute";
                    this.options.constraints.push(constraintAutoroute);
                }
                if (options.exclusions[c] === "tunnel") {
                    constraintTunnel.constraintType = "banned";
                    constraintTunnel.key = "wayType";
                    constraintTunnel.operator = "=";
                    constraintTunnel.value = "tunnel";
                    this.options.constraints.push(constraintTunnel);
                }
                if (options.exclusions[c] === "bridge") {
                    constraintPont.constraintType = "banned";
                    constraintPont.key = "wayType";
                    constraintPont.operator = "=";
                    constraintPont.value = "pont";
                    this.options.constraints.push(constraintPont);
                }
            }
        }
    }

    // on passe l'option outputFormat en minuscules afin d'éviter des exceptions.
    this.options.outputFormat = (typeof options.outputFormat === "string") ? options.outputFormat.toLowerCase() : "json";
    if (options.outputFormat && options.outputFormat !== "json") {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_NOT_SUPPORT", "outputFormat"));
    }
    this.options.outputFormat = "json";

    // gestion de l'url du service par defaut
    // si l'url n'est pas renseignée, il faut utiliser les urls par defaut
    if (!this.options.serverUrl) {
        var urlFound = _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__["default"].ProcessIsoCurve.newUrl();
        if (!urlFound) {
            throw new Error("Url by default not found !");
        }
        this.options.serverUrl = urlFound;
        this.logger.trace("Serveur URL par defaut : " + this.options.serverUrl);
    }
}

/**
 * @lends module:ProcessIsoCurve#
 */
ProcessIsoCurve.prototype = Object.create(_CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].prototype, {
    // todo
    // getter/setter
});

/*
 * Constructeur (alias)
 */
ProcessIsoCurve.prototype.constructor = ProcessIsoCurve;

/**
 * Création de la requête (overwrite)
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
ProcessIsoCurve.prototype.buildRequest = function (error, success) {
    try {
        var oIsoCurve = new _Request_ProcessIsoCurveRequest__WEBPACK_IMPORTED_MODULE_5__["default"](this.options);
        if (!oIsoCurve.processRequestString()) {
            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_REQUEST_BUILD"));
        }

        this.request = oIsoCurve.requestString;
    } catch (e) {
        error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](e.message));
        return;
    }

    success.call(this, this.request);
};

/**
 * (overwrite)
 * Analyse de la reponse
 *
 * @param {Function} onError   - callback des erreurs
 * @param {Function} onSuccess - callback de succès de l'analyse de la réponse
 */
ProcessIsoCurve.prototype.analyzeResponse = function (onError, onSuccess) {
    if (this.response) {
        var options = {
            response : this.response,
            outputFormat : this.options.outputFormat,
            rawResponse : this.options.rawResponse,
            onSuccess : onSuccess,
            onError : onError,
            scope : this
        };

        _Response_ProcessIsoCurveResponseFactory__WEBPACK_IMPORTED_MODULE_6__["default"].build(options);
    } else {
        onError.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ProcessIsoCurve);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/Request/ProcessIsoCurveRequest.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/Request/ProcessIsoCurveRequest.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Utils/MessagesResources */ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js");
/* harmony import */ var _model_ProcessIsoCurveParam__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./model/ProcessIsoCurveParam */ "./node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/Request/model/ProcessIsoCurveParam.js");





/**
 * @classdesc
 * Classe de gestion des requêtes sur le service de calcul d'isoschrone/isodistance.
 *  Les requêtes peuvent être en mode GET ou POST,
 *  et le format de sorti est en JSON.
 *
 * @constructor
 * @alias Gp.Services.ProcessIsoCurve.Request.ProcessIsoCurveRequest
 * @param {Object} options - options
 *
 * @example
 * var options = {
 *      httpMethod : 'GET', // GET|POST
 *      // spécifique au service
 *      position : {
 *          x : 2.3242664298058053,
 *          y : 48.86118017324745
 *      },
 *      graph : "car",
 *      method : 'time',
 *      time : 1000, //distance : 200
 *      reverse : false,
 *      srs : 'EPSG:4326'
 *  };
 *
 * try {
 *
 *      var oIsoCurve = new ProcessIsoCurveRequest (options);
 *      if (!oIsoCurve.processRequestString ()) {
 *          // error
 *      }
 *
 *      var request = oIsoCurve.requestString;
 *
 * } catch (e) {
 *      // error
 * }
 * @private
 */
function ProcessIsoCurveRequest (options) {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("ProcessIsoCurveRequest");
    this.logger.trace("[Constructeur ProcessIsoCurveRequest ()]");

    if (!(this instanceof ProcessIsoCurveRequest)) {
        throw new TypeError("ProcessIsoCurveRequest constructor cannot be called as a function.");
    }

    // existance des options
    if (!options) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_EMPTY", "options"));
    }

    /**
     * Liste des options
     */
    this.settings = options;

    /**
     * Mode HTPP.
     * Par defaut, "GET".
     * @type {String}
     */
    this.mode = this.settings.httpMethod || "GET";
}

ProcessIsoCurveRequest.prototype = {

    /**
     * @lends module:ProcessIsoCurveRequest#
     */

    /**
     * Requête
     * @type {String}
     */
    requestString : null,

    /**
     * Constructeur (alias)
     */
    constructor : ProcessIsoCurveRequest,

    /**
     * Construction de la requête.
     *
     * @example
     * // GET  out :
     *   //  (http://wxs.ign.fr/KEY/isochrone?)
     *   //  resource=&
     *   //  point=&
     *   //  costValue=&
     *   //  costType=&
     *   //  profile=&
     *   //  constraints=&
     *   //  direction=&
     *   //  crs=
     *
     * // POST out :
     * {
     *  resource: "bduni-idf-pgr",
     *  point: "2.337306,48.849319",
     *  costValue: 100,
     *  costType: "time",
     *  profile: "car",
     *  constraints: [{
     *      constraintType: "banned",
     *      key: "ways_type",
     *      operator: "=",
     *      value: "autoroute"
     *  }]
     * }
     *
     * @returns {String} request
     */
    processRequestString : function () {
        var request = "";
        var i = 0;

        switch (this.mode) {
            case "GET":
                this.logger.trace("Process GET Request");

                // Mapping des options avec le service de l'API REST
                var oParams = new _model_ProcessIsoCurveParam__WEBPACK_IMPORTED_MODULE_2__["default"](this.settings);
                var params = oParams.getParams();

                for (i = 0; i < params.length; i++) {
                    var o = params[i];
                    if (request) {
                        request += "&";
                    }
                    request += o.k + "=" + o.v;
                }

                break;

            case "POST":
                this.logger.trace("Process POST Request");
                // creation du JSON
                var postRequest = {};

                postRequest.resource = this.settings.resource;

                postRequest.point = this.settings.position.x + "," + this.settings.position.y;

                if (this.settings.method === "distance") {
                    postRequest.costType = "distance";
                    postRequest.costValue = this.settings.distance;
                } else {
                    postRequest.costType = "time";
                    postRequest.costValue = this.settings.time;
                }

                postRequest.profile = this.settings.graph;

                if (this.settings.reverse) {
                    postRequest.direction = "arrival";
                } else {
                    postRequest.direction = "departure";
                }

                postRequest.constraints = this.settings.constraints;

                postRequest.distanceUnit = this.settings.distanceUnit;

                postRequest.timeUnit = this.settings.timeUnit;

                postRequest.crs = this.settings.srs;

                // conversion en chaîne de caractères
                request = JSON.stringify(postRequest);
                break;

            default:
                this.logger.error("No other HTTP method supported by the service !");
        }

        this.logger.trace(request);
        this.requestString = request;

        return this.requestString;
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ProcessIsoCurveRequest);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/Request/model/ProcessIsoCurveParam.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/Request/model/ProcessIsoCurveParam.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");



/**
 * @classdesc
 *
 * Classe de gestion des param. des requêtes du service de calcul des iso.
 * Permet le mapping avec les options du service.
 *
 * @constructor
 * @alias Gp.Services.ProcessIsoCurve.Request.ProcessIsoCurveParam
 * @param {Object} options - options
 * @private
 *
 */
function ProcessIsoCurveParam (options) {
    if (!(this instanceof ProcessIsoCurveParam)) {
        throw new TypeError("ProcessIsoCurveParam constructor cannot be called as a function.");
    }

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur ProcessIsoCurveParam ()]");

    /**
     * Options en paramêtres du constructeur.
     */
    this.options = options || {};

    // mapping des options avec l'API REST

    /** Identifiant de l’isochrone */
    this.id = this.options.id;

    /** Resource */
    this.resource = this.options.resource;

    /** Coordonnées de départ (ou arrivée si le reverse est à true). */
    this.point = this.options.position;

    /** projection (code EPSG comme epsg:4326 ou wgs84) */
    this.crs = this.options.srs;

    /**
     * Profil de véhicule à utiliser pour le calcul.
     * Voiture ou Pieton
     */
    this.profile = this.options.graph;

    /** Liste des règles de restrictions à utiliser */
    this.constraints = this.options.constraints;

    this.reverse = this.options.reverse;

    this.timeUnit = this.options.timeUnit;

    this.distanceUnit = this.options.distanceUnit;

    /**
     * "time" pour isochrone ou "distance" for isodistance.
     * Par defaut, time...
     */
    if (this.options.method === "distance") {
        this.costType = "distance";
        this.costValue = this.options.distance;
    } else {
        this.costType = "time";
        this.costValue = this.options.time;
    }
}

/**
 * CLASSNAME
 */
ProcessIsoCurveParam.CLASSNAME = "ProcessIsoCurveParam";

ProcessIsoCurveParam.prototype = {

    /**
     * @lends module:ProcessIsoCurveParam#
     */

    /**
     * Constructeur (alias)
     */
    constructor : ProcessIsoCurveParam,

    /**
     * Retourne le point
     * @returns {String} x,y
     */
    getLocation : function () {
        return this.point.x + "," + this.point.y;
    },

    /**
     * Retourne l'unité de la distance
     * @returns {String}
     */
    getDistanceUnit : function () {
        if (this.distanceUnit === "m") {
            return "meter";
        }
        if (this.distanceUnit === "km") {
            return "kilometer";
        }
        return "";
    },

    /**
     * Retourne la liste des contraintes
     * @returns {String}
     */
    getConstraints : function () {
        var constraintArray = [];

        if (this.constraints.length !== 0) {
            for (var k = 0; k < this.constraints.length; k++) {
                constraintArray.push(JSON.stringify(this.constraints[k]));
            }
        }
        return constraintArray.join("|");
    },

    /**
     * Retourne la direction
     * @returns {String}
     */
    getDirection : function () {
        if (this.reverse) {
            return "arrival";
        } else {
            return "departure";
        }
    }
};

/**
 * Tableau de clefs/valeurs pour param.
 *
 * @returns {Object[]} KVP
 */
ProcessIsoCurveParam.prototype.getParams = function () {
    var map = [];

    map.push({
        k : "resource",
        v : this.resource
    });

    map.push({
        k : "point",
        v : this.getLocation()
    });

    map.push({
        k : "direction",
        v : this.getDirection()
    });

    map.push({
        k : "costType",
        v : this.costType
    });

    map.push({
        k : "costValue",
        v : this.costValue
    });

    map.push({
        k : "profile",
        v : this.profile
    });

    map.push({
        k : "timeUnit",
        v : this.timeUnit
    });

    map.push({
        k : "distanceUnit",
        v : this.getDistanceUnit()
    });

    if (this.crs) {
        map.push({
            k : "crs",
            v : this.crs
        });
    }

    if (this.constraints) {
        map.push({
            k : "constraints",
            v : this.getConstraints()
        });
    }

    return map;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ProcessIsoCurveParam);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/Response/ProcessIsoCurveResponseFactory.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/Response/ProcessIsoCurveResponseFactory.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Utils/MessagesResources */ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js");
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../Exceptions/ErrorService */ "./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js");
/* harmony import */ var _model_ProcessIsoCurveResponse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model/ProcessIsoCurveResponse */ "./node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/Response/model/ProcessIsoCurveResponse.js");





/**
 * Factory pour générer une reponse JSON à partir d'un JSON
 * (Factory)
 *
 * @module ProcessIsoCurveResponseFactory
 * @alias Gp.Services.ProcessIsoCurve.Response.ProcessIsoCurveResponseFactory
 * @private
 */
var ProcessIsoCurveResponseFactory = {

    /**
     * interface unique
     *
     * @method build
     * @static
     * @param {Object} options - options definies dans le composant ProcessIsoCurve
     *
     * @example
     *   var options = {
     *      response :
     *      outputFormat :
     *      rawResponse :
     *      scope :
     *      onSuccess :
     *      onError :
     *   };
     *
     */
    build : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("ProcessIsoCurveResponseFactory");
        logger.trace(["ProcessIsoCurveResponseFactory::build()"]);

        var data = null;

        if (options.response) {
            if (options.rawResponse) {
                logger.trace("analyze response : raw");
                data = options.response;
            } else {
                logger.trace("analyze response : json");

                var JSONResponse;
                if (typeof options.response === "string") {
                    JSONResponse = JSON.parse(options.response);
                } else {
                    JSONResponse = options.response;
                }

                // analyse de la reponse
                // création de l'objet de réponse
                data = new _model_ProcessIsoCurveResponse__WEBPACK_IMPORTED_MODULE_3__["default"]();

                // remplissage de l'objet créé avec les attribtuts de la réponse du service
                if (JSONResponse) {
                    if (JSONResponse.costType === "distance") {
                        data.time = "";
                        data.distance = JSONResponse.costValue;
                    } else {
                        data.time = JSONResponse.costValue;
                        data.distance = "";
                    }

                    data.message = "";
                    data.id = "";
                    data.srs = JSONResponse.crs;
                    data.geometry = JSONResponse.geometry;
                    var coords = JSONResponse.point.split(",");
                    if (data.location) {
                        data.location.x = coords[0];
                        data.location.y = coords[1];
                    }
                } else {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_ANALYSE", options.response)));
                    return;
                }

                // info : en cas de problèmes de droits (clé invalide ou autre), la réponse est au format XML !!
                // ex. <ExceptionReport><Exception exceptionCode="MissingParameter">Key does not exist or has expired</Exception></ExceptionReport>
                // mais le statut est 403, l'erreur est donc remontée plus tôt.
                if (data.exceptionReport) {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"]({
                        message : _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", data.exceptionReport),
                        type : _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"].TYPE_SRVERR,
                        status : 200
                    }));
                    return;
                }
            }
        } else {
            // si la réponse est vide, on appelle le callback d'erreur
            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
            return;
        }

        // si tout s'est bien passé, on appelle le callback de succès
        options.onSuccess.call(options.scope, data);
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ProcessIsoCurveResponseFactory);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/Response/model/ProcessIsoCurveResponse.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/Response/model/ProcessIsoCurveResponse.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/**
 * Response object for {@link module:Services~isoCurve Gp.Services.isoCurve ()} invocation when successful. Received as the argument of onSuccess callback function.
 *
 * @property {Float} distance - distance (expressed in meters) used for the request.
 * @property {Float} time - time (expressed in seconds) used for the request.
 * @property {Object} geometry - Geometry (expressed in [GeoJSON]{@link http://geojson.org/}) of the isocurve.
 * @property {String} id - request id (used by underlying webservice).
 * @property {Gp.Point} location - Position of the start or end point used for the request (expressed in "srs" coordinates system).
 * @property {String} message - message
 * @property {String} srs - Identifier of the coordinates system used for the isocurve.
 *
 * @namespace
 * @alias Gp.Services.IsoCurveResponse
 *
 */
function ProcessIsoCurveResponse () {
    if (!(this instanceof ProcessIsoCurveResponse)) {
        throw new TypeError("ProcessIsoCurveResponse constructor cannot be called as a function.");
    }

    this.message = null;

    this.id = null;

    this.location = {};
    this.location.x = null;
    this.location.y = null;

    this.srs = null;

    this.geometry = null;

    this.time = null;

    this.distance = null;
}

ProcessIsoCurveResponse.prototype = {

    constructor : ProcessIsoCurveResponse

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ProcessIsoCurveResponse);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Route/Request/RouteRequestFactory.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Route/Request/RouteRequestFactory.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Exceptions/ErrorService */ "./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js");
/* harmony import */ var _RouteRequestREST__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RouteRequestREST */ "./node_modules/geoportal-access-lib/src/Services/Route/Request/RouteRequestREST.js");




/**
 * Creation d'une requête REST en mode POST ou GET
 * (Factory)
 *
 * @module RouteRequestFactory
 * @alias Gp.Services.Route.Request.RouteRequestFactory
 * @private
 */
var RouteRequestFactory = {

    /**
     * interface unique
     *
     * @method build
     * @static
     * @param {Object} options - options definies dans le composant Route
     *
     * @example
     *   // utilisation avec les callback
     *   var options = {
     *      (...)
     *      onSuccess : function (response) {},
     *      onError : function (error) {},
     *      // spécifique au service
     *      startPoint : {
     *          x : 42.1121,
     *          y : 1.5557
     *      },
     *      endPoint : {
     *          x : 42.1121,
     *          y : 1.5557
     *      },
     *      provideBbox : false,
     *      exclusions : ["bridge", "tunnel", "toll"],
     *      distanceUnit : "km",
     *      graph : "Voiture",
     *      geometryInInstructions : false,
     *      routePreference : "fastest"
     *   };
     *   RouteRequestFactory.build(options);
     *
     *   // utilisation sans callback
     *   var options = {...};
     *   try {
     *      var result = RouteRequestFactory.build(options);
     *      if (! result) { throw new Error("..."):}
     *   } catch (e) {
     *      // todo
     *   }
     * @returns {String} request
     */
    build : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("RouteRequestFactory");
        logger.trace(["RouteRequestFactory::build()"]);

        var request = null;

        var settings = options || {};

        // gestion des callback
        var bOnError = !!(options.onError !== null && typeof options.onError === "function");

        var message = null;

        // FIXME les exceptions ne sont pas 'catchées' sur le constructeur !
        var myReq = new _RouteRequestREST__WEBPACK_IMPORTED_MODULE_2__["default"](settings);
        if (!myReq.processRequestString()) {
            message = "Error process request (rest) !";
            if (bOnError) {
                options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_1__["default"](message));
                return;
            }
            throw new Error(message);
        }
        request = myReq.requestString;

        return request;
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RouteRequestFactory);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Route/Request/RouteRequestREST.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Route/Request/RouteRequestREST.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Utils/MessagesResources */ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js");
/* harmony import */ var _model_RouteParamREST__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./model/RouteParamREST */ "./node_modules/geoportal-access-lib/src/Services/Route/Request/model/RouteParamREST.js");





/**
 * @classdesc
 * Classe de gestion des requêtes de type REST sur le service de calcul d'itineraire
 * (uniquement en GET)
 *
 * @constructor
 * @alias Gp.Services.Route.Request.RouteRequestREST
 * @param {Object} options - options definies dans le composant Route
 *
 * @example
 * var options = {
 *      (...)
 * };
 *
 * @private
 */
function RouteRequestREST (options) {
    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("RouteRequestREST");
    this.logger.trace("[Constructeur RouteRequestREST ()]");

    if (!(this instanceof RouteRequestREST)) {
        throw new TypeError("RouteRequestREST constructor cannot be called as a function.");
    }

    // existance des options
    if (!options) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_EMPTY", "options"));
    }

    /** liste des options */
    this.settings = options;
}

RouteRequestREST.prototype = {

    /**
     * @lends module:RouteRequestREST#
     */

    /**
     * request
     * @type {String}
     */
    requestString : null,

    /**
     * Constructeur (alias)
     */
    constructor : RouteRequestREST,

    /**
     * Construction de la requête.
     *
     * @example
     * // GET  out : origin=2.416907353809513,48.8465772142297&destination=2.4248037771493673,48.84591353161838
     * // POST out : Not yet supported method POST !
     * @returns {String} request
     */
    processRequestString : function () {
        // INFO
        // construction simple sans template...,
        // mais en attendant que les services soient fixés, on taggue ce composant en mode PROTOTYPE !
        this.logger.warn(" PROTOTYPE !");

        // Mapping des options avec le service de l'API REST
        var oParams = new _model_RouteParamREST__WEBPACK_IMPORTED_MODULE_2__["default"](this.settings);
        var params = oParams.getParams();

        var request = "";
        for (var i = 0; i < params.length; i++) {
            var o = params[i];
            if (request) {
                request += "&";
            }
            request += o.k + "=" + o.v;
        }

        // Exemple :
        //  http://wxs.ign.fr/KEY/itineraire/rest/route.json?
        //  origin=&
        //  destination=&
        //  waypoints=&
        //  method=DISTANCE&
        //  graph=Pieton&
        //  graphName=Pieton&
        //  exclusions=&
        //  tolerance=10&
        //  srs=

        this.logger.trace(request);
        this.requestString = request;

        return this.requestString;
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RouteRequestREST);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Route/Request/model/RouteParamREST.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Route/Request/model/RouteParamREST.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");



/**
 * @classdesc
 * Classe de gestion des param. des requêtes du service de calcul d'itineraire (REST).
 *      Permet le mapping avec les options du service.
 * @constructor
 * @alias Gp.Services.Route.Request.RouteParamREST
 * @param {Object} options - options
 *
 * @private
 */
function RouteParamREST (options) {
    if (!(this instanceof RouteParamREST)) {
        throw new TypeError("RouteParamREST constructor cannot be called as a function.");
    }

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger();
    this.logger.trace("[Constructeur RouteParamREST ()]");
    /**
     * Options en paramêtres du constructeur.
     */
    this.options = options || {};

    // mapping des options avec l'API REST

    /** Ressource utilisée */
    this.resource = this.options.resource;

    /** Coordonnées du point de départ. */
    this.start = this.options.startPoint.x + "," + this.options.startPoint.y;

    /** Coordonnées du point d’arrivée. */
    this.end = this.options.endPoint.x + "," + this.options.endPoint.y;

    /** Coordonnées des étapes point de départ. */
    this.intermediates = this.options.viaPoints;

    /** Nom du profile à utiliser */
    this.profile = this.options.graph;

    /** projection (code EPSG comme epsg:4326 ou wgs84) */
    this.crs = this.options.srs;

    /** Liste des contraintes */
    this.constraints = this.options.constraints;

    /** Nom de l'optimisation à utiliser */
    this.optimization = this.options.routePreference;

    /** Format de sortie (résumé de l’itinéraire) */
    this.getSteps = (this.options.geometryInInstructions) ? "true" : "false";

    /** Unité des distances */
    this.distanceUnit = this.options.distanceUnit;

    /** Unité des durées */
    this.timeUnit = this.options.timeUnit;

    /** Attributs des voies */
    this.waysAttributes = this.options.waysAttributes;
}

/**
 * CLASSNAME
 */
RouteParamREST.CLASSNAME = "RouteParamREST";

RouteParamREST.prototype = {

    /**
     * @lends module:RouteParamREST#
     */

    /**
     * Constructeur (alias)
     */
    constructor : RouteParamREST,

    /**
     * Retourne une liste de points
     * @returns {String} une liste de points (sep '|')
     */
    getIntermediates : function () {
        var array = [];
        if (this.intermediates.length !== 0) {
            for (var i = 0; i < this.intermediates.length; i++) {
                var obj = this.intermediates[i];
                array.push(obj.x + "," + obj.y);
            }
        }

        return array.join("|");
    },

    /**
     * Retourne une liste d'attributs
     * @returns {String} une liste d'attributs (sep '|')
     */
    getWaysAttributes : function () {
        return this.waysAttributes.join("|");
    },

    /**
     * Retourne un profile
     * @returns {String} profile
     */
    getProfile : function () {
        return this.profile;
    },

    /**
     * Retourne un distanceUnit
     * @returns {String} distanceUnit
     */
    getDistanceUnit : function () {
        if (this.distanceUnit === "m") {
            return "meter";
        }
        if (this.distanceUnit === "km") {
            return "kilometer";
        }
        return "";
    },

    /**
     * Retourne une optimisation
     * @returns {String} optimization
     */
    getOptimization : function () {
        if (this.optimization) {
            return this.optimization;
        } else {
            return "";
        }
    },

    /**
     * Retourne la liste des constraints
     * @returns {String} une liste des constraints (sep '|')
     */
    getConstraints : function () {
        var constraintArray = [];

        if (this.constraints.length !== 0) {
            for (var k = 0; k < this.constraints.length; k++) {
                constraintArray.push(JSON.stringify(this.constraints[k]));
            }
        }
        return constraintArray.join("|");
    }
};

/**
 * Tableau de clefs/valeurs pour param.
 *
 * @returns {Array} liste de paramêtres
 */
RouteParamREST.prototype.getParams = function () {
    var map = [];

    map.push({
        k : "resource",
        v : this.resource
    });

    map.push({
        k : "start",
        v : this.start
    });

    map.push({
        k : "end",
        v : this.end
    });

    map.push({
        k : "geometryFormat",
        v : "geojson"
    });

    if (this.optimization) {
        map.push({
            k : "optimization",
            v : this.getOptimization()
        });
    }

    if (this.intermediates) {
        map.push({
            k : "intermediates",
            v : this.getIntermediates()
        });
    }

    if (this.profile) {
        map.push({
            k : "profile",
            v : this.getProfile()
        });
    }

    if (this.constraints) {
        map.push({
            k : "constraints",
            v : this.getConstraints()
        });
    }

    if (this.crs) {
        map.push({
            k : "crs",
            v : this.crs
        });
    }

    if (this.distanceUnit) {
        map.push({
            k : "distanceUnit",
            v : this.getDistanceUnit()
        });
    }

    if (this.timeUnit) {
        map.push({
            k : "timeUnit",
            v : this.timeUnit
        });
    }

    if (this.waysAttributes) {
        map.push({
            k : "waysAttributes",
            v : this.getWaysAttributes()
        });
    }

    return map;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RouteParamREST);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Route/Response/RouteResponseFactory.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Route/Response/RouteResponseFactory.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Utils/MessagesResources */ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js");
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../Exceptions/ErrorService */ "./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js");
/* harmony import */ var _model_RouteResponse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model/RouteResponse */ "./node_modules/geoportal-access-lib/src/Services/Route/Response/model/RouteResponse.js");
/* harmony import */ var _model_RouteInstruction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./model/RouteInstruction */ "./node_modules/geoportal-access-lib/src/Services/Route/Response/model/RouteInstruction.js");






/**
 * Factory pour générer une reponse JSON à partir d'un XML ou d'un JSON
 * (Factory)
 *
 * @module RouteResponseFactory
 * @alias Gp.Services.Route.Response.RouteResponseFactory
 * @private
 */
var RouteResponseFactory = {

    /**
     * interface unique
     *
     * @method build
     * @static
     * @param {Object} options - options definies dans le composant Route
     *
     * @example
     *   var options = {
     *      response :
     *      outputFormat :
     *      rawResponse :
     *      scope :
     *      onSuccess :
     *      onError :
     *   };
     *
     */
    build : function (options) {
        // logger
        var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("RouteResponseFactory");
        logger.trace("RouteResponseFactory::build()");

        var data = null;

        if (options.response) {
            if (options.rawResponse) {
                logger.trace("analyze response : raw");
                data = options.response;
            } else {
                logger.trace("analyze response : json");

                var JSONResponse;
                if (typeof options.response === "string") {
                    JSONResponse = JSON.parse(options.response);
                } else {
                    JSONResponse = options.response;
                }

                // construction de l'objet réponse JSON
                if (JSONResponse) {
                    // le service renvoie t il une erreur ?
                    if (JSONResponse.message) {
                        // ex. {"message":"message not null", "status":"ERROR"}
                        options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION", JSONResponse.message)));
                        return;
                    }
                    var legs = [];
                    var legSteps = [];
                    var steps = [];

                    data = new _model_RouteResponse__WEBPACK_IMPORTED_MODULE_3__["default"]();

                    if (data.hasOwnProperty("totalTime")) {
                        data.totalTime = parseFloat(JSONResponse.duration);
                    }
                    if (data.hasOwnProperty("totalDistance")) {
                        data.totalDistance = parseFloat(JSONResponse.distance);
                    }

                    if (data.hasOwnProperty("bbox")) {
                        data.bbox.left = parseFloat(JSONResponse.bbox[0]);
                        data.bbox.bottom = parseFloat(JSONResponse.bbox[1]);
                        data.bbox.right = parseFloat(JSONResponse.bbox[2]);
                        data.bbox.top = parseFloat(JSONResponse.bbox[3]);
                    }

                    if (data.hasOwnProperty("routeGeometry") && !options.geometryInInstructions) {
                        data.routeGeometry = JSONResponse.geometry;
                    }

                    if (data.hasOwnProperty("routeInstructions") && options.geometryInInstructions) {
                        var legList = JSONResponse.portions;
                        var i;
                        if (Array.isArray(legList) && legList.length) {
                            for (i = 0; i < legList.length; i++) {
                                legs.push(legList[i]);
                            }
                        }
                        if (legs.length) {
                            for (i = 0; i < legs.length; i++) {
                                legSteps.push(legs[i].steps);
                            }
                        }
                        if (legSteps.length) {
                            for (i = 0; i < legSteps.length; i++) {
                                steps = steps.concat(legSteps[i]);
                            }
                        }

                        steps.forEach(function (step) {
                            data.routeInstructions.push(new _model_RouteInstruction__WEBPACK_IMPORTED_MODULE_4__["default"]());
                            data.routeInstructions[data.routeInstructions.length - 1].duration = step.duration;
                            data.routeInstructions[data.routeInstructions.length - 1].distance = step.distance;
                            data.routeInstructions[data.routeInstructions.length - 1].code = "";
                            data.routeInstructions[data.routeInstructions.length - 1].instruction = "";
                            data.routeInstructions[data.routeInstructions.length - 1].geometry = step.geometry;

                            // on ne souhaite pas de ce type de valeur...
                            if (step.name === "Valeur non renseignée") {
                                step.name = "";
                            }

                            switch (step.instruction.type) {
                                case "turn":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Tourner";
                                    break;
                                case "new name":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Continuer tout droit";
                                    break;
                                case "depart":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Départ";
                                    break;
                                case "arrive":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Arrivée";
                                    break;
                                case "merge":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Rejoindre";
                                    break;
                                case "ramp":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Prendre la bretelle";
                                    break;
                                case "on ramp":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Prendre la bretelle";
                                    break;
                                case "off ramp":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Prendre la sortie";
                                    break;
                                case "fork":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Sur la bifurcation, prendre";
                                    break;
                                case "end of road":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "À la fin de la route, prendre";
                                    break;
                                case "use lane":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Utiliser la file";
                                    break;
                                case "continue":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Continuer";
                                    break;
                                case "roundabout":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Au rond-point";
                                    break;
                                case "rotary":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Au rond-point";
                                    break;
                                case "roundabout turn":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "Au rond point, tourner";
                                    break;
                                case "notification":
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "";
                                    break;
                                default:
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += "?" + step.instruction.type + "?";
                                    break;
                            }

                            if (step.instruction.modifier) {
                                switch (step.instruction.modifier) {
                                    case "uturn":
                                        data.routeInstructions[data.routeInstructions.length - 1].instruction = "Faire demi-tour";
                                        break;
                                    case "sharp right":
                                        data.routeInstructions[data.routeInstructions.length - 1].instruction += " complètement à droite";
                                        break;
                                    case "right":
                                        data.routeInstructions[data.routeInstructions.length - 1].instruction += " à droite";
                                        break;
                                    case "slight right":
                                        data.routeInstructions[data.routeInstructions.length - 1].instruction += " légèrement à droite";
                                        break;
                                    case "straight":
                                        data.routeInstructions[data.routeInstructions.length - 1].instruction = "Continuer tout droit";
                                        break;
                                    case "slight left":
                                        data.routeInstructions[data.routeInstructions.length - 1].instruction += " lègèrement à gauche";
                                        break;
                                    case "left":
                                        data.routeInstructions[data.routeInstructions.length - 1].instruction += " à gauche";
                                        break;
                                    case "sharp left":
                                        data.routeInstructions[data.routeInstructions.length - 1].instruction += " complètement à gauche";
                                        break;
                                    default:
                                        data.routeInstructions[data.routeInstructions.length - 1].instruction += " ?" + step.instruction.modifier + "?";
                                        break;
                                }
                            }

                            if (step.instruction.exit) {
                                data.routeInstructions[data.routeInstructions.length - 1].instruction += `${step.instruction.exit}e sortie`;
                            }

                            if (step.attributes.name) {
                                if (step.attributes.name.nom_1_droite || step.attributes.name.toponyme) {
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += " sur";
                                }

                                if (step.attributes.name.nom_1_droite) {
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += ` ${step.attributes.name.nom_1_droite}`;
                                }

                                if (step.attributes.name.toponyme) {
                                    data.routeInstructions[data.routeInstructions.length - 1].instruction += ` ${step.attributes.name.toponyme}`;
                                }
                            }
                        });
                    }
                }

                if (!data) {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_ANALYSE", "json")));
                    return;
                }

                // Si la réponse contenait une exception renvoyée par le service
                if (data.exceptionReport) {
                    options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EXCEPTION_2")));
                    return;
                }
            }
        } else {
            options.onError.call(options.scope, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
            return;
        }

        options.onSuccess.call(options.scope, data);
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RouteResponseFactory);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Route/Response/model/RouteInstruction.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Route/Response/model/RouteInstruction.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });

/**
 * Single Route Instruction object.
 *
 * @property {String} code - Instruction code :
 *
 * - "F" : Straight forward
 * - "B" : U-turn
 * - "L" : turn left
 * - "R" : turn right
 * - "BL" : turn left strongly
 * - "BR" : turn right strongly
 * - "FL" : turn lightly to the left
 * - "FR" : turn lightly to the right
 * - "round_about_entry" : round about entry
 * - "round_about_exit" : round about exit
 *
 * @property {String} instruction - Instruction text : translated code + street name
 * @property {Object} geometry - Geometry (expressed in [GeoJSON]{@link http://geojson.org/}) of the street.
 * @property {Float} distance - Length of the instruction. Expressed in km or m, depending on distanceUnit parameter.
 * @property {Float} duration - Instruction duration in seconds.
 *
 * @namespace
 * @alias Gp.Services.Route.RouteInstruction
 */
function RouteInstruction () {
    if (!(this instanceof RouteInstruction)) {
        throw new TypeError("RouteInstruction constructor cannot be called as a function.");
    }

    this.duration = null;

    this.distance = null;

    this.code = null;

    this.instruction = null;

    this.geometry = null; // FIXME can be null if option 'geometryInInstructions' is false !
}

RouteInstruction.prototype = {

    constructor : RouteInstruction

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RouteInstruction);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Route/Response/model/RouteResponse.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Route/Response/model/RouteResponse.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Response object for {@link module:Services~route Gp.Services.route ()} invocation when successful. Received as the argument of onSuccess callback function.
 *
 * @property {Gp.BBox} bbox - Bounding Box of the route. Given when provideBBox parameter is used in function call.
 * @property {Object} routeGeometry - Geometry (expressed in [GeoJSON]{@link http://geojson.org/}) of the route.
 * @property {Array.<Gp.Services.Route.RouteInstruction>} routeInstructions - Instructions of the route.
 * @property {String} totalDistance - Length of the route. If distanceUnit parameter was set to "km" (default), totalDistance is a string containing the total distance expressed in kilometers, followed by " Km" (e.g. : "19.6 Km"). If distanceUnit parameter was set to "m", totalDistance is a string containing the total distance expressed in meters (e.g. : "19599.14").
 * @property {Float} totalTime - Route duration in seconds.
 *
 * @namespace
 * @alias Gp.Services.RouteResponse
 */
function RouteResponse () {
    if (!(this instanceof RouteResponse)) {
        throw new TypeError("RouteResponse constructor cannot be called as a function.");
    }

    this.totalTime = null;

    this.totalDistance = null;

    this.bbox = {
        left : null,
        right : null,
        top : null,
        bottom : null
    };

    this.routeGeometry = null; // FIXME can be null if option 'geometryInInstructions' is true !

    this.routeInstructions = [];
}

RouteResponse.prototype = {

    constructor : RouteResponse

};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RouteResponse);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Route/Route.js":
/*!***********************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Route/Route.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Utils/MessagesResources */ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js");
/* harmony import */ var _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Exceptions/ErrorService */ "./node_modules/geoportal-access-lib/src/Exceptions/ErrorService.js");
/* harmony import */ var _CommonService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../CommonService */ "./node_modules/geoportal-access-lib/src/Services/CommonService.js");
/* harmony import */ var _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../DefaultUrlService */ "./node_modules/geoportal-access-lib/src/Services/DefaultUrlService.js");
/* harmony import */ var _Request_RouteRequestFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Request/RouteRequestFactory */ "./node_modules/geoportal-access-lib/src/Services/Route/Request/RouteRequestFactory.js");
/* harmony import */ var _Response_RouteResponseFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Response/RouteResponseFactory */ "./node_modules/geoportal-access-lib/src/Services/Route/Response/RouteResponseFactory.js");









/**
 * @classdesc
 * Appel du service d'itinéraire du Géoportail :
 *     envoi de la requête construite selon les paramètres en options,
 *     éventuellement parsing et analyse  de la réponse,
 *     retour d'une réponse en paramètre de la fonction onSuccess.
 *
 * @alias Gp.Services.Route
 * @constructor
 * @extends {Gp.Services.CommonService}
 * @param {Object} options - options spécifiques au service (+ les options heritées)
 *
 * @param {String} options.resource - La ressource utilisée pour le calcul. Ce paramètre devrait être obligatoire car il l'est dans l'appel au service. Mais il ne l'est pas pour des raisons de rétrocompatibilité.
 *
 * @param {String} options.outputFormat - Le format de la réponse du service itineraire : 'json' uniquement et par défaut.
 *
 * @param {String} [options.routePreference = "fastest"] - Mode de calcul à utiliser :
 * - le plus rapide « fastest »
 * - le plus court « shortest »
 * Par défaut : « fastest ».
 *
 * @param {Object} options.startPoint - Point de départ du calcul. Coordonnées exprimées en longitudes, latitudes (EPSG:4326)
 * @param {Float} options.startPoint.x - Abcisse du point de départ du calcul d'itinéraire.
 * @param {Float} options.startPoint.y - Ordonnée du point de départ du calcul d'itinéraire.
 *
 * @param {Object} options.endPoint - Point d'arrivée du calcul. Coordonnées exprimées en longitudes, latitudes (EPSG:4326)
 * @param {Float} options.endPoint.x - Abcisse du point d'arrivée du calcul d'itinéraire.
 * @param {Float} options.endPoint.y - Ordonnée du point d'arrivée du calcul d'itinéraire.
 *
 * @param {Object[]} [options.viaPoints] - Liste de point ({x:Float,y:Float}) intermédaires que l'itinéraire doit emprunter dans l'ordre du tableau.
 *      Coordonnées exprimées en longitudes, latitudes (EPSG:4326) :{x:float, y:float}
 *
 * @param {String} [options.graph = "voiture"] - Type de graphe utilisé : "Voiture" ou "Pieton".
 *      Détermine le profil de vitesses utilisé pour le calcul ainsi que les tronçons autorisés ou non.
 *      Par défaut, c'est la valeur "Voiture" qui sera utilisée.
 *
 * @param {String[]} [options.exclusions] - DEPRECATED: Critères d'exclusions à appliquer pour le calcul. (correspond au paramètre "avoidFeature" d'OpenLS)
 *      On précise ici le type de tronçons que l'on ne veut pas que l'itinéraire emprunte
 *      (valeurs possibles : « toll » (éviter les péages), « bridge », « tunnel »).
 *      Ce paramètre est conservé pour une rétrocompatibilité de l'api. Le nouveau paramètre à utiliser est options.constraints
 *
 * @param {Object[]} [options.constraints] - Critères de contraintes à appliquer sur un itinéraire. Les valeurs disponibles dépendent de la ressource utilisée. Il est donc utile de regarder le getCapabilities.
 * @param {String} [options.constraints.constraintType] - Type de la contrainte. Généralement "banned".
 * @param {String} [options.constraints.key] - Clé de la contrainte. Généralement "wayType".
 * @param {String} [options.constraints.operator] - Opérateur de la contrainte. Généralement "=".
 * @param {String} [options.constraints.value] - Valeur de la contrainte. Généralement "autoroute".
 *
 * @param {Boolean} [options.geometryInInstructions = false] - Indique si la géométrie de l'itinéraire doit être reprise morceau par morceau dans les instructions.
 *      (correspond au paramètre "provideGeometry" d'OpenLS) Par défaut : false.
 *
 * @param {Boolean} [options.provideBbox = true] - Indique si les instructions doivent être localisées par une bbox dans la réponse.
 *      Par défaut : true.
 *
 * @param {String} [options.distanceUnit = "m"] - Indique si la distance doit être exprimée en km ou m dans la réponse.
 *      Par défaut : m.
 * @param {String} [options.timeUnit = "second"] - Indique si la durée doit être exprimée en seconde, minute ou heure dans la réponse. Il peut-être formatté hh:mm::ss avec la valeur standard.
 *      Les valeurs possibles sont "standard", "second", "minute" ou "hour".
 *      Par défaut : "standard".
 *
 * @param {String} [options.srs] - Système de coordonnées dans lequel les paramètres géographiques en entrée et la réponse du service sont exprimés.
 *      Pas de valeur par défaut. Si le serveur consulté est celui du Géoportail, la valeur par défaut sera donc celle du service : 'EPSG:4326'.
 *
 * @param {String[]} [options.waysAttributes] - Nom des attributs des voies. Les valeurs disponibles dépendent de la ressource utilisée. Il est donc utile de regarder le getCapabilities.
 *
 * @example
 *  var options = {
 *      // options communes aux services
 *      apiKey : null,
 *      serverUrl : 'http://localhost/service/',
 *      protocol : 'XHR',
 *      proxyURL : null,
 *      httpMethod : 'GET', // GET|POST
 *      timeOut : 10000, // ms
 *      rawResponse : false, // true|false
 *      scope : null, // this
 *      onSuccess : function (response) {},
 *      onFailure : function (error) {},
 *      // spécifique au service
 *      resource : 'bdtopo'
 *      outputFormat : 'json',
 *      startPoint : {
 *          x : 42.1121,
 *          y : 1.5557
 *      },
 *      endPoint : {
 *          x : 42.1121,
 *          y : 1.5557
 *      },
 *      provideBbox : true,
 *      exclusions : ["Bridge", "Tunnel", "Toll"],
 *      distanceUnit : "km",
 *      graph : "Voiture",
 *      geometryInInstructions : true,
 *      routePreference : "fastest"
 *  };
 *
 */
function Route (options) {
    if (!(this instanceof Route)) {
        throw new TypeError(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("CLASS_CONSTRUCTOR", "Route"));
    }

    /**
     * Nom de la classe (heritage)
     */
    this.CLASSNAME = "Route";

    // appel du constructeur par heritage
    _CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].apply(this, arguments);

    this.logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_0__["default"].getLogger("Gp.Services.Route");
    this.logger.trace("[Constructeur Route (options)]");

    if (!options.startPoint) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "startPoint"));
    }

    // on lance une exception afin d'eviter au service de le faire...
    if (options.startPoint.x === null) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "startPoint.x"));
    }

    if (options.startPoint.y === null) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "startPoint.y"));
    }

    if (!options.endPoint) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "endPoint"));
    }

    // on lance une exception afin d'eviter au service de le faire...
    if (options.endPoint.x === null) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "endPoint.x"));
    }

    if (options.endPoint.y === null) {
        throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_MISSING", "endPoint.y"));
    }

    // options par defaut

    // on passe l'option outputFormat en minuscules afin d'éviter des exceptions.
    if (options.outputFormat && options.outputFormat !== "json") {
        this.logger.warn("options.outputFormat could only be json");
    }
    this.options.outputFormat = "json";

    this.options.resource = options.resource || "bdtopo-osrm";
    this.options.startPoint = options.startPoint;
    this.options.endPoint = options.endPoint;
    this.options.viaPoints = options.viaPoints || [];
    this.options.routePreference = options.routePreference || "fastest";
    /** Gestion des anciennes valeurs de graph */
    if (options.graph) {
        if (options.graph === "Voiture") {
            this.options.graph = "car";
        }
        if (options.graph === "Pieton") {
            this.options.graph = "pedestrian";
        }
    } else {
        this.options.graph = "car";
    }
    this.options.constraints = [];
    if (options.constraints) {
        if (Array.isArray(options.constraints)) {
            for (var k = 0; k < options.constraints.length; k++) {
                this.options.constraints.push(options.constraints[k]);
            }
        } else {
            throw new Error(_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("PARAM_TYPE", "constraints"));
        }
    }

    /** Gestion de l'ancien paramètre exclusion */
    var constraintTunnel = {};
    var constraintPont = {};
    var constraintAutoroute = {};
    if (options.exclusions) {
        if (options.exclusions.length !== 0) {
            this.logger.warn("options.exclusions is DEPRECATED !!");
            for (var c = 0; c < options.exclusions.length; c++) {
                if (typeof options.exclusions[c] === "string") {
                    options.exclusions[c] = options.exclusions[c].toLowerCase();
                } else {
                    // on ne crée pas une erreur pour rétro-compatibilité avec les anciennes versions
                    continue;
                }
                if (options.exclusions[c] === "toll") {
                    constraintAutoroute.constraintType = "banned";
                    constraintAutoroute.key = "wayType";
                    constraintAutoroute.operator = "=";
                    constraintAutoroute.value = "autoroute";
                    this.options.constraints.push(constraintAutoroute);
                }
                if (options.exclusions[c] === "tunnel") {
                    constraintTunnel.constraintType = "banned";
                    constraintTunnel.key = "wayType";
                    constraintTunnel.operator = "=";
                    constraintTunnel.value = "tunnel";
                    this.options.constraints.push(constraintTunnel);
                }
                if (options.exclusions[c] === "bridge") {
                    constraintPont.constraintType = "banned";
                    constraintPont.key = "wayType";
                    constraintPont.operator = "=";
                    constraintPont.value = "pont";
                    this.options.constraints.push(constraintPont);
                }
            }
        }
    }

    this.options.geometryInInstructions = options.geometryInInstructions || false;
    this.options.provideBbox = options.provideBbox || true;
    this.options.distanceUnit = options.distanceUnit || "m";
    this.options.timeUnit = options.timeUnit || "second";
    this.options.expectedStartTime = null; // FIXME not yet implemented !
    this.options.srs = options.srs || "EPSG:4326";
    this.options.waysAttributes = options.waysAttributes || [];

    // gestion de l'url du service par defaut
    // si l'url n'est pas renseignée, il faut utiliser les urls par defaut
    if (!this.options.serverUrl) {
        var UrlByDefault = _DefaultUrlService__WEBPACK_IMPORTED_MODULE_4__["default"].Route.newUrl();

        if (!UrlByDefault) {
            throw new Error("Url by default not found !");
        }
        this.options.serverUrl = UrlByDefault;
        this.logger.trace("Serveur URL par defaut : " + this.options.serverUrl);
    }
}

/**
 * @lends module:Route#
 */
Route.prototype = Object.create(_CommonService__WEBPACK_IMPORTED_MODULE_3__["default"].prototype, {
    // todo
    // getter/setter
});

/*
 * Constructeur (alias)
 */
Route.prototype.constructor = Route;

/**
 * (overwrite)
 * Création de la requête
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
Route.prototype.buildRequest = function (error, success) {
    var options = {
        // spécifique au service
        resource : this.options.resource,
        startPoint : this.options.startPoint,
        endPoint : this.options.endPoint,
        viaPoints : this.options.viaPoints,
        provideBbox : this.options.provideBbox,
        constraints : this.options.constraints,
        distanceUnit : this.options.distanceUnit,
        timeUnit : this.options.timeUnit,
        graph : this.options.graph,
        geometryInInstructions : this.options.geometryInInstructions,
        routePreference : this.options.routePreference,
        srs : this.options.srs,
        waysAttributes : this.options.waysAttributes
    };

    this.request = _Request_RouteRequestFactory__WEBPACK_IMPORTED_MODULE_5__["default"].build(options);

    // on teste si la requete a bien été construite !
    if (!this.request) {
        error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_REQUEST_BUILD")));
    } else {
        success.call(this, this.request);
    }
};

/**
 * (overwrite)
 * Analyse de la reponse
 *
 * @param {Function} error   - callback des erreurs
 * @param {Function} success - callback
 */
Route.prototype.analyzeResponse = function (error, success) {
    // INFO
    // Factory pour masquer la complexité du retour du service

    if (this.response) {
        var options = {
            distanceUnit : this.options.distanceUnit,
            timeUnit : this.options.timeUnit,
            response : this.response,
            outputFormat : this.options.outputFormat, // utile pour parser la string en mode XHR : JSON ou XML !
            rawResponse : this.options.rawResponse,
            onError : error,
            onSuccess : success,
            scope : this,
            geometryInInstructions : this.options.geometryInInstructions
        };

        _Response_RouteResponseFactory__WEBPACK_IMPORTED_MODULE_6__["default"].build(options);
    } else {
        error.call(this, new _Exceptions_ErrorService__WEBPACK_IMPORTED_MODULE_2__["default"](_Utils_MessagesResources__WEBPACK_IMPORTED_MODULE_1__["default"].getMessage("SERVICE_RESPONSE_EMPTY")));
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Route);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Services/Services.js":
/*!********************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Services/Services.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Config_Config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Config/Config */ "./node_modules/geoportal-access-lib/src/Services/Config/Config.js");
/* harmony import */ var _Alti_Alti__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Alti/Alti */ "./node_modules/geoportal-access-lib/src/Services/Alti/Alti.js");
/* harmony import */ var _Geocode_Geocode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Geocode/Geocode */ "./node_modules/geoportal-access-lib/src/Services/Geocode/Geocode.js");
/* harmony import */ var _Geocode_ReverseGeocode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Geocode/ReverseGeocode */ "./node_modules/geoportal-access-lib/src/Services/Geocode/ReverseGeocode.js");
/* harmony import */ var _AutoComplete_AutoComplete__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AutoComplete/AutoComplete */ "./node_modules/geoportal-access-lib/src/Services/AutoComplete/AutoComplete.js");
/* harmony import */ var _Route_Route__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Route/Route */ "./node_modules/geoportal-access-lib/src/Services/Route/Route.js");
/* harmony import */ var _ProcessIsoCurve_ProcessIsoCurve__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ProcessIsoCurve/ProcessIsoCurve */ "./node_modules/geoportal-access-lib/src/Services/ProcessIsoCurve/ProcessIsoCurve.js");
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "point|circle|bbox" }] */

/**
* Geoportal web services invocation namespace.
*
* @module Services
* @alias Gp.Services
*/








var Services = {
    /**
     * Access to Geoportal resources metadata availables with one ore several keys
     *
     * @method getConfig
     * @param {Object} options - Options for function call.
     * @param {String} [options.apiKey] - Access key(s) ("," as separator, no spaces) to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}
     * @param {String} [options.customConfigFile] - path to a local config file. Overload the apiKey parameter
     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.GetConfigResponse} object as a parameter except if "rawResponse" parameter is set to true : a String will be returned.
     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
     */
    getConfig : function (options) {
        var configService = new _Config_Config__WEBPACK_IMPORTED_MODULE_0__["default"](options);
        configService.call();
    },
    /**
     * Getting elevations in or along of one or several points on french territories using the [elevation services of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/alti.html}.<br/>
     * Two use cases are availables :<br/>
     * 1. getting elevations of the given points : don't use the options.sampling parameter ;<br/>
     * 2. getting a regular set of elevations along the given points : use the options.sampling parameter.
     *
     * @method getAltitude
     * @param {Object} options - Options for function call.
     * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}.
     * @param {Array.<Object>} options.positions - Array of positions ({lon:float, lat:float}) expressed in CRS:84 coordinates system, where to get elevations. 50 positions maximum may be given. 2 positions minimum are required if you use the options.sampling parameter.
     * @param {Number} [options.sampling] - Number of points to use (between 2 and 5000) in order to compute an elevation path. The points given with the options.positions parameter are used to fix the planimetric path along which the elevations will be computed.<br/>
     * If not used, only elevations of these positions will be returned.
     * @param {Boolean} [options.zonly=false] - Set this parameter to true if you only want to have elevations returned without corresponding coordinates.
     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.AltiResponse} object as a parameter, except if "rawResponse" is set to true.
     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
     * @param {String} [options.serverUrl=https://data.geopf.fr/altimetrie/1.0/calcul/alti/rest/elevation.json] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.
     * @param {Boolean} [options.ssl = true] - Use of HTTPS or HTTP protocol to request the services. HTTPS by default (ssl=true).
     * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.
     * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.
     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.
     * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {String} [options.contentType="application/xml"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.
     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Only use if you know what you are doing.
     * @param {String} [options.api='REST'] - What API to use for interacting with underlying web service : 'REST'. Only use if you know what you are doing.
     * @param {String} [options.outputFormat='xml'] - Output format for underlying web service response : 'xml' or 'json'. Only use if you know what you are doing.
     */
    getAltitude : function (options) {
        var altiService = new _Alti_Alti__WEBPACK_IMPORTED_MODULE_1__["default"](options);
        altiService.call();
    },
    /**
     * Getting positon of a geographic identifier (places names, address, cadastral parcel, other...) using the [geocoding web service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/geocodage.html}.
     *
     * @example
     * Gp.Services.geocode ({
     *     apiKey : "carte",
     *     location : "73 avenue de Paris, Saint-Mandé",
     *     // traitement des resultats
     *     onSuccess  : function (result) {
     *         console.log("found (x:"+result.position.x+", y:"+result.position.y+")") ;
     *     }
     * }) ;
     *
     *
     * @method geocode
     * @param {Object} options - Options for function call.
     * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}.
     * @param {String} [options.index="StreetAddress"] - Geographical identifier type to search. Values currently availables are : "PositionOfInterest" for place names, "StreetAddress" for address search, "CadastralParcel" for Cadastral parcels search, "location" for a multi-index search on "StreetAddress" and "PositionOfInterest". Default is "StreetAddress".
     * @param {String} options.query - Geographic identifier to locate.
     * @param {Object} [options.filters] - Additional filters to apply to search. The following properties may be given.
     *      @param {String} [options.filters.[prop]] - Additionnal properties to filter search. Properties depends on options.index, and values type should be "String".
     *      <br/><br/>
     *      Properties availables for address search :<br/>
     *      "postalCode", "inseeCode" and "city".
     *      <br/><br/>
     *      Properties availables for place names search :<br/>
     *      "postalCode", "inseeCode" and "type".
     *      <br/><br/>
     *      Properties availables for cadastral parcels search :<br/>
     *      "codeDepartement", "codeCommune", "nomCommune", "codeCommuneAbs", "codeArrondissement", "section", "numero", "feuille".
     * @param {Number} [options.maximumResponses=20] - Maximum number of responses. Default underlying service value applies (20) if not provided.
     * @param {Boolean} [options.returnTrueGeometry=false] - Set this parameter to true if you wish to have the true geometrie returned.
     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.GeocodeResponse} object as a parameter except if "rawResponse" is set to true.
     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
     * @param {String} [options.serverUrl=http (s)://data.geopf.fr/geocodage/search] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.
     * @param {Boolean} [options.ssl = true] - Use of HTTPS or HTTP protocol to request the services. HTTPS by default (ssl=true).
     * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.
     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.
     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.
     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Only use if you know what you are doing.
     */
    geocode : function (options) {
        var geocodeService = new _Geocode_Geocode__WEBPACK_IMPORTED_MODULE_2__["default"](options);
        geocodeService.call();
    },
    /**
     * Retrieving geographical identifiers (place names, address, cadastral parcels, ...) near a given position, using the [reverse geocoding web service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/geocodage-inverse.html}.
     *
     * @method reverseGeocode
     * @param {Object} options - Options for function call.
     * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}.
     * @param {String} [options.index="StreetAddress"] - Geographical identifier type to search. Values currently availables are : "PositionOfInterest" for place names, "StreetAddress" for address search, "CadastralParcel" for Cadastral parcels search, "location" for a multi-index search on "StreetAddress" and "PositionOfInterest". Default is "StreetAddress".
     * @param {Object} options.position - Reference position where to search geographical identifiers.
     *      @param {Float} options.position.lon - Longitude
     *      @param {Float} options.position.lat - Latitude
     * @param {Object} [options.filters] - Additional filters to apply to search. The following properties may be given.
     *      @param {String} [options.filters.[prop]] - Additionnal properties to filter search. Properties depends on options.index, and values type should be "String".
     *      <br/><br/>
     *      Properties availables for address search :<br/>
     *      "postalCode", "inseeCode" and "city".
     *      <br/><br/>
     *      Properties availables for place names search :<br/>
     *      "postalCode", "inseeCode" and "type".
     *      <br/><br/>
     *      Properties availables for cadastral parcels search :<br/>
     *      "codeDepartement", "codeCommune", "nomCommune", "codeCommuneAbs", "codeArrondissement", "section", "numero", "feuille".
     * @param {Object} [options.searchGeometry] - Location where to perform the search.
     *      @param {String} options.searchGeometry.type - Geometry type (Point|Circle|Linestring|Polygon)
     *      @param {Array.<Float>|Array.Array.<Float>} options.searchGeometry.coordinates - Coordinates
     *      @param {Float} [options.searchGeometry.radius] - Radius (only for type 'Circle')
     * @param {Number} [options.maximumResponses=20] - Maximum number of responses. Default underlying service value applies (20) if not provided.
     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.GeocodeResponse} object as a parameter except if "rawResponse" is set to true.
     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
     * @param {String} [options.serverUrl=https://data.geopf.fr/geocodage/reverse] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.
     * @param {Boolean} [options.ssl = true] - Use of HTTPS or HTTP protocol to request the services. HTTPS by default (ssl=true).
     * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.
     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.
     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.
     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Only use if you know what you are doing.
     */
    reverseGeocode : function (options) {
        var reverseGeocodeService = new _Geocode_ReverseGeocode__WEBPACK_IMPORTED_MODULE_3__["default"](options);
        reverseGeocodeService.call();
    },
    /**
     * Getting suggestions of probable places names or address based on uncomplete texts, using the [autocompletion service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/autocompletion.html}
     *
     * @method autoComplete
     * @param {Object} options - Options for function call.
     * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}.
     * @param {String} options.text - Text input to complete.
     * @param {Array.<String>} [options.filterOptions.type = "StreetAddress"] - Suggestion types to provide : address ("StreetAddress") and/or place name ("PositionOfInterest").
     * @param {Array.<String>} [options.filterOptions.territory] - Places where to limit the search of suggestions : "METROPOLE" (Corsica and metropolitan France), "DOMTOM" (French overseas departments and territories), or an INSEE code of a department. No limitation by default. For instance : ['METROPOLE', '31']
     * @param {Number} [options.maximumResponses = 10] - Maximum number of responses.
     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.AutoCompleteResponse} object as a parameter except if "rawResponse" is set to true.
     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
     * @param {String} [options.serverUrl=https://data.geopf.fr/geocodage/completion] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.
     * @param {Boolean} [options.ssl = true] - Use of HTTPS or HTTP protocol to request the services. HTTPS by default (ssl=true).
     * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.
     * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.
     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.
     * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {String} [options.contentType="application/xml"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.
     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Only use if you know what you are doing.
     */
    autoComplete : function (options) {
        var autoCompleteService = new _AutoComplete_AutoComplete__WEBPACK_IMPORTED_MODULE_4__["default"](options);
        autoCompleteService.call();
    },
    /**
     * Getting a route from one point to another using the [route service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/itineraires.html}.
     *
     * @method route
     * @param {Object} options - Options for function call.
     * @param {String} options.resource - Resource used to compute the route. Available values are in the GetCapabilities.
     * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}.
     * @param {String} [options.routePreference = "fastest"] - Indicates the way to compute the route : "fastest" (time optimisation) or "shortest" (distance optimisation). Available values are in the GetCapabilities.
     * @param {Gp.Point} options.startPoint - Start point of the route. Expressed in CRS:84 coordinates system (startPoint.x corresponds to longitude, startPoint.y corresponds to latitude). Available bbox are in the GetCapabilities.
     * @param {Gp.Point} options.endPoint - End point of the route. Expressed in CRS:84 coordinates system (endPoint.x corresponds to longitude, endPoint.y corresponds to latitude). Available bbox are in the GetCapabilities.
     * @param {Array.<Gp.Point>} [options.viaPoints] - Ordered via Points of the route. Expressed in CRS:84 coordinates system (viaPoints[i].x corresponds to longitude, viaPoints[i].y corresponds to latitude). Available bbox are in the GetCapabilities.
     * @param {String} [options.graph = "Voiture"] - User profile to use to compute the route : "Voiture" (using a vehicule) or "Pieton" (pedestrian). Has an influence on the kind of roads the route may use and the average speed. Available bbox are in the GetCapabilities.
     * @param {Array.<String>} [options.exclusions] - DEPRECATED: use options.constraints. Indicates if route has to avoid some features ("toll", "bridge" or "tunnel").
     * @param {Boolean} [options.geometryInInstructions = false] - Indicates if route geometry has to be also returned with route instructions.
     * @param {Boolean} [options.provideBoundingBox = true] - Indicates if route instructions has to be localised with a BBOX in the response.
     * @param {String} [options.distanceUnit = "m"] - The unit used to provide distances in the response ("meter" or "kilometer").
     * @param {String} [options.timeUnit = "second"] - The unit used to provide duration in the response ("standard", "second", "minute", "hour").
     * @param {Array.<String>} [options.waysAttributes] - Way Attributes to add in the response. Available values are in the GetCapabilities.
     * @param {Array.<Object>} [options.constraints] - Constraints used ({'constraintType':'banned','key':'ways_type','operator':'=','value':'autoroute'}). Available values are in the GetCapabilities.
     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.RouteResponse} object as a parameter except if "rawResponse" is set to true.
     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
     * @param {String} [options.outputFormat='json'] - Output format ("json" or "xml") to use for underlying webService. Only use if you know what you are doing.
     * @param {String} [options.serverUrl=https://data.geopf.fr/navigation/itineraire] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.
     * @param {Boolean} [options.ssl = true] - Use of HTTPS or HTTP protocol to request the services. HTTPS by default (ssl=true).
     * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.
     * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.
     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.
     * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {String} [options.contentType="application/xml"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.
     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Only use if you know what you are doing.
     */
    route : function (options) {
        var routeService = new _Route_Route__WEBPACK_IMPORTED_MODULE_5__["default"](options);
        routeService.call();
    },
    /**
     * Computing a set of places (curve) reachable from a given point (or from where to start to reach a given point) within a time or distance constraint using the [isochrone service of the Geoportal Platform]{@link https://geoservices.ign.fr/documentation/geoservices/isochrones.html}.
     *
     * @method isoCurve
     * @param {Object} options - Options for function call.
     * @param {String} options.apiKey - Access key to Geoportal platform, obtained [here]{@link https://geoservices.ign.fr/services-web}.
     * @param {String} options.resource - Resource used to compute the route. Available values are in the GetCapabilities.
     * @param {Gp.Point} options.position - Start or Arrival (options.reverse===true) Point for the computing. Expressed in CRS:84 coordinates system (position.x corresponds to longitude, position.y corresponds to latitude).
     * @param {String} [options.graph = "Voiture"] - User profile to use to compute the isoCurve : "Voiture" (using a vehicule) or "Pieton" (pedestrian). Has an influence on the kind of roads to use and the average speed. Available values are in the GetCapabilities.
     * @param {Array.<String>} [options.exclusions] - DEPRECATED: use options.constraints. Indicates if route has to avoid some features ("toll", "bridge" or "tunnel").
     * @param {Array.<Object>} [options.constraints] - Constraints used ({'constraintType':'banned','key':'ways_type','operator':'=','value':'autoroute'}). Available values are in the GetCapabilities.
     * @param {String} [options.method = "time"] - Computing method to use : "time" (using a duration as a constraint) or "distance" (using a distance as a constraint). Available values are in the GetCapabilities.
     * @param {Float} options.time - Maximum duration (expressed in seconds) to use when options.method is set to "time".
     * @param {Float} options.distance - Maximum distance (expressed in meters) to use when options.method is set to "distance".
     * @param {Boolean} [options.reverse = false] - Set this parameter to true if you want options.position to be the destination (instead of departure) for the computing.
     * @param {String} [options.distanceUnit = "km"] - The unit used to provide distances in the response ("m" or "km").
     * @param {String} [options.timeUnit = "second"] - The unit used to provide duration in the response ("standard", "second", "minute", "hour").
     * @param {Boolean} [options.smoothing = false] - DEPRECATED: Set this parameter to true if you want the resulting geometry to be smoothed.
     * @param {Boolean} [options.holes = false] - DEPRECATED: Set this parameter to true if you want the resulting geometry (polygon) to have holes if pertinent.
     * @param {Function} options.onSuccess - Callback function for getting successful service response. Takes a {@link Gp.Services.IsoCurveResponse} object as a parameter except if "rawResponse" is set to true.
     * @param {Function} [options.onFailure] - Callback function for handling unsuccessful service responses (timeOut, missing rights, ...). Takes a {@link Gp.Error} object as parameter.
     * @param {Number} [options.timeOut=0] - Number of milliseconds above which a timeOut response will be returned with onFailure callback (see above). Default value is 0 which means timeOut will not be handled.
     * @param {String} [options.outputFormat='json'] - Output format ("json") to use for underlying webService. Only use if you know what you are doing.
     * @param {String} [options.serverUrl=https://data.geopf.fr/navigation/isochrone] - Web service URL. If used, options.apiKey parameter is ignored. Only use if you know what you're doing.
     * @param {Boolean} [options.ssl = true] - Use of HTTPS or HTTP protocol to request the services. HTTPS by default (ssl=true).
     * @param {String} [options.protocol=XHR] - Protocol used to handle dialog with web service. Possible values are 'JSONP' ({@link https://en.wikipedia.org/wiki/JSONP}) and 'XHR' ({@link https://en.wikipedia.org/wiki/XMLHttpRequest}). Only XHR protocol is supported in a NodeJS environment. Only use if you know what you're doing.
     * @param {String} [options.proxyURL] - Proxy URL to use when requesting underlying web service. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you're doing.
     * @param {String} [options.callbackSuffix] - Callback function name suffix to use in case of a JSONP protocol use (see above), to set your own suffix instead of auto-increment. Ignored when options.protocol is set to 'XHR' value. Only use if you know what you're doing.
     * @param {String} [options.httpMethod=GET] - HTTP method to use when requesting underlying web service in case of a XHR protocol use (see above). Possible values are 'GET' and 'POST'. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {String} [options.contentType="application/xml"] - Content-Type to use when requesting underlying web service in case of a XHR protocol use (see above) and if method HTTP is POST. Ignored when options.protocol is set to 'JSONP' value. Only use if you know what you are doing.
     * @param {Boolean} [options.rawResponse=false] - Setting this parameter to true implies you want to handle the service response by yourself : it will be returned as an unparsed String in onSuccess callback parameter. Only use if you know what you are doing.
     * @param {Function} [options.onBeforeParse] - Callback function for handling service response before parsing (as an unparsed String). Takes a String as a parameter (the raw service response). Returns a String that will be parsed as the service response. Only use if you know what you are doing.
     */
    isoCurve : function (options) {
        var processIsoCurveService = new _ProcessIsoCurve_ProcessIsoCurve__WEBPACK_IMPORTED_MODULE_6__["default"](options);
        processIsoCurveService.call();
    }
};

/**
 * Point object.
 *
 * @namespace
 * @alias Gp.Point
 *
 * @property {Float} x - Point abscissa
 * @property {Float} y - Point ordinate
 */
var point = {};

/**
 * Circle object.
 *
 * @namespace
 * @alias Gp.Circle
 *
 * @property {Float} x - Circle center abscissa.
 * @property {Float} y - Circle center ordinate.
 * @property {Float} radius - Circle radius.
 */
var circle = {};

/**
 * Bounding box object, expressed with four coordinates.
 *
 * @namespace
 * @alias Gp.BBox
 *
 * @property {Float} left - minimum abscissa
 * @property {Float} right - maximum abscissa
 * @property {Float} bottom - minimum ordinate
 * @property {Float} top - maximum ordinate
 */
var bbox = {};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Services);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Utils/Helper.js":
/*!***************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Utils/Helper.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Classe utilitaire
 *
 * @module Helper
 * @alias Gp.Helper
 */
var Helper = {

    /**
     * concatenation des parametres key/value dans les urls
     *
     * @method normalyzeParameters
     * @static
     * @param {Object} params - tableau de clef/valeur
     *
     * @example
     *  Gp.Utils.Helper.normalyzeParameters ({
     *         key1:value1,
     *         key2:value2,
     *         key3:value3
     *  });
     *  // out : "key1=value1&key2=value2&key3=value3"
     *
     * @returns {String} retourne les paramètres concaténés
     */
    normalyzeParameters : function (params) {
        var myParams = null;

        if (params) {
            var tabParams = [];
            for (var key in params) {
                if (params.hasOwnProperty(key)) {
                    var value = params[key];
                    if (!value) {
                        value = "";
                    }
                    tabParams.push(key + "=" + value);
                }
            }

            myParams = tabParams.join("&");
        }

        return myParams;
    },

    /**
     * Concaténation et encodage des urls.
     *
     * @method normalyzeUrl
     * @static
     * @param {String} url - url
     * @param {Object|String} params - tableau de clef/valeur ou string
     * @param {Boolean} encode - true|false, false par defaut
     *
     * @example
     *  Gp.Utils.Helper.normalyzeUrl (url, {
     *         key1:value1,
     *         key2=:value2,
     *         key3:value3
     *  });
     *  // out : "url?key1=value1&key2=value2&key3=value3"
     *
     * @returns {String} retourne une url normalisée
     */
    normalyzeUrl : function (url, params, encode) {
        var myUrl = url;

        if (url) {
            var k = url.indexOf("?");
            if (k === -1) { // pas de ? et KVP
                myUrl += "?";
            }

            if (k !== -1 && k !== url.length - 1) { // KVP
                myUrl += "&";
            }
        }

        if (params) {
            if (typeof params === "string") {
                params = params.replace("?", "");
                myUrl += params;
            } else {
                myUrl += this.normalyzeParameters(params);
            }
        }

        if (encode) {
            // FIXME bonne idée ?
            myUrl = encodeURIComponent(myUrl);
        }

        return myUrl;
    },

    /**
     * Indentation d'une chaine
     *
     * @method indent
     * @static
     * @param {Number} n - nombre de tabulation
     * @param {String} msg - chaine
     *
     * @example
     * Gp.Utils.Helper.indent (2, "message à indenter")
     * // out
     * // ........message à indenter
     *
     * @returns {String} retourne une chaine indentée
     */
    indent : function (n, msg) {
        var num = n || 0;
        return new Array(num + 1).join("\t") + msg;
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Helper);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js":
/*!************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Utils/LoggerByDefault.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! loglevel */ "./node_modules/loglevel/lib/loglevel.js");
/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(loglevel__WEBPACK_IMPORTED_MODULE_0__);


var LoggerByDefault = {
    /**
     * logger statique
     *
     * @static
     * @param {String} name - nom du logger
     * @returns {Object} retourne un logger
     */
    getLogger : function (name) {
        // Substitute global constants configured at compile time
        // cf. webpack.config.js
        // on définit process si non défini dans l'environnement
        // eslint-disable-next-line no-use-before-define
        if (typeof process === "undefined") {
            var process = {};
            process.env = {
                VERBOSE : false
            };
        }
        (process.env.VERBOSE) ? loglevel__WEBPACK_IMPORTED_MODULE_0__.enableAll() : loglevel__WEBPACK_IMPORTED_MODULE_0__.disableAll();
        var logname = name || "default";
        return loglevel__WEBPACK_IMPORTED_MODULE_0__.getLogger(logname);
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LoggerByDefault);


/***/ }),

/***/ "./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js":
/*!**************************************************************************!*\
  !*** ./node_modules/geoportal-access-lib/src/Utils/MessagesResources.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Classe de gestion des erreurs qui permer d'associer un message d'erreur à l'exception lancée.
 *
 * @example
 * MessagesResources.getMessage("ERROR_PARAM_MISSING", "x", "y", "z")));
 * // --> output : Parameter(s) 'x - y - z' missing
 *
 * @module MessagesResources
 * @alias Gp.Utils.MessagesResources
 * @private
 */
var MessagesResources = {

    // Paramètres
    PARAM_MISSING : "Parameter(s) '%var%' missing",
    PARAM_EMPTY : "Parameter(s) '%var%' empty",
    PARAM_TYPE : "Wrong type(s) for parameter(s) '%var%'",
    PARAM_FORMAT : "Parameter(s) '%var%' not correctly formatted",
    PARAM_NOT_SUPPORT : "Value(s) for parameter(s) '%var%' not supported",
    PARAM_NOT_SUPPORT_NODEJS : "Value(s) for parameter(s) '%var%' not supported to NodeJS",
    PARAM_UNKNOWN : "Value(s) for parameter(s) '%var%' unknown",

    // Services
    // Requête
    SERVICE_REQUEST_BUILD : "An error occurred during the request building of the service",
    SERVICE_REQUEST_EMPTY : "The request sent to the service is empty",

    // Réponse
    SERVICE_RESPONSE_EXCEPTION : "The service returned an exception : '%var%'",
    SERVICE_RESPONSE_EXCEPTION_2 : "The service returned an exception",
    SERVICE_RESPONSE_ANALYSE : "An error occurred while parsing the response '%var%' of the service",
    SERVICE_RESPONSE_ANALYSE_2 : "An unknown error occurred while parsing the response",
    SERVICE_RESPONSE_EMPTY : "The response of the service is empty",
    SERVICE_RESPONSE_EMPTY_2 : "The response from the service could not be analyzed or is empty",
    SERVICE_RESPONSE_FORMAT : "The format of the service response is not supported (handled format(s) : '%var%')",
    SERVICE_RESPONSE_FORMAT_2 : "The format of the service response is not supported",
    SERVICE_RESPONSE_FORMAT_3 : "No suggestion matching the search",

    // Classes
    CLASS_CONSTRUCTOR : "'%var%' constructor cannot be called as a function.",

    /**
     * Fonction qui va retourner le message d'erreur associé à la clé donnée
     *
     * @method getMessage
     * @param {String} clef - Clef de l'erreur (ex : ERROR_PARAM)
     * @param {String[]} parametres - Paramètres/variables concernés par le message d'erreur associé à la clef donnée
     * @return {String} message - String contenant le message de l'exception
     */
    getMessage : function (clef, parametres) {
        // param de la fonction uniquement pour la documentation...

        if (Object.keys(arguments).length === 0) {
            return "Message indefined !";
        }

        var params = Array.prototype.slice.call(arguments);
        var key = params.shift();
        var args = params;

        var message = this[key];

        try {
            if (Array.isArray(args) && args.length > 0) {
                message = message.replace("%var%", args.join(" - "));
            } else {
                message = message.replace("%var%", "%var% (not specified)");
            }
        } catch (e) {
            // error de string.replace()

        }

        return message;
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MessagesResources);


/***/ }),

/***/ "./node_modules/loglevel/lib/loglevel.js":
/*!***********************************************!*\
  !*** ./node_modules/loglevel/lib/loglevel.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    var _loggersByName = {};
    var defaultLogger = null;

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods() {
        /*jshint validthis:true */
        var level = this.getLevel();

        // Replace the actual methods.
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, this.name);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;

        // Return any important warnings.
        if (typeof console === undefinedType && level < this.levels.SILENT) {
            return "No console available for logging";
        }
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, _level, _loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, factory) {
      // Private instance variables.
      var self = this;
      /**
       * The level inherited from a parent logger (or a global default). We
       * cache this here rather than delegating to the parent so that it stays
       * in sync with the actual logging methods that we have installed (the
       * parent could change levels but we might not have rebuilt the loggers
       * in this child yet).
       * @type {number}
       */
      var inheritedLevel;
      /**
       * The default level for this logger, if any. If set, this overrides
       * `inheritedLevel`.
       * @type {number|null}
       */
      var defaultLevel;
      /**
       * A user-specific level for this logger. If set, this overrides
       * `defaultLevel`.
       * @type {number|null}
       */
      var userLevel;

      var storageKey = "loglevel";
      if (typeof name === "string") {
        storageKey += ":" + name;
      } else if (typeof name === "symbol") {
        storageKey = undefined;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType || !storageKey) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType || !storageKey) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var cookieName = encodeURIComponent(storageKey);
                  var location = cookie.indexOf(cookieName + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(
                          cookie.slice(location + cookieName.length + 1)
                      )[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      function clearPersistedLevel() {
          if (typeof window === undefinedType || !storageKey) return;

          // Use localStorage if available
          try {
              window.localStorage.removeItem(storageKey);
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch (ignore) {}
      }

      function normalizeLevel(input) {
          var level = input;
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              return level;
          } else {
              throw new TypeError("log.setLevel() called with invalid level: " + input);
          }
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          if (userLevel != null) {
            return userLevel;
          } else if (defaultLevel != null) {
            return defaultLevel;
          } else {
            return inheritedLevel;
          }
      };

      self.setLevel = function (level, persist) {
          userLevel = normalizeLevel(level);
          if (persist !== false) {  // defaults to true
              persistLevelIfPossible(userLevel);
          }

          // NOTE: in v2, this should call rebuild(), which updates children.
          return replaceLoggingMethods.call(self);
      };

      self.setDefaultLevel = function (level) {
          defaultLevel = normalizeLevel(level);
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.resetLevel = function () {
          userLevel = null;
          clearPersistedLevel();
          replaceLoggingMethods.call(self);
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      self.rebuild = function () {
          if (defaultLogger !== self) {
              inheritedLevel = normalizeLevel(defaultLogger.getLevel());
          }
          replaceLoggingMethods.call(self);

          if (defaultLogger === self) {
              for (var childName in _loggersByName) {
                _loggersByName[childName].rebuild();
              }
          }
      };

      // Initialize all the internal levels.
      inheritedLevel = normalizeLevel(
          defaultLogger ? defaultLogger.getLevel() : "WARN"
      );
      var initialLevel = getPersistedLevel();
      if (initialLevel != null) {
          userLevel = normalizeLevel(initialLevel);
      }
      replaceLoggingMethods.call(self);
    }

    /*
     *
     * Top-level API
     *
     */

    defaultLogger = new Logger();

    defaultLogger.getLogger = function getLogger(name) {
        if ((typeof name !== "symbol" && typeof name !== "string") || name === "") {
            throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
            logger = _loggersByName[name] = new Logger(
                name,
                defaultLogger.methodFactory
            );
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    // ES6 default export, for compatibility
    defaultLogger['default'] = defaultLogger;

    return defaultLogger;
}));


/***/ }),

/***/ "./src/packages/CSS/Controls/Editor/GPFeditor.css":
/*!********************************************************!*\
  !*** ./src/packages/CSS/Controls/Editor/GPFeditor.css ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/packages/CSS/Controls/ElevationPath/GPFelevationPath.css":
/*!**********************************************************************!*\
  !*** ./src/packages/CSS/Controls/ElevationPath/GPFelevationPath.css ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/packages/CSS/Controls/Export/GPFexport.css":
/*!********************************************************!*\
  !*** ./src/packages/CSS/Controls/Export/GPFexport.css ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/packages/CSS/Controls/Isochron/GPFisochron.css":
/*!************************************************************!*\
  !*** ./src/packages/CSS/Controls/Isochron/GPFisochron.css ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/packages/CSS/Controls/LayerImport/GPFlayerImport.css":
/*!******************************************************************!*\
  !*** ./src/packages/CSS/Controls/LayerImport/GPFlayerImport.css ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/packages/CSS/Controls/LayerSwitcher/GPFlayerSwitcher.css":
/*!**********************************************************************!*\
  !*** ./src/packages/CSS/Controls/LayerSwitcher/GPFlayerSwitcher.css ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/packages/CSS/Controls/LocationSelector/GPFlocation.css":
/*!********************************************************************!*\
  !*** ./src/packages/CSS/Controls/LocationSelector/GPFlocation.css ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/packages/CSS/Controls/Route/GPFroute.css":
/*!******************************************************!*\
  !*** ./src/packages/CSS/Controls/Route/GPFroute.css ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/packages/CSS/Controls/ToolBoxMeasure/GPFtoolBoxMeasure.css":
/*!************************************************************************!*\
  !*** ./src/packages/CSS/Controls/ToolBoxMeasure/GPFtoolBoxMeasure.css ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/node-fetch/browser.js":
/*!********************************************!*\
  !*** ./node_modules/node-fetch/browser.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";


// ref: https://github.com/tc39/proposal-global
var getGlobal = function () {
	// the only reliable means to get the global object is
	// `Function('return this')()`
	// However, this causes CSP violations in Chrome apps.
	if (typeof self !== 'undefined') { return self; }
	if (typeof window !== 'undefined') { return window; }
	if (typeof __webpack_require__.g !== 'undefined') { return __webpack_require__.g; }
	throw new Error('unable to locate global object');
}

var globalObject = getGlobal();

module.exports = exports = globalObject.fetch;

// Needed for TypeScript and Webpack.
if (globalObject.fetch) {
	exports["default"] = globalObject.fetch.bind(globalObject);
}

exports.Headers = globalObject.Headers;
exports.Request = globalObject.Request;
exports.Response = globalObject.Response;


/***/ }),

/***/ "./node_modules/sortablejs/modular/sortable.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/sortablejs/modular/sortable.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MultiDrag: () => (/* binding */ MultiDragPlugin),
/* harmony export */   Sortable: () => (/* binding */ Sortable),
/* harmony export */   Swap: () => (/* binding */ SwapPlugin),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**!
 * Sortable 1.15.2
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var version = "1.15.2";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches( /**HTMLElement*/el, /**String*/selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest( /**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }
      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = '';
  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');
      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
      i = 0,
      n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}

/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode;

    // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect();

          // Set relative to edges of padding box of container
          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
      scaleX = elMatrix && elMatrix.a,
      scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}

/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
    elSideVal = getRect(el)[elSide];

  /* jshint boss:true */
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
      visible = void 0;
    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}

/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0,
    i = 0,
    children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}

/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}

/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */
function index(el, selector) {
  var index = 0;
  if (!el || !el.parentNode) {
    return -1;
  }

  /* jshint boss:true */
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }
  return index;
}

/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */
function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
    offsetTop = 0,
    winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el),
        scaleX = elMatrix.a,
        scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}

/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
        _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
function setRect(el, rect) {
  css(el, 'position', 'absolute');
  css(el, 'top', rect.top);
  css(el, 'left', rect.left);
  css(el, 'width', rect.width);
  css(el, 'height', rect.height);
}
function unsetRect(el) {
  css(el, 'position', '');
  css(el, 'top', '');
  css(el, 'left', '');
  css(el, 'width', '');
  css(el, 'height', '');
}
function getChildContainingRectFromElement(container, options, ghostEl) {
  var rect = {};
  Array.from(container.children).forEach(function (child) {
    var _rect$left, _rect$top, _rect$right, _rect$bottom;
    if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl) return;
    var childRect = getRect(child);
    rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
    rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
    rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
    rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
  });
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
    animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);

        // If animating: compensate for current animation
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }
      var animating = false,
        animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
          target = state.target,
          fromRect = target.fromRect,
          toRect = getRect(target),
          prevFromRect = target.prevFromRect,
          prevToRect = target.prevToRect,
          animatingRect = state.rect,
          targetMatrix = matrix(target, true);
        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) &&
          // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }

        // if fromRect != toRect: animate
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
          scaleX = elMatrix && elMatrix.a,
          scaleY = elMatrix && elMatrix.d,
          translateX = (currentRect.left - toRect.left) / (scaleX || 1),
          translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }
    plugins.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function () {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return;
      // Fire global events if it exists in this sortable
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable: sortable
        }, evt));
      }

      // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;

      // Add default options from plugin
      _extends(defaults, initialized.defaults);
    });
    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);
      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return;

      // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
    rootEl = _ref.rootEl,
    name = _ref.name,
    targetEl = _ref.targetEl,
    cloneEl = _ref.cloneEl,
    toEl = _ref.toEl,
    fromEl = _ref.fromEl,
    oldIndex = _ref.oldIndex,
    newIndex = _ref.newIndex,
    oldDraggableIndex = _ref.oldDraggableIndex,
    newDraggableIndex = _ref.newDraggableIndex,
    originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
    options = sortable.options,
    onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);
  // Support for new CustomEvent feature
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }
  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var _excluded = ["evt"];
var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
    originalEvent = _ref.evt,
    data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}
var dragEl,
  parentEl,
  ghostEl,
  rootEl,
  nextEl,
  lastDownEl,
  cloneEl,
  cloneHidden,
  oldIndex,
  newIndex,
  oldDraggableIndex,
  newDraggableIndex,
  activeGroup,
  putSortable,
  awaitingDragStarted = false,
  ignoreNextClick = false,
  sortables = [],
  tapEvt,
  touchEvt,
  lastDx,
  lastDy,
  tapDistanceLeft,
  tapDistanceTop,
  moved,
  lastTarget,
  lastDirection,
  pastFirstInvertThresh = false,
  isCircumstantialInvert = false,
  targetMoveDistance,
  // For positioning ghost absolutely
  ghostRelativeParent,
  ghostRelativeParentInitialScroll = [],
  // (left, top)

  _silent = false,
  savedInputChecked = [];

/** @const */
var documentExists = typeof document !== 'undefined',
  PositionGhostAbsolutely = IOS,
  CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
  // This will not pass for IE9, because IE9 DnD only works on anchors
  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
  supportCssPointerEvents = function () {
    if (!documentExists) return;
    // false when <= IE11
    if (IE11OrLess) {
      return false;
    }
    var el = document.createElement('x');
    el.style.cssText = 'pointer-events:auto';
    return el.style.pointerEvents === 'auto';
  }(),
  _detectDirection = function _detectDirection(el, options) {
    var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
    if (elCSS.display === 'flex') {
      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
    }
    if (elCSS.display === 'grid') {
      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
    }
    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
      var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
    }
    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
  },
  _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  },
  /**
   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
   * @param  {Number} x      X position
   * @param  {Number} y      Y position
   * @return {HTMLElement}   Element of the first found nearest Sortable
   */
  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
    var ret;
    sortables.some(function (sortable) {
      var threshold = sortable[expando].options.emptyInsertThreshold;
      if (!threshold || lastChild(sortable)) return;
      var rect = getRect(sortable),
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
      if (insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  },
  _prepareGroup = function _prepareGroup(options) {
    function toFn(value, pull) {
      return function (to, from, dragEl, evt) {
        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
        if (value == null && (pull || sameGroup)) {
          // Default pull value
          // Default pull and put value if same group
          return true;
        } else if (value == null || value === false) {
          return false;
        } else if (pull && value === 'clone') {
          return value;
        } else if (typeof value === 'function') {
          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
        } else {
          var otherGroup = (pull ? to : from).options.group.name;
          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
        }
      };
    }
    var group = {};
    var originalGroup = options.group;
    if (!originalGroup || _typeof(originalGroup) != 'object') {
      originalGroup = {
        name: originalGroup
      };
    }
    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
  },
  _hideGhostForTarget = function _hideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', 'none');
    }
  },
  _unhideGhostForTarget = function _unhideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', '');
    }
  };

// #1184 fix - Prevent click event on fallback if dragged but item not changed position
if (documentExists && !ChromeForAndroid) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      // Create imitation event
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};

/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el; // root element
  this.options = options = _extends({}, options);

  // Export instance
  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults);

  // Set default options
  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }
  _prepareGroup(options);

  // Bind all private methods
  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  }

  // Setup drag mode
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  }

  // Bind events
  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }
  sortables.push(this.el);

  // Restore sorting
  options.store && options.store.get && this.sort(options.store.get(this) || []);

  // Add animation state manager
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart( /** Event|TouchEvent */evt) {
    if (!evt.cancelable) return;
    var _this = this,
      el = this.el,
      options = this.options,
      preventOnFilter = options.preventOnFilter,
      type = evt.type,
      touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
      target = (touch || evt).target,
      originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
      filter = options.filter;
    _saveInputCheckedState(el);

    // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    }

    // cancel dnd if original target is content editable
    if (originalTarget.isContentEditable) {
      return;
    }

    // Safari ignores further event handling after mousedown
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    }

    // Get the index of the dragged element within its parent
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);

    // Check filter
    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }

    // Prepare `dragstart`
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart( /** Event */evt, /** Touch */touch, /** HTMLElement */target) {
    var _this = this,
      el = _this.el,
      options = _this.options,
      ownerDocument = el.ownerDocument,
      dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';
      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }

        // Bind the events: dragstart/dragend
        _this._triggerDragStart(evt, touch);

        // Drag start event
        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        });

        // Chosen item
        toggleClass(dragEl, options.chosenClass, true);
      };

      // Disable "draggable"
      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop);

      // Make dragEl draggable (must be before delay for FireFox)
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent('delayStart', this, {
        evt: evt
      });

      // Delay is impossible for native DnD in Edge or IE
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag
        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler( /** TouchEvent|PointerEvent **/e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart( /** Event */evt, /** Touch */touch) {
    touch = touch || evt.pointerType == 'touch' && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }
    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });
      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }
      var options = this.options;

      // Apply effect
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();

      // Drag start event
      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent; // store last element
        }
        /* jshint boss:true */ while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove( /**TouchEvent*/evt) {
    if (tapEvt) {
      var options = this.options,
        fallbackTolerance = options.fallbackTolerance,
        fallbackOffset = options.fallbackOffset,
        touch = evt.touches ? evt.touches[0] : evt,
        ghostMatrix = ghostEl && matrix(ghostEl, true),
        scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
        scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
        relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
        dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
        dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);

      // only set the status to dragging, when we are actually dragging
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
        rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
        options = this.options;

      // Position absolutely
      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);

      // Set transform-origin
      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart( /**Event*/evt, /**boolean*/fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent('setupClone', this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }

    // #1143: IFrame support workaround
    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);

    // Set proper drop events
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, 'drop', _this);

      // #1276 fix:
      css(dragEl, 'transform', 'translateZ(0)');
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;
    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver( /**Event*/evt) {
    var el = this.el,
      target = evt.target,
      dragRect,
      targetRect,
      revert,
      options = this.options,
      group = options.group,
      activeSortable = Sortable.active,
      isOwner = activeGroup === group,
      canSort = options.sort,
      fromSortable = putSortable || activeSortable,
      vertical,
      _this = this,
      completedFired = false;
    if (_silent) return;
    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    }

    // Capture animation state
    function capture() {
      dragOverEvent('dragOverAnimationCapture');
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }

    // Return invocation when dragEl is inserted (or completed)
    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });
      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }

        // Animation
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }

      // Null lastTarget if it is not inside a previously swapped element
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }

      // no bubbling and not fallback
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);

        // Do not detect for empty insert if already inserted
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }

    // Call when dragEl has been inserted
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;
      if (revert) {
        parentEl = rootEl; // actualization
        capture();
        this._hideClone();
        dragOverEvent('revert');
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // Insert to end of list

        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        }

        // if there is a last element, it is the target
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            // the last draggable element is not the last node
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        // Insert to start of list
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
          targetBeforeFirstSwap,
          differentLevel = dragEl.parentNode !== el,
          differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
          side1 = vertical ? 'top' : 'left',
          scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
          scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        }
        // If dragEl is already beside target: Do not insert
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
          after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }

          // Undo chrome's scroll adjustment (has no effect on other browsers)
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode; // actualization

          // must be done before animation
          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop( /**Event*/evt) {
    var el = this.el,
      options = this.options;

    // Get the index of the dragged element within its parent
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode;

    // Get again after plugin event
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);

    // Unbind events
    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, 'user-select', '');
    }
    css(dragEl, 'transform', '');
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }
        _disableDraggable(dragEl);
        dragEl.style['will-change'] = '';

        // Remove classes
        // ghostClass is added in dragStarted
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);

        // Drag stop event
        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            // Remove event
            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            });

            // drag from one list and drop into another
            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          });

          // Save sorting
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent( /**Event*/evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);
        break;
      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
      el,
      children = this.el.children,
      i = 0,
      n = children.length,
      options = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {},
      rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];
      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);
    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    }
    // Remove draggable attributes
    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return;

      // show clone at dragEl or original position
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};
function _globalDragOver( /**Event*/evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
    sortable = fromEl[expando],
    onMoveFn = sortable.options.onMove,
    retVal;
  // Support for new CustomEvent feature
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
    targetLength = vertical ? targetRect.height : targetRect.width,
    targetS1 = vertical ? targetRect.top : targetRect.left,
    targetS2 = vertical ? targetRect.bottom : targetRect.right,
    invert = false;
  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}

/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}

/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
    i = str.length,
    sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}

// Fixed #973:
if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}

// Export utils
Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};

/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */
Sortable.get = function (element) {
  return element[expando];
};

/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */
Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }
  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};

/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */
Sortable.create = function (el, options) {
  return new Sortable(el, options);
};

// Export
Sortable.version = version;

var autoScrolls = [],
  scrollEl,
  scrollRootEl,
  scrolling = false,
  lastAutoScrollX,
  lastAutoScrollY,
  touchEvt$1,
  pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };

    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX,
        y = (evt.touches ? evt.touches[0] : evt).clientY,
        elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;

      // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);

        // Listener for pointer element change
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          // Detect for pointer elem change, emulating native DnD behaviour
          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
    y = (evt.touches ? evt.touches[0] : evt).clientY,
    sens = options.scrollSensitivity,
    speed = options.scrollSpeed,
    winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
    scrollCustomFn;

  // New scroll root, set scrollEl
  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent,
      rect = getRect(el),
      top = rect.top,
      bottom = rect.bottom,
      left = rect.left,
      right = rect.right,
      width = rect.width,
      height = rect.height,
      canScrollX = void 0,
      canScrollY = void 0,
      scrollWidth = el.scrollWidth,
      scrollHeight = el.scrollHeight,
      elCSS = css(el),
      scrollPosX = el.scrollLeft,
      scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */
        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    dragEl = _ref.dragEl,
    activeSortable = _ref.activeSortable,
    dispatchSortableEvent = _ref.dispatchSortableEvent,
    hideGhostForTarget = _ref.hideGhostForTarget,
    unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};
function Revert() {}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
      putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable) {
      putSortable.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }
    this.sortable.animateAll();
    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};
_extends(Revert, {
  pluginName: 'revertOnSpill'
});
function Remove() {}
Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
      putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};
_extends(Remove, {
  pluginName: 'removeOnSpill'
});

var lastSwapEl;
function SwapPlugin() {
  function Swap() {
    this.defaults = {
      swapClass: 'sortable-swap-highlight'
    };
  }
  Swap.prototype = {
    dragStart: function dragStart(_ref) {
      var dragEl = _ref.dragEl;
      lastSwapEl = dragEl;
    },
    dragOverValid: function dragOverValid(_ref2) {
      var completed = _ref2.completed,
        target = _ref2.target,
        onMove = _ref2.onMove,
        activeSortable = _ref2.activeSortable,
        changed = _ref2.changed,
        cancel = _ref2.cancel;
      if (!activeSortable.options.swap) return;
      var el = this.sortable.el,
        options = this.options;
      if (target && target !== el) {
        var prevSwapEl = lastSwapEl;
        if (onMove(target) !== false) {
          toggleClass(target, options.swapClass, true);
          lastSwapEl = target;
        } else {
          lastSwapEl = null;
        }
        if (prevSwapEl && prevSwapEl !== lastSwapEl) {
          toggleClass(prevSwapEl, options.swapClass, false);
        }
      }
      changed();
      completed(true);
      cancel();
    },
    drop: function drop(_ref3) {
      var activeSortable = _ref3.activeSortable,
        putSortable = _ref3.putSortable,
        dragEl = _ref3.dragEl;
      var toSortable = putSortable || this.sortable;
      var options = this.options;
      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);
      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {
        if (dragEl !== lastSwapEl) {
          toSortable.captureAnimationState();
          if (toSortable !== activeSortable) activeSortable.captureAnimationState();
          swapNodes(dragEl, lastSwapEl);
          toSortable.animateAll();
          if (toSortable !== activeSortable) activeSortable.animateAll();
        }
      }
    },
    nulling: function nulling() {
      lastSwapEl = null;
    }
  };
  return _extends(Swap, {
    pluginName: 'swap',
    eventProperties: function eventProperties() {
      return {
        swapItem: lastSwapEl
      };
    }
  });
}
function swapNodes(n1, n2) {
  var p1 = n1.parentNode,
    p2 = n2.parentNode,
    i1,
    i2;
  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;
  i1 = index(n1);
  i2 = index(n2);
  if (p1.isEqualNode(p2) && i1 < i2) {
    i2++;
  }
  p1.insertBefore(n2, p1.children[i1]);
  p2.insertBefore(n1, p2.children[i2]);
}

var multiDragElements = [],
  multiDragClones = [],
  lastMultiDragSelect,
  // for selection with modifier key down (SHIFT)
  multiDragSortable,
  initialFolding = false,
  // Initial multi-drag fold when drag started
  folding = false,
  // Folding any other time
  dragStarted = false,
  dragEl$1,
  clonesFromRect,
  clonesHidden;
function MultiDragPlugin() {
  function MultiDrag(sortable) {
    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
    if (!sortable.options.avoidImplicitDeselect) {
      if (sortable.options.supportPointer) {
        on(document, 'pointerup', this._deselectMultiDrag);
      } else {
        on(document, 'mouseup', this._deselectMultiDrag);
        on(document, 'touchend', this._deselectMultiDrag);
      }
    }
    on(document, 'keydown', this._checkKeyDown);
    on(document, 'keyup', this._checkKeyUp);
    this.defaults = {
      selectedClass: 'sortable-selected',
      multiDragKey: null,
      avoidImplicitDeselect: false,
      setData: function setData(dataTransfer, dragEl) {
        var data = '';
        if (multiDragElements.length && multiDragSortable === sortable) {
          multiDragElements.forEach(function (multiDragElement, i) {
            data += (!i ? '' : ', ') + multiDragElement.textContent;
          });
        } else {
          data = dragEl.textContent;
        }
        dataTransfer.setData('Text', data);
      }
    };
  }
  MultiDrag.prototype = {
    multiDragKeyDown: false,
    isMultiDrag: false,
    delayStartGlobal: function delayStartGlobal(_ref) {
      var dragged = _ref.dragEl;
      dragEl$1 = dragged;
    },
    delayEnded: function delayEnded() {
      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
    },
    setupClone: function setupClone(_ref2) {
      var sortable = _ref2.sortable,
        cancel = _ref2.cancel;
      if (!this.isMultiDrag) return;
      for (var i = 0; i < multiDragElements.length; i++) {
        multiDragClones.push(clone(multiDragElements[i]));
        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
        multiDragClones[i].draggable = false;
        multiDragClones[i].style['will-change'] = '';
        toggleClass(multiDragClones[i], this.options.selectedClass, false);
        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
      }
      sortable._hideClone();
      cancel();
    },
    clone: function clone(_ref3) {
      var sortable = _ref3.sortable,
        rootEl = _ref3.rootEl,
        dispatchSortableEvent = _ref3.dispatchSortableEvent,
        cancel = _ref3.cancel;
      if (!this.isMultiDrag) return;
      if (!this.options.removeCloneOnHide) {
        if (multiDragElements.length && multiDragSortable === sortable) {
          insertMultiDragClones(true, rootEl);
          dispatchSortableEvent('clone');
          cancel();
        }
      }
    },
    showClone: function showClone(_ref4) {
      var cloneNowShown = _ref4.cloneNowShown,
        rootEl = _ref4.rootEl,
        cancel = _ref4.cancel;
      if (!this.isMultiDrag) return;
      insertMultiDragClones(false, rootEl);
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', '');
      });
      cloneNowShown();
      clonesHidden = false;
      cancel();
    },
    hideClone: function hideClone(_ref5) {
      var _this = this;
      var sortable = _ref5.sortable,
        cloneNowHidden = _ref5.cloneNowHidden,
        cancel = _ref5.cancel;
      if (!this.isMultiDrag) return;
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', 'none');
        if (_this.options.removeCloneOnHide && clone.parentNode) {
          clone.parentNode.removeChild(clone);
        }
      });
      cloneNowHidden();
      clonesHidden = true;
      cancel();
    },
    dragStartGlobal: function dragStartGlobal(_ref6) {
      var sortable = _ref6.sortable;
      if (!this.isMultiDrag && multiDragSortable) {
        multiDragSortable.multiDrag._deselectMultiDrag();
      }
      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.sortableIndex = index(multiDragElement);
      });

      // Sort multi-drag elements
      multiDragElements = multiDragElements.sort(function (a, b) {
        return a.sortableIndex - b.sortableIndex;
      });
      dragStarted = true;
    },
    dragStarted: function dragStarted(_ref7) {
      var _this2 = this;
      var sortable = _ref7.sortable;
      if (!this.isMultiDrag) return;
      if (this.options.sort) {
        // Capture rects,
        // hide multi drag elements (by positioning them absolute),
        // set multi drag elements rects to dragRect,
        // show multi drag elements,
        // animate to rects,
        // unset rects & remove from DOM

        sortable.captureAnimationState();
        if (this.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            css(multiDragElement, 'position', 'absolute');
          });
          var dragRect = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRect);
          });
          folding = true;
          initialFolding = true;
        }
      }
      sortable.animateAll(function () {
        folding = false;
        initialFolding = false;
        if (_this2.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
        }

        // Remove all auxiliary multidrag items from el, if sorting enabled
        if (_this2.options.sort) {
          removeMultiDragElements();
        }
      });
    },
    dragOver: function dragOver(_ref8) {
      var target = _ref8.target,
        completed = _ref8.completed,
        cancel = _ref8.cancel;
      if (folding && ~multiDragElements.indexOf(target)) {
        completed(false);
        cancel();
      }
    },
    revert: function revert(_ref9) {
      var fromSortable = _ref9.fromSortable,
        rootEl = _ref9.rootEl,
        sortable = _ref9.sortable,
        dragRect = _ref9.dragRect;
      if (multiDragElements.length > 1) {
        // Setup unfold animation
        multiDragElements.forEach(function (multiDragElement) {
          sortable.addAnimationState({
            target: multiDragElement,
            rect: folding ? getRect(multiDragElement) : dragRect
          });
          unsetRect(multiDragElement);
          multiDragElement.fromRect = dragRect;
          fromSortable.removeAnimationState(multiDragElement);
        });
        folding = false;
        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref10) {
      var sortable = _ref10.sortable,
        isOwner = _ref10.isOwner,
        insertion = _ref10.insertion,
        activeSortable = _ref10.activeSortable,
        parentEl = _ref10.parentEl,
        putSortable = _ref10.putSortable;
      var options = this.options;
      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        }
        initialFolding = false;
        // If leaving sort:false root, or already folding - Fold to new location
        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {
          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible
          var dragRectAbsolute = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRectAbsolute);

            // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted
            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable
            parentEl.appendChild(multiDragElement);
          });
          folding = true;
        }

        // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out
        if (!isOwner) {
          // Only remove if not folding (folding will remove them anyways)
          if (!folding) {
            removeMultiDragElements();
          }
          if (multiDragElements.length > 1) {
            var clonesHiddenBefore = clonesHidden;
            activeSortable._showClone(sortable);

            // Unfold animation for clones if showing from hidden
            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
              multiDragClones.forEach(function (clone) {
                activeSortable.addAnimationState({
                  target: clone,
                  rect: clonesFromRect
                });
                clone.fromRect = clonesFromRect;
                clone.thisAnimationDuration = null;
              });
            }
          } else {
            activeSortable._showClone(sortable);
          }
        }
      }
    },
    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
      var dragRect = _ref11.dragRect,
        isOwner = _ref11.isOwner,
        activeSortable = _ref11.activeSortable;
      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.thisAnimationDuration = null;
      });
      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
        clonesFromRect = _extends({}, dragRect);
        var dragMatrix = matrix(dragEl$1, true);
        clonesFromRect.top -= dragMatrix.f;
        clonesFromRect.left -= dragMatrix.e;
      }
    },
    dragOverAnimationComplete: function dragOverAnimationComplete() {
      if (folding) {
        folding = false;
        removeMultiDragElements();
      }
    },
    drop: function drop(_ref12) {
      var evt = _ref12.originalEvent,
        rootEl = _ref12.rootEl,
        parentEl = _ref12.parentEl,
        sortable = _ref12.sortable,
        dispatchSortableEvent = _ref12.dispatchSortableEvent,
        oldIndex = _ref12.oldIndex,
        putSortable = _ref12.putSortable;
      var toSortable = putSortable || this.sortable;
      if (!evt) return;
      var options = this.options,
        children = parentEl.children;

      // Multi-drag selection
      if (!dragStarted) {
        if (options.multiDragKey && !this.multiDragKeyDown) {
          this._deselectMultiDrag();
        }
        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));
        if (!~multiDragElements.indexOf(dragEl$1)) {
          multiDragElements.push(dragEl$1);
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'select',
            targetEl: dragEl$1,
            originalEvent: evt
          });

          // Modifier activated, select from last to dragEl
          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
            var lastIndex = index(lastMultiDragSelect),
              currentIndex = index(dragEl$1);
            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
              // Must include lastMultiDragSelect (select it), in case modified selection from no selection
              // (but previous selection existed)
              var n, i;
              if (currentIndex > lastIndex) {
                i = lastIndex;
                n = currentIndex;
              } else {
                i = currentIndex;
                n = lastIndex + 1;
              }
              for (; i < n; i++) {
                if (~multiDragElements.indexOf(children[i])) continue;
                toggleClass(children[i], options.selectedClass, true);
                multiDragElements.push(children[i]);
                dispatchEvent({
                  sortable: sortable,
                  rootEl: rootEl,
                  name: 'select',
                  targetEl: children[i],
                  originalEvent: evt
                });
              }
            }
          } else {
            lastMultiDragSelect = dragEl$1;
          }
          multiDragSortable = toSortable;
        } else {
          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
          lastMultiDragSelect = null;
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'deselect',
            targetEl: dragEl$1,
            originalEvent: evt
          });
        }
      }

      // Multi-drag drop
      if (dragStarted && this.isMultiDrag) {
        folding = false;
        // Do not "unfold" after around dragEl if reverted
        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {
          var dragRect = getRect(dragEl$1),
            multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');
          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;
          toSortable.captureAnimationState();
          if (!initialFolding) {
            if (options.animation) {
              dragEl$1.fromRect = dragRect;
              multiDragElements.forEach(function (multiDragElement) {
                multiDragElement.thisAnimationDuration = null;
                if (multiDragElement !== dragEl$1) {
                  var rect = folding ? getRect(multiDragElement) : dragRect;
                  multiDragElement.fromRect = rect;

                  // Prepare unfold animation
                  toSortable.addAnimationState({
                    target: multiDragElement,
                    rect: rect
                  });
                }
              });
            }

            // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert
            // properly they must all be removed
            removeMultiDragElements();
            multiDragElements.forEach(function (multiDragElement) {
              if (children[multiDragIndex]) {
                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);
              } else {
                parentEl.appendChild(multiDragElement);
              }
              multiDragIndex++;
            });

            // If initial folding is done, the elements may have changed position because they are now
            // unfolding around dragEl, even though dragEl may not have his index changed, so update event
            // must be fired here as Sortable will not.
            if (oldIndex === index(dragEl$1)) {
              var update = false;
              multiDragElements.forEach(function (multiDragElement) {
                if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                  update = true;
                  return;
                }
              });
              if (update) {
                dispatchSortableEvent('update');
                dispatchSortableEvent('sort');
              }
            }
          }

          // Must be done after capturing individual rects (scroll bar)
          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
          toSortable.animateAll();
        }
        multiDragSortable = toSortable;
      }

      // Remove clones if necessary
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        multiDragClones.forEach(function (clone) {
          clone.parentNode && clone.parentNode.removeChild(clone);
        });
      }
    },
    nullingGlobal: function nullingGlobal() {
      this.isMultiDrag = dragStarted = false;
      multiDragClones.length = 0;
    },
    destroyGlobal: function destroyGlobal() {
      this._deselectMultiDrag();
      off(document, 'pointerup', this._deselectMultiDrag);
      off(document, 'mouseup', this._deselectMultiDrag);
      off(document, 'touchend', this._deselectMultiDrag);
      off(document, 'keydown', this._checkKeyDown);
      off(document, 'keyup', this._checkKeyUp);
    },
    _deselectMultiDrag: function _deselectMultiDrag(evt) {
      if (typeof dragStarted !== "undefined" && dragStarted) return;

      // Only deselect if selection is in this sortable
      if (multiDragSortable !== this.sortable) return;

      // Only deselect if target is not item in this sortable
      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return;

      // Only deselect if left click
      if (evt && evt.button !== 0) return;
      while (multiDragElements.length) {
        var el = multiDragElements[0];
        toggleClass(el, this.options.selectedClass, false);
        multiDragElements.shift();
        dispatchEvent({
          sortable: this.sortable,
          rootEl: this.sortable.el,
          name: 'deselect',
          targetEl: el,
          originalEvent: evt
        });
      }
    },
    _checkKeyDown: function _checkKeyDown(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = true;
      }
    },
    _checkKeyUp: function _checkKeyUp(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = false;
      }
    }
  };
  return _extends(MultiDrag, {
    // Static methods & properties
    pluginName: 'multiDrag',
    utils: {
      /**
       * Selects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be selected
       */
      select: function select(el) {
        var sortable = el.parentNode[expando];
        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;
        if (multiDragSortable && multiDragSortable !== sortable) {
          multiDragSortable.multiDrag._deselectMultiDrag();
          multiDragSortable = sortable;
        }
        toggleClass(el, sortable.options.selectedClass, true);
        multiDragElements.push(el);
      },
      /**
       * Deselects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be deselected
       */
      deselect: function deselect(el) {
        var sortable = el.parentNode[expando],
          index = multiDragElements.indexOf(el);
        if (!sortable || !sortable.options.multiDrag || !~index) return;
        toggleClass(el, sortable.options.selectedClass, false);
        multiDragElements.splice(index, 1);
      }
    },
    eventProperties: function eventProperties() {
      var _this3 = this;
      var oldIndicies = [],
        newIndicies = [];
      multiDragElements.forEach(function (multiDragElement) {
        oldIndicies.push({
          multiDragElement: multiDragElement,
          index: multiDragElement.sortableIndex
        });

        // multiDragElements will already be sorted if folding
        var newIndex;
        if (folding && multiDragElement !== dragEl$1) {
          newIndex = -1;
        } else if (folding) {
          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');
        } else {
          newIndex = index(multiDragElement);
        }
        newIndicies.push({
          multiDragElement: multiDragElement,
          index: newIndex
        });
      });
      return {
        items: _toConsumableArray(multiDragElements),
        clones: [].concat(multiDragClones),
        oldIndicies: oldIndicies,
        newIndicies: newIndicies
      };
    },
    optionListeners: {
      multiDragKey: function multiDragKey(key) {
        key = key.toLowerCase();
        if (key === 'ctrl') {
          key = 'Control';
        } else if (key.length > 1) {
          key = key.charAt(0).toUpperCase() + key.substr(1);
        }
        return key;
      }
    }
  });
}
function insertMultiDragElements(clonesInserted, rootEl) {
  multiDragElements.forEach(function (multiDragElement, i) {
    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];
    if (target) {
      rootEl.insertBefore(multiDragElement, target);
    } else {
      rootEl.appendChild(multiDragElement);
    }
  });
}

/**
 * Insert multi-drag clones
 * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted
 * @param  {HTMLElement} rootEl
 */
function insertMultiDragClones(elementsInserted, rootEl) {
  multiDragClones.forEach(function (clone, i) {
    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];
    if (target) {
      rootEl.insertBefore(clone, target);
    } else {
      rootEl.appendChild(clone);
    }
  });
}
function removeMultiDragElements() {
  multiDragElements.forEach(function (multiDragElement) {
    if (multiDragElement === dragEl$1) return;
    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
  });
}

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Sortable);



/***/ }),

/***/ "ol/Collection":
/*!********************************!*\
  !*** external "ol.Collection" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.Collection;

/***/ }),

/***/ "ol/Feature":
/*!*****************************!*\
  !*** external "ol.Feature" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = ol.Feature;

/***/ }),

/***/ "ol/Map.js":
/*!*************************!*\
  !*** external "ol.Map" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = ol.Map;

/***/ }),

/***/ "ol/Observable":
/*!********************************!*\
  !*** external "ol.Observable" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.Observable;

/***/ }),

/***/ "ol/Overlay":
/*!*****************************!*\
  !*** external "ol.Overlay" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = ol.Overlay;

/***/ }),

/***/ "ol/TileState.js":
/*!*******************************!*\
  !*** external "ol.TileState" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = ol.TileState;

/***/ }),

/***/ "ol/View.js":
/*!**************************!*\
  !*** external "ol.View" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = ol.View;

/***/ }),

/***/ "ol/control/Control":
/*!*************************************!*\
  !*** external "ol.control.Control" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = ol.control.Control;

/***/ }),

/***/ "ol/events/Event.js":
/*!**********************************!*\
  !*** external "ol.events.Event" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.events.Event;

/***/ }),

/***/ "ol/events/condition":
/*!**************************************!*\
  !*** external "ol.events.condition" ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = ol.events.condition;

/***/ }),

/***/ "ol/extent":
/*!****************************!*\
  !*** external "ol.extent" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = ol.extent;

/***/ }),

/***/ "ol/format/GPX":
/*!********************************!*\
  !*** external "ol.format.GPX" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.format.GPX;

/***/ }),

/***/ "ol/format/GeoJSON":
/*!************************************!*\
  !*** external "ol.format.GeoJSON" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = ol.format.GeoJSON;

/***/ }),

/***/ "ol/format/KML":
/*!********************************!*\
  !*** external "ol.format.KML" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.format.KML;

/***/ }),

/***/ "ol/format/MVT":
/*!********************************!*\
  !*** external "ol.format.MVT" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.format.MVT;

/***/ }),

/***/ "ol/format/WMSCapabilities":
/*!********************************************!*\
  !*** external "ol.format.WMSCapabilities" ***!
  \********************************************/
/***/ ((module) => {

"use strict";
module.exports = ol.format.WMSCapabilities;

/***/ }),

/***/ "ol/format/WMTSCapabilities":
/*!*********************************************!*\
  !*** external "ol.format.WMTSCapabilities" ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = ol.format.WMTSCapabilities;

/***/ }),

/***/ "ol/functions.js":
/*!*******************************!*\
  !*** external "ol.functions" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = ol.functions;

/***/ }),

/***/ "ol/geom":
/*!**************************!*\
  !*** external "ol.geom" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = ol.geom;

/***/ }),

/***/ "ol/geom/LineString":
/*!*************************************!*\
  !*** external "ol.geom.LineString" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = ol.geom.LineString;

/***/ }),

/***/ "ol/geom/MultiLineString":
/*!******************************************!*\
  !*** external "ol.geom.MultiLineString" ***!
  \******************************************/
/***/ ((module) => {

"use strict";
module.exports = ol.geom.MultiLineString;

/***/ }),

/***/ "ol/geom/MultiPolygon":
/*!***************************************!*\
  !*** external "ol.geom.MultiPolygon" ***!
  \***************************************/
/***/ ((module) => {

"use strict";
module.exports = ol.geom.MultiPolygon;

/***/ }),

/***/ "ol/geom/Polygon":
/*!**********************************!*\
  !*** external "ol.geom.Polygon" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.geom.Polygon;

/***/ }),

/***/ "ol/interaction":
/*!*********************************!*\
  !*** external "ol.interaction" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.interaction;

/***/ }),

/***/ "ol/layer/Group.js":
/*!*********************************!*\
  !*** external "ol.layer.Group" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.layer.Group;

/***/ }),

/***/ "ol/layer/Image.js":
/*!*********************************!*\
  !*** external "ol.layer.Image" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.layer.Image;

/***/ }),

/***/ "ol/layer/Layer.js":
/*!*********************************!*\
  !*** external "ol.layer.Layer" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.layer.Layer;

/***/ }),

/***/ "ol/layer/Tile":
/*!********************************!*\
  !*** external "ol.layer.Tile" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.layer.Tile;

/***/ }),

/***/ "ol/layer/Vector":
/*!**********************************!*\
  !*** external "ol.layer.Vector" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.layer.Vector;

/***/ }),

/***/ "ol/layer/VectorTile":
/*!**************************************!*\
  !*** external "ol.layer.VectorTile" ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = ol.layer.VectorTile;

/***/ }),

/***/ "ol/loadingstrategy.js":
/*!*************************************!*\
  !*** external "ol.loadingstrategy" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = ol.loadingstrategy;

/***/ }),

/***/ "ol/proj":
/*!**************************!*\
  !*** external "ol.proj" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = ol.proj;

/***/ }),

/***/ "ol/proj/Units.js":
/*!********************************!*\
  !*** external "ol.proj.Units" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.proj.Units;

/***/ }),

/***/ "ol/render/canvas.js":
/*!***********************************!*\
  !*** external "ol.render.canvas" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.render.canvas;

/***/ }),

/***/ "ol/source/Raster.js":
/*!***********************************!*\
  !*** external "ol.source.Raster" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.source.Raster;

/***/ }),

/***/ "ol/source/Source.js":
/*!***********************************!*\
  !*** external "ol.source.Source" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.source.Source;

/***/ }),

/***/ "ol/source/TileJSON":
/*!*************************************!*\
  !*** external "ol.source.TileJSON" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = ol.source.TileJSON;

/***/ }),

/***/ "ol/source/TileWMS":
/*!************************************!*\
  !*** external "ol.source.TileWMS" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = ol.source.TileWMS;

/***/ }),

/***/ "ol/source/Vector":
/*!***********************************!*\
  !*** external "ol.source.Vector" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.source.Vector;

/***/ }),

/***/ "ol/source/VectorTile":
/*!***************************************!*\
  !*** external "ol.source.VectorTile" ***!
  \***************************************/
/***/ ((module) => {

"use strict";
module.exports = ol.source.VectorTile;

/***/ }),

/***/ "ol/source/WMTS":
/*!*********************************!*\
  !*** external "ol.source.WMTS" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.source.WMTS;

/***/ }),

/***/ "ol/sphere":
/*!****************************!*\
  !*** external "ol.sphere" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = ol.sphere;

/***/ }),

/***/ "ol/style":
/*!***************************!*\
  !*** external "ol.style" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = ol.style;

/***/ }),

/***/ "ol/style/Circle":
/*!**********************************!*\
  !*** external "ol.style.Circle" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.style.Circle;

/***/ }),

/***/ "ol/style/Fill":
/*!********************************!*\
  !*** external "ol.style.Fill" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.style.Fill;

/***/ }),

/***/ "ol/style/Icon":
/*!********************************!*\
  !*** external "ol.style.Icon" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.style.Icon;

/***/ }),

/***/ "ol/style/Stroke":
/*!**********************************!*\
  !*** external "ol.style.Stroke" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.style.Stroke;

/***/ }),

/***/ "ol/style/Style":
/*!*********************************!*\
  !*** external "ol.style.Style" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.style.Style;

/***/ }),

/***/ "ol/style/Text":
/*!********************************!*\
  !*** external "ol.style.Text" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.style.Text;

/***/ }),

/***/ "ol/tilegrid.js":
/*!******************************!*\
  !*** external "ol.tilegrid" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = ol.tilegrid;

/***/ }),

/***/ "ol/tilegrid/TileGrid.js":
/*!***************************************!*\
  !*** external "ol.tilegrid.TileGrid" ***!
  \***************************************/
/***/ ((module) => {

"use strict";
module.exports = ol.tilegrid.TileGrid;

/***/ }),

/***/ "ol/tilegrid/WMTS":
/*!***********************************!*\
  !*** external "ol.tilegrid.WMTS" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = ol.tilegrid.WMTS;

/***/ }),

/***/ "ol/tileurlfunction.js":
/*!*************************************!*\
  !*** external "ol.tileurlfunction" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = ol.tileurlfunction;

/***/ }),

/***/ "ol/util.js":
/*!**************************!*\
  !*** external "ol.util" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = ol.util;

/***/ }),

/***/ "ol":
/*!**************************************************************************!*\
  !*** external {"commonjs":"ol","commonjs2":"ol","amd":"ol","root":"ol"} ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = undefined;

/***/ }),

/***/ "xmldom":
/*!***************************************************************************!*\
  !*** external {"commonjs2":"xmldom","commonjs":"xmldom","amd":"require"} ***!
  \***************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = undefined;

/***/ }),

/***/ "./node_modules/ol-mapbox-style/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ol-mapbox-style/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MapboxVectorLayer: () => (/* binding */ MapboxVectorLayer),
/* harmony export */   addMapboxLayer: () => (/* binding */ addMapboxLayer),
/* harmony export */   apply: () => (/* binding */ apply),
/* harmony export */   applyBackground: () => (/* binding */ applyBackground),
/* harmony export */   applyStyle: () => (/* binding */ applyStyle),
/* harmony export */   "default": () => (/* binding */ apply),
/* harmony export */   getFeatureState: () => (/* binding */ getFeatureState),
/* harmony export */   getLayer: () => (/* binding */ getLayer),
/* harmony export */   getLayers: () => (/* binding */ getLayers),
/* harmony export */   getMapboxLayer: () => (/* binding */ getMapboxLayer),
/* harmony export */   getSource: () => (/* binding */ getSource),
/* harmony export */   getStyleForLayer: () => (/* binding */ getStyleForLayer),
/* harmony export */   recordStyleLayer: () => (/* binding */ recordStyleLayer),
/* harmony export */   removeMapboxLayer: () => (/* binding */ removeMapboxLayer),
/* harmony export */   renderTransparent: () => (/* binding */ renderTransparent),
/* harmony export */   setFeatureState: () => (/* binding */ setFeatureState),
/* harmony export */   stylefunction: () => (/* binding */ stylefunction),
/* harmony export */   updateMapboxLayer: () => (/* binding */ updateMapboxLayer),
/* harmony export */   updateMapboxSource: () => (/* binding */ updateMapboxSource)
/* harmony export */ });
/* harmony import */ var ol_style_Circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ol/style/Circle.js */ "ol/style/Circle");
/* harmony import */ var ol_style_Fill_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ol/style/Fill.js */ "ol/style/Fill");
/* harmony import */ var ol_style_Icon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ol/style/Icon.js */ "ol/style/Icon");
/* harmony import */ var ol_render_Feature_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ol/render/Feature.js */ "./node_modules/ol/render/Feature.js");
/* harmony import */ var ol_style_Stroke_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ol/style/Stroke.js */ "ol/style/Stroke");
/* harmony import */ var ol_style_Style_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ol/style/Style.js */ "ol/style/Style");
/* harmony import */ var ol_style_Text_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ol/style/Text.js */ "ol/style/Text");
/* harmony import */ var ol_functions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ol/functions.js */ "ol/functions.js");
/* harmony import */ var ol_render_canvas_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ol/render/canvas.js */ "ol/render/canvas.js");
/* harmony import */ var ol_tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ol/tilegrid/TileGrid.js */ "ol/tilegrid/TileGrid.js");
/* harmony import */ var ol_TileState_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ol/TileState.js */ "ol/TileState.js");
/* harmony import */ var ol__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ol */ "ol");
/* harmony import */ var ol_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ol/tileurlfunction.js */ "ol/tileurlfunction.js");
/* harmony import */ var ol_proj_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ol/proj.js */ "ol/proj");
/* harmony import */ var ol_util_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ol/util.js */ "ol/util.js");
/* harmony import */ var ol_format_GeoJSON_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ol/format/GeoJSON.js */ "ol/format/GeoJSON");
/* harmony import */ var ol_layer_Image_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ol/layer/Image.js */ "ol/layer/Image.js");
/* harmony import */ var ol_layer_Layer_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ol/layer/Layer.js */ "ol/layer/Layer.js");
/* harmony import */ var ol_layer_Group_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ol/layer/Group.js */ "ol/layer/Group.js");
/* harmony import */ var ol_format_MVT_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ol/format/MVT.js */ "ol/format/MVT");
/* harmony import */ var ol_Map_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ol/Map.js */ "ol/Map.js");
/* harmony import */ var ol_source_Raster_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ol/source/Raster.js */ "ol/source/Raster.js");
/* harmony import */ var ol_source_Source_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ol/source/Source.js */ "ol/source/Source.js");
/* harmony import */ var ol_source_TileJSON_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ol/source/TileJSON.js */ "ol/source/TileJSON");
/* harmony import */ var ol_layer_Tile_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ol/layer/Tile.js */ "ol/layer/Tile");
/* harmony import */ var ol_layer_Vector_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ol/layer/Vector.js */ "ol/layer/Vector");
/* harmony import */ var ol_source_Vector_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ol/source/Vector.js */ "ol/source/Vector");
/* harmony import */ var ol_layer_VectorTile_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ol/layer/VectorTile.js */ "ol/layer/VectorTile");
/* harmony import */ var ol_source_VectorTile_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ol/source/VectorTile.js */ "ol/source/VectorTile");
/* harmony import */ var ol_View_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ol/View.js */ "ol/View.js");
/* harmony import */ var ol_proj_Units_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ol/proj/Units.js */ "ol/proj/Units.js");
/* harmony import */ var ol_loadingstrategy_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ol/loadingstrategy.js */ "ol/loadingstrategy.js");
/* harmony import */ var ol_tilegrid_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ol/tilegrid.js */ "ol/tilegrid.js");
/* harmony import */ var ol_extent_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ol/extent.js */ "ol/extent");
/* harmony import */ var ol_events_Event_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ol/events/Event.js */ "ol/events/Event.js");
/* harmony import */ var ol_events_EventType_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ol/events/EventType.js */ "./node_modules/ol/events/EventType.js");





































function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var csscolorparser = {};

var parseCSSColor_1;
// (c) Dean McNamee <dean@gmail.com>, 2012.
//
// https://github.com/deanm/css-color-parser-js
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// http://www.w3.org/TR/css3-color/
var kCSSColorTable = {
    'transparent': [
        0,
        0,
        0,
        0
    ],
    'aliceblue': [
        240,
        248,
        255,
        1
    ],
    'antiquewhite': [
        250,
        235,
        215,
        1
    ],
    'aqua': [
        0,
        255,
        255,
        1
    ],
    'aquamarine': [
        127,
        255,
        212,
        1
    ],
    'azure': [
        240,
        255,
        255,
        1
    ],
    'beige': [
        245,
        245,
        220,
        1
    ],
    'bisque': [
        255,
        228,
        196,
        1
    ],
    'black': [
        0,
        0,
        0,
        1
    ],
    'blanchedalmond': [
        255,
        235,
        205,
        1
    ],
    'blue': [
        0,
        0,
        255,
        1
    ],
    'blueviolet': [
        138,
        43,
        226,
        1
    ],
    'brown': [
        165,
        42,
        42,
        1
    ],
    'burlywood': [
        222,
        184,
        135,
        1
    ],
    'cadetblue': [
        95,
        158,
        160,
        1
    ],
    'chartreuse': [
        127,
        255,
        0,
        1
    ],
    'chocolate': [
        210,
        105,
        30,
        1
    ],
    'coral': [
        255,
        127,
        80,
        1
    ],
    'cornflowerblue': [
        100,
        149,
        237,
        1
    ],
    'cornsilk': [
        255,
        248,
        220,
        1
    ],
    'crimson': [
        220,
        20,
        60,
        1
    ],
    'cyan': [
        0,
        255,
        255,
        1
    ],
    'darkblue': [
        0,
        0,
        139,
        1
    ],
    'darkcyan': [
        0,
        139,
        139,
        1
    ],
    'darkgoldenrod': [
        184,
        134,
        11,
        1
    ],
    'darkgray': [
        169,
        169,
        169,
        1
    ],
    'darkgreen': [
        0,
        100,
        0,
        1
    ],
    'darkgrey': [
        169,
        169,
        169,
        1
    ],
    'darkkhaki': [
        189,
        183,
        107,
        1
    ],
    'darkmagenta': [
        139,
        0,
        139,
        1
    ],
    'darkolivegreen': [
        85,
        107,
        47,
        1
    ],
    'darkorange': [
        255,
        140,
        0,
        1
    ],
    'darkorchid': [
        153,
        50,
        204,
        1
    ],
    'darkred': [
        139,
        0,
        0,
        1
    ],
    'darksalmon': [
        233,
        150,
        122,
        1
    ],
    'darkseagreen': [
        143,
        188,
        143,
        1
    ],
    'darkslateblue': [
        72,
        61,
        139,
        1
    ],
    'darkslategray': [
        47,
        79,
        79,
        1
    ],
    'darkslategrey': [
        47,
        79,
        79,
        1
    ],
    'darkturquoise': [
        0,
        206,
        209,
        1
    ],
    'darkviolet': [
        148,
        0,
        211,
        1
    ],
    'deeppink': [
        255,
        20,
        147,
        1
    ],
    'deepskyblue': [
        0,
        191,
        255,
        1
    ],
    'dimgray': [
        105,
        105,
        105,
        1
    ],
    'dimgrey': [
        105,
        105,
        105,
        1
    ],
    'dodgerblue': [
        30,
        144,
        255,
        1
    ],
    'firebrick': [
        178,
        34,
        34,
        1
    ],
    'floralwhite': [
        255,
        250,
        240,
        1
    ],
    'forestgreen': [
        34,
        139,
        34,
        1
    ],
    'fuchsia': [
        255,
        0,
        255,
        1
    ],
    'gainsboro': [
        220,
        220,
        220,
        1
    ],
    'ghostwhite': [
        248,
        248,
        255,
        1
    ],
    'gold': [
        255,
        215,
        0,
        1
    ],
    'goldenrod': [
        218,
        165,
        32,
        1
    ],
    'gray': [
        128,
        128,
        128,
        1
    ],
    'green': [
        0,
        128,
        0,
        1
    ],
    'greenyellow': [
        173,
        255,
        47,
        1
    ],
    'grey': [
        128,
        128,
        128,
        1
    ],
    'honeydew': [
        240,
        255,
        240,
        1
    ],
    'hotpink': [
        255,
        105,
        180,
        1
    ],
    'indianred': [
        205,
        92,
        92,
        1
    ],
    'indigo': [
        75,
        0,
        130,
        1
    ],
    'ivory': [
        255,
        255,
        240,
        1
    ],
    'khaki': [
        240,
        230,
        140,
        1
    ],
    'lavender': [
        230,
        230,
        250,
        1
    ],
    'lavenderblush': [
        255,
        240,
        245,
        1
    ],
    'lawngreen': [
        124,
        252,
        0,
        1
    ],
    'lemonchiffon': [
        255,
        250,
        205,
        1
    ],
    'lightblue': [
        173,
        216,
        230,
        1
    ],
    'lightcoral': [
        240,
        128,
        128,
        1
    ],
    'lightcyan': [
        224,
        255,
        255,
        1
    ],
    'lightgoldenrodyellow': [
        250,
        250,
        210,
        1
    ],
    'lightgray': [
        211,
        211,
        211,
        1
    ],
    'lightgreen': [
        144,
        238,
        144,
        1
    ],
    'lightgrey': [
        211,
        211,
        211,
        1
    ],
    'lightpink': [
        255,
        182,
        193,
        1
    ],
    'lightsalmon': [
        255,
        160,
        122,
        1
    ],
    'lightseagreen': [
        32,
        178,
        170,
        1
    ],
    'lightskyblue': [
        135,
        206,
        250,
        1
    ],
    'lightslategray': [
        119,
        136,
        153,
        1
    ],
    'lightslategrey': [
        119,
        136,
        153,
        1
    ],
    'lightsteelblue': [
        176,
        196,
        222,
        1
    ],
    'lightyellow': [
        255,
        255,
        224,
        1
    ],
    'lime': [
        0,
        255,
        0,
        1
    ],
    'limegreen': [
        50,
        205,
        50,
        1
    ],
    'linen': [
        250,
        240,
        230,
        1
    ],
    'magenta': [
        255,
        0,
        255,
        1
    ],
    'maroon': [
        128,
        0,
        0,
        1
    ],
    'mediumaquamarine': [
        102,
        205,
        170,
        1
    ],
    'mediumblue': [
        0,
        0,
        205,
        1
    ],
    'mediumorchid': [
        186,
        85,
        211,
        1
    ],
    'mediumpurple': [
        147,
        112,
        219,
        1
    ],
    'mediumseagreen': [
        60,
        179,
        113,
        1
    ],
    'mediumslateblue': [
        123,
        104,
        238,
        1
    ],
    'mediumspringgreen': [
        0,
        250,
        154,
        1
    ],
    'mediumturquoise': [
        72,
        209,
        204,
        1
    ],
    'mediumvioletred': [
        199,
        21,
        133,
        1
    ],
    'midnightblue': [
        25,
        25,
        112,
        1
    ],
    'mintcream': [
        245,
        255,
        250,
        1
    ],
    'mistyrose': [
        255,
        228,
        225,
        1
    ],
    'moccasin': [
        255,
        228,
        181,
        1
    ],
    'navajowhite': [
        255,
        222,
        173,
        1
    ],
    'navy': [
        0,
        0,
        128,
        1
    ],
    'oldlace': [
        253,
        245,
        230,
        1
    ],
    'olive': [
        128,
        128,
        0,
        1
    ],
    'olivedrab': [
        107,
        142,
        35,
        1
    ],
    'orange': [
        255,
        165,
        0,
        1
    ],
    'orangered': [
        255,
        69,
        0,
        1
    ],
    'orchid': [
        218,
        112,
        214,
        1
    ],
    'palegoldenrod': [
        238,
        232,
        170,
        1
    ],
    'palegreen': [
        152,
        251,
        152,
        1
    ],
    'paleturquoise': [
        175,
        238,
        238,
        1
    ],
    'palevioletred': [
        219,
        112,
        147,
        1
    ],
    'papayawhip': [
        255,
        239,
        213,
        1
    ],
    'peachpuff': [
        255,
        218,
        185,
        1
    ],
    'peru': [
        205,
        133,
        63,
        1
    ],
    'pink': [
        255,
        192,
        203,
        1
    ],
    'plum': [
        221,
        160,
        221,
        1
    ],
    'powderblue': [
        176,
        224,
        230,
        1
    ],
    'purple': [
        128,
        0,
        128,
        1
    ],
    'rebeccapurple': [
        102,
        51,
        153,
        1
    ],
    'red': [
        255,
        0,
        0,
        1
    ],
    'rosybrown': [
        188,
        143,
        143,
        1
    ],
    'royalblue': [
        65,
        105,
        225,
        1
    ],
    'saddlebrown': [
        139,
        69,
        19,
        1
    ],
    'salmon': [
        250,
        128,
        114,
        1
    ],
    'sandybrown': [
        244,
        164,
        96,
        1
    ],
    'seagreen': [
        46,
        139,
        87,
        1
    ],
    'seashell': [
        255,
        245,
        238,
        1
    ],
    'sienna': [
        160,
        82,
        45,
        1
    ],
    'silver': [
        192,
        192,
        192,
        1
    ],
    'skyblue': [
        135,
        206,
        235,
        1
    ],
    'slateblue': [
        106,
        90,
        205,
        1
    ],
    'slategray': [
        112,
        128,
        144,
        1
    ],
    'slategrey': [
        112,
        128,
        144,
        1
    ],
    'snow': [
        255,
        250,
        250,
        1
    ],
    'springgreen': [
        0,
        255,
        127,
        1
    ],
    'steelblue': [
        70,
        130,
        180,
        1
    ],
    'tan': [
        210,
        180,
        140,
        1
    ],
    'teal': [
        0,
        128,
        128,
        1
    ],
    'thistle': [
        216,
        191,
        216,
        1
    ],
    'tomato': [
        255,
        99,
        71,
        1
    ],
    'turquoise': [
        64,
        224,
        208,
        1
    ],
    'violet': [
        238,
        130,
        238,
        1
    ],
    'wheat': [
        245,
        222,
        179,
        1
    ],
    'white': [
        255,
        255,
        255,
        1
    ],
    'whitesmoke': [
        245,
        245,
        245,
        1
    ],
    'yellow': [
        255,
        255,
        0,
        1
    ],
    'yellowgreen': [
        154,
        205,
        50,
        1
    ]
};
function clamp_css_byte(i) {
    // Clamp to integer 0 .. 255.
    i = Math.round(i);
    // Seems to be what Chrome does (vs truncation).
    return i < 0 ? 0 : i > 255 ? 255 : i;
}
function clamp_css_float(f) {
    // Clamp to float 0.0 .. 1.0.
    return f < 0 ? 0 : f > 1 ? 1 : f;
}
function parse_css_int(str) {
    // int or percentage.
    if (str[str.length - 1] === '%')
        return clamp_css_byte(parseFloat(str) / 100 * 255);
    return clamp_css_byte(parseInt(str));
}
function parse_css_float(str) {
    // float or percentage.
    if (str[str.length - 1] === '%')
        return clamp_css_float(parseFloat(str) / 100);
    return clamp_css_float(parseFloat(str));
}
function css_hue_to_rgb(m1, m2, h) {
    if (h < 0)
        h += 1;
    else if (h > 1)
        h -= 1;
    if (h * 6 < 1)
        return m1 + (m2 - m1) * h * 6;
    if (h * 2 < 1)
        return m2;
    if (h * 3 < 2)
        return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    return m1;
}
function parseCSSColor(css_str) {
    // Remove all whitespace, not compliant, but should just be more accepting.
    var str = css_str.replace(/ /g, '').toLowerCase();
    // Color keywords (and transparent) lookup.
    if (str in kCSSColorTable)
        return kCSSColorTable[str].slice();
    // dup.
    // #abc and #abc123 syntax.
    if (str[0] === '#') {
        if (str.length === 4) {
            var iv = parseInt(str.substr(1), 16);
            // TODO(deanm): Stricter parsing.
            if (!(iv >= 0 && iv <= 4095))
                return null;
            // Covers NaN.
            return [
                (iv & 3840) >> 4 | (iv & 3840) >> 8,
                iv & 240 | (iv & 240) >> 4,
                iv & 15 | (iv & 15) << 4,
                1
            ];
        } else if (str.length === 7) {
            var iv = parseInt(str.substr(1), 16);
            // TODO(deanm): Stricter parsing.
            if (!(iv >= 0 && iv <= 16777215))
                return null;
            // Covers NaN.
            return [
                (iv & 16711680) >> 16,
                (iv & 65280) >> 8,
                iv & 255,
                1
            ];
        }
        return null;
    }
    var op = str.indexOf('('), ep = str.indexOf(')');
    if (op !== -1 && ep + 1 === str.length) {
        var fname = str.substr(0, op);
        var params = str.substr(op + 1, ep - (op + 1)).split(',');
        var alpha = 1;
        // To allow case fallthrough.
        switch (fname) {
        case 'rgba':
            if (params.length !== 4)
                return null;
            alpha = parse_css_float(params.pop());
        // Fall through.
        case 'rgb':
            if (params.length !== 3)
                return null;
            return [
                parse_css_int(params[0]),
                parse_css_int(params[1]),
                parse_css_int(params[2]),
                alpha
            ];
        case 'hsla':
            if (params.length !== 4)
                return null;
            alpha = parse_css_float(params.pop());
        // Fall through.
        case 'hsl':
            if (params.length !== 3)
                return null;
            var h = (parseFloat(params[0]) % 360 + 360) % 360 / 360;
            // 0 .. 1
            // NOTE(deanm): According to the CSS spec s/l should only be
            // percentages, but we don't bother and let float or percentage.
            var s = parse_css_float(params[1]);
            var l = parse_css_float(params[2]);
            var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
            var m1 = l * 2 - m2;
            return [
                clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),
                clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255),
                alpha
            ];
        default:
            return null;
        }
    }
    return null;
}
try {
    parseCSSColor_1 = csscolorparser.parseCSSColor = parseCSSColor;
} catch (e) {
}

//      
/**
 * An RGBA color value. Create instances from color strings using the static
 * method `Color.parse`. The constructor accepts RGB channel values in the range
 * `[0, 1]`, premultiplied by A.
 *
 * @param {number} r The red channel.
 * @param {number} g The green channel.
 * @param {number} b The blue channel.
 * @param {number} a The alpha channel.
 * @private
 */
class Color {
    constructor(r, g, b, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    /**
     * Parses valid CSS color strings and returns a `Color` instance.
     * @returns A `Color` instance, or `undefined` if the input is not a valid color string.
     */
    static parse(input) {
        if (!input) {
            return undefined;
        }
        if (input instanceof Color) {
            return input;
        }
        if (typeof input !== 'string') {
            return undefined;
        }
        const rgba = parseCSSColor_1(input);
        if (!rgba) {
            return undefined;
        }
        return new Color(rgba[0] / 255 * rgba[3], rgba[1] / 255 * rgba[3], rgba[2] / 255 * rgba[3], rgba[3]);
    }
    /**
     * Returns an RGBA string representing the color value.
     *
     * @returns An RGBA string.
     * @example
     * var purple = new Color.parse('purple');
     * purple.toString; // = "rgba(128,0,128,1)"
     * var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');
     * translucentGreen.toString(); // = "rgba(26,207,26,0.73)"
     */
    toString() {
        const [r, g, b, a] = this.toArray();
        return `rgba(${ Math.round(r) },${ Math.round(g) },${ Math.round(b) },${ a })`;
    }
    /**
     * Returns an RGBA array of values representing the color, unpremultiplied by A.
     *
     * @returns An array of RGBA color values in the range [0, 255].
     */
    toArray() {
        const {r, g, b, a} = this;
        return a === 0 ? [
            0,
            0,
            0,
            0
        ] : [
            r * 255 / a,
            g * 255 / a,
            b * 255 / a,
            a
        ];
    }
    /**
     * Returns a RGBA array of float values representing the color, unpremultiplied by A.
     *
     * @returns An array of RGBA color values in the range [0, 1].
     */
    toArray01() {
        const {r, g, b, a} = this;
        return a === 0 ? [
            0,
            0,
            0,
            0
        ] : [
            r / a,
            g / a,
            b / a,
            a
        ];
    }
    /**
     * Returns an RGBA array of values representing the color, premultiplied by A.
     *
     * @returns An array of RGBA color values in the range [0, 1].
     */
    toArray01PremultipliedAlpha() {
        const {r, g, b, a} = this;
        return [
            r,
            g,
            b,
            a
        ];
    }
}
Color.black = new Color(0, 0, 0, 1);
Color.white = new Color(1, 1, 1, 1);
Color.transparent = new Color(0, 0, 0, 0);
Color.red = new Color(1, 0, 0, 1);
Color.blue = new Color(0, 0, 1, 1);
var Color$1 = Color;

function convertLiteral(value) {
    return typeof value === 'object' ? [
        'literal',
        value
    ] : value;
}
function convertFunction(parameters, propertySpec) {
    let stops = parameters.stops;
    if (!stops) {
        // identity function
        return convertIdentityFunction(parameters, propertySpec);
    }
    const zoomAndFeatureDependent = stops && typeof stops[0][0] === 'object';
    const featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
    const zoomDependent = zoomAndFeatureDependent || !featureDependent;
    stops = stops.map(stop => {
        if (!featureDependent && propertySpec.tokens && typeof stop[1] === 'string') {
            return [
                stop[0],
                convertTokenString(stop[1])
            ];
        }
        return [
            stop[0],
            convertLiteral(stop[1])
        ];
    });
    if (zoomAndFeatureDependent) {
        return convertZoomAndPropertyFunction(parameters, propertySpec, stops);
    } else if (zoomDependent) {
        return convertZoomFunction(parameters, propertySpec, stops);
    } else {
        return convertPropertyFunction(parameters, propertySpec, stops);
    }
}
function convertIdentityFunction(parameters, propertySpec) {
    const get = [
        'get',
        parameters.property
    ];
    if (parameters.default === undefined) {
        // By default, expressions for string-valued properties get coerced. To preserve
        // legacy function semantics, insert an explicit assertion instead.
        return propertySpec.type === 'string' ? [
            'string',
            get
        ] : get;
    } else if (propertySpec.type === 'enum') {
        return [
            'match',
            get,
            Object.keys(propertySpec.values),
            get,
            parameters.default
        ];
    } else {
        const expression = [
            propertySpec.type === 'color' ? 'to-color' : propertySpec.type,
            get,
            convertLiteral(parameters.default)
        ];
        if (propertySpec.type === 'array') {
            expression.splice(1, 0, propertySpec.value, propertySpec.length || null);
        }
        return expression;
    }
}
function getInterpolateOperator(parameters) {
    switch (parameters.colorSpace) {
    case 'hcl':
        return 'interpolate-hcl';
    case 'lab':
        return 'interpolate-lab';
    default:
        return 'interpolate';
    }
}
function convertZoomAndPropertyFunction(parameters, propertySpec, stops) {
    const featureFunctionParameters = {};
    const featureFunctionStops = {};
    const zoomStops = [];
    for (let s = 0; s < stops.length; s++) {
        const stop = stops[s];
        const zoom = stop[0].zoom;
        if (featureFunctionParameters[zoom] === undefined) {
            featureFunctionParameters[zoom] = {
                zoom,
                type: parameters.type,
                property: parameters.property,
                default: parameters.default
            };
            featureFunctionStops[zoom] = [];
            zoomStops.push(zoom);
        }
        featureFunctionStops[zoom].push([
            stop[0].value,
            stop[1]
        ]);
    }
    // the interpolation type for the zoom dimension of a zoom-and-property
    // function is determined directly from the style property specification
    // for which it's being used: linear for interpolatable properties, step
    // otherwise.
    const functionType = getFunctionType({}, propertySpec);
    if (functionType === 'exponential') {
        const expression = [
            getInterpolateOperator(parameters),
            ['linear'],
            ['zoom']
        ];
        for (const z of zoomStops) {
            const output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);
            appendStopPair(expression, z, output, false);
        }
        return expression;
    } else {
        const expression = [
            'step',
            ['zoom']
        ];
        for (const z of zoomStops) {
            const output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);
            appendStopPair(expression, z, output, true);
        }
        fixupDegenerateStepCurve(expression);
        return expression;
    }
}
function coalesce(a, b) {
    if (a !== undefined)
        return a;
    if (b !== undefined)
        return b;
}
function getFallback(parameters, propertySpec) {
    const defaultValue = convertLiteral(coalesce(parameters.default, propertySpec.default));
    /*
     * Some fields with type: resolvedImage have an undefined default.
     * Because undefined is an invalid value for resolvedImage, set fallback to
     * an empty string instead of undefined to ensure output
     * passes validation.
     */
    if (defaultValue === undefined && propertySpec.type === 'resolvedImage') {
        return '';
    }
    return defaultValue;
}
function convertPropertyFunction(parameters, propertySpec, stops) {
    const type = getFunctionType(parameters, propertySpec);
    const get = [
        'get',
        parameters.property
    ];
    if (type === 'categorical' && typeof stops[0][0] === 'boolean') {
        const expression = ['case'];
        for (const stop of stops) {
            expression.push([
                '==',
                get,
                stop[0]
            ], stop[1]);
        }
        expression.push(getFallback(parameters, propertySpec));
        return expression;
    } else if (type === 'categorical') {
        const expression = [
            'match',
            get
        ];
        for (const stop of stops) {
            appendStopPair(expression, stop[0], stop[1], false);
        }
        expression.push(getFallback(parameters, propertySpec));
        return expression;
    } else if (type === 'interval') {
        const expression = [
            'step',
            [
                'number',
                get
            ]
        ];
        for (const stop of stops) {
            appendStopPair(expression, stop[0], stop[1], true);
        }
        fixupDegenerateStepCurve(expression);
        return parameters.default === undefined ? expression : [
            'case',
            [
                '==',
                [
                    'typeof',
                    get
                ],
                'number'
            ],
            expression,
            convertLiteral(parameters.default)
        ];
    } else if (type === 'exponential') {
        const base = parameters.base !== undefined ? parameters.base : 1;
        const expression = [
            getInterpolateOperator(parameters),
            base === 1 ? ['linear'] : [
                'exponential',
                base
            ],
            [
                'number',
                get
            ]
        ];
        for (const stop of stops) {
            appendStopPair(expression, stop[0], stop[1], false);
        }
        return parameters.default === undefined ? expression : [
            'case',
            [
                '==',
                [
                    'typeof',
                    get
                ],
                'number'
            ],
            expression,
            convertLiteral(parameters.default)
        ];
    } else {
        throw new Error(`Unknown property function type ${ type }`);
    }
}
function convertZoomFunction(parameters, propertySpec, stops, input = ['zoom']) {
    const type = getFunctionType(parameters, propertySpec);
    let expression;
    let isStep = false;
    if (type === 'interval') {
        expression = [
            'step',
            input
        ];
        isStep = true;
    } else if (type === 'exponential') {
        const base = parameters.base !== undefined ? parameters.base : 1;
        expression = [
            getInterpolateOperator(parameters),
            base === 1 ? ['linear'] : [
                'exponential',
                base
            ],
            input
        ];
    } else {
        throw new Error(`Unknown zoom function type "${ type }"`);
    }
    for (const stop of stops) {
        appendStopPair(expression, stop[0], stop[1], isStep);
    }
    fixupDegenerateStepCurve(expression);
    return expression;
}
function fixupDegenerateStepCurve(expression) {
    // degenerate step curve (i.e. a constant function): add a noop stop
    if (expression[0] === 'step' && expression.length === 3) {
        expression.push(0);
        expression.push(expression[3]);
    }
}
function appendStopPair(curve, input, output, isStep) {
    // Skip duplicate stop values. They were not validated for functions, but they are for expressions.
    // https://github.com/mapbox/mapbox-gl-js/issues/4107
    if (curve.length > 3 && input === curve[curve.length - 2]) {
        return;
    }
    // step curves don't get the first input value, as it is redundant.
    if (!(isStep && curve.length === 2)) {
        curve.push(input);
    }
    curve.push(output);
}
function getFunctionType(parameters, propertySpec) {
    if (parameters.type) {
        return parameters.type;
    } else {
        return propertySpec.expression.interpolated ? 'exponential' : 'interval';
    }
}
// "String with {name} token" => ["concat", "String with ", ["get", "name"], " token"]
function convertTokenString(s) {
    const result = ['concat'];
    const re = /{([^{}]+)}/g;
    let pos = 0;
    for (let match = re.exec(s); match !== null; match = re.exec(s)) {
        const literal = s.slice(pos, re.lastIndex - match[0].length);
        pos = re.lastIndex;
        if (literal.length > 0)
            result.push(literal);
        result.push([
            'get',
            match[1]
        ]);
    }
    if (result.length === 1) {
        return s;
    }
    if (pos < s.length) {
        result.push(s.slice(pos));
    } else if (result.length === 2) {
        return [
            'to-string',
            result[1]
        ];
    }
    return result;
}

//      
class ParsingError extends Error {
    constructor(key, message) {
        super(message);
        this.message = message;
        this.key = key;
    }
}
var ParsingError$1 = ParsingError;

//      
/**
 * Tracks `let` bindings during expression parsing.
 * @private
 */
class Scope {
    constructor(parent, bindings = []) {
        this.parent = parent;
        this.bindings = {};
        for (const [name, expression] of bindings) {
            this.bindings[name] = expression;
        }
    }
    concat(bindings) {
        return new Scope(this, bindings);
    }
    get(name) {
        if (this.bindings[name]) {
            return this.bindings[name];
        }
        if (this.parent) {
            return this.parent.get(name);
        }
        throw new Error(`${ name } not found in scope.`);
    }
    has(name) {
        if (this.bindings[name])
            return true;
        return this.parent ? this.parent.has(name) : false;
    }
}
var Scope$1 = Scope;

//      
const NullType = { kind: 'null' };
const NumberType = { kind: 'number' };
const StringType = { kind: 'string' };
const BooleanType = { kind: 'boolean' };
const ColorType = { kind: 'color' };
const ObjectType = { kind: 'object' };
const ValueType = { kind: 'value' };
const ErrorType = { kind: 'error' };
const CollatorType = { kind: 'collator' };
const FormattedType = { kind: 'formatted' };
const ResolvedImageType = { kind: 'resolvedImage' };
function array$1(itemType, N) {
    return {
        kind: 'array',
        itemType,
        N
    };
}
function toString$1(type) {
    if (type.kind === 'array') {
        const itemType = toString$1(type.itemType);
        return typeof type.N === 'number' ? `array<${ itemType }, ${ type.N }>` : type.itemType.kind === 'value' ? 'array' : `array<${ itemType }>`;
    } else {
        return type.kind;
    }
}
const valueMemberTypes = [
    NullType,
    NumberType,
    StringType,
    BooleanType,
    ColorType,
    FormattedType,
    ObjectType,
    array$1(ValueType),
    ResolvedImageType
];
/**
 * Returns null if `t` is a subtype of `expected`; otherwise returns an
 * error message.
 * @private
 */
function checkSubtype(expected, t) {
    if (t.kind === 'error') {
        // Error is a subtype of every type
        return null;
    } else if (expected.kind === 'array') {
        if (t.kind === 'array' && (t.N === 0 && t.itemType.kind === 'value' || !checkSubtype(expected.itemType, t.itemType)) && (typeof expected.N !== 'number' || expected.N === t.N)) {
            return null;
        }
    } else if (expected.kind === t.kind) {
        return null;
    } else if (expected.kind === 'value') {
        for (const memberType of valueMemberTypes) {
            if (!checkSubtype(memberType, t)) {
                return null;
            }
        }
    }
    return `Expected ${ toString$1(expected) } but found ${ toString$1(t) } instead.`;
}
function isValidType(provided, allowedTypes) {
    return allowedTypes.some(t => t.kind === provided.kind);
}
function isValidNativeType(provided, allowedTypes) {
    return allowedTypes.some(t => {
        if (t === 'null') {
            return provided === null;
        } else if (t === 'array') {
            return Array.isArray(provided);
        } else if (t === 'object') {
            return provided && !Array.isArray(provided) && typeof provided === 'object';
        } else {
            return t === typeof provided;
        }
    });
}

//      
// Flow type declarations for Intl cribbed from
// https://github.com/facebook/flow/issues/1270
class Collator {
    constructor(caseSensitive, diacriticSensitive, locale) {
        if (caseSensitive)
            this.sensitivity = diacriticSensitive ? 'variant' : 'case';
        else
            this.sensitivity = diacriticSensitive ? 'accent' : 'base';
        this.locale = locale;
        this.collator = new Intl.Collator(this.locale ? this.locale : [], {
            sensitivity: this.sensitivity,
            usage: 'search'
        });
    }
    compare(lhs, rhs) {
        return this.collator.compare(lhs, rhs);
    }
    resolvedLocale() {
        // We create a Collator without "usage: search" because we don't want
        // the search options encoded in our result (e.g. "en-u-co-search")
        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
    }
}

//      
class FormattedSection {
    constructor(text, image, scale, fontStack, textColor) {
        // combine characters so that diacritic marks are not separate code points
        this.text = text.normalize ? text.normalize() : text;
        this.image = image;
        this.scale = scale;
        this.fontStack = fontStack;
        this.textColor = textColor;
    }
}
class Formatted {
    constructor(sections) {
        this.sections = sections;
    }
    static fromString(unformatted) {
        return new Formatted([new FormattedSection(unformatted, null, null, null, null)]);
    }
    isEmpty() {
        if (this.sections.length === 0)
            return true;
        return !this.sections.some(section => section.text.length !== 0 || section.image && section.image.name.length !== 0);
    }
    static factory(text) {
        if (text instanceof Formatted) {
            return text;
        } else {
            return Formatted.fromString(text);
        }
    }
    toString() {
        if (this.sections.length === 0)
            return '';
        return this.sections.map(section => section.text).join('');
    }
    serialize() {
        const serialized = ['format'];
        for (const section of this.sections) {
            if (section.image) {
                serialized.push([
                    'image',
                    section.image.name
                ]);
                continue;
            }
            serialized.push(section.text);
            const options = {};
            if (section.fontStack) {
                options['text-font'] = [
                    'literal',
                    section.fontStack.split(',')
                ];
            }
            if (section.scale) {
                options['font-scale'] = section.scale;
            }
            if (section.textColor) {
                options['text-color'] = ['rgba'].concat(section.textColor.toArray());
            }
            serialized.push(options);
        }
        return serialized;
    }
}

//      
class ResolvedImage {
    constructor(options) {
        this.name = options.name;
        this.available = options.available;
    }
    toString() {
        return this.name;
    }
    static fromString(name) {
        if (!name)
            return null;
        // treat empty values as no image
        return new ResolvedImage({
            name,
            available: false
        });
    }
    serialize() {
        return [
            'image',
            this.name
        ];
    }
}

function validateRGBA(r, g, b, a) {
    if (!(typeof r === 'number' && r >= 0 && r <= 255 && typeof g === 'number' && g >= 0 && g <= 255 && typeof b === 'number' && b >= 0 && b <= 255)) {
        const value = typeof a === 'number' ? [
            r,
            g,
            b,
            a
        ] : [
            r,
            g,
            b
        ];
        return `Invalid rgba value [${ value.join(', ') }]: 'r', 'g', and 'b' must be between 0 and 255.`;
    }
    if (!(typeof a === 'undefined' || typeof a === 'number' && a >= 0 && a <= 1)) {
        return `Invalid rgba value [${ [
            r,
            g,
            b,
            a
        ].join(', ') }]: 'a' must be between 0 and 1.`;
    }
    return null;
}
function isValue(mixed) {
    if (mixed === null) {
        return true;
    } else if (typeof mixed === 'string') {
        return true;
    } else if (typeof mixed === 'boolean') {
        return true;
    } else if (typeof mixed === 'number') {
        return true;
    } else if (mixed instanceof Color$1) {
        return true;
    } else if (mixed instanceof Collator) {
        return true;
    } else if (mixed instanceof Formatted) {
        return true;
    } else if (mixed instanceof ResolvedImage) {
        return true;
    } else if (Array.isArray(mixed)) {
        for (const item of mixed) {
            if (!isValue(item)) {
                return false;
            }
        }
        return true;
    } else if (typeof mixed === 'object') {
        for (const key in mixed) {
            if (!isValue(mixed[key])) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}
function typeOf(value) {
    if (value === null) {
        return NullType;
    } else if (typeof value === 'string') {
        return StringType;
    } else if (typeof value === 'boolean') {
        return BooleanType;
    } else if (typeof value === 'number') {
        return NumberType;
    } else if (value instanceof Color$1) {
        return ColorType;
    } else if (value instanceof Collator) {
        return CollatorType;
    } else if (value instanceof Formatted) {
        return FormattedType;
    } else if (value instanceof ResolvedImage) {
        return ResolvedImageType;
    } else if (Array.isArray(value)) {
        const length = value.length;
        let itemType;
        for (const item of value) {
            const t = typeOf(item);
            if (!itemType) {
                itemType = t;
            } else if (itemType === t) {
                continue;
            } else {
                itemType = ValueType;
                break;
            }
        }
        return array$1(itemType || ValueType, length);
    } else {
        return ObjectType;
    }
}
function toString(value) {
    const type = typeof value;
    if (value === null) {
        return '';
    } else if (type === 'string' || type === 'number' || type === 'boolean') {
        return String(value);
    } else if (value instanceof Color$1 || value instanceof Formatted || value instanceof ResolvedImage) {
        return value.toString();
    } else {
        return JSON.stringify(value);
    }
}

class Literal {
    constructor(type, value) {
        this.type = type;
        this.value = value;
    }
    static parse(args, context) {
        if (args.length !== 2)
            return context.error(`'literal' expression requires exactly one argument, but found ${ args.length - 1 } instead.`);
        if (!isValue(args[1]))
            return context.error(`invalid value`);
        const value = args[1];
        let type = typeOf(value);
        // special case: infer the item type if possible for zero-length arrays
        const expected = context.expectedType;
        if (type.kind === 'array' && type.N === 0 && expected && expected.kind === 'array' && (typeof expected.N !== 'number' || expected.N === 0)) {
            type = expected;
        }
        return new Literal(type, value);
    }
    evaluate() {
        return this.value;
    }
    eachChild() {
    }
    outputDefined() {
        return true;
    }
    serialize() {
        if (this.type.kind === 'array' || this.type.kind === 'object') {
            return [
                'literal',
                this.value
            ];
        } else if (this.value instanceof Color$1) {
            // Constant-folding can generate Literal expressions that you
            // couldn't actually generate with a "literal" expression,
            // so we have to implement an equivalent serialization here
            return ['rgba'].concat(this.value.toArray());
        } else if (this.value instanceof Formatted) {
            // Same as Color
            return this.value.serialize();
        } else {
            return this.value;
        }
    }
}
var Literal$1 = Literal;

//      
class RuntimeError {
    constructor(message) {
        this.name = 'ExpressionEvaluationError';
        this.message = message;
    }
    toJSON() {
        return this.message;
    }
}
var RuntimeError$1 = RuntimeError;

const types$2 = {
    string: StringType,
    number: NumberType,
    boolean: BooleanType,
    object: ObjectType
};
class Assertion {
    constructor(type, args) {
        this.type = type;
        this.args = args;
    }
    static parse(args, context) {
        if (args.length < 2)
            return context.error(`Expected at least one argument.`);
        let i = 1;
        let type;
        const name = args[0];
        if (name === 'array') {
            let itemType;
            if (args.length > 2) {
                const type = args[1];
                if (typeof type !== 'string' || !(type in types$2) || type === 'object')
                    return context.error('The item type argument of "array" must be one of string, number, boolean', 1);
                itemType = types$2[type];
                i++;
            } else {
                itemType = ValueType;
            }
            let N;
            if (args.length > 3) {
                if (args[2] !== null && (typeof args[2] !== 'number' || args[2] < 0 || args[2] !== Math.floor(args[2]))) {
                    return context.error('The length argument to "array" must be a positive integer literal', 2);
                }
                N = args[2];
                i++;
            }
            type = array$1(itemType, N);
        } else {
            type = types$2[name];
        }
        const parsed = [];
        for (; i < args.length; i++) {
            const input = context.parse(args[i], i, ValueType);
            if (!input)
                return null;
            parsed.push(input);
        }
        return new Assertion(type, parsed);
    }
    evaluate(ctx) {
        for (let i = 0; i < this.args.length; i++) {
            const value = this.args[i].evaluate(ctx);
            const error = checkSubtype(this.type, typeOf(value));
            if (!error) {
                return value;
            } else if (i === this.args.length - 1) {
                throw new RuntimeError$1(`Expected value to be of type ${ toString$1(this.type) }, but found ${ toString$1(typeOf(value)) } instead.`);
            }
        }
        return null;
    }
    eachChild(fn) {
        this.args.forEach(fn);
    }
    outputDefined() {
        return this.args.every(arg => arg.outputDefined());
    }
    serialize() {
        const type = this.type;
        const serialized = [type.kind];
        if (type.kind === 'array') {
            const itemType = type.itemType;
            if (itemType.kind === 'string' || itemType.kind === 'number' || itemType.kind === 'boolean') {
                serialized.push(itemType.kind);
                const N = type.N;
                if (typeof N === 'number' || this.args.length > 1) {
                    serialized.push(N);
                }
            }
        }
        return serialized.concat(this.args.map(arg => arg.serialize()));
    }
}
var Assertion$1 = Assertion;

//      
class FormatExpression {
    constructor(sections) {
        this.type = FormattedType;
        this.sections = sections;
    }
    static parse(args, context) {
        if (args.length < 2) {
            return context.error(`Expected at least one argument.`);
        }
        const firstArg = args[1];
        if (!Array.isArray(firstArg) && typeof firstArg === 'object') {
            return context.error(`First argument must be an image or text section.`);
        }
        const sections = [];
        let nextTokenMayBeObject = false;
        for (let i = 1; i <= args.length - 1; ++i) {
            const arg = args[i];
            if (nextTokenMayBeObject && typeof arg === 'object' && !Array.isArray(arg)) {
                nextTokenMayBeObject = false;
                let scale = null;
                if (arg['font-scale']) {
                    scale = context.parse(arg['font-scale'], 1, NumberType);
                    if (!scale)
                        return null;
                }
                let font = null;
                if (arg['text-font']) {
                    font = context.parse(arg['text-font'], 1, array$1(StringType));
                    if (!font)
                        return null;
                }
                let textColor = null;
                if (arg['text-color']) {
                    textColor = context.parse(arg['text-color'], 1, ColorType);
                    if (!textColor)
                        return null;
                }
                const lastExpression = sections[sections.length - 1];
                lastExpression.scale = scale;
                lastExpression.font = font;
                lastExpression.textColor = textColor;
            } else {
                const content = context.parse(args[i], 1, ValueType);
                if (!content)
                    return null;
                const kind = content.type.kind;
                if (kind !== 'string' && kind !== 'value' && kind !== 'null' && kind !== 'resolvedImage')
                    return context.error(`Formatted text type must be 'string', 'value', 'image' or 'null'.`);
                nextTokenMayBeObject = true;
                sections.push({
                    content,
                    scale: null,
                    font: null,
                    textColor: null
                });
            }
        }
        return new FormatExpression(sections);
    }
    evaluate(ctx) {
        const evaluateSection = section => {
            const evaluatedContent = section.content.evaluate(ctx);
            if (typeOf(evaluatedContent) === ResolvedImageType) {
                return new FormattedSection('', evaluatedContent, null, null, null);
            }
            return new FormattedSection(toString(evaluatedContent), null, section.scale ? section.scale.evaluate(ctx) : null, section.font ? section.font.evaluate(ctx).join(',') : null, section.textColor ? section.textColor.evaluate(ctx) : null);
        };
        return new Formatted(this.sections.map(evaluateSection));
    }
    eachChild(fn) {
        for (const section of this.sections) {
            fn(section.content);
            if (section.scale) {
                fn(section.scale);
            }
            if (section.font) {
                fn(section.font);
            }
            if (section.textColor) {
                fn(section.textColor);
            }
        }
    }
    outputDefined() {
        // Technically the combinatoric set of all children
        // Usually, this.text will be undefined anyway
        return false;
    }
    serialize() {
        const serialized = ['format'];
        for (const section of this.sections) {
            serialized.push(section.content.serialize());
            const options = {};
            if (section.scale) {
                options['font-scale'] = section.scale.serialize();
            }
            if (section.font) {
                options['text-font'] = section.font.serialize();
            }
            if (section.textColor) {
                options['text-color'] = section.textColor.serialize();
            }
            serialized.push(options);
        }
        return serialized;
    }
}

//      
class ImageExpression {
    constructor(input) {
        this.type = ResolvedImageType;
        this.input = input;
    }
    static parse(args, context) {
        if (args.length !== 2) {
            return context.error(`Expected two arguments.`);
        }
        const name = context.parse(args[1], 1, StringType);
        if (!name)
            return context.error(`No image name provided.`);
        return new ImageExpression(name);
    }
    evaluate(ctx) {
        const evaluatedImageName = this.input.evaluate(ctx);
        const value = ResolvedImage.fromString(evaluatedImageName);
        if (value && ctx.availableImages)
            value.available = ctx.availableImages.indexOf(evaluatedImageName) > -1;
        return value;
    }
    eachChild(fn) {
        fn(this.input);
    }
    outputDefined() {
        // The output of image is determined by the list of available images in the evaluation context
        return false;
    }
    serialize() {
        return [
            'image',
            this.input.serialize()
        ];
    }
}

const types$1 = {
    'to-boolean': BooleanType,
    'to-color': ColorType,
    'to-number': NumberType,
    'to-string': StringType
};
/**
 * Special form for error-coalescing coercion expressions "to-number",
 * "to-color".  Since these coercions can fail at runtime, they accept multiple
 * arguments, only evaluating one at a time until one succeeds.
 *
 * @private
 */
class Coercion {
    constructor(type, args) {
        this.type = type;
        this.args = args;
    }
    static parse(args, context) {
        if (args.length < 2)
            return context.error(`Expected at least one argument.`);
        const name = args[0];
        if ((name === 'to-boolean' || name === 'to-string') && args.length !== 2)
            return context.error(`Expected one argument.`);
        const type = types$1[name];
        const parsed = [];
        for (let i = 1; i < args.length; i++) {
            const input = context.parse(args[i], i, ValueType);
            if (!input)
                return null;
            parsed.push(input);
        }
        return new Coercion(type, parsed);
    }
    evaluate(ctx) {
        if (this.type.kind === 'boolean') {
            return Boolean(this.args[0].evaluate(ctx));
        } else if (this.type.kind === 'color') {
            let input;
            let error;
            for (const arg of this.args) {
                input = arg.evaluate(ctx);
                error = null;
                if (input instanceof Color$1) {
                    return input;
                } else if (typeof input === 'string') {
                    const c = ctx.parseColor(input);
                    if (c)
                        return c;
                } else if (Array.isArray(input)) {
                    if (input.length < 3 || input.length > 4) {
                        error = `Invalid rbga value ${ JSON.stringify(input) }: expected an array containing either three or four numeric values.`;
                    } else {
                        error = validateRGBA(input[0], input[1], input[2], input[3]);
                    }
                    if (!error) {
                        return new Color$1(input[0] / 255, input[1] / 255, input[2] / 255, input[3]);
                    }
                }
            }
            throw new RuntimeError$1(error || `Could not parse color from value '${ typeof input === 'string' ? input : String(JSON.stringify(input)) }'`);
        } else if (this.type.kind === 'number') {
            let value = null;
            for (const arg of this.args) {
                value = arg.evaluate(ctx);
                if (value === null)
                    return 0;
                const num = Number(value);
                if (isNaN(num))
                    continue;
                return num;
            }
            throw new RuntimeError$1(`Could not convert ${ JSON.stringify(value) } to number.`);
        } else if (this.type.kind === 'formatted') {
            // There is no explicit 'to-formatted' but this coercion can be implicitly
            // created by properties that expect the 'formatted' type.
            return Formatted.fromString(toString(this.args[0].evaluate(ctx)));
        } else if (this.type.kind === 'resolvedImage') {
            return ResolvedImage.fromString(toString(this.args[0].evaluate(ctx)));
        } else {
            return toString(this.args[0].evaluate(ctx));
        }
    }
    eachChild(fn) {
        this.args.forEach(fn);
    }
    outputDefined() {
        return this.args.every(arg => arg.outputDefined());
    }
    serialize() {
        if (this.type.kind === 'formatted') {
            return new FormatExpression([{
                    content: this.args[0],
                    scale: null,
                    font: null,
                    textColor: null
                }]).serialize();
        }
        if (this.type.kind === 'resolvedImage') {
            return new ImageExpression(this.args[0]).serialize();
        }
        const serialized = [`to-${ this.type.kind }`];
        this.eachChild(child => {
            serialized.push(child.serialize());
        });
        return serialized;
    }
}
var Coercion$1 = Coercion;

//      
const geometryTypes = [
    'Unknown',
    'Point',
    'LineString',
    'Polygon'
];
class EvaluationContext {
    constructor() {
        this.globals = null;
        this.feature = null;
        this.featureState = null;
        this.formattedSection = null;
        this._parseColorCache = {};
        this.availableImages = null;
        this.canonical = null;
        this.featureTileCoord = null;
        this.featureDistanceData = null;
    }
    id() {
        return this.feature && this.feature.id !== undefined ? this.feature.id : null;
    }
    geometryType() {
        return this.feature ? typeof this.feature.type === 'number' ? geometryTypes[this.feature.type] : this.feature.type : null;
    }
    geometry() {
        return this.feature && 'geometry' in this.feature ? this.feature.geometry : null;
    }
    canonicalID() {
        return this.canonical;
    }
    properties() {
        return this.feature && this.feature.properties || {};
    }
    distanceFromCenter() {
        if (this.featureTileCoord && this.featureDistanceData) {
            const c = this.featureDistanceData.center;
            const scale = this.featureDistanceData.scale;
            const {x, y} = this.featureTileCoord;
            // Calculate the distance vector `d` (left handed)
            const dX = x * scale - c[0];
            const dY = y * scale - c[1];
            // The bearing vector `b` (left handed)
            const bX = this.featureDistanceData.bearing[0];
            const bY = this.featureDistanceData.bearing[1];
            // Distance is calculated as `dot(d, v)`
            const dist = bX * dX + bY * dY;
            return dist;
        }
        return 0;
    }
    parseColor(input) {
        let cached = this._parseColorCache[input];
        if (!cached) {
            cached = this._parseColorCache[input] = Color$1.parse(input);
        }
        return cached;
    }
}
var EvaluationContext$1 = EvaluationContext;

//      
class CompoundExpression {
    constructor(name, type, evaluate, args) {
        this.name = name;
        this.type = type;
        this._evaluate = evaluate;
        this.args = args;
    }
    evaluate(ctx) {
        return this._evaluate(ctx, this.args);
    }
    eachChild(fn) {
        this.args.forEach(fn);
    }
    outputDefined() {
        return false;
    }
    serialize() {
        return [this.name].concat(this.args.map(arg => arg.serialize()));
    }
    static parse(args, context) {
        const op = args[0];
        const definition = CompoundExpression.definitions[op];
        if (!definition) {
            return context.error(`Unknown expression "${ op }". If you wanted a literal array, use ["literal", [...]].`, 0);
        }
        // Now check argument types against each signature
        const type = Array.isArray(definition) ? definition[0] : definition.type;
        const availableOverloads = Array.isArray(definition) ? [[
                definition[1],
                definition[2]
            ]] : definition.overloads;
        const overloads = availableOverloads.filter(([signature]) => !Array.isArray(signature) || // varags
        signature.length === args.length - 1    // correct param count
);
        let signatureContext = null;
        for (const [params, evaluate] of overloads) {
            // Use a fresh context for each attempted signature so that, if
            // we eventually succeed, we haven't polluted `context.errors`.
            signatureContext = new ParsingContext$1(context.registry, context.path, null, context.scope);
            // First parse all the args, potentially coercing to the
            // types expected by this overload.
            const parsedArgs = [];
            let argParseFailed = false;
            for (let i = 1; i < args.length; i++) {
                const arg = args[i];
                const expectedType = Array.isArray(params) ? params[i - 1] : params.type;
                const parsed = signatureContext.parse(arg, 1 + parsedArgs.length, expectedType);
                if (!parsed) {
                    argParseFailed = true;
                    break;
                }
                parsedArgs.push(parsed);
            }
            if (argParseFailed) {
                // Couldn't coerce args of this overload to expected type, move
                // on to next one.
                continue;
            }
            if (Array.isArray(params)) {
                if (params.length !== parsedArgs.length) {
                    signatureContext.error(`Expected ${ params.length } arguments, but found ${ parsedArgs.length } instead.`);
                    continue;
                }
            }
            for (let i = 0; i < parsedArgs.length; i++) {
                const expected = Array.isArray(params) ? params[i] : params.type;
                const arg = parsedArgs[i];
                signatureContext.concat(i + 1).checkSubtype(expected, arg.type);
            }
            if (signatureContext.errors.length === 0) {
                return new CompoundExpression(op, type, evaluate, parsedArgs);
            }
        }
        if (overloads.length === 1) {
            context.errors.push(...signatureContext.errors);
        } else {
            const expected = overloads.length ? overloads : availableOverloads;
            const signatures = expected.map(([params]) => stringifySignature(params)).join(' | ');
            const actualTypes = [];
            // For error message, re-parse arguments without trying to
            // apply any coercions
            for (let i = 1; i < args.length; i++) {
                const parsed = context.parse(args[i], 1 + actualTypes.length);
                if (!parsed)
                    return null;
                actualTypes.push(toString$1(parsed.type));
            }
            context.error(`Expected arguments of type ${ signatures }, but found (${ actualTypes.join(', ') }) instead.`);
        }
        return null;
    }
    static register(registry, definitions) {
        CompoundExpression.definitions = definitions;
        for (const name in definitions) {
            registry[name] = CompoundExpression;
        }
    }
}
function stringifySignature(signature) {
    if (Array.isArray(signature)) {
        return `(${ signature.map(toString$1).join(', ') })`;
    } else {
        return `(${ toString$1(signature.type) }...)`;
    }
}
var CompoundExpression$1 = CompoundExpression;

//      
class CollatorExpression {
    constructor(caseSensitive, diacriticSensitive, locale) {
        this.type = CollatorType;
        this.locale = locale;
        this.caseSensitive = caseSensitive;
        this.diacriticSensitive = diacriticSensitive;
    }
    static parse(args, context) {
        if (args.length !== 2)
            return context.error(`Expected one argument.`);
        const options = args[1];
        if (typeof options !== 'object' || Array.isArray(options))
            return context.error(`Collator options argument must be an object.`);
        const caseSensitive = context.parse(options['case-sensitive'] === undefined ? false : options['case-sensitive'], 1, BooleanType);
        if (!caseSensitive)
            return null;
        const diacriticSensitive = context.parse(options['diacritic-sensitive'] === undefined ? false : options['diacritic-sensitive'], 1, BooleanType);
        if (!diacriticSensitive)
            return null;
        let locale = null;
        if (options['locale']) {
            locale = context.parse(options['locale'], 1, StringType);
            if (!locale)
                return null;
        }
        return new CollatorExpression(caseSensitive, diacriticSensitive, locale);
    }
    evaluate(ctx) {
        return new Collator(this.caseSensitive.evaluate(ctx), this.diacriticSensitive.evaluate(ctx), this.locale ? this.locale.evaluate(ctx) : null);
    }
    eachChild(fn) {
        fn(this.caseSensitive);
        fn(this.diacriticSensitive);
        if (this.locale) {
            fn(this.locale);
        }
    }
    outputDefined() {
        // Technically the set of possible outputs is the combinatoric set of Collators produced
        // by all possible outputs of locale/caseSensitive/diacriticSensitive
        // But for the primary use of Collators in comparison operators, we ignore the Collator's
        // possible outputs anyway, so we can get away with leaving this false for now.
        return false;
    }
    serialize() {
        const options = {};
        options['case-sensitive'] = this.caseSensitive.serialize();
        options['diacritic-sensitive'] = this.diacriticSensitive.serialize();
        if (this.locale) {
            options['locale'] = this.locale.serialize();
        }
        return [
            'collator',
            options
        ];
    }
}

//      
// minX, minY, maxX, maxY
const EXTENT = 8192;
function updateBBox(bbox, coord) {
    bbox[0] = Math.min(bbox[0], coord[0]);
    bbox[1] = Math.min(bbox[1], coord[1]);
    bbox[2] = Math.max(bbox[2], coord[0]);
    bbox[3] = Math.max(bbox[3], coord[1]);
}
function mercatorXfromLng(lng) {
    return (180 + lng) / 360;
}
function mercatorYfromLat(lat) {
    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;
}
function boxWithinBox(bbox1, bbox2) {
    if (bbox1[0] <= bbox2[0])
        return false;
    if (bbox1[2] >= bbox2[2])
        return false;
    if (bbox1[1] <= bbox2[1])
        return false;
    if (bbox1[3] >= bbox2[3])
        return false;
    return true;
}
function getTileCoordinates(p, canonical) {
    const x = mercatorXfromLng(p[0]);
    const y = mercatorYfromLat(p[1]);
    const tilesAtZoom = Math.pow(2, canonical.z);
    return [
        Math.round(x * tilesAtZoom * EXTENT),
        Math.round(y * tilesAtZoom * EXTENT)
    ];
}
function onBoundary(p, p1, p2) {
    const x1 = p[0] - p1[0];
    const y1 = p[1] - p1[1];
    const x2 = p[0] - p2[0];
    const y2 = p[1] - p2[1];
    return x1 * y2 - x2 * y1 === 0 && x1 * x2 <= 0 && y1 * y2 <= 0;
}
function rayIntersect(p, p1, p2) {
    return p1[1] > p[1] !== p2[1] > p[1] && p[0] < (p2[0] - p1[0]) * (p[1] - p1[1]) / (p2[1] - p1[1]) + p1[0];
}
// ray casting algorithm for detecting if point is in polygon
function pointWithinPolygon(point, rings) {
    let inside = false;
    for (let i = 0, len = rings.length; i < len; i++) {
        const ring = rings[i];
        for (let j = 0, len2 = ring.length; j < len2 - 1; j++) {
            if (onBoundary(point, ring[j], ring[j + 1]))
                return false;
            if (rayIntersect(point, ring[j], ring[j + 1]))
                inside = !inside;
        }
    }
    return inside;
}
function pointWithinPolygons(point, polygons) {
    for (let i = 0; i < polygons.length; i++) {
        if (pointWithinPolygon(point, polygons[i]))
            return true;
    }
    return false;
}
function perp(v1, v2) {
    return v1[0] * v2[1] - v1[1] * v2[0];
}
// check if p1 and p2 are in different sides of line segment q1->q2
function twoSided(p1, p2, q1, q2) {
    // q1->p1 (x1, y1), q1->p2 (x2, y2), q1->q2 (x3, y3)
    const x1 = p1[0] - q1[0];
    const y1 = p1[1] - q1[1];
    const x2 = p2[0] - q1[0];
    const y2 = p2[1] - q1[1];
    const x3 = q2[0] - q1[0];
    const y3 = q2[1] - q1[1];
    const det1 = x1 * y3 - x3 * y1;
    const det2 = x2 * y3 - x3 * y2;
    if (det1 > 0 && det2 < 0 || det1 < 0 && det2 > 0)
        return true;
    return false;
}
// a, b are end points for line segment1, c and d are end points for line segment2
function lineIntersectLine(a, b, c, d) {
    // check if two segments are parallel or not
    // precondition is end point a, b is inside polygon, if line a->b is
    // parallel to polygon edge c->d, then a->b won't intersect with c->d
    const vectorP = [
        b[0] - a[0],
        b[1] - a[1]
    ];
    const vectorQ = [
        d[0] - c[0],
        d[1] - c[1]
    ];
    if (perp(vectorQ, vectorP) === 0)
        return false;
    // If lines are intersecting with each other, the relative location should be:
    // a and b lie in different sides of segment c->d
    // c and d lie in different sides of segment a->b
    if (twoSided(a, b, c, d) && twoSided(c, d, a, b))
        return true;
    return false;
}
function lineIntersectPolygon(p1, p2, polygon) {
    for (const ring of polygon) {
        // loop through every edge of the ring
        for (let j = 0; j < ring.length - 1; ++j) {
            if (lineIntersectLine(p1, p2, ring[j], ring[j + 1])) {
                return true;
            }
        }
    }
    return false;
}
function lineStringWithinPolygon(line, polygon) {
    // First, check if geometry points of line segments are all inside polygon
    for (let i = 0; i < line.length; ++i) {
        if (!pointWithinPolygon(line[i], polygon)) {
            return false;
        }
    }
    // Second, check if there is line segment intersecting polygon edge
    for (let i = 0; i < line.length - 1; ++i) {
        if (lineIntersectPolygon(line[i], line[i + 1], polygon)) {
            return false;
        }
    }
    return true;
}
function lineStringWithinPolygons(line, polygons) {
    for (let i = 0; i < polygons.length; i++) {
        if (lineStringWithinPolygon(line, polygons[i]))
            return true;
    }
    return false;
}
function getTilePolygon(coordinates, bbox, canonical) {
    const polygon = [];
    for (let i = 0; i < coordinates.length; i++) {
        const ring = [];
        for (let j = 0; j < coordinates[i].length; j++) {
            const coord = getTileCoordinates(coordinates[i][j], canonical);
            updateBBox(bbox, coord);
            ring.push(coord);
        }
        polygon.push(ring);
    }
    return polygon;
}
function getTilePolygons(coordinates, bbox, canonical) {
    const polygons = [];
    for (let i = 0; i < coordinates.length; i++) {
        const polygon = getTilePolygon(coordinates[i], bbox, canonical);
        polygons.push(polygon);
    }
    return polygons;
}
function updatePoint(p, bbox, polyBBox, worldSize) {
    if (p[0] < polyBBox[0] || p[0] > polyBBox[2]) {
        const halfWorldSize = worldSize * 0.5;
        let shift = p[0] - polyBBox[0] > halfWorldSize ? -worldSize : polyBBox[0] - p[0] > halfWorldSize ? worldSize : 0;
        if (shift === 0) {
            shift = p[0] - polyBBox[2] > halfWorldSize ? -worldSize : polyBBox[2] - p[0] > halfWorldSize ? worldSize : 0;
        }
        p[0] += shift;
    }
    updateBBox(bbox, p);
}
function resetBBox(bbox) {
    bbox[0] = bbox[1] = Infinity;
    bbox[2] = bbox[3] = -Infinity;
}
function getTilePoints(geometry, pointBBox, polyBBox, canonical) {
    const worldSize = Math.pow(2, canonical.z) * EXTENT;
    const shifts = [
        canonical.x * EXTENT,
        canonical.y * EXTENT
    ];
    const tilePoints = [];
    if (!geometry)
        return tilePoints;
    for (const points of geometry) {
        for (const point of points) {
            const p = [
                point.x + shifts[0],
                point.y + shifts[1]
            ];
            updatePoint(p, pointBBox, polyBBox, worldSize);
            tilePoints.push(p);
        }
    }
    return tilePoints;
}
function getTileLines(geometry, lineBBox, polyBBox, canonical) {
    const worldSize = Math.pow(2, canonical.z) * EXTENT;
    const shifts = [
        canonical.x * EXTENT,
        canonical.y * EXTENT
    ];
    const tileLines = [];
    if (!geometry)
        return tileLines;
    for (const line of geometry) {
        const tileLine = [];
        for (const point of line) {
            const p = [
                point.x + shifts[0],
                point.y + shifts[1]
            ];
            updateBBox(lineBBox, p);
            tileLine.push(p);
        }
        tileLines.push(tileLine);
    }
    if (lineBBox[2] - lineBBox[0] <= worldSize / 2) {
        resetBBox(lineBBox);
        for (const line of tileLines) {
            for (const p of line) {
                updatePoint(p, lineBBox, polyBBox, worldSize);
            }
        }
    }
    return tileLines;
}
function pointsWithinPolygons(ctx, polygonGeometry) {
    const pointBBox = [
        Infinity,
        Infinity,
        -Infinity,
        -Infinity
    ];
    const polyBBox = [
        Infinity,
        Infinity,
        -Infinity,
        -Infinity
    ];
    const canonical = ctx.canonicalID();
    if (!canonical) {
        return false;
    }
    if (polygonGeometry.type === 'Polygon') {
        const tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
        const tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
        if (!boxWithinBox(pointBBox, polyBBox))
            return false;
        for (const point of tilePoints) {
            if (!pointWithinPolygon(point, tilePolygon))
                return false;
        }
    }
    if (polygonGeometry.type === 'MultiPolygon') {
        const tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
        const tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);
        if (!boxWithinBox(pointBBox, polyBBox))
            return false;
        for (const point of tilePoints) {
            if (!pointWithinPolygons(point, tilePolygons))
                return false;
        }
    }
    return true;
}
function linesWithinPolygons(ctx, polygonGeometry) {
    const lineBBox = [
        Infinity,
        Infinity,
        -Infinity,
        -Infinity
    ];
    const polyBBox = [
        Infinity,
        Infinity,
        -Infinity,
        -Infinity
    ];
    const canonical = ctx.canonicalID();
    if (!canonical) {
        return false;
    }
    if (polygonGeometry.type === 'Polygon') {
        const tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);
        const tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
        if (!boxWithinBox(lineBBox, polyBBox))
            return false;
        for (const line of tileLines) {
            if (!lineStringWithinPolygon(line, tilePolygon))
                return false;
        }
    }
    if (polygonGeometry.type === 'MultiPolygon') {
        const tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);
        const tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);
        if (!boxWithinBox(lineBBox, polyBBox))
            return false;
        for (const line of tileLines) {
            if (!lineStringWithinPolygons(line, tilePolygons))
                return false;
        }
    }
    return true;
}
class Within {
    constructor(geojson, geometries) {
        this.type = BooleanType;
        this.geojson = geojson;
        this.geometries = geometries;
    }
    static parse(args, context) {
        if (args.length !== 2)
            return context.error(`'within' expression requires exactly one argument, but found ${ args.length - 1 } instead.`);
        if (isValue(args[1])) {
            const geojson = args[1];
            if (geojson.type === 'FeatureCollection') {
                for (let i = 0; i < geojson.features.length; ++i) {
                    const type = geojson.features[i].geometry.type;
                    if (type === 'Polygon' || type === 'MultiPolygon') {
                        return new Within(geojson, geojson.features[i].geometry);
                    }
                }
            } else if (geojson.type === 'Feature') {
                const type = geojson.geometry.type;
                if (type === 'Polygon' || type === 'MultiPolygon') {
                    return new Within(geojson, geojson.geometry);
                }
            } else if (geojson.type === 'Polygon' || geojson.type === 'MultiPolygon') {
                return new Within(geojson, geojson);
            }
        }
        return context.error(`'within' expression requires valid geojson object that contains polygon geometry type.`);
    }
    evaluate(ctx) {
        if (ctx.geometry() != null && ctx.canonicalID() != null) {
            if (ctx.geometryType() === 'Point') {
                return pointsWithinPolygons(ctx, this.geometries);
            } else if (ctx.geometryType() === 'LineString') {
                return linesWithinPolygons(ctx, this.geometries);
            }
        }
        return false;
    }
    eachChild() {
    }
    outputDefined() {
        return true;
    }
    serialize() {
        return [
            'within',
            this.geojson
        ];
    }
}
var Within$1 = Within;

//      
function isFeatureConstant(e) {
    if (e instanceof CompoundExpression$1) {
        if (e.name === 'get' && e.args.length === 1) {
            return false;
        } else if (e.name === 'feature-state') {
            return false;
        } else if (e.name === 'has' && e.args.length === 1) {
            return false;
        } else if (e.name === 'properties' || e.name === 'geometry-type' || e.name === 'id') {
            return false;
        } else if (/^filter-/.test(e.name)) {
            return false;
        }
    }
    if (e instanceof Within$1) {
        return false;
    }
    let result = true;
    e.eachChild(arg => {
        if (result && !isFeatureConstant(arg)) {
            result = false;
        }
    });
    return result;
}
function isStateConstant(e) {
    if (e instanceof CompoundExpression$1) {
        if (e.name === 'feature-state') {
            return false;
        }
    }
    let result = true;
    e.eachChild(arg => {
        if (result && !isStateConstant(arg)) {
            result = false;
        }
    });
    return result;
}
function isGlobalPropertyConstant(e, properties) {
    if (e instanceof CompoundExpression$1 && properties.indexOf(e.name) >= 0) {
        return false;
    }
    let result = true;
    e.eachChild(arg => {
        if (result && !isGlobalPropertyConstant(arg, properties)) {
            result = false;
        }
    });
    return result;
}

//      
class Var {
    constructor(name, boundExpression) {
        this.type = boundExpression.type;
        this.name = name;
        this.boundExpression = boundExpression;
    }
    static parse(args, context) {
        if (args.length !== 2 || typeof args[1] !== 'string')
            return context.error(`'var' expression requires exactly one string literal argument.`);
        const name = args[1];
        if (!context.scope.has(name)) {
            return context.error(`Unknown variable "${ name }". Make sure "${ name }" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        return new Var(name, context.scope.get(name));
    }
    evaluate(ctx) {
        return this.boundExpression.evaluate(ctx);
    }
    eachChild() {
    }
    outputDefined() {
        return false;
    }
    serialize() {
        return [
            'var',
            this.name
        ];
    }
}
var Var$1 = Var;

//      
/**
 * State associated parsing at a given point in an expression tree.
 * @private
 */
class ParsingContext {
    // The expected type of this expression. Provided only to allow Expression
    // implementations to infer argument types: Expression#parse() need not
    // check that the output type of the parsed expression matches
    // `expectedType`.
    constructor(registry, path = [], expectedType, scope = new Scope$1(), errors = []) {
        this.registry = registry;
        this.path = path;
        this.key = path.map(part => `[${ part }]`).join('');
        this.scope = scope;
        this.errors = errors;
        this.expectedType = expectedType;
    }
    /**
     * @param expr the JSON expression to parse
     * @param index the optional argument index if this expression is an argument of a parent expression that's being parsed
     * @param options
     * @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.
     * @private
     */
    parse(expr, index, expectedType, bindings, options = {}) {
        if (index) {
            return this.concat(index, expectedType, bindings)._parse(expr, options);
        }
        return this._parse(expr, options);
    }
    _parse(expr, options) {
        if (expr === null || typeof expr === 'string' || typeof expr === 'boolean' || typeof expr === 'number') {
            expr = [
                'literal',
                expr
            ];
        }
        function annotate(parsed, type, typeAnnotation) {
            if (typeAnnotation === 'assert') {
                return new Assertion$1(type, [parsed]);
            } else if (typeAnnotation === 'coerce') {
                return new Coercion$1(type, [parsed]);
            } else {
                return parsed;
            }
        }
        if (Array.isArray(expr)) {
            if (expr.length === 0) {
                return this.error(`Expected an array with at least one element. If you wanted a literal array, use ["literal", []].`);
            }
            const op = expr[0];
            if (typeof op !== 'string') {
                this.error(`Expression name must be a string, but found ${ typeof op } instead. If you wanted a literal array, use ["literal", [...]].`, 0);
                return null;
            }
            const Expr = this.registry[op];
            if (Expr) {
                let parsed = Expr.parse(expr, this);
                if (!parsed)
                    return null;
                if (this.expectedType) {
                    const expected = this.expectedType;
                    const actual = parsed.type;
                    // When we expect a number, string, boolean, or array but have a value, wrap it in an assertion.
                    // When we expect a color or formatted string, but have a string or value, wrap it in a coercion.
                    // Otherwise, we do static type-checking.
                    //
                    // These behaviors are overridable for:
                    //   * The "coalesce" operator, which needs to omit type annotations.
                    //   * String-valued properties (e.g. `text-field`), where coercion is more convenient than assertion.
                    //
                    if ((expected.kind === 'string' || expected.kind === 'number' || expected.kind === 'boolean' || expected.kind === 'object' || expected.kind === 'array') && actual.kind === 'value') {
                        parsed = annotate(parsed, expected, options.typeAnnotation || 'assert');
                    } else if ((expected.kind === 'color' || expected.kind === 'formatted' || expected.kind === 'resolvedImage') && (actual.kind === 'value' || actual.kind === 'string')) {
                        parsed = annotate(parsed, expected, options.typeAnnotation || 'coerce');
                    } else if (this.checkSubtype(expected, actual)) {
                        return null;
                    }
                }
                // If an expression's arguments are all literals, we can evaluate
                // it immediately and replace it with a literal value in the
                // parsed/compiled result. Expressions that expect an image should
                // not be resolved here so we can later get the available images.
                if (!(parsed instanceof Literal$1) && parsed.type.kind !== 'resolvedImage' && isConstant(parsed)) {
                    const ec = new EvaluationContext$1();
                    try {
                        parsed = new Literal$1(parsed.type, parsed.evaluate(ec));
                    } catch (e) {
                        this.error(e.message);
                        return null;
                    }
                }
                return parsed;
            }
            return this.error(`Unknown expression "${ op }". If you wanted a literal array, use ["literal", [...]].`, 0);
        } else if (typeof expr === 'undefined') {
            return this.error(`'undefined' value invalid. Use null instead.`);
        } else if (typeof expr === 'object') {
            return this.error(`Bare objects invalid. Use ["literal", {...}] instead.`);
        } else {
            return this.error(`Expected an array, but found ${ typeof expr } instead.`);
        }
    }
    /**
     * Returns a copy of this context suitable for parsing the subexpression at
     * index `index`, optionally appending to 'let' binding map.
     *
     * Note that `errors` property, intended for collecting errors while
     * parsing, is copied by reference rather than cloned.
     * @private
     */
    concat(index, expectedType, bindings) {
        const path = typeof index === 'number' ? this.path.concat(index) : this.path;
        const scope = bindings ? this.scope.concat(bindings) : this.scope;
        return new ParsingContext(this.registry, path, expectedType || null, scope, this.errors);
    }
    /**
     * Push a parsing (or type checking) error into the `this.errors`
     * @param error The message
     * @param keys Optionally specify the source of the error at a child
     * of the current expression at `this.key`.
     * @private
     */
    error(error, ...keys) {
        const key = `${ this.key }${ keys.map(k => `[${ k }]`).join('') }`;
        this.errors.push(new ParsingError$1(key, error));
    }
    /**
     * Returns null if `t` is a subtype of `expected`; otherwise returns an
     * error message and also pushes it to `this.errors`.
     */
    checkSubtype(expected, t) {
        const error = checkSubtype(expected, t);
        if (error)
            this.error(error);
        return error;
    }
}
var ParsingContext$1 = ParsingContext;
function isConstant(expression) {
    if (expression instanceof Var$1) {
        return isConstant(expression.boundExpression);
    } else if (expression instanceof CompoundExpression$1 && expression.name === 'error') {
        return false;
    } else if (expression instanceof CollatorExpression) {
        // Although the results of a Collator expression with fixed arguments
        // generally shouldn't change between executions, we can't serialize them
        // as constant expressions because results change based on environment.
        return false;
    } else if (expression instanceof Within$1) {
        return false;
    }
    const isTypeAnnotation = expression instanceof Coercion$1 || expression instanceof Assertion$1;
    let childrenConstant = true;
    expression.eachChild(child => {
        // We can _almost_ assume that if `expressions` children are constant,
        // they would already have been evaluated to Literal values when they
        // were parsed.  Type annotations are the exception, because they might
        // have been inferred and added after a child was parsed.
        // So we recurse into isConstant() for the children of type annotations,
        // but otherwise simply check whether they are Literals.
        if (isTypeAnnotation) {
            childrenConstant = childrenConstant && isConstant(child);
        } else {
            childrenConstant = childrenConstant && child instanceof Literal$1;
        }
    });
    if (!childrenConstant) {
        return false;
    }
    return isFeatureConstant(expression) && isGlobalPropertyConstant(expression, [
        'zoom',
        'heatmap-density',
        'line-progress',
        'sky-radial-progress',
        'accumulated',
        'is-supported-script',
        'pitch',
        'distance-from-center'
    ]);
}

//      
/**
 * Returns the index of the last stop <= input, or 0 if it doesn't exist.
 * @private
 */
function findStopLessThanOrEqualTo(stops, input) {
    const lastIndex = stops.length - 1;
    let lowerIndex = 0;
    let upperIndex = lastIndex;
    let currentIndex = 0;
    let currentValue, nextValue;
    while (lowerIndex <= upperIndex) {
        currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
        currentValue = stops[currentIndex];
        nextValue = stops[currentIndex + 1];
        if (currentValue <= input) {
            if (currentIndex === lastIndex || input < nextValue) {
                // Search complete
                return currentIndex;
            }
            lowerIndex = currentIndex + 1;
        } else if (currentValue > input) {
            upperIndex = currentIndex - 1;
        } else {
            throw new RuntimeError$1('Input is not a number.');
        }
    }
    return 0;
}

//      
class Step {
    constructor(type, input, stops) {
        this.type = type;
        this.input = input;
        this.labels = [];
        this.outputs = [];
        for (const [label, expression] of stops) {
            this.labels.push(label);
            this.outputs.push(expression);
        }
    }
    static parse(args, context) {
        if (args.length - 1 < 4) {
            return context.error(`Expected at least 4 arguments, but found only ${ args.length - 1 }.`);
        }
        if ((args.length - 1) % 2 !== 0) {
            return context.error(`Expected an even number of arguments.`);
        }
        const input = context.parse(args[1], 1, NumberType);
        if (!input)
            return null;
        const stops = [];
        let outputType = null;
        if (context.expectedType && context.expectedType.kind !== 'value') {
            outputType = context.expectedType;
        }
        for (let i = 1; i < args.length; i += 2) {
            const label = i === 1 ? -Infinity : args[i];
            const value = args[i + 1];
            const labelKey = i;
            const valueKey = i + 1;
            if (typeof label !== 'number') {
                return context.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
            }
            if (stops.length && stops[stops.length - 1][0] >= label) {
                return context.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', labelKey);
            }
            const parsed = context.parse(value, valueKey, outputType);
            if (!parsed)
                return null;
            outputType = outputType || parsed.type;
            stops.push([
                label,
                parsed
            ]);
        }
        return new Step(outputType, input, stops);
    }
    evaluate(ctx) {
        const labels = this.labels;
        const outputs = this.outputs;
        if (labels.length === 1) {
            return outputs[0].evaluate(ctx);
        }
        const value = this.input.evaluate(ctx);
        if (value <= labels[0]) {
            return outputs[0].evaluate(ctx);
        }
        const stopCount = labels.length;
        if (value >= labels[stopCount - 1]) {
            return outputs[stopCount - 1].evaluate(ctx);
        }
        const index = findStopLessThanOrEqualTo(labels, value);
        return outputs[index].evaluate(ctx);
    }
    eachChild(fn) {
        fn(this.input);
        for (const expression of this.outputs) {
            fn(expression);
        }
    }
    outputDefined() {
        return this.outputs.every(out => out.outputDefined());
    }
    serialize() {
        const serialized = [
            'step',
            this.input.serialize()
        ];
        for (let i = 0; i < this.labels.length; i++) {
            if (i > 0) {
                serialized.push(this.labels[i]);
            }
            serialized.push(this.outputs[i].serialize());
        }
        return serialized;
    }
}
var Step$1 = Step;

/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Ported from Webkit
 * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h
 */

var unitbezier = UnitBezier;
function UnitBezier(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    this.cx = 3 * p1x;
    this.bx = 3 * (p2x - p1x) - this.cx;
    this.ax = 1 - this.cx - this.bx;
    this.cy = 3 * p1y;
    this.by = 3 * (p2y - p1y) - this.cy;
    this.ay = 1 - this.cy - this.by;
    this.p1x = p1x;
    this.p1y = p2y;
    this.p2x = p2x;
    this.p2y = p2y;
}
UnitBezier.prototype.sampleCurveX = function (t) {
    // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
    return ((this.ax * t + this.bx) * t + this.cx) * t;
};
UnitBezier.prototype.sampleCurveY = function (t) {
    return ((this.ay * t + this.by) * t + this.cy) * t;
};
UnitBezier.prototype.sampleCurveDerivativeX = function (t) {
    return (3 * this.ax * t + 2 * this.bx) * t + this.cx;
};
UnitBezier.prototype.solveCurveX = function (x, epsilon) {
    if (typeof epsilon === 'undefined')
        epsilon = 0.000001;
    var t0, t1, t2, x2, i;
    // First try a few iterations of Newton's method -- normally very fast.
    for (t2 = x, i = 0; i < 8; i++) {
        x2 = this.sampleCurveX(t2) - x;
        if (Math.abs(x2) < epsilon)
            return t2;
        var d2 = this.sampleCurveDerivativeX(t2);
        if (Math.abs(d2) < 0.000001)
            break;
        t2 = t2 - x2 / d2;
    }
    // Fall back to the bisection method for reliability.
    t0 = 0;
    t1 = 1;
    t2 = x;
    if (t2 < t0)
        return t0;
    if (t2 > t1)
        return t1;
    while (t0 < t1) {
        x2 = this.sampleCurveX(t2);
        if (Math.abs(x2 - x) < epsilon)
            return t2;
        if (x > x2) {
            t0 = t2;
        } else {
            t1 = t2;
        }
        t2 = (t1 - t0) * 0.5 + t0;
    }
    // Failure.
    return t2;
};
UnitBezier.prototype.solve = function (x, epsilon) {
    return this.sampleCurveY(this.solveCurveX(x, epsilon));
};

var UnitBezier$1 = /*@__PURE__*/getDefaultExportFromCjs(unitbezier);

//      
function number(a, b, t) {
    return a * (1 - t) + b * t;
}
function color(from, to, t) {
    return new Color$1(number(from.r, to.r, t), number(from.g, to.g, t), number(from.b, to.b, t), number(from.a, to.a, t));
}
function array(from, to, t) {
    return from.map((d, i) => {
        return number(d, to[i], t);
    });
}

var interpolate = /*#__PURE__*/Object.freeze({
	__proto__: null,
	number: number,
	color: color,
	array: array
});

//      
// Constants
const Xn = 0.95047,
    // D65 standard referent
    Yn = 1, Zn = 1.08883, t0 = 4 / 29, t1 = 6 / 29, t2 = 3 * t1 * t1, t3 = t1 * t1 * t1, deg2rad$1 = Math.PI / 180, rad2deg = 180 / Math.PI;
// Utilities
function xyz2lab(t) {
    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
    return t > t1 ? t * t * t : t2 * (t - t0);
}
function xyz2rgb(x) {
    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2xyz(x) {
    x /= 255;
    return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
// LAB
function rgbToLab(rgbColor) {
    const b = rgb2xyz(rgbColor.r), a = rgb2xyz(rgbColor.g), l = rgb2xyz(rgbColor.b), x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn), y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.072175 * l) / Yn), z = xyz2lab((0.0193339 * b + 0.119192 * a + 0.9503041 * l) / Zn);
    return {
        l: 116 * y - 16,
        a: 500 * (x - y),
        b: 200 * (y - z),
        alpha: rgbColor.a
    };
}
function labToRgb(labColor) {
    let y = (labColor.l + 16) / 116, x = isNaN(labColor.a) ? y : y + labColor.a / 500, z = isNaN(labColor.b) ? y : y - labColor.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new Color$1(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
    xyz2rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), labColor.alpha);
}
function interpolateLab(from, to, t) {
    return {
        l: number(from.l, to.l, t),
        a: number(from.a, to.a, t),
        b: number(from.b, to.b, t),
        alpha: number(from.alpha, to.alpha, t)
    };
}
// HCL
function rgbToHcl(rgbColor) {
    const {l, a, b} = rgbToLab(rgbColor);
    const h = Math.atan2(b, a) * rad2deg;
    return {
        h: h < 0 ? h + 360 : h,
        c: Math.sqrt(a * a + b * b),
        l,
        alpha: rgbColor.a
    };
}
function hclToRgb(hclColor) {
    const h = hclColor.h * deg2rad$1, c = hclColor.c, l = hclColor.l;
    return labToRgb({
        l,
        a: Math.cos(h) * c,
        b: Math.sin(h) * c,
        alpha: hclColor.alpha
    });
}
function interpolateHue(a, b, t) {
    const d = b - a;
    return a + t * (d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d);
}
function interpolateHcl(from, to, t) {
    return {
        h: interpolateHue(from.h, to.h, t),
        c: number(from.c, to.c, t),
        l: number(from.l, to.l, t),
        alpha: number(from.alpha, to.alpha, t)
    };
}
const lab = {
    forward: rgbToLab,
    reverse: labToRgb,
    interpolate: interpolateLab
};
const hcl = {
    forward: rgbToHcl,
    reverse: hclToRgb,
    interpolate: interpolateHcl
};

//      
class Interpolate {
    constructor(type, operator, interpolation, input, stops) {
        this.type = type;
        this.operator = operator;
        this.interpolation = interpolation;
        this.input = input;
        this.labels = [];
        this.outputs = [];
        for (const [label, expression] of stops) {
            this.labels.push(label);
            this.outputs.push(expression);
        }
    }
    static interpolationFactor(interpolation, input, lower, upper) {
        let t = 0;
        if (interpolation.name === 'exponential') {
            t = exponentialInterpolation(input, interpolation.base, lower, upper);
        } else if (interpolation.name === 'linear') {
            t = exponentialInterpolation(input, 1, lower, upper);
        } else if (interpolation.name === 'cubic-bezier') {
            const c = interpolation.controlPoints;
            const ub = new UnitBezier$1(c[0], c[1], c[2], c[3]);
            t = ub.solve(exponentialInterpolation(input, 1, lower, upper));
        }
        return t;
    }
    static parse(args, context) {
        let [operator, interpolation, input, ...rest] = args;
        if (!Array.isArray(interpolation) || interpolation.length === 0) {
            return context.error(`Expected an interpolation type expression.`, 1);
        }
        if (interpolation[0] === 'linear') {
            interpolation = { name: 'linear' };
        } else if (interpolation[0] === 'exponential') {
            const base = interpolation[1];
            if (typeof base !== 'number')
                return context.error(`Exponential interpolation requires a numeric base.`, 1, 1);
            interpolation = {
                name: 'exponential',
                base
            };
        } else if (interpolation[0] === 'cubic-bezier') {
            const controlPoints = interpolation.slice(1);
            if (controlPoints.length !== 4 || controlPoints.some(t => typeof t !== 'number' || t < 0 || t > 1)) {
                return context.error('Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.', 1);
            }
            interpolation = {
                name: 'cubic-bezier',
                controlPoints: controlPoints
            };
        } else {
            return context.error(`Unknown interpolation type ${ String(interpolation[0]) }`, 1, 0);
        }
        if (args.length - 1 < 4) {
            return context.error(`Expected at least 4 arguments, but found only ${ args.length - 1 }.`);
        }
        if ((args.length - 1) % 2 !== 0) {
            return context.error(`Expected an even number of arguments.`);
        }
        input = context.parse(input, 2, NumberType);
        if (!input)
            return null;
        const stops = [];
        let outputType = null;
        if (operator === 'interpolate-hcl' || operator === 'interpolate-lab') {
            outputType = ColorType;
        } else if (context.expectedType && context.expectedType.kind !== 'value') {
            outputType = context.expectedType;
        }
        for (let i = 0; i < rest.length; i += 2) {
            const label = rest[i];
            const value = rest[i + 1];
            const labelKey = i + 3;
            const valueKey = i + 4;
            if (typeof label !== 'number') {
                return context.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);
            }
            if (stops.length && stops[stops.length - 1][0] >= label) {
                return context.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', labelKey);
            }
            const parsed = context.parse(value, valueKey, outputType);
            if (!parsed)
                return null;
            outputType = outputType || parsed.type;
            stops.push([
                label,
                parsed
            ]);
        }
        if (outputType.kind !== 'number' && outputType.kind !== 'color' && !(outputType.kind === 'array' && outputType.itemType.kind === 'number' && typeof outputType.N === 'number')) {
            return context.error(`Type ${ toString$1(outputType) } is not interpolatable.`);
        }
        return new Interpolate(outputType, operator, interpolation, input, stops);
    }
    evaluate(ctx) {
        const labels = this.labels;
        const outputs = this.outputs;
        if (labels.length === 1) {
            return outputs[0].evaluate(ctx);
        }
        const value = this.input.evaluate(ctx);
        if (value <= labels[0]) {
            return outputs[0].evaluate(ctx);
        }
        const stopCount = labels.length;
        if (value >= labels[stopCount - 1]) {
            return outputs[stopCount - 1].evaluate(ctx);
        }
        const index = findStopLessThanOrEqualTo(labels, value);
        const lower = labels[index];
        const upper = labels[index + 1];
        const t = Interpolate.interpolationFactor(this.interpolation, value, lower, upper);
        const outputLower = outputs[index].evaluate(ctx);
        const outputUpper = outputs[index + 1].evaluate(ctx);
        if (this.operator === 'interpolate') {
            return interpolate[this.type.kind.toLowerCase()](outputLower, outputUpper, t);    // eslint-disable-line import/namespace
        } else if (this.operator === 'interpolate-hcl') {
            return hcl.reverse(hcl.interpolate(hcl.forward(outputLower), hcl.forward(outputUpper), t));
        } else {
            return lab.reverse(lab.interpolate(lab.forward(outputLower), lab.forward(outputUpper), t));
        }
    }
    eachChild(fn) {
        fn(this.input);
        for (const expression of this.outputs) {
            fn(expression);
        }
    }
    outputDefined() {
        return this.outputs.every(out => out.outputDefined());
    }
    serialize() {
        let interpolation;
        if (this.interpolation.name === 'linear') {
            interpolation = ['linear'];
        } else if (this.interpolation.name === 'exponential') {
            if (this.interpolation.base === 1) {
                interpolation = ['linear'];
            } else {
                interpolation = [
                    'exponential',
                    this.interpolation.base
                ];
            }
        } else {
            interpolation = ['cubic-bezier'].concat(this.interpolation.controlPoints);
        }
        const serialized = [
            this.operator,
            interpolation,
            this.input.serialize()
        ];
        for (let i = 0; i < this.labels.length; i++) {
            serialized.push(this.labels[i], this.outputs[i].serialize());
        }
        return serialized;
    }
}
/**
 * Returns a ratio that can be used to interpolate between exponential function
 * stops.
 * How it works: Two consecutive stop values define a (scaled and shifted) exponential function `f(x) = a * base^x + b`, where `base` is the user-specified base,
 * and `a` and `b` are constants affording sufficient degrees of freedom to fit
 * the function to the given stops.
 *
 * Here's a bit of algebra that lets us compute `f(x)` directly from the stop
 * values without explicitly solving for `a` and `b`:
 *
 * First stop value: `f(x0) = y0 = a * base^x0 + b`
 * Second stop value: `f(x1) = y1 = a * base^x1 + b`
 * => `y1 - y0 = a(base^x1 - base^x0)`
 * => `a = (y1 - y0)/(base^x1 - base^x0)`
 *
 * Desired value: `f(x) = y = a * base^x + b`
 * => `f(x) = y0 + a * (base^x - base^x0)`
 *
 * From the above, we can replace the `a` in `a * (base^x - base^x0)` and do a
 * little algebra:
 * ```
 * a * (base^x - base^x0) = (y1 - y0)/(base^x1 - base^x0) * (base^x - base^x0)
 *                     = (y1 - y0) * (base^x - base^x0) / (base^x1 - base^x0)
 * ```
 *
 * If we let `(base^x - base^x0) / (base^x1 base^x0)`, then we have
 * `f(x) = y0 + (y1 - y0) * ratio`.  In other words, `ratio` may be treated as
 * an interpolation factor between the two stops' output values.
 *
 * (Note: a slightly different form for `ratio`,
 * `(base^(x-x0) - 1) / (base^(x1-x0) - 1) `, is equivalent, but requires fewer
 * expensive `Math.pow()` operations.)
 *
 * @private
*/
function exponentialInterpolation(input, base, lowerValue, upperValue) {
    const difference = upperValue - lowerValue;
    const progress = input - lowerValue;
    if (difference === 0) {
        return 0;
    } else if (base === 1) {
        return progress / difference;
    } else {
        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
    }
}
var Interpolate$1 = Interpolate;

class Coalesce {
    constructor(type, args) {
        this.type = type;
        this.args = args;
    }
    static parse(args, context) {
        if (args.length < 2) {
            return context.error('Expectected at least one argument.');
        }
        let outputType = null;
        const expectedType = context.expectedType;
        if (expectedType && expectedType.kind !== 'value') {
            outputType = expectedType;
        }
        const parsedArgs = [];
        for (const arg of args.slice(1)) {
            const parsed = context.parse(arg, 1 + parsedArgs.length, outputType, undefined, { typeAnnotation: 'omit' });
            if (!parsed)
                return null;
            outputType = outputType || parsed.type;
            parsedArgs.push(parsed);
        }
        // Above, we parse arguments without inferred type annotation so that
        // they don't produce a runtime error for `null` input, which would
        // preempt the desired null-coalescing behavior.
        // Thus, if any of our arguments would have needed an annotation, we
        // need to wrap the enclosing coalesce expression with it instead.
        const needsAnnotation = expectedType && parsedArgs.some(arg => checkSubtype(expectedType, arg.type));
        return needsAnnotation ? new Coalesce(ValueType, parsedArgs) : new Coalesce(outputType, parsedArgs);
    }
    evaluate(ctx) {
        let result = null;
        let argCount = 0;
        let firstImage;
        for (const arg of this.args) {
            argCount++;
            result = arg.evaluate(ctx);
            // we need to keep track of the first requested image in a coalesce statement
            // if coalesce can't find a valid image, we return the first image so styleimagemissing can fire
            if (result && result instanceof ResolvedImage && !result.available) {
                // set to first image
                if (!firstImage) {
                    firstImage = result;
                }
                result = null;
                // if we reach the end, return the first image
                if (argCount === this.args.length) {
                    return firstImage;
                }
            }
            if (result !== null)
                break;
        }
        return result;
    }
    eachChild(fn) {
        this.args.forEach(fn);
    }
    outputDefined() {
        return this.args.every(arg => arg.outputDefined());
    }
    serialize() {
        const serialized = ['coalesce'];
        this.eachChild(child => {
            serialized.push(child.serialize());
        });
        return serialized;
    }
}
var Coalesce$1 = Coalesce;

//      
class Let {
    constructor(bindings, result) {
        this.type = result.type;
        this.bindings = [].concat(bindings);
        this.result = result;
    }
    evaluate(ctx) {
        return this.result.evaluate(ctx);
    }
    eachChild(fn) {
        for (const binding of this.bindings) {
            fn(binding[1]);
        }
        fn(this.result);
    }
    static parse(args, context) {
        if (args.length < 4)
            return context.error(`Expected at least 3 arguments, but found ${ args.length - 1 } instead.`);
        const bindings = [];
        for (let i = 1; i < args.length - 1; i += 2) {
            const name = args[i];
            if (typeof name !== 'string') {
                return context.error(`Expected string, but found ${ typeof name } instead.`, i);
            }
            if (/[^a-zA-Z0-9_]/.test(name)) {
                return context.error(`Variable names must contain only alphanumeric characters or '_'.`, i);
            }
            const value = context.parse(args[i + 1], i + 1);
            if (!value)
                return null;
            bindings.push([
                name,
                value
            ]);
        }
        const result = context.parse(args[args.length - 1], args.length - 1, context.expectedType, bindings);
        if (!result)
            return null;
        return new Let(bindings, result);
    }
    outputDefined() {
        return this.result.outputDefined();
    }
    serialize() {
        const serialized = ['let'];
        for (const [name, expr] of this.bindings) {
            serialized.push(name, expr.serialize());
        }
        serialized.push(this.result.serialize());
        return serialized;
    }
}
var Let$1 = Let;

//      
class At {
    constructor(type, index, input) {
        this.type = type;
        this.index = index;
        this.input = input;
    }
    static parse(args, context) {
        if (args.length !== 3)
            return context.error(`Expected 2 arguments, but found ${ args.length - 1 } instead.`);
        const index = context.parse(args[1], 1, NumberType);
        const input = context.parse(args[2], 2, array$1(context.expectedType || ValueType));
        if (!index || !input)
            return null;
        const t = input.type;
        return new At(t.itemType, index, input);
    }
    evaluate(ctx) {
        const index = this.index.evaluate(ctx);
        const array = this.input.evaluate(ctx);
        if (index < 0) {
            throw new RuntimeError$1(`Array index out of bounds: ${ index } < 0.`);
        }
        if (index >= array.length) {
            throw new RuntimeError$1(`Array index out of bounds: ${ index } > ${ array.length - 1 }.`);
        }
        if (index !== Math.floor(index)) {
            throw new RuntimeError$1(`Array index must be an integer, but found ${ index } instead.`);
        }
        return array[index];
    }
    eachChild(fn) {
        fn(this.index);
        fn(this.input);
    }
    outputDefined() {
        return false;
    }
    serialize() {
        return [
            'at',
            this.index.serialize(),
            this.input.serialize()
        ];
    }
}
var At$1 = At;

//      
class In {
    constructor(needle, haystack) {
        this.type = BooleanType;
        this.needle = needle;
        this.haystack = haystack;
    }
    static parse(args, context) {
        if (args.length !== 3) {
            return context.error(`Expected 2 arguments, but found ${ args.length - 1 } instead.`);
        }
        const needle = context.parse(args[1], 1, ValueType);
        const haystack = context.parse(args[2], 2, ValueType);
        if (!needle || !haystack)
            return null;
        if (!isValidType(needle.type, [
                BooleanType,
                StringType,
                NumberType,
                NullType,
                ValueType
            ])) {
            return context.error(`Expected first argument to be of type boolean, string, number or null, but found ${ toString$1(needle.type) } instead`);
        }
        return new In(needle, haystack);
    }
    evaluate(ctx) {
        const needle = this.needle.evaluate(ctx);
        const haystack = this.haystack.evaluate(ctx);
        if (haystack == null)
            return false;
        if (!isValidNativeType(needle, [
                'boolean',
                'string',
                'number',
                'null'
            ])) {
            throw new RuntimeError$1(`Expected first argument to be of type boolean, string, number or null, but found ${ toString$1(typeOf(needle)) } instead.`);
        }
        if (!isValidNativeType(haystack, [
                'string',
                'array'
            ])) {
            throw new RuntimeError$1(`Expected second argument to be of type array or string, but found ${ toString$1(typeOf(haystack)) } instead.`);
        }
        return haystack.indexOf(needle) >= 0;
    }
    eachChild(fn) {
        fn(this.needle);
        fn(this.haystack);
    }
    outputDefined() {
        return true;
    }
    serialize() {
        return [
            'in',
            this.needle.serialize(),
            this.haystack.serialize()
        ];
    }
}
var In$1 = In;

//      
class IndexOf {
    constructor(needle, haystack, fromIndex) {
        this.type = NumberType;
        this.needle = needle;
        this.haystack = haystack;
        this.fromIndex = fromIndex;
    }
    static parse(args, context) {
        if (args.length <= 2 || args.length >= 5) {
            return context.error(`Expected 3 or 4 arguments, but found ${ args.length - 1 } instead.`);
        }
        const needle = context.parse(args[1], 1, ValueType);
        const haystack = context.parse(args[2], 2, ValueType);
        if (!needle || !haystack)
            return null;
        if (!isValidType(needle.type, [
                BooleanType,
                StringType,
                NumberType,
                NullType,
                ValueType
            ])) {
            return context.error(`Expected first argument to be of type boolean, string, number or null, but found ${ toString$1(needle.type) } instead`);
        }
        if (args.length === 4) {
            const fromIndex = context.parse(args[3], 3, NumberType);
            if (!fromIndex)
                return null;
            return new IndexOf(needle, haystack, fromIndex);
        } else {
            return new IndexOf(needle, haystack);
        }
    }
    evaluate(ctx) {
        const needle = this.needle.evaluate(ctx);
        const haystack = this.haystack.evaluate(ctx);
        if (!isValidNativeType(needle, [
                'boolean',
                'string',
                'number',
                'null'
            ])) {
            throw new RuntimeError$1(`Expected first argument to be of type boolean, string, number or null, but found ${ toString$1(typeOf(needle)) } instead.`);
        }
        if (!isValidNativeType(haystack, [
                'string',
                'array'
            ])) {
            throw new RuntimeError$1(`Expected second argument to be of type array or string, but found ${ toString$1(typeOf(haystack)) } instead.`);
        }
        if (this.fromIndex) {
            const fromIndex = this.fromIndex.evaluate(ctx);
            return haystack.indexOf(needle, fromIndex);
        }
        return haystack.indexOf(needle);
    }
    eachChild(fn) {
        fn(this.needle);
        fn(this.haystack);
        if (this.fromIndex) {
            fn(this.fromIndex);
        }
    }
    outputDefined() {
        return false;
    }
    serialize() {
        if (this.fromIndex != null && this.fromIndex !== undefined) {
            const fromIndex = this.fromIndex.serialize();
            return [
                'index-of',
                this.needle.serialize(),
                this.haystack.serialize(),
                fromIndex
            ];
        }
        return [
            'index-of',
            this.needle.serialize(),
            this.haystack.serialize()
        ];
    }
}
var IndexOf$1 = IndexOf;

// Map input label values to output expression index
class Match {
    constructor(inputType, outputType, input, cases, outputs, otherwise) {
        this.inputType = inputType;
        this.type = outputType;
        this.input = input;
        this.cases = cases;
        this.outputs = outputs;
        this.otherwise = otherwise;
    }
    static parse(args, context) {
        if (args.length < 5)
            return context.error(`Expected at least 4 arguments, but found only ${ args.length - 1 }.`);
        if (args.length % 2 !== 1)
            return context.error(`Expected an even number of arguments.`);
        let inputType;
        let outputType;
        if (context.expectedType && context.expectedType.kind !== 'value') {
            outputType = context.expectedType;
        }
        const cases = {};
        const outputs = [];
        for (let i = 2; i < args.length - 1; i += 2) {
            let labels = args[i];
            const value = args[i + 1];
            if (!Array.isArray(labels)) {
                labels = [labels];
            }
            const labelContext = context.concat(i);
            if (labels.length === 0) {
                return labelContext.error('Expected at least one branch label.');
            }
            for (const label of labels) {
                if (typeof label !== 'number' && typeof label !== 'string') {
                    return labelContext.error(`Branch labels must be numbers or strings.`);
                } else if (typeof label === 'number' && Math.abs(label) > Number.MAX_SAFE_INTEGER) {
                    return labelContext.error(`Branch labels must be integers no larger than ${ Number.MAX_SAFE_INTEGER }.`);
                } else if (typeof label === 'number' && Math.floor(label) !== label) {
                    return labelContext.error(`Numeric branch labels must be integer values.`);
                } else if (!inputType) {
                    inputType = typeOf(label);
                } else if (labelContext.checkSubtype(inputType, typeOf(label))) {
                    return null;
                }
                if (typeof cases[String(label)] !== 'undefined') {
                    return labelContext.error('Branch labels must be unique.');
                }
                cases[String(label)] = outputs.length;
            }
            const result = context.parse(value, i, outputType);
            if (!result)
                return null;
            outputType = outputType || result.type;
            outputs.push(result);
        }
        const input = context.parse(args[1], 1, ValueType);
        if (!input)
            return null;
        const otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
        if (!otherwise)
            return null;
        if (input.type.kind !== 'value' && context.concat(1).checkSubtype(inputType, input.type)) {
            return null;
        }
        return new Match(inputType, outputType, input, cases, outputs, otherwise);
    }
    evaluate(ctx) {
        const input = this.input.evaluate(ctx);
        const output = typeOf(input) === this.inputType && this.outputs[this.cases[input]] || this.otherwise;
        return output.evaluate(ctx);
    }
    eachChild(fn) {
        fn(this.input);
        this.outputs.forEach(fn);
        fn(this.otherwise);
    }
    outputDefined() {
        return this.outputs.every(out => out.outputDefined()) && this.otherwise.outputDefined();
    }
    serialize() {
        const serialized = [
            'match',
            this.input.serialize()
        ];
        // Sort so serialization has an arbitrary defined order, even though
        // branch order doesn't affect evaluation
        const sortedLabels = Object.keys(this.cases).sort();
        // Group branches by unique match expression to support condensed
        // serializations of the form [case1, case2, ...] -> matchExpression
        const groupedByOutput = [];
        const outputLookup = {};
        // lookup index into groupedByOutput for a given output expression
        for (const label of sortedLabels) {
            const outputIndex = outputLookup[this.cases[label]];
            if (outputIndex === undefined) {
                // First time seeing this output, add it to the end of the grouped list
                outputLookup[this.cases[label]] = groupedByOutput.length;
                groupedByOutput.push([
                    this.cases[label],
                    [label]
                ]);
            } else {
                // We've seen this expression before, add the label to that output's group
                groupedByOutput[outputIndex][1].push(label);
            }
        }
        const coerceLabel = label => this.inputType.kind === 'number' ? Number(label) : label;
        for (const [outputIndex, labels] of groupedByOutput) {
            if (labels.length === 1) {
                // Only a single label matches this output expression
                serialized.push(coerceLabel(labels[0]));
            } else {
                // Array of literal labels pointing to this output expression
                serialized.push(labels.map(coerceLabel));
            }
            serialized.push(this.outputs[outputIndex].serialize());
        }
        serialized.push(this.otherwise.serialize());
        return serialized;
    }
}
var Match$1 = Match;

class Case {
    constructor(type, branches, otherwise) {
        this.type = type;
        this.branches = branches;
        this.otherwise = otherwise;
    }
    static parse(args, context) {
        if (args.length < 4)
            return context.error(`Expected at least 3 arguments, but found only ${ args.length - 1 }.`);
        if (args.length % 2 !== 0)
            return context.error(`Expected an odd number of arguments.`);
        let outputType;
        if (context.expectedType && context.expectedType.kind !== 'value') {
            outputType = context.expectedType;
        }
        const branches = [];
        for (let i = 1; i < args.length - 1; i += 2) {
            const test = context.parse(args[i], i, BooleanType);
            if (!test)
                return null;
            const result = context.parse(args[i + 1], i + 1, outputType);
            if (!result)
                return null;
            branches.push([
                test,
                result
            ]);
            outputType = outputType || result.type;
        }
        const otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);
        if (!otherwise)
            return null;
        return new Case(outputType, branches, otherwise);
    }
    evaluate(ctx) {
        for (const [test, expression] of this.branches) {
            if (test.evaluate(ctx)) {
                return expression.evaluate(ctx);
            }
        }
        return this.otherwise.evaluate(ctx);
    }
    eachChild(fn) {
        for (const [test, expression] of this.branches) {
            fn(test);
            fn(expression);
        }
        fn(this.otherwise);
    }
    outputDefined() {
        return this.branches.every(([_, out]) => out.outputDefined()) && this.otherwise.outputDefined();
    }
    serialize() {
        const serialized = ['case'];
        this.eachChild(child => {
            serialized.push(child.serialize());
        });
        return serialized;
    }
}
var Case$1 = Case;

//      
class Slice {
    constructor(type, input, beginIndex, endIndex) {
        this.type = type;
        this.input = input;
        this.beginIndex = beginIndex;
        this.endIndex = endIndex;
    }
    static parse(args, context) {
        if (args.length <= 2 || args.length >= 5) {
            return context.error(`Expected 3 or 4 arguments, but found ${ args.length - 1 } instead.`);
        }
        const input = context.parse(args[1], 1, ValueType);
        const beginIndex = context.parse(args[2], 2, NumberType);
        if (!input || !beginIndex)
            return null;
        if (!isValidType(input.type, [
                array$1(ValueType),
                StringType,
                ValueType
            ])) {
            return context.error(`Expected first argument to be of type array or string, but found ${ toString$1(input.type) } instead`);
        }
        if (args.length === 4) {
            const endIndex = context.parse(args[3], 3, NumberType);
            if (!endIndex)
                return null;
            return new Slice(input.type, input, beginIndex, endIndex);
        } else {
            return new Slice(input.type, input, beginIndex);
        }
    }
    evaluate(ctx) {
        const input = this.input.evaluate(ctx);
        const beginIndex = this.beginIndex.evaluate(ctx);
        if (!isValidNativeType(input, [
                'string',
                'array'
            ])) {
            throw new RuntimeError$1(`Expected first argument to be of type array or string, but found ${ toString$1(typeOf(input)) } instead.`);
        }
        if (this.endIndex) {
            const endIndex = this.endIndex.evaluate(ctx);
            return input.slice(beginIndex, endIndex);
        }
        return input.slice(beginIndex);
    }
    eachChild(fn) {
        fn(this.input);
        fn(this.beginIndex);
        if (this.endIndex) {
            fn(this.endIndex);
        }
    }
    outputDefined() {
        return false;
    }
    serialize() {
        if (this.endIndex != null && this.endIndex !== undefined) {
            const endIndex = this.endIndex.serialize();
            return [
                'slice',
                this.input.serialize(),
                this.beginIndex.serialize(),
                endIndex
            ];
        }
        return [
            'slice',
            this.input.serialize(),
            this.beginIndex.serialize()
        ];
    }
}
var Slice$1 = Slice;

//      
function isComparableType(op, type) {
    if (op === '==' || op === '!=') {
        // equality operator
        return type.kind === 'boolean' || type.kind === 'string' || type.kind === 'number' || type.kind === 'null' || type.kind === 'value';
    } else {
        // ordering operator
        return type.kind === 'string' || type.kind === 'number' || type.kind === 'value';
    }
}
function eq(ctx, a, b) {
    return a === b;
}
function neq(ctx, a, b) {
    return a !== b;
}
function lt(ctx, a, b) {
    return a < b;
}
function gt(ctx, a, b) {
    return a > b;
}
function lteq(ctx, a, b) {
    return a <= b;
}
function gteq(ctx, a, b) {
    return a >= b;
}
function eqCollate(ctx, a, b, c) {
    return c.compare(a, b) === 0;
}
function neqCollate(ctx, a, b, c) {
    return !eqCollate(ctx, a, b, c);
}
function ltCollate(ctx, a, b, c) {
    return c.compare(a, b) < 0;
}
function gtCollate(ctx, a, b, c) {
    return c.compare(a, b) > 0;
}
function lteqCollate(ctx, a, b, c) {
    return c.compare(a, b) <= 0;
}
function gteqCollate(ctx, a, b, c) {
    return c.compare(a, b) >= 0;
}
/**
 * Special form for comparison operators, implementing the signatures:
 * - (T, T, ?Collator) => boolean
 * - (T, value, ?Collator) => boolean
 * - (value, T, ?Collator) => boolean
 *
 * For inequalities, T must be either value, string, or number. For ==/!=, it
 * can also be boolean or null.
 *
 * Equality semantics are equivalent to Javascript's strict equality (===/!==)
 * -- i.e., when the arguments' types don't match, == evaluates to false, != to
 * true.
 *
 * When types don't match in an ordering comparison, a runtime error is thrown.
 *
 * @private
 */
function makeComparison(op, compareBasic, compareWithCollator) {
    const isOrderComparison = op !== '==' && op !== '!=';
    return class Comparison {
        constructor(lhs, rhs, collator) {
            this.type = BooleanType;
            this.lhs = lhs;
            this.rhs = rhs;
            this.collator = collator;
            this.hasUntypedArgument = lhs.type.kind === 'value' || rhs.type.kind === 'value';
        }
        static parse(args, context) {
            if (args.length !== 3 && args.length !== 4)
                return context.error(`Expected two or three arguments.`);
            const op = args[0];
            let lhs = context.parse(args[1], 1, ValueType);
            if (!lhs)
                return null;
            if (!isComparableType(op, lhs.type)) {
                return context.concat(1).error(`"${ op }" comparisons are not supported for type '${ toString$1(lhs.type) }'.`);
            }
            let rhs = context.parse(args[2], 2, ValueType);
            if (!rhs)
                return null;
            if (!isComparableType(op, rhs.type)) {
                return context.concat(2).error(`"${ op }" comparisons are not supported for type '${ toString$1(rhs.type) }'.`);
            }
            if (lhs.type.kind !== rhs.type.kind && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
                return context.error(`Cannot compare types '${ toString$1(lhs.type) }' and '${ toString$1(rhs.type) }'.`);
            }
            if (isOrderComparison) {
                // typing rules specific to less/greater than operators
                if (lhs.type.kind === 'value' && rhs.type.kind !== 'value') {
                    // (value, T)
                    lhs = new Assertion$1(rhs.type, [lhs]);
                } else if (lhs.type.kind !== 'value' && rhs.type.kind === 'value') {
                    // (T, value)
                    rhs = new Assertion$1(lhs.type, [rhs]);
                }
            }
            let collator = null;
            if (args.length === 4) {
                if (lhs.type.kind !== 'string' && rhs.type.kind !== 'string' && lhs.type.kind !== 'value' && rhs.type.kind !== 'value') {
                    return context.error(`Cannot use collator to compare non-string types.`);
                }
                collator = context.parse(args[3], 3, CollatorType);
                if (!collator)
                    return null;
            }
            return new Comparison(lhs, rhs, collator);
        }
        evaluate(ctx) {
            const lhs = this.lhs.evaluate(ctx);
            const rhs = this.rhs.evaluate(ctx);
            if (isOrderComparison && this.hasUntypedArgument) {
                const lt = typeOf(lhs);
                const rt = typeOf(rhs);
                // check that type is string or number, and equal
                if (lt.kind !== rt.kind || !(lt.kind === 'string' || lt.kind === 'number')) {
                    throw new RuntimeError$1(`Expected arguments for "${ op }" to be (string, string) or (number, number), but found (${ lt.kind }, ${ rt.kind }) instead.`);
                }
            }
            if (this.collator && !isOrderComparison && this.hasUntypedArgument) {
                const lt = typeOf(lhs);
                const rt = typeOf(rhs);
                if (lt.kind !== 'string' || rt.kind !== 'string') {
                    return compareBasic(ctx, lhs, rhs);
                }
            }
            return this.collator ? compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) : compareBasic(ctx, lhs, rhs);
        }
        eachChild(fn) {
            fn(this.lhs);
            fn(this.rhs);
            if (this.collator) {
                fn(this.collator);
            }
        }
        outputDefined() {
            return true;
        }
        serialize() {
            const serialized = [op];
            this.eachChild(child => {
                serialized.push(child.serialize());
            });
            return serialized;
        }
    };
}
const Equals = makeComparison('==', eq, eqCollate);
const NotEquals = makeComparison('!=', neq, neqCollate);
const LessThan = makeComparison('<', lt, ltCollate);
const GreaterThan = makeComparison('>', gt, gtCollate);
const LessThanOrEqual = makeComparison('<=', lteq, lteqCollate);
const GreaterThanOrEqual = makeComparison('>=', gteq, gteqCollate);

//      
class NumberFormat {
    // BCP 47 language tag
    // ISO 4217 currency code, required if style=currency
    // Simple units sanctioned for use in ECMAScript, required if style=unit. https://tc39.es/proposal-unified-intl-numberformat/section6/locales-currencies-tz_proposed_out.html#sec-issanctionedsimpleunitidentifier
    // Default 0
    // Default 3
    constructor(number, locale, currency, unit, minFractionDigits, maxFractionDigits) {
        this.type = StringType;
        this.number = number;
        this.locale = locale;
        this.currency = currency;
        this.unit = unit;
        this.minFractionDigits = minFractionDigits;
        this.maxFractionDigits = maxFractionDigits;
    }
    static parse(args, context) {
        if (args.length !== 3)
            return context.error(`Expected two arguments.`);
        const number = context.parse(args[1], 1, NumberType);
        if (!number)
            return null;
        const options = args[2];
        if (typeof options !== 'object' || Array.isArray(options))
            return context.error(`NumberFormat options argument must be an object.`);
        let locale = null;
        if (options['locale']) {
            locale = context.parse(options['locale'], 1, StringType);
            if (!locale)
                return null;
        }
        let currency = null;
        if (options['currency']) {
            currency = context.parse(options['currency'], 1, StringType);
            if (!currency)
                return null;
        }
        let unit = null;
        if (options['unit']) {
            unit = context.parse(options['unit'], 1, StringType);
            if (!unit)
                return null;
        }
        let minFractionDigits = null;
        if (options['min-fraction-digits']) {
            minFractionDigits = context.parse(options['min-fraction-digits'], 1, NumberType);
            if (!minFractionDigits)
                return null;
        }
        let maxFractionDigits = null;
        if (options['max-fraction-digits']) {
            maxFractionDigits = context.parse(options['max-fraction-digits'], 1, NumberType);
            if (!maxFractionDigits)
                return null;
        }
        return new NumberFormat(number, locale, currency, unit, minFractionDigits, maxFractionDigits);
    }
    evaluate(ctx) {
        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(ctx) : [], {
            style: this.currency && 'currency' || this.unit && 'unit' || 'decimal',
            currency: this.currency ? this.currency.evaluate(ctx) : undefined,
            unit: this.unit ? this.unit.evaluate(ctx) : undefined,
            minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(ctx) : undefined,
            maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(ctx) : undefined
        }).format(this.number.evaluate(ctx));
    }
    eachChild(fn) {
        fn(this.number);
        if (this.locale) {
            fn(this.locale);
        }
        if (this.currency) {
            fn(this.currency);
        }
        if (this.unit) {
            fn(this.unit);
        }
        if (this.minFractionDigits) {
            fn(this.minFractionDigits);
        }
        if (this.maxFractionDigits) {
            fn(this.maxFractionDigits);
        }
    }
    outputDefined() {
        return false;
    }
    serialize() {
        const options = {};
        if (this.locale) {
            options['locale'] = this.locale.serialize();
        }
        if (this.currency) {
            options['currency'] = this.currency.serialize();
        }
        if (this.unit) {
            options['unit'] = this.unit.serialize();
        }
        if (this.minFractionDigits) {
            options['min-fraction-digits'] = this.minFractionDigits.serialize();
        }
        if (this.maxFractionDigits) {
            options['max-fraction-digits'] = this.maxFractionDigits.serialize();
        }
        return [
            'number-format',
            this.number.serialize(),
            options
        ];
    }
}

//      
class Length {
    constructor(input) {
        this.type = NumberType;
        this.input = input;
    }
    static parse(args, context) {
        if (args.length !== 2)
            return context.error(`Expected 1 argument, but found ${ args.length - 1 } instead.`);
        const input = context.parse(args[1], 1);
        if (!input)
            return null;
        if (input.type.kind !== 'array' && input.type.kind !== 'string' && input.type.kind !== 'value')
            return context.error(`Expected argument of type string or array, but found ${ toString$1(input.type) } instead.`);
        return new Length(input);
    }
    evaluate(ctx) {
        const input = this.input.evaluate(ctx);
        if (typeof input === 'string') {
            return input.length;
        } else if (Array.isArray(input)) {
            return input.length;
        } else {
            throw new RuntimeError$1(`Expected value to be of type string or array, but found ${ toString$1(typeOf(input)) } instead.`);
        }
    }
    eachChild(fn) {
        fn(this.input);
    }
    outputDefined() {
        return false;
    }
    serialize() {
        const serialized = ['length'];
        this.eachChild(child => {
            serialized.push(child.serialize());
        });
        return serialized;
    }
}
var Length$1 = Length;

//      
const expressions = {
    // special forms
    '==': Equals,
    '!=': NotEquals,
    '>': GreaterThan,
    '<': LessThan,
    '>=': GreaterThanOrEqual,
    '<=': LessThanOrEqual,
    'array': Assertion$1,
    'at': At$1,
    'boolean': Assertion$1,
    'case': Case$1,
    'coalesce': Coalesce$1,
    'collator': CollatorExpression,
    'format': FormatExpression,
    'image': ImageExpression,
    'in': In$1,
    'index-of': IndexOf$1,
    'interpolate': Interpolate$1,
    'interpolate-hcl': Interpolate$1,
    'interpolate-lab': Interpolate$1,
    'length': Length$1,
    'let': Let$1,
    'literal': Literal$1,
    'match': Match$1,
    'number': Assertion$1,
    'number-format': NumberFormat,
    'object': Assertion$1,
    'slice': Slice$1,
    'step': Step$1,
    'string': Assertion$1,
    'to-boolean': Coercion$1,
    'to-color': Coercion$1,
    'to-number': Coercion$1,
    'to-string': Coercion$1,
    'var': Var$1,
    'within': Within$1
};
function rgba(ctx, [r, g, b, a]) {
    r = r.evaluate(ctx);
    g = g.evaluate(ctx);
    b = b.evaluate(ctx);
    const alpha = a ? a.evaluate(ctx) : 1;
    const error = validateRGBA(r, g, b, alpha);
    if (error)
        throw new RuntimeError$1(error);
    return new Color$1(r / 255 * alpha, g / 255 * alpha, b / 255 * alpha, alpha);
}
function has(key, obj) {
    return key in obj;
}
function get(key, obj) {
    const v = obj[key];
    return typeof v === 'undefined' ? null : v;
}
function binarySearch(v, a, i, j) {
    while (i <= j) {
        const m = i + j >> 1;
        if (a[m] === v)
            return true;
        if (a[m] > v)
            j = m - 1;
        else
            i = m + 1;
    }
    return false;
}
function varargs(type) {
    return { type };
}
CompoundExpression$1.register(expressions, {
    'error': [
        ErrorType,
        [StringType],
        (ctx, [v]) => {
            throw new RuntimeError$1(v.evaluate(ctx));
        }
    ],
    'typeof': [
        StringType,
        [ValueType],
        (ctx, [v]) => toString$1(typeOf(v.evaluate(ctx)))
    ],
    'to-rgba': [
        array$1(NumberType, 4),
        [ColorType],
        (ctx, [v]) => {
            return v.evaluate(ctx).toArray();
        }
    ],
    'rgb': [
        ColorType,
        [
            NumberType,
            NumberType,
            NumberType
        ],
        rgba
    ],
    'rgba': [
        ColorType,
        [
            NumberType,
            NumberType,
            NumberType,
            NumberType
        ],
        rgba
    ],
    'has': {
        type: BooleanType,
        overloads: [
            [
                [StringType],
                (ctx, [key]) => has(key.evaluate(ctx), ctx.properties())
            ],
            [
                [
                    StringType,
                    ObjectType
                ],
                (ctx, [key, obj]) => has(key.evaluate(ctx), obj.evaluate(ctx))
            ]
        ]
    },
    'get': {
        type: ValueType,
        overloads: [
            [
                [StringType],
                (ctx, [key]) => get(key.evaluate(ctx), ctx.properties())
            ],
            [
                [
                    StringType,
                    ObjectType
                ],
                (ctx, [key, obj]) => get(key.evaluate(ctx), obj.evaluate(ctx))
            ]
        ]
    },
    'feature-state': [
        ValueType,
        [StringType],
        (ctx, [key]) => get(key.evaluate(ctx), ctx.featureState || {})
    ],
    'properties': [
        ObjectType,
        [],
        ctx => ctx.properties()
    ],
    'geometry-type': [
        StringType,
        [],
        ctx => ctx.geometryType()
    ],
    'id': [
        ValueType,
        [],
        ctx => ctx.id()
    ],
    'zoom': [
        NumberType,
        [],
        ctx => ctx.globals.zoom
    ],
    'pitch': [
        NumberType,
        [],
        ctx => ctx.globals.pitch || 0
    ],
    'distance-from-center': [
        NumberType,
        [],
        ctx => ctx.distanceFromCenter()
    ],
    'heatmap-density': [
        NumberType,
        [],
        ctx => ctx.globals.heatmapDensity || 0
    ],
    'line-progress': [
        NumberType,
        [],
        ctx => ctx.globals.lineProgress || 0
    ],
    'sky-radial-progress': [
        NumberType,
        [],
        ctx => ctx.globals.skyRadialProgress || 0
    ],
    'accumulated': [
        ValueType,
        [],
        ctx => ctx.globals.accumulated === undefined ? null : ctx.globals.accumulated
    ],
    '+': [
        NumberType,
        varargs(NumberType),
        (ctx, args) => {
            let result = 0;
            for (const arg of args) {
                result += arg.evaluate(ctx);
            }
            return result;
        }
    ],
    '*': [
        NumberType,
        varargs(NumberType),
        (ctx, args) => {
            let result = 1;
            for (const arg of args) {
                result *= arg.evaluate(ctx);
            }
            return result;
        }
    ],
    '-': {
        type: NumberType,
        overloads: [
            [
                [
                    NumberType,
                    NumberType
                ],
                (ctx, [a, b]) => a.evaluate(ctx) - b.evaluate(ctx)
            ],
            [
                [NumberType],
                (ctx, [a]) => -a.evaluate(ctx)
            ]
        ]
    },
    '/': [
        NumberType,
        [
            NumberType,
            NumberType
        ],
        (ctx, [a, b]) => a.evaluate(ctx) / b.evaluate(ctx)
    ],
    '%': [
        NumberType,
        [
            NumberType,
            NumberType
        ],
        (ctx, [a, b]) => a.evaluate(ctx) % b.evaluate(ctx)
    ],
    'ln2': [
        NumberType,
        [],
        () => Math.LN2
    ],
    'pi': [
        NumberType,
        [],
        () => Math.PI
    ],
    'e': [
        NumberType,
        [],
        () => Math.E
    ],
    '^': [
        NumberType,
        [
            NumberType,
            NumberType
        ],
        (ctx, [b, e]) => Math.pow(b.evaluate(ctx), e.evaluate(ctx))
    ],
    'sqrt': [
        NumberType,
        [NumberType],
        (ctx, [x]) => Math.sqrt(x.evaluate(ctx))
    ],
    'log10': [
        NumberType,
        [NumberType],
        (ctx, [n]) => Math.log(n.evaluate(ctx)) / Math.LN10
    ],
    'ln': [
        NumberType,
        [NumberType],
        (ctx, [n]) => Math.log(n.evaluate(ctx))
    ],
    'log2': [
        NumberType,
        [NumberType],
        (ctx, [n]) => Math.log(n.evaluate(ctx)) / Math.LN2
    ],
    'sin': [
        NumberType,
        [NumberType],
        (ctx, [n]) => Math.sin(n.evaluate(ctx))
    ],
    'cos': [
        NumberType,
        [NumberType],
        (ctx, [n]) => Math.cos(n.evaluate(ctx))
    ],
    'tan': [
        NumberType,
        [NumberType],
        (ctx, [n]) => Math.tan(n.evaluate(ctx))
    ],
    'asin': [
        NumberType,
        [NumberType],
        (ctx, [n]) => Math.asin(n.evaluate(ctx))
    ],
    'acos': [
        NumberType,
        [NumberType],
        (ctx, [n]) => Math.acos(n.evaluate(ctx))
    ],
    'atan': [
        NumberType,
        [NumberType],
        (ctx, [n]) => Math.atan(n.evaluate(ctx))
    ],
    'min': [
        NumberType,
        varargs(NumberType),
        (ctx, args) => Math.min(...args.map(arg => arg.evaluate(ctx)))
    ],
    'max': [
        NumberType,
        varargs(NumberType),
        (ctx, args) => Math.max(...args.map(arg => arg.evaluate(ctx)))
    ],
    'abs': [
        NumberType,
        [NumberType],
        (ctx, [n]) => Math.abs(n.evaluate(ctx))
    ],
    'round': [
        NumberType,
        [NumberType],
        (ctx, [n]) => {
            const v = n.evaluate(ctx);
            // Javascript's Math.round() rounds towards +Infinity for halfway
            // values, even when they're negative. It's more common to round
            // away from 0 (e.g., this is what python and C++ do)
            return v < 0 ? -Math.round(-v) : Math.round(v);
        }
    ],
    'floor': [
        NumberType,
        [NumberType],
        (ctx, [n]) => Math.floor(n.evaluate(ctx))
    ],
    'ceil': [
        NumberType,
        [NumberType],
        (ctx, [n]) => Math.ceil(n.evaluate(ctx))
    ],
    'filter-==': [
        BooleanType,
        [
            StringType,
            ValueType
        ],
        (ctx, [k, v]) => ctx.properties()[k.value] === v.value
    ],
    'filter-id-==': [
        BooleanType,
        [ValueType],
        (ctx, [v]) => ctx.id() === v.value
    ],
    'filter-type-==': [
        BooleanType,
        [StringType],
        (ctx, [v]) => ctx.geometryType() === v.value
    ],
    'filter-<': [
        BooleanType,
        [
            StringType,
            ValueType
        ],
        (ctx, [k, v]) => {
            const a = ctx.properties()[k.value];
            const b = v.value;
            return typeof a === typeof b && a < b;
        }
    ],
    'filter-id-<': [
        BooleanType,
        [ValueType],
        (ctx, [v]) => {
            const a = ctx.id();
            const b = v.value;
            return typeof a === typeof b && a < b;
        }
    ],
    'filter->': [
        BooleanType,
        [
            StringType,
            ValueType
        ],
        (ctx, [k, v]) => {
            const a = ctx.properties()[k.value];
            const b = v.value;
            return typeof a === typeof b && a > b;
        }
    ],
    'filter-id->': [
        BooleanType,
        [ValueType],
        (ctx, [v]) => {
            const a = ctx.id();
            const b = v.value;
            return typeof a === typeof b && a > b;
        }
    ],
    'filter-<=': [
        BooleanType,
        [
            StringType,
            ValueType
        ],
        (ctx, [k, v]) => {
            const a = ctx.properties()[k.value];
            const b = v.value;
            return typeof a === typeof b && a <= b;
        }
    ],
    'filter-id-<=': [
        BooleanType,
        [ValueType],
        (ctx, [v]) => {
            const a = ctx.id();
            const b = v.value;
            return typeof a === typeof b && a <= b;
        }
    ],
    'filter->=': [
        BooleanType,
        [
            StringType,
            ValueType
        ],
        (ctx, [k, v]) => {
            const a = ctx.properties()[k.value];
            const b = v.value;
            return typeof a === typeof b && a >= b;
        }
    ],
    'filter-id->=': [
        BooleanType,
        [ValueType],
        (ctx, [v]) => {
            const a = ctx.id();
            const b = v.value;
            return typeof a === typeof b && a >= b;
        }
    ],
    'filter-has': [
        BooleanType,
        [ValueType],
        (ctx, [k]) => k.value in ctx.properties()
    ],
    'filter-has-id': [
        BooleanType,
        [],
        ctx => ctx.id() !== null && ctx.id() !== undefined
    ],
    'filter-type-in': [
        BooleanType,
        [array$1(StringType)],
        (ctx, [v]) => v.value.indexOf(ctx.geometryType()) >= 0
    ],
    'filter-id-in': [
        BooleanType,
        [array$1(ValueType)],
        (ctx, [v]) => v.value.indexOf(ctx.id()) >= 0
    ],
    'filter-in-small': [
        BooleanType,
        [
            StringType,
            array$1(ValueType)
        ],
        // assumes v is an array literal
        (ctx, [k, v]) => v.value.indexOf(ctx.properties()[k.value]) >= 0
    ],
    'filter-in-large': [
        BooleanType,
        [
            StringType,
            array$1(ValueType)
        ],
        // assumes v is a array literal with values sorted in ascending order and of a single type
        (ctx, [k, v]) => binarySearch(ctx.properties()[k.value], v.value, 0, v.value.length - 1)
    ],
    'all': {
        type: BooleanType,
        overloads: [
            [
                [
                    BooleanType,
                    BooleanType
                ],
                (ctx, [a, b]) => a.evaluate(ctx) && b.evaluate(ctx)
            ],
            [
                varargs(BooleanType),
                (ctx, args) => {
                    for (const arg of args) {
                        if (!arg.evaluate(ctx))
                            return false;
                    }
                    return true;
                }
            ]
        ]
    },
    'any': {
        type: BooleanType,
        overloads: [
            [
                [
                    BooleanType,
                    BooleanType
                ],
                (ctx, [a, b]) => a.evaluate(ctx) || b.evaluate(ctx)
            ],
            [
                varargs(BooleanType),
                (ctx, args) => {
                    for (const arg of args) {
                        if (arg.evaluate(ctx))
                            return true;
                    }
                    return false;
                }
            ]
        ]
    },
    '!': [
        BooleanType,
        [BooleanType],
        (ctx, [b]) => !b.evaluate(ctx)
    ],
    'is-supported-script': [
        BooleanType,
        [StringType],
        // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant
        (ctx, [s]) => {
            const isSupportedScript = ctx.globals && ctx.globals.isSupportedScript;
            if (isSupportedScript) {
                return isSupportedScript(s.evaluate(ctx));
            }
            return true;
        }
    ],
    'upcase': [
        StringType,
        [StringType],
        (ctx, [s]) => s.evaluate(ctx).toUpperCase()
    ],
    'downcase': [
        StringType,
        [StringType],
        (ctx, [s]) => s.evaluate(ctx).toLowerCase()
    ],
    'concat': [
        StringType,
        varargs(ValueType),
        (ctx, args) => args.map(arg => toString(arg.evaluate(ctx))).join('')
    ],
    'resolved-locale': [
        StringType,
        [CollatorType],
        (ctx, [collator]) => collator.evaluate(ctx).resolvedLocale()
    ]
});
var definitions = expressions;

//      
/**
 * A type used for returning and propagating errors. The first element of the union
 * represents success and contains a value, and the second represents an error and
 * contains an error value.
 * @private
 */
function success(value) {
    return {
        result: 'success',
        value
    };
}
function error(value) {
    return {
        result: 'error',
        value
    };
}

//      
function supportsPropertyExpression(spec) {
    return spec['property-type'] === 'data-driven';
}
function supportsZoomExpression(spec) {
    return !!spec.expression && spec.expression.parameters.indexOf('zoom') > -1;
}
function supportsInterpolation(spec) {
    return !!spec.expression && spec.expression.interpolated;
}

function isFunction(value) {
    return typeof value === 'object' && value !== null && !Array.isArray(value);
}

class StyleExpression {
    constructor(expression, propertySpec) {
        this.expression = expression;
        this._warningHistory = {};
        this._evaluator = new EvaluationContext$1();
        this._defaultValue = propertySpec ? getDefaultValue(propertySpec) : null;
        this._enumValues = propertySpec && propertySpec.type === 'enum' ? propertySpec.values : null;
    }
    evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection, featureTileCoord, featureDistanceData) {
        this._evaluator.globals = globals;
        this._evaluator.feature = feature;
        this._evaluator.featureState = featureState;
        this._evaluator.canonical = canonical || null;
        this._evaluator.availableImages = availableImages || null;
        this._evaluator.formattedSection = formattedSection;
        this._evaluator.featureTileCoord = featureTileCoord || null;
        this._evaluator.featureDistanceData = featureDistanceData || null;
        return this.expression.evaluate(this._evaluator);
    }
    evaluate(globals, feature, featureState, canonical, availableImages, formattedSection, featureTileCoord, featureDistanceData) {
        this._evaluator.globals = globals;
        this._evaluator.feature = feature || null;
        this._evaluator.featureState = featureState || null;
        this._evaluator.canonical = canonical || null;
        this._evaluator.availableImages = availableImages || null;
        this._evaluator.formattedSection = formattedSection || null;
        this._evaluator.featureTileCoord = featureTileCoord || null;
        this._evaluator.featureDistanceData = featureDistanceData || null;
        try {
            const val = this.expression.evaluate(this._evaluator);
            // eslint-disable-next-line no-self-compare
            if (val === null || val === undefined || typeof val === 'number' && val !== val) {
                return this._defaultValue;
            }
            if (this._enumValues && !(val in this._enumValues)) {
                throw new RuntimeError$1(`Expected value to be one of ${ Object.keys(this._enumValues).map(v => JSON.stringify(v)).join(', ') }, but found ${ JSON.stringify(val) } instead.`);
            }
            return val;
        } catch (e) {
            if (!this._warningHistory[e.message]) {
                this._warningHistory[e.message] = true;
                if (typeof console !== 'undefined') {
                    console.warn(e.message);
                }
            }
            return this._defaultValue;
        }
    }
}
function isExpression(expression) {
    return Array.isArray(expression) && expression.length > 0 && typeof expression[0] === 'string' && expression[0] in definitions;
}
/**
 * Parse and typecheck the given style spec JSON expression.  If
 * options.defaultValue is provided, then the resulting StyleExpression's
 * `evaluate()` method will handle errors by logging a warning (once per
 * message) and returning the default value.  Otherwise, it will throw
 * evaluation errors.
 *
 * @private
 */
function createExpression(expression, propertySpec) {
    const parser = new ParsingContext$1(definitions, [], propertySpec ? getExpectedType(propertySpec) : undefined);
    // For string-valued properties, coerce to string at the top level rather than asserting.
    const parsed = parser.parse(expression, undefined, undefined, undefined, propertySpec && propertySpec.type === 'string' ? { typeAnnotation: 'coerce' } : undefined);
    if (!parsed) {
        return error(parser.errors);
    }
    return success(new StyleExpression(parsed, propertySpec));
}
class ZoomConstantExpression {
    constructor(kind, expression) {
        this.kind = kind;
        this._styleExpression = expression;
        this.isStateDependent = kind !== 'constant' && !isStateConstant(expression.expression);
    }
    evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
        return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
    }
    evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
        return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
    }
}
class ZoomDependentExpression {
    constructor(kind, expression, zoomStops, interpolationType) {
        this.kind = kind;
        this.zoomStops = zoomStops;
        this._styleExpression = expression;
        this.isStateDependent = kind !== 'camera' && !isStateConstant(expression.expression);
        this.interpolationType = interpolationType;
    }
    evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {
        return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);
    }
    evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {
        return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);
    }
    interpolationFactor(input, lower, upper) {
        if (this.interpolationType) {
            return Interpolate$1.interpolationFactor(this.interpolationType, input, lower, upper);
        } else {
            return 0;
        }
    }
}
function createPropertyExpression(expression, propertySpec) {
    expression = createExpression(expression, propertySpec);
    if (expression.result === 'error') {
        return expression;
    }
    const parsed = expression.value.expression;
    const isFeatureConstant$1 = isFeatureConstant(parsed);
    if (!isFeatureConstant$1 && !supportsPropertyExpression(propertySpec)) {
        return error([new ParsingError$1('', 'data expressions not supported')]);
    }
    const isZoomConstant = isGlobalPropertyConstant(parsed, [
        'zoom',
        'pitch',
        'distance-from-center'
    ]);
    if (!isZoomConstant && !supportsZoomExpression(propertySpec)) {
        return error([new ParsingError$1('', 'zoom expressions not supported')]);
    }
    const zoomCurve = findZoomCurve(parsed);
    if (!zoomCurve && !isZoomConstant) {
        return error([new ParsingError$1('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
    } else if (zoomCurve instanceof ParsingError$1) {
        return error([zoomCurve]);
    } else if (zoomCurve instanceof Interpolate$1 && !supportsInterpolation(propertySpec)) {
        return error([new ParsingError$1('', '"interpolate" expressions cannot be used with this property')]);
    }
    if (!zoomCurve) {
        return success(isFeatureConstant$1 ? new ZoomConstantExpression('constant', expression.value) : new ZoomConstantExpression('source', expression.value));
    }
    const interpolationType = zoomCurve instanceof Interpolate$1 ? zoomCurve.interpolation : undefined;
    return success(isFeatureConstant$1 ? new ZoomDependentExpression('camera', expression.value, zoomCurve.labels, interpolationType) : new ZoomDependentExpression('composite', expression.value, zoomCurve.labels, interpolationType));
}
// Zoom-dependent expressions may only use ["zoom"] as the input to a top-level "step" or "interpolate"
// expression (collectively referred to as a "curve"). The curve may be wrapped in one or more "let" or
// "coalesce" expressions.
function findZoomCurve(expression) {
    let result = null;
    if (expression instanceof Let$1) {
        result = findZoomCurve(expression.result);
    } else if (expression instanceof Coalesce$1) {
        for (const arg of expression.args) {
            result = findZoomCurve(arg);
            if (result) {
                break;
            }
        }
    } else if ((expression instanceof Step$1 || expression instanceof Interpolate$1) && expression.input instanceof CompoundExpression$1 && expression.input.name === 'zoom') {
        result = expression;
    }
    if (result instanceof ParsingError$1) {
        return result;
    }
    expression.eachChild(child => {
        const childResult = findZoomCurve(child);
        if (childResult instanceof ParsingError$1) {
            result = childResult;
        } else if (!result && childResult) {
            result = new ParsingError$1('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.');
        } else if (result && childResult && result !== childResult) {
            result = new ParsingError$1('', 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.');
        }
    });
    return result;
}
function getExpectedType(spec) {
    const types = {
        color: ColorType,
        string: StringType,
        number: NumberType,
        enum: StringType,
        boolean: BooleanType,
        formatted: FormattedType,
        resolvedImage: ResolvedImageType
    };
    if (spec.type === 'array') {
        return array$1(types[spec.value] || ValueType, spec.length);
    }
    return types[spec.type];
}
function getDefaultValue(spec) {
    if (spec.type === 'color' && (isFunction(spec.default) || Array.isArray(spec.default))) {
        // Special case for heatmap-color: it uses the 'default:' to define a
        // default color ramp, but createExpression expects a simple value to fall
        // back to in case of runtime errors
        return new Color$1(0, 0, 0, 0);
    } else if (spec.type === 'color') {
        return Color$1.parse(spec.default) || null;
    } else if (spec.default === undefined) {
        return null;
    } else {
        return spec.default;
    }
}

//      
// Turn jsonlint-lines-primitives objects into primitive objects
function unbundle(value) {
    if (value instanceof Number || value instanceof String || value instanceof Boolean) {
        return value.valueOf();
    } else {
        return value;
    }
}
function deepUnbundle(value) {
    if (Array.isArray(value)) {
        return value.map(deepUnbundle);
    } else if (value instanceof Object && !(value instanceof Number || value instanceof String || value instanceof Boolean)) {
        const unbundledValue = {};
        for (const key in value) {
            unbundledValue[key] = deepUnbundle(value[key]);
        }
        return unbundledValue;
    }
    return unbundle(value);
}

var spec = {"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"expression_name":{"type":"enum","values":{"let":{"group":"Variable binding"},"var":{"group":"Variable binding"},"literal":{"group":"Types"},"array":{"group":"Types"},"at":{"group":"Lookup"},"in":{"group":"Lookup"},"index-of":{"group":"Lookup"},"slice":{"group":"Lookup"},"case":{"group":"Decision"},"match":{"group":"Decision"},"coalesce":{"group":"Decision"},"step":{"group":"Ramps, scales, curves"},"interpolate":{"group":"Ramps, scales, curves"},"interpolate-hcl":{"group":"Ramps, scales, curves"},"interpolate-lab":{"group":"Ramps, scales, curves"},"ln2":{"group":"Math"},"pi":{"group":"Math"},"e":{"group":"Math"},"typeof":{"group":"Types"},"string":{"group":"Types"},"number":{"group":"Types"},"boolean":{"group":"Types"},"object":{"group":"Types"},"collator":{"group":"Types"},"format":{"group":"Types"},"image":{"group":"Types"},"number-format":{"group":"Types"},"to-string":{"group":"Types"},"to-number":{"group":"Types"},"to-boolean":{"group":"Types"},"to-rgba":{"group":"Color"},"to-color":{"group":"Types"},"rgb":{"group":"Color"},"rgba":{"group":"Color"},"get":{"group":"Lookup"},"has":{"group":"Lookup"},"length":{"group":"Lookup"},"properties":{"group":"Feature data"},"feature-state":{"group":"Feature data"},"geometry-type":{"group":"Feature data"},"id":{"group":"Feature data"},"zoom":{"group":"Camera"},"pitch":{"group":"Camera"},"distance-from-center":{"group":"Camera"},"heatmap-density":{"group":"Heatmap"},"line-progress":{"group":"Feature data"},"sky-radial-progress":{"group":"sky"},"accumulated":{"group":"Feature data"},"+":{"group":"Math"},"*":{"group":"Math"},"-":{"group":"Math"},"/":{"group":"Math"},"%":{"group":"Math"},"^":{"group":"Math"},"sqrt":{"group":"Math"},"log10":{"group":"Math"},"ln":{"group":"Math"},"log2":{"group":"Math"},"sin":{"group":"Math"},"cos":{"group":"Math"},"tan":{"group":"Math"},"asin":{"group":"Math"},"acos":{"group":"Math"},"atan":{"group":"Math"},"min":{"group":"Math"},"max":{"group":"Math"},"round":{"group":"Math"},"abs":{"group":"Math"},"ceil":{"group":"Math"},"floor":{"group":"Math"},"distance":{"group":"Math"},"==":{"group":"Decision"},"!=":{"group":"Decision"},">":{"group":"Decision"},"<":{"group":"Decision"},">=":{"group":"Decision"},"<=":{"group":"Decision"},"all":{"group":"Decision"},"any":{"group":"Decision"},"!":{"group":"Decision"},"within":{"group":"Decision"},"is-supported-script":{"group":"String"},"upcase":{"group":"String"},"downcase":{"group":"String"},"concat":{"group":"String"},"resolved-locale":{"group":"String"}}},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}};

//      
function isExpressionFilter(filter) {
    if (filter === true || filter === false) {
        return true;
    }
    if (!Array.isArray(filter) || filter.length === 0) {
        return false;
    }
    switch (filter[0]) {
    case 'has':
        return filter.length >= 2 && filter[1] !== '$id' && filter[1] !== '$type';
    case 'in':
        return filter.length >= 3 && (typeof filter[1] !== 'string' || Array.isArray(filter[2]));
    case '!in':
    case '!has':
    case 'none':
        return false;
    case '==':
    case '!=':
    case '>':
    case '>=':
    case '<':
    case '<=':
        return filter.length !== 3 || (Array.isArray(filter[1]) || Array.isArray(filter[2]));
    case 'any':
    case 'all':
        for (const f of filter.slice(1)) {
            if (!isExpressionFilter(f) && typeof f !== 'boolean') {
                return false;
            }
        }
        return true;
    default:
        return true;
    }
}
/**
 * Given a filter expressed as nested arrays, return a new function
 * that evaluates whether a given feature (with a .properties or .tags property)
 * passes its test.
 *
 * @private
 * @param {Array} filter mapbox gl filter
 * @param {string} layerType the type of the layer this filter will be applied to.
 * @returns {Function} filter-evaluating function
 */
function createFilter(filter, layerType = 'fill') {
    if (filter === null || filter === undefined) {
        return {
            filter: () => true,
            needGeometry: false,
            needFeature: false
        };
    }
    if (!isExpressionFilter(filter)) {
        filter = convertFilter(filter);
    }
    const filterExp = filter;
    let staticFilter = true;
    try {
        staticFilter = extractStaticFilter(filterExp);
    } catch (e) {
        console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${ JSON.stringify(filterExp, null, 2) }
        `);
    }
    // Compile the static component of the filter
    const filterSpec = spec[`filter_${ layerType }`];
    const compiledStaticFilter = createExpression(staticFilter, filterSpec);
    let filterFunc = null;
    if (compiledStaticFilter.result === 'error') {
        throw new Error(compiledStaticFilter.value.map(err => `${ err.key }: ${ err.message }`).join(', '));
    } else {
        filterFunc = (globalProperties, feature, canonical) => compiledStaticFilter.value.evaluate(globalProperties, feature, {}, canonical);
    }
    // If the static component is not equal to the entire filter then we have a dynamic component
    // Compile the dynamic component separately
    let dynamicFilterFunc = null;
    let needFeature = null;
    if (staticFilter !== filterExp) {
        const compiledDynamicFilter = createExpression(filterExp, filterSpec);
        if (compiledDynamicFilter.result === 'error') {
            throw new Error(compiledDynamicFilter.value.map(err => `${ err.key }: ${ err.message }`).join(', '));
        } else {
            dynamicFilterFunc = (globalProperties, feature, canonical, featureTileCoord, featureDistanceData) => compiledDynamicFilter.value.evaluate(globalProperties, feature, {}, canonical, undefined, undefined, featureTileCoord, featureDistanceData);
            needFeature = !isFeatureConstant(compiledDynamicFilter.value.expression);
        }
    }
    filterFunc = filterFunc;
    const needGeometry = geometryNeeded(staticFilter);
    return {
        filter: filterFunc,
        dynamicFilter: dynamicFilterFunc ? dynamicFilterFunc : undefined,
        needGeometry,
        needFeature: !!needFeature
    };
}
function extractStaticFilter(filter) {
    if (!isDynamicFilter(filter)) {
        return filter;
    }
    // Shallow copy so we can replace expressions in-place
    let result = deepUnbundle(filter);
    // 1. Union branches
    unionDynamicBranches(result);
    // 2. Collapse dynamic conditions to  `true`
    result = collapseDynamicBooleanExpressions(result);
    return result;
}
function collapseDynamicBooleanExpressions(expression) {
    if (!Array.isArray(expression)) {
        return expression;
    }
    const collapsed = collapsedExpression(expression);
    if (collapsed === true) {
        return collapsed;
    } else {
        return collapsed.map(subExpression => collapseDynamicBooleanExpressions(subExpression));
    }
}
/**
 * Traverses the expression and replaces all instances of branching on a
 * `dynamic` conditional (such as `['pitch']` or `['distance-from-center']`)
 * into an `any` expression.
 * This ensures that all possible outcomes of a `dynamic` branch are considered
 * when evaluating the expression upfront during filtering.
 *
 * @param {Array<any>} filter the filter expression mutated in-place.
 */
function unionDynamicBranches(filter) {
    let isBranchingDynamically = false;
    const branches = [];
    if (filter[0] === 'case') {
        for (let i = 1; i < filter.length - 1; i += 2) {
            isBranchingDynamically = isBranchingDynamically || isDynamicFilter(filter[i]);
            branches.push(filter[i + 1]);
        }
        branches.push(filter[filter.length - 1]);
    } else if (filter[0] === 'match') {
        isBranchingDynamically = isBranchingDynamically || isDynamicFilter(filter[1]);
        for (let i = 2; i < filter.length - 1; i += 2) {
            branches.push(filter[i + 1]);
        }
        branches.push(filter[filter.length - 1]);
    } else if (filter[0] === 'step') {
        isBranchingDynamically = isBranchingDynamically || isDynamicFilter(filter[1]);
        for (let i = 1; i < filter.length - 1; i += 2) {
            branches.push(filter[i + 1]);
        }
    }
    if (isBranchingDynamically) {
        filter.length = 0;
        filter.push('any', ...branches);
    }
    // traverse and recurse into children
    for (let i = 1; i < filter.length; i++) {
        unionDynamicBranches(filter[i]);
    }
}
function isDynamicFilter(filter) {
    // Base Cases
    if (!Array.isArray(filter)) {
        return false;
    }
    if (isRootExpressionDynamic(filter[0])) {
        return true;
    }
    for (let i = 1; i < filter.length; i++) {
        const child = filter[i];
        if (isDynamicFilter(child)) {
            return true;
        }
    }
    return false;
}
function isRootExpressionDynamic(expression) {
    return expression === 'pitch' || expression === 'distance-from-center';
}
const dynamicConditionExpressions = new Set([
    'in',
    '==',
    '!=',
    '>',
    '>=',
    '<',
    '<=',
    'to-boolean'
]);
function collapsedExpression(expression) {
    if (dynamicConditionExpressions.has(expression[0])) {
        for (let i = 1; i < expression.length; i++) {
            const param = expression[i];
            if (isDynamicFilter(param)) {
                return true;
            }
        }
    }
    return expression;
}
// Comparison function to sort numbers and strings
function compare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}
function geometryNeeded(filter) {
    if (!Array.isArray(filter))
        return false;
    if (filter[0] === 'within')
        return true;
    for (let index = 1; index < filter.length; index++) {
        if (geometryNeeded(filter[index]))
            return true;
    }
    return false;
}
function convertFilter(filter) {
    if (!filter)
        return true;
    const op = filter[0];
    if (filter.length <= 1)
        return op !== 'any';
    const converted = op === '==' ? convertComparisonOp(filter[1], filter[2], '==') : op === '!=' ? convertNegation(convertComparisonOp(filter[1], filter[2], '==')) : op === '<' || op === '>' || op === '<=' || op === '>=' ? convertComparisonOp(filter[1], filter[2], op) : op === 'any' ? convertDisjunctionOp(filter.slice(1)) : op === 'all' ? ['all'].concat(filter.slice(1).map(convertFilter)) : op === 'none' ? ['all'].concat(filter.slice(1).map(convertFilter).map(convertNegation)) : op === 'in' ? convertInOp(filter[1], filter.slice(2)) : op === '!in' ? convertNegation(convertInOp(filter[1], filter.slice(2))) : op === 'has' ? convertHasOp(filter[1]) : op === '!has' ? convertNegation(convertHasOp(filter[1])) : op === 'within' ? filter : true;
    return converted;
}
function convertComparisonOp(property, value, op) {
    switch (property) {
    case '$type':
        return [
            `filter-type-${ op }`,
            value
        ];
    case '$id':
        return [
            `filter-id-${ op }`,
            value
        ];
    default:
        return [
            `filter-${ op }`,
            property,
            value
        ];
    }
}
function convertDisjunctionOp(filters) {
    return ['any'].concat(filters.map(convertFilter));
}
function convertInOp(property, values) {
    if (values.length === 0) {
        return false;
    }
    switch (property) {
    case '$type':
        return [
            `filter-type-in`,
            [
                'literal',
                values
            ]
        ];
    case '$id':
        return [
            `filter-id-in`,
            [
                'literal',
                values
            ]
        ];
    default:
        if (values.length > 200 && !values.some(v => typeof v !== typeof values[0])) {
            return [
                'filter-in-large',
                property,
                [
                    'literal',
                    values.sort(compare)
                ]
            ];
        } else {
            return [
                'filter-in-small',
                property,
                [
                    'literal',
                    values
                ]
            ];
        }
    }
}
function convertHasOp(property) {
    switch (property) {
    case '$type':
        return true;
    case '$id':
        return [`filter-has-id`];
    default:
        return [
            `filter-has`,
            property
        ];
    }
}
function convertNegation(filter) {
    return [
        '!',
        filter
    ];
}

//      
var refProperties = [
    'type',
    'source',
    'source-layer',
    'minzoom',
    'maxzoom',
    'filter',
    'layout'
];

//      
function deref(layer, parent) {
    const result = {};
    for (const k in layer) {
        if (k !== 'ref') {
            result[k] = layer[k];
        }
    }
    refProperties.forEach(k => {
        if (k in parent) {
            result[k] = parent[k];
        }
    });
    return result;
}
/**
 * Given an array of layers, some of which may contain `ref` properties
 * whose value is the `id` of another property, return a new array where
 * such layers have been augmented with the 'type', 'source', etc. properties
 * from the parent layer, and the `ref` property has been removed.
 *
 * The input is not modified. The output may contain references to portions
 * of the input.
 *
 * @private
 * @param {Array<Layer>} layers
 * @returns {Array<Layer>}
 */
function derefLayers(layers) {
    layers = layers.slice();
    const map = Object.create(null);
    for (let i = 0; i < layers.length; i++) {
        map[layers[i].id] = layers[i];
    }
    for (let i = 0; i < layers.length; i++) {
        if ('ref' in layers[i]) {
            layers[i] = deref(layers[i], map[layers[i].ref]);
        }
    }
    return layers;
}

var fontWeights = {
    thin: 100,
    hairline: 100,
    'ultra-light': 100,
    'extra-light': 100,
    light: 200,
    book: 300,
    regular: 400,
    normal: 400,
    plain: 400,
    roman: 400,
    standard: 400,
    medium: 500,
    'semi-bold': 600,
    'demi-bold': 600,
    bold: 700,
    heavy: 800,
    black: 800,
    'extra-bold': 800,
    'ultra-black': 900,
    'extra-black': 900,
    'ultra-bold': 900,
    'heavy-black': 900,
    fat: 900,
    poster: 900
};
var sp = ' ';
var italicRE = /(italic|oblique)$/i;
var fontCache = {};
var mapboxToCssFont = function (fonts, size, lineHeight) {
    var cssData = fontCache[fonts];
    if (!cssData) {
        if (!Array.isArray(fonts)) {
            fonts = [fonts];
        }
        var weight = 400;
        var style = 'normal';
        var fontFamilies = [];
        var haveWeight, haveStyle;
        for (var i = 0, ii = fonts.length; i < ii; ++i) {
            var font = fonts[i];
            var parts = font.split(' ');
            var maybeWeight = parts[parts.length - 1].toLowerCase();
            if (maybeWeight == 'normal' || maybeWeight == 'italic' || maybeWeight == 'oblique') {
                style = haveStyle ? style : maybeWeight;
                parts.pop();
                maybeWeight = parts[parts.length - 1].toLowerCase();
            } else if (italicRE.test(maybeWeight)) {
                maybeWeight = maybeWeight.replace(italicRE, '');
                style = haveStyle ? style : parts[parts.length - 1].replace(maybeWeight, '');
            }
            for (var w in fontWeights) {
                var previousPart = parts.length > 1 ? parts[parts.length - 2].toLowerCase() : '';
                if (maybeWeight == w || maybeWeight == w.replace('-', '') || previousPart + '-' + maybeWeight == w) {
                    weight = haveWeight ? weight : fontWeights[w];
                    parts.pop();
                    if (previousPart && w.startsWith(previousPart)) {
                        parts.pop();
                    }
                    break;
                }
            }
            if (!haveWeight && typeof maybeWeight == 'number') {
                weight = maybeWeight;
            }
            var fontFamily = parts.join(sp).replace('Klokantech Noto Sans', 'Noto Sans');
            if (fontFamily.indexOf(sp) !== -1) {
                fontFamily = '"' + fontFamily + '"';
            }
            fontFamilies.push(fontFamily);
        }
        // CSS font property: font-style font-weight font-size/line-height font-family
        cssData = fontCache[fonts] = [
            style,
            weight,
            fontFamilies
        ];
    }
    return cssData[0] + sp + cssData[1] + sp + size + 'px' + (lineHeight ? '/' + lineHeight : '') + sp + cssData[2];
};

var mb2css = /*@__PURE__*/getDefaultExportFromCjs(mapboxToCssFont);

const mapboxBaseUrl = 'https://api.mapbox.com';
/**
 * Gets the path from a mapbox:// URL.
 * @param {string} url The Mapbox URL.
 * @return {string} The path.
 * @private
 */
function getMapboxPath(url) {
    const startsWith = 'mapbox://';
    if (url.indexOf(startsWith) !== 0) {
        return '';
    }
    return url.slice(startsWith.length);
}
/**
 * Turns mapbox:// sprite URLs into resolvable URLs.
 * @param {string} url The sprite URL.
 * @param {string} token The access token.
 * @param {string} styleUrl The style URL.
 * @return {string} A resolvable URL.
 * @private
 */
function normalizeSpriteUrl(url, token, styleUrl) {
    const mapboxPath = getMapboxPath(url);
    if (!mapboxPath) {
        return decodeURI(new URL(url, styleUrl).href);
    }
    const startsWith = 'sprites/';
    if (mapboxPath.indexOf(startsWith) !== 0) {
        throw new Error(`unexpected sprites url: ${ url }`);
    }
    const sprite = mapboxPath.slice(startsWith.length);
    return `${ mapboxBaseUrl }/styles/v1/${ sprite }/sprite?access_token=${ token }`;
}
/**
 * Turns mapbox:// style URLs into resolvable URLs.
 * @param {string} url The style URL.
 * @param {string} token The access token.
 * @return {string} A resolvable URL.
 * @private
 */
function normalizeStyleUrl(url, token) {
    const mapboxPath = getMapboxPath(url);
    if (!mapboxPath) {
        return decodeURI(new URL(url, location.href).href);
    }
    const startsWith = 'styles/';
    if (mapboxPath.indexOf(startsWith) !== 0) {
        throw new Error(`unexpected style url: ${ url }`);
    }
    const style = mapboxPath.slice(startsWith.length);
    return `${ mapboxBaseUrl }/styles/v1/${ style }?&access_token=${ token }`;
}
/**
 * Turns mapbox:// source URLs into vector tile URL templates.
 * @param {string} url The source URL.
 * @param {string} token The access token.
 * @param {string} tokenParam The access token key.
 * @param {string} styleUrl The style URL.
 * @return {string} A vector tile template.
 * @private
 */
function normalizeSourceUrl(url, token, tokenParam, styleUrl) {
    const urlObject = new URL(url, styleUrl);
    const mapboxPath = getMapboxPath(url);
    if (!mapboxPath) {
        if (!token) {
            return decodeURI(urlObject.href);
        }
        if (!urlObject.searchParams.has(tokenParam)) {
            urlObject.searchParams.set(tokenParam, token);
        }
        return decodeURI(urlObject.href);
    }
    if (mapboxPath === 'mapbox.satellite') {
        const sizeFactor = window.devicePixelRatio >= 1.5 ? '@2x' : '';
        return `https://api.mapbox.com/v4/${ mapboxPath }/{z}/{x}/{y}${ sizeFactor }.webp?access_token=${ token }`;
    }
    return `https://{a-d}.tiles.mapbox.com/v4/${ mapboxPath }/{z}/{x}/{y}.vector.pbf?access_token=${ token }`;
}

/** @typedef {'Style'|'Source'|'Sprite'|'SpriteImage'|'Tiles'|'GeoJSON'} ResourceType */
/** @typedef {import("ol").Map} Map */
/** @typedef {import("ol/layer").Layer} Layer */
/** @typedef {import("ol/layer").Group} LayerGroup */
/** @typedef {import("ol/layer").Vector} VectorLayer */
/** @typedef {import("ol/layer").VectorTile} VectorTileLayer */
/** @typedef {import("ol/source").Source} Source */
const functionCacheByStyleId = {};
const filterCacheByStyleId = {};
let styleId = 0;
function getStyleId(glStyle) {
    if (!glStyle.id) {
        glStyle.id = styleId++;
    }
    return glStyle.id;
}
function getStyleFunctionKey(glStyle, olLayer) {
    return getStyleId(glStyle) + '.' + (0,ol_util_js__WEBPACK_IMPORTED_MODULE_13__.getUid)(olLayer);
}
/**
 * @param {Object} glStyle Mapboox style object.
 * @return {Object} Function cache.
 */
function getFunctionCache(glStyle) {
    let functionCache = functionCacheByStyleId[glStyle.id];
    if (!functionCache) {
        functionCache = {};
        functionCacheByStyleId[getStyleId(glStyle)] = functionCache;
    }
    return functionCache;
}
function clearFunctionCache() {
    for (const key in functionCacheByStyleId) {
        delete functionCacheByStyleId[key];
    }
}
/**
 * @param {Object} glStyle Mapboox style object.
 * @return {Object} Filter cache.
 */
function getFilterCache(glStyle) {
    let filterCache = filterCacheByStyleId[glStyle.id];
    if (!filterCache) {
        filterCache = {};
        filterCacheByStyleId[getStyleId(glStyle)] = filterCache;
    }
    return filterCache;
}
function deg2rad(degrees) {
    return degrees * Math.PI / 180;
}
const defaultResolutions = (function () {
    const resolutions = [];
    for (let res = 78271.51696402048; resolutions.length <= 24; res /= 2) {
        resolutions.push(res);
    }
    return resolutions;
}());
const defaultTileGrid = new ol_tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_8__({
    extent: (0,ol_proj_js__WEBPACK_IMPORTED_MODULE_12__.get)('EPSG:3857').getExtent(),
    resolutions: defaultResolutions
});
/**
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @return {HTMLCanvasElement} Canvas.
 */
function createCanvas(width, height) {
    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && typeof OffscreenCanvas !== 'undefined') {
        // eslint-disable-line
        return new OffscreenCanvas(width, height);
    }
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    return canvas;
}
function getZoomForResolution(resolution, resolutions) {
    let i = 0;
    const ii = resolutions.length;
    for (; i < ii; ++i) {
        const candidate = resolutions[i];
        if (candidate < resolution && i + 1 < ii) {
            const zoomFactor = resolutions[i] / resolutions[i + 1];
            return i + Math.log(resolutions[i] / resolution) / Math.log(zoomFactor);
        }
    }
    return ii - 1;
}
const pendingRequests = {};
/**
 * @param {ResourceType} resourceType Type of resource to load.
 * @param {string} url Url of the resource.
 * @param {Options} [options={}] Options.
 * @param {{request?: Request}} [metadata] Object to be filled with the request.
 * @return {Promise<Object|Response>} Promise that resolves with the loaded resource
 * or rejects with the Response object.
 * @private
 */
function fetchResource(resourceType, url, options = {}, metadata) {
    if (url in pendingRequests) {
        if (metadata) {
            metadata.request = pendingRequests[url][0];
        }
        return pendingRequests[url][1];
    }
    const transformedRequest = options.transformRequest ? options.transformRequest(url, resourceType) || url : url;
    const pendingRequest = (0,ol_functions_js__WEBPACK_IMPORTED_MODULE_6__.toPromise)(() => transformedRequest).then(transformedRequest => {
        if (!(transformedRequest instanceof Request)) {
            transformedRequest = new Request(transformedRequest);
        }
        if (!transformedRequest.headers.get('Accept')) {
            transformedRequest.headers.set('Accept', 'application/json');
        }
        if (metadata) {
            metadata.request = transformedRequest;
        }
        return fetch(transformedRequest).then(function (response) {
            delete pendingRequests[url];
            return response.ok ? response.json() : Promise.reject(new Error('Error fetching source ' + url));
        }).catch(function (error) {
            delete pendingRequests[url];
            return Promise.reject(new Error('Error fetching source ' + url));
        });
    });
    pendingRequests[url] = [
        transformedRequest,
        pendingRequest
    ];
    return pendingRequest;
}
function getGlStyle(glStyleOrUrl, options) {
    if (typeof glStyleOrUrl === 'string') {
        if (glStyleOrUrl.trim().startsWith('{')) {
            try {
                const glStyle = JSON.parse(glStyleOrUrl);
                return Promise.resolve(glStyle);
            } catch (error) {
                return Promise.reject(error);
            }
        } else {
            glStyleOrUrl = normalizeStyleUrl(glStyleOrUrl, options.accessToken);
            return fetchResource('Style', glStyleOrUrl, options);
        }
    } else {
        return Promise.resolve(glStyleOrUrl);
    }
}
const tilejsonCache = {};
/**
 * @param {Object} glSource glStyle source object.
 * @param {string} styleUrl Style URL.
 * @param {Options} options Options.
 * @return {Promise<{tileJson: Object, tileLoadFunction: import('ol/Tile.js').LoadFunction}?>} TileJson and load function
 */
function getTileJson(glSource, styleUrl, options = {}) {
    const cacheKey = [
        styleUrl,
        JSON.stringify(glSource)
    ].toString();
    let promise = tilejsonCache[cacheKey];
    if (!promise || options.transformRequest) {
        let tileLoadFunction;
        if (options.transformRequest) {
            tileLoadFunction = (tile, src) => {
                const transformedRequest = options.transformRequest ? options.transformRequest(src, 'Tiles') || src : src;
                if (tile instanceof ol__WEBPACK_IMPORTED_MODULE_10__.VectorTile) {
                    tile.setLoader((extent, resolution, projection) => {
                        (0,ol_functions_js__WEBPACK_IMPORTED_MODULE_6__.toPromise)(() => transformedRequest).then(transformedRequest => {
                            fetch(transformedRequest).then(response => response.arrayBuffer()).then(data => {
                                const format = tile.getFormat();
                                const features = format.readFeatures(data, {
                                    extent: extent,
                                    featureProjection: projection
                                });
                                // @ts-ignore
                                tile.setFeatures(features);
                            }).catch(e => tile.setState(ol_TileState_js__WEBPACK_IMPORTED_MODULE_9__.ERROR));
                        });
                    });
                } else {
                    const img = tile.getImage();
                    (0,ol_functions_js__WEBPACK_IMPORTED_MODULE_6__.toPromise)(() => transformedRequest).then(transformedRequest => {
                        if (transformedRequest instanceof Request) {
                            fetch(transformedRequest).then(response => response.blob()).then(blob => {
                                const url = URL.createObjectURL(blob);
                                img.addEventListener('load', () => URL.revokeObjectURL(url));
                                img.addEventListener('error', () => URL.revokeObjectURL(url));
                                img.src = url;
                            }).catch(e => tile.setState(ol_TileState_js__WEBPACK_IMPORTED_MODULE_9__.ERROR));
                        } else {
                            img.src = transformedRequest;
                        }
                    });
                }
            };
        }
        const url = glSource.url;
        if (url && !glSource.tiles) {
            const normalizedSourceUrl = normalizeSourceUrl(url, options.accessToken, options.accessTokenParam || 'access_token', styleUrl || location.href);
            if (url.startsWith('mapbox://')) {
                promise = Promise.resolve({
                    tileJson: Object.assign({}, glSource, {
                        url: undefined,
                        tiles: (0,ol_tileurlfunction_js__WEBPACK_IMPORTED_MODULE_11__.expandUrl)(normalizedSourceUrl)
                    }),
                    tileLoadFunction
                });
            } else {
                const metadata = {};
                promise = fetchResource('Source', normalizedSourceUrl, options, metadata).then(function (tileJson) {
                    tileJson.tiles = tileJson.tiles.map(function (tileUrl) {
                        if (tileJson.scheme === 'tms') {
                            tileUrl = tileUrl.replace('{y}', '{-y}');
                        }
                        return normalizeSourceUrl(tileUrl, options.accessToken, options.accessTokenParam || 'access_token', metadata.request.url);
                    });
                    return Promise.resolve({
                        tileJson,
                        tileLoadFunction
                    });
                });
            }
        } else {
            glSource = Object.assign({}, glSource, {
                tiles: glSource.tiles.map(function (tileUrl) {
                    if (glSource.scheme === 'tms') {
                        tileUrl = tileUrl.replace('{y}', '{-y}');
                    }
                    return normalizeSourceUrl(tileUrl, options.accessToken, options.accessTokenParam || 'access_token', styleUrl || location.href);
                })
            });
            promise = Promise.resolve({
                tileJson: Object.assign({}, glSource),
                tileLoadFunction
            });
        }
        tilejsonCache[cacheKey] = promise;
    }
    return promise;
}
/**
 * @param {HTMLImageElement|HTMLCanvasElement} spriteImage Sprite image id.
 * @param {{x: number, y: number, width: number, height: number, pixelRatio: number}} spriteImageData Sprite image data.
 * @param {number} haloWidth Halo width.
 * @param {{r: number, g: number, b: number, a: number}} haloColor Halo color.
 * @return {HTMLCanvasElement} Canvas element with the halo.
 */
function drawIconHalo(spriteImage, spriteImageData, haloWidth, haloColor) {
    const imageCanvas = document.createElement('canvas');
    const imgSize = [
        2 * haloWidth * spriteImageData.pixelRatio + spriteImageData.width,
        2 * haloWidth * spriteImageData.pixelRatio + spriteImageData.height
    ];
    imageCanvas.width = imgSize[0];
    imageCanvas.height = imgSize[1];
    const imageContext = imageCanvas.getContext('2d');
    imageContext.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, haloWidth * spriteImageData.pixelRatio, haloWidth * spriteImageData.pixelRatio, spriteImageData.width, spriteImageData.height);
    const imageData = imageContext.getImageData(0, 0, imgSize[0], imgSize[1]);
    imageContext.globalCompositeOperation = 'destination-over';
    imageContext.fillStyle = `rgba(${ haloColor.r * 255 },${ haloColor.g * 255 },${ haloColor.b * 255 },${ haloColor.a })`;
    const data = imageData.data;
    for (let i = 0, ii = imageData.width; i < ii; ++i) {
        for (let j = 0, jj = imageData.height; j < jj; ++j) {
            const index = (j * ii + i) * 4;
            const alpha = data[index + 3];
            if (alpha > 0) {
                imageContext.arc(i, j, haloWidth * spriteImageData.pixelRatio, 0, 2 * Math.PI);
            }
        }
    }
    imageContext.fill();
    return imageCanvas;
}
function smoothstep(min, max, value) {
    const x = Math.max(0, Math.min(1, (value - min) / (max - min)));
    return x * x * (3 - 2 * x);
}
/**
 * @param {HTMLImageElement} image SDF image
 * @param {{x: number, y: number, width: number, height: number}} area Area to unSDF
 * @param {{r: number, g: number, b: number, a: number}} color Color to use
 * @return {HTMLCanvasElement} Regular image
 */
function drawSDF(image, area, color) {
    const imageCanvas = document.createElement('canvas');
    imageCanvas.width = area.width;
    imageCanvas.height = area.height;
    const imageContext = imageCanvas.getContext('2d');
    imageContext.drawImage(image, area.x, area.y, area.width, area.height, 0, 0, area.width, area.height);
    const imageData = imageContext.getImageData(0, 0, area.width, area.height);
    const data = imageData.data;
    for (let i = 0, ii = imageData.width; i < ii; ++i) {
        for (let j = 0, jj = imageData.height; j < jj; ++j) {
            const index = (j * ii + i) * 4;
            const dist = data[index + 3] / 255;
            const buffer = 0.75;
            const gamma = 0.1;
            const alpha = smoothstep(buffer - gamma, buffer + gamma, dist);
            if (alpha > 0) {
                data[index + 0] = Math.round(255 * color.r * alpha);
                data[index + 1] = Math.round(255 * color.g * alpha);
                data[index + 2] = Math.round(255 * color.b * alpha);
                data[index + 3] = Math.round(255 * alpha);
            } else {
                data[index + 3] = 0;
            }
        }
    }
    imageContext.putImageData(imageData, 0, 0);
    return imageCanvas;
}    /**
 * @typedef {import("./apply.js").Options} Options
 * @private
 */

const hairSpacePool = Array(256).join('\u200A');
function applyLetterSpacing(text, letterSpacing) {
    if (letterSpacing >= 0.05) {
        let textWithLetterSpacing = '';
        const lines = text.split('\n');
        const joinSpaceString = hairSpacePool.slice(0, Math.round(letterSpacing / 0.1));
        for (let l = 0, ll = lines.length; l < ll; ++l) {
            if (l > 0) {
                textWithLetterSpacing += '\n';
            }
            textWithLetterSpacing += lines[l].split('').join(joinSpaceString);
        }
        return textWithLetterSpacing;
    }
    return text;
}
let measureContext;
function getMeasureContext() {
    if (!measureContext) {
        measureContext = createCanvas(1, 1).getContext('2d');
    }
    return measureContext;
}
function measureText(text, letterSpacing) {
    return getMeasureContext().measureText(text).width + (text.length - 1) * letterSpacing;
}
const measureCache = {};
function wrapText(text, font, em, letterSpacing) {
    if (text.indexOf('\n') !== -1) {
        const hardLines = text.split('\n');
        const lines = [];
        for (let i = 0, ii = hardLines.length; i < ii; ++i) {
            lines.push(wrapText(hardLines[i], font, em, letterSpacing));
        }
        return lines.join('\n');
    }
    const key = em + ',' + font + ',' + text + ',' + letterSpacing;
    let wrappedText = measureCache[key];
    if (!wrappedText) {
        const words = text.split(' ');
        if (words.length > 1) {
            const ctx = getMeasureContext();
            ctx.font = font;
            const oneEm = ctx.measureText('M').width;
            const maxWidth = oneEm * em;
            let line = '';
            const lines = [];
            // Pass 1 - wrap lines to not exceed maxWidth
            for (let i = 0, ii = words.length; i < ii; ++i) {
                const word = words[i];
                const testLine = line + (line ? ' ' : '') + word;
                if (measureText(testLine, letterSpacing) <= maxWidth) {
                    line = testLine;
                } else {
                    if (line) {
                        lines.push(line);
                    }
                    line = word;
                }
            }
            if (line) {
                lines.push(line);
            }
            // Pass 2 - add lines with a width of less than 30% of maxWidth to the previous or next line
            for (let i = 0, ii = lines.length; i < ii && ii > 1; ++i) {
                const line = lines[i];
                if (measureText(line, letterSpacing) < maxWidth * 0.35) {
                    const prevWidth = i > 0 ? measureText(lines[i - 1], letterSpacing) : Infinity;
                    const nextWidth = i < ii - 1 ? measureText(lines[i + 1], letterSpacing) : Infinity;
                    lines.splice(i, 1);
                    ii -= 1;
                    if (prevWidth < nextWidth) {
                        lines[i - 1] += ' ' + line;
                        i -= 1;
                    } else {
                        lines[i] = line + ' ' + lines[i];
                    }
                }
            }
            // Pass 3 - try to fill 80% of maxWidth for each line
            for (let i = 0, ii = lines.length - 1; i < ii; ++i) {
                const line = lines[i];
                const next = lines[i + 1];
                if (measureText(line, letterSpacing) > maxWidth * 0.7 && measureText(next, letterSpacing) < maxWidth * 0.6) {
                    const lineWords = line.split(' ');
                    const lastWord = lineWords.pop();
                    if (measureText(lastWord, letterSpacing) < maxWidth * 0.2) {
                        lines[i] = lineWords.join(' ');
                        lines[i + 1] = lastWord + ' ' + next;
                    }
                    ii -= 1;
                }
            }
            wrappedText = lines.join('\n');
        } else {
            wrappedText = text;
        }
        wrappedText = applyLetterSpacing(wrappedText, letterSpacing);
        measureCache[key] = wrappedText;
    }
    return wrappedText;
}
const fontFamilyRegEx = /font-family: ?([^;]*);/;
const stripQuotesRegEx = /("|')/g;
let loadedFontFamilies;
function hasFontFamily(family) {
    if (!loadedFontFamilies) {
        loadedFontFamilies = {};
        const styleSheets = document.styleSheets;
        for (let i = 0, ii = styleSheets.length; i < ii; ++i) {
            const styleSheet = styleSheets[i];
            try {
                const cssRules = styleSheet.rules || styleSheet.cssRules;
                if (cssRules) {
                    for (let j = 0, jj = cssRules.length; j < jj; ++j) {
                        const cssRule = cssRules[j];
                        if (cssRule.type == 5) {
                            const match = cssRule.cssText.match(fontFamilyRegEx);
                            loadedFontFamilies[match[1].replace(stripQuotesRegEx, '')] = true;
                        }
                    }
                }
            } catch (e) {
            }
        }
    }
    return family in loadedFontFamilies;
}
const processedFontFamilies = {};
/**
 * @param {Array} fonts Fonts.
 * @param {string} [templateUrl] Template URL.
 * @return {Array} Processed fonts.
 * @private
 */
function getFonts(fonts, templateUrl = 'https://cdn.jsdelivr.net/npm/@fontsource/{font-family}/{fontweight}{-fontstyle}.css') {
    const fontsKey = fonts.toString();
    if (fontsKey in processedFontFamilies) {
        return processedFontFamilies[fontsKey];
    }
    const fontDescriptions = [];
    for (let i = 0, ii = fonts.length; i < ii; ++i) {
        fonts[i] = fonts[i].replace('Arial Unicode MS', 'Arial');
        const font = fonts[i];
        const cssFont = mb2css(font, 1);
        (0,ol_render_canvas_js__WEBPACK_IMPORTED_MODULE_7__.registerFont)(cssFont);
        const parts = cssFont.split(' ');
        fontDescriptions.push([
            parts.slice(3).join(' ').replace(/"/g, ''),
            parts[1],
            parts[0]
        ]);
    }
    for (let i = 0, ii = fontDescriptions.length; i < ii; ++i) {
        const fontDescription = fontDescriptions[i];
        const family = fontDescription[0];
        if (!hasFontFamily(family)) {
            if (ol_render_canvas_js__WEBPACK_IMPORTED_MODULE_7__.checkedFonts.get(`${ fontDescription[2] }\n${ fontDescription[1] } \n${ family }`) !== 100) {
                const fontUrl = templateUrl.replace('{font-family}', family.replace(/ /g, '-').toLowerCase()).replace('{Font+Family}', family.replace(/ /g, '+')).replace('{fontweight}', fontDescription[1]).replace('{-fontstyle}', fontDescription[2].replace('normal', '').replace(/(.+)/, '-$1')).replace('{fontstyle}', fontDescription[2]);
                if (!document.querySelector('link[href="' + fontUrl + '"]')) {
                    const markup = document.createElement('link');
                    markup.href = fontUrl;
                    markup.rel = 'stylesheet';
                    document.head.appendChild(markup);
                }
            }
        }
    }
    processedFontFamilies[fontsKey] = fonts;
    return fonts;
}

/*
ol-mapbox-style - Use Mapbox Style objects with OpenLayers
Copyright 2016-present ol-mapbox-style contributors
License: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE
*/
/**
 * @typedef {import("ol/layer/Vector").default} VectorLayer
 * @typedef {import("ol/layer/VectorTile").default} VectorTileLayer
 * @typedef {import("ol/style/Style").StyleFunction} StyleFunction
 * @typedef {import('./util.js').ResourceType} ResourceType
 */
const types = {
    'Point': 1,
    'MultiPoint': 1,
    'LineString': 2,
    'MultiLineString': 2,
    'Polygon': 3,
    'MultiPolygon': 3
};
const anchor = {
    'center': [
        0.5,
        0.5
    ],
    'left': [
        0,
        0.5
    ],
    'right': [
        1,
        0.5
    ],
    'top': [
        0.5,
        0
    ],
    'bottom': [
        0.5,
        1
    ],
    'top-left': [
        0,
        0
    ],
    'top-right': [
        1,
        0
    ],
    'bottom-left': [
        0,
        1
    ],
    'bottom-right': [
        1,
        1
    ]
};
const expressionData = function (rawExpression, propertySpec) {
    const compiledExpression = createPropertyExpression(rawExpression, propertySpec);
    if (compiledExpression.result === 'error') {
        throw new Error(compiledExpression.value.map(err => `${ err.key }: ${ err.message }`).join(', '));
    }
    return compiledExpression.value;
};
const emptyObj$1 = {};
const zoomObj = { zoom: 0 };
let renderFeatureCoordinates, renderFeature;
/**
 * @private
 * @param {Object} layer Gl object layer.
 * @param {string} layoutOrPaint 'layout' or 'paint'.
 * @param {string} property Feature property.
 * @param {number} zoom Zoom.
 * @param {Object} feature Gl feature.
 * @param {Object} [functionCache] Function cache.
 * @param {Object} [featureState] Feature state.
 * @return {?} Value.
 */
function getValue(layer, layoutOrPaint, property, zoom, feature, functionCache, featureState) {
    const layerId = layer.id;
    if (!functionCache) {
        functionCache = {};
        console.warn('No functionCache provided to getValue()');    //eslint-disable-line no-console
    }
    if (!functionCache[layerId]) {
        functionCache[layerId] = {};
    }
    const functions = functionCache[layerId];
    if (!functions[property]) {
        let value = (layer[layoutOrPaint] || emptyObj$1)[property];
        const propertySpec = spec[`${ layoutOrPaint }_${ layer.type }`][property];
        if (value === undefined) {
            value = propertySpec.default;
        }
        let isExpr = isExpression(value);
        if (!isExpr && isFunction(value)) {
            value = convertFunction(value, propertySpec);
            isExpr = true;
        }
        if (isExpr) {
            const compiledExpression = expressionData(value, propertySpec);
            functions[property] = compiledExpression.evaluate.bind(compiledExpression);
        } else {
            if (propertySpec.type == 'color') {
                value = Color$1.parse(value);
            }
            functions[property] = function () {
                return value;
            };
        }
    }
    zoomObj.zoom = zoom;
    return functions[property](zoomObj, feature, featureState);
}
/**
 * @private
 * @param {Object} layer Gl object layer.
 * @param {number} zoom Zoom.
 * @param {Object} feature Gl feature.
 * @param {"icon"|"text"} prefix Style property prefix.
 * @param {Object} [functionCache] Function cache.
 * @return {"declutter"|"obstacle"|"none"} Value.
 */
function getDeclutterMode(layer, zoom, feature, prefix, functionCache) {
    const allowOverlap = getValue(layer, 'layout', `${ prefix }-allow-overlap`, zoom, feature, functionCache);
    if (!allowOverlap) {
        return 'declutter';
    }
    const ignorePlacement = getValue(layer, 'layout', `${ prefix }-ignore-placement`, zoom, feature, functionCache);
    if (!ignorePlacement) {
        return 'obstacle';
    }
    return 'none';
}
/**
 * @private
 * @param {string} layerId Layer id.
 * @param {?} filter Filter.
 * @param {Object} feature Feature.
 * @param {number} zoom Zoom.
 * @param {Object} [filterCache] Filter cache.
 * @return {boolean} Filter result.
 */
function evaluateFilter(layerId, filter, feature, zoom, filterCache) {
    if (!filterCache) {
        console.warn('No filterCache provided to evaluateFilter()');    //eslint-disable-line no-console
    }
    if (!(layerId in filterCache)) {
        filterCache[layerId] = createFilter(filter).filter;
    }
    zoomObj.zoom = zoom;
    return filterCache[layerId](zoomObj, feature);
}
let renderTransparentEnabled = false;
/**
 * Configure whether features with a transparent style should be rendered. When
 * set to `true`, it will be possible to hit detect content that is not visible,
 * like transparent fills of polygons, using `ol/layer/Layer#getFeatures()` or
 * `ol/Map#getFeaturesAtPixel()`
 * @param {boolean} enabled Rendering of transparent elements is enabled.
 * Default is `false`.
 */
function renderTransparent(enabled) {
    if (enabled !== renderTransparentEnabled) {
        clearFunctionCache();
        renderTransparentEnabled = enabled;
    }
}
/**
 * @private
 * @param {?} color Color.
 * @param {number} [opacity] Opacity.
 * @return {string} Color.
 */
function colorWithOpacity(color, opacity) {
    if (color) {
        if (!renderTransparentEnabled && (color.a === 0 || opacity === 0)) {
            return undefined;
        }
        const a = color.a;
        opacity = opacity === undefined ? 1 : opacity;
        return a === 0 ? 'transparent' : 'rgba(' + Math.round(color.r * 255 / a) + ',' + Math.round(color.g * 255 / a) + ',' + Math.round(color.b * 255 / a) + ',' + a * opacity + ')';
    }
    return color;
}
const templateRegEx = /\{[^{}}]*\}/g;
/**
 * @private
 * @param {string} text Text.
 * @param {Object} properties Properties.
 * @return {string} Text.
 */
function fromTemplate(text, properties) {
    return text.replace(templateRegEx, function (match) {
        return properties[match.slice(1, -1)] || '';
    });
}
let recordLayer = false;
/**
 * Turns recording of the Mapbox Style's `layer` on and off. When turned on,
 * the layer that a rendered feature belongs to will be set as the feature's
 * `mapbox-layer` property.
 * @param {boolean} record Recording of the style layer is on.
 */
function recordStyleLayer(record = false) {
    recordLayer = record;
}
const styleFunctionArgs = {};
/**
 * Creates a style function from the `glStyle` object for all layers that use
 * the specified `source`, which needs to be a `"type": "vector"` or
 * `"type": "geojson"` source and applies it to the specified OpenLayers layer.
 *
 * Two additional properties will be set on the provided layer:
 *
 *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the
 *    OpenLayers layer was created from. Usually `apply()` creates one
 *    OpenLayers layer per Mapbox Style source, unless the layer stack has
 *    layers from different sources in between.
 *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are
 *    included in the OpenLayers layer.
 *
 * This function also works in a web worker. In worker mode, the main thread needs
 * to listen to messages from the worker and respond with another message to make
 * sure that sprite image loading works:
 *
 * ```js
 *  worker.addEventListener('message', event => {
 *   if (event.data.action === 'loadImage') {
 *     const image = new Image();
 *     image.crossOrigin = 'anonymous';
 *     image.addEventListener('load', function() {
 *       createImageBitmap(image, 0, 0, image.width, image.height).then(imageBitmap => {
 *         worker.postMessage({
 *           action: 'imageLoaded',
 *           image: imageBitmap,
 *           src: event.data.src
 *         }, [imageBitmap]);
 *       });
 *     });
 *     image.src = event.data.src;
 *   }
 * });
 * ```
 *
 * @param {VectorLayer|VectorTileLayer} olLayer OpenLayers layer to
 * apply the style to. In addition to the style, the layer will get two
 * properties: `mapbox-source` will be the `id` of the `glStyle`'s source used
 * for the layer, and `mapbox-layers` will be an array of the `id`s of the
 * `glStyle`'s layers.
 * @param {string|Object} glStyle Mapbox Style object.
 * @param {string|Array<string>} sourceOrLayers `source` key or an array of layer `id`s
 * from the Mapbox Style object. When a `source` key is provided, all layers for
 * the specified source will be included in the style function. When layer `id`s
 * are provided, they must be from layers that use the same source.
 * @param {Array<number>} resolutions
 * Resolutions for mapping resolution to zoom level.
 * @param {Object} spriteData Sprite data from the url specified in
 * the Mapbox Style object's `sprite` property. Only required if a `sprite`
 * property is specified in the Mapbox Style object.
 * @param {string|Request|Promise<string|Request>} spriteImageUrl Sprite image url for the sprite
 * specified in the Mapbox Style object's `sprite` property. Only required if a
 * `sprite` property is specified in the Mapbox Style object.
 * @param {function(Array<string>, string=):Array<string>} getFonts Function that
 * receives a font stack and the url template from the GL style's `metadata['ol:webfonts']`
 * property (if set) as arguments, and returns a (modified) font stack that
 * is available. Font names are the names used in the Mapbox Style object. If
 * not provided, the font stack will be used as-is. This function can also be
 * used for loading web fonts.
 * @param {function(VectorLayer|VectorTileLayer, string):HTMLImageElement|HTMLCanvasElement|string|undefined} [getImage=undefined]
 * Function that returns an image or a URL for an image name. If the result is an HTMLImageElement, it must already be
 * loaded. The layer can be used to call layer.changed() when the loading and processing of the image has finished.
 * This function can be used for icons not in the sprite or to override sprite icons.
 * @return {StyleFunction} Style function for use in
 * `ol.layer.Vector` or `ol.layer.VectorTile`.
 */
function stylefunction(olLayer, glStyle, sourceOrLayers, resolutions = defaultResolutions, spriteData = undefined, spriteImageUrl = undefined, getFonts = undefined, getImage = undefined) {
    if (typeof glStyle == 'string') {
        glStyle = JSON.parse(glStyle);
    }
    if (glStyle.version != 8) {
        throw new Error('glStyle version 8 required.');
    }
    styleFunctionArgs[getStyleFunctionKey(glStyle, olLayer)] = Array.from(arguments);
    let spriteImage, spriteImageSize;
    let spriteImageUnSDFed;
    if (spriteImageUrl) {
        if (typeof Image !== 'undefined') {
            const img = new Image();
            let blobUrl;
            (0,ol_functions_js__WEBPACK_IMPORTED_MODULE_6__.toPromise)(() => spriteImageUrl).then(spriteImageUrl => {
                if (spriteImageUrl instanceof Request) {
                    fetch(spriteImageUrl).then(response => response.blob()).then(blob => {
                        blobUrl = URL.createObjectURL(blob);
                        img.src = blobUrl;
                    }).catch(() => {
                    });
                } else {
                    img.crossOrigin = 'anonymous';
                    img.src = spriteImageUrl;
                    if (blobUrl) {
                        URL.revokeObjectURL(blobUrl);
                    }
                }
            });
            img.onload = function () {
                spriteImage = img;
                spriteImageSize = [
                    img.width,
                    img.height
                ];
                olLayer.changed();
                img.onload = null;
            };
        } else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
            //eslint-disable-line
            const worker = self;
            // Main thread needs to handle 'loadImage' and dispatch 'imageLoaded'
            worker.postMessage({
                action: 'loadImage',
                src: spriteImageUrl
            });
            worker.addEventListener('message', function handler(event) {
                if (event.data.action === 'imageLoaded' && event.data.src === spriteImageUrl) {
                    spriteImage = event.data.image;
                    spriteImageSize = [
                        spriteImage.width,
                        spriteImage.height
                    ];
                }
            });
        }
    }
    const allLayers = derefLayers(glStyle.layers);
    const layersBySourceLayer = {};
    const mapboxLayers = [];
    const iconImageCache = {};
    const patternCache = {};
    const functionCache = getFunctionCache(glStyle);
    const filterCache = getFilterCache(glStyle);
    let mapboxSource;
    for (let i = 0, ii = allLayers.length; i < ii; ++i) {
        const layer = allLayers[i];
        const layerId = layer.id;
        if (typeof sourceOrLayers == 'string' && layer.source == sourceOrLayers || Array.isArray(sourceOrLayers) && sourceOrLayers.indexOf(layerId) !== -1) {
            const sourceLayer = layer['source-layer'];
            if (!mapboxSource) {
                mapboxSource = layer.source;
                const source = glStyle.sources[mapboxSource];
                if (!source) {
                    throw new Error(`Source "${ mapboxSource }" is not defined`);
                }
                const type = source.type;
                if (type !== 'vector' && type !== 'geojson') {
                    throw new Error(`Source "${ mapboxSource }" is not of type "vector" or "geojson", but "${ type }"`);
                }
            } else if (layer.source !== mapboxSource) {
                throw new Error(`Layer "${ layerId }" does not use source "${ mapboxSource }`);
            }
            let layers = layersBySourceLayer[sourceLayer];
            if (!layers) {
                layers = [];
                layersBySourceLayer[sourceLayer] = layers;
            }
            layers.push({
                layer: layer,
                index: i
            });
            mapboxLayers.push(layerId);
        }
    }
    const textHalo = new ol_style_Stroke_js__WEBPACK_IMPORTED_MODULE_3__();
    const textColor = new ol_style_Fill_js__WEBPACK_IMPORTED_MODULE_1__();
    const styles = [];
    /**
   * @param {import("ol/Feature").default|import("ol/render/Feature").default} feature Feature.
   * @param {number} resolution Resolution.
   * @param {string} [onlyLayer] Calculate style for this layer only.
   * @return {Array<import("ol/style/Style").default>} Style.
   */
    const styleFunction = function (feature, resolution, onlyLayer) {
        const properties = feature.getProperties();
        const layers = layersBySourceLayer[properties.layer];
        if (!layers) {
            return undefined;
        }
        let zoom = resolutions.indexOf(resolution);
        if (zoom == -1) {
            zoom = getZoomForResolution(resolution, resolutions);
        }
        const type = types[feature.getGeometry().getType()];
        const f = {
            id: feature.getId(),
            properties: properties,
            type: type
        };
        const featureState = olLayer.get('mapbox-featurestate')[feature.getId()];
        let stylesLength = -1;
        let featureBelongsToLayer;
        for (let i = 0, ii = layers.length; i < ii; ++i) {
            const layerData = layers[i];
            const layer = layerData.layer;
            const layerId = layer.id;
            if (onlyLayer !== undefined && onlyLayer !== layerId) {
                continue;
            }
            const layout = layer.layout || emptyObj$1;
            const paint = layer.paint || emptyObj$1;
            if (layout.visibility === 'none' || 'minzoom' in layer && zoom < layer.minzoom || 'maxzoom' in layer && zoom >= layer.maxzoom) {
                continue;
            }
            const filter = layer.filter;
            if (!filter || evaluateFilter(layerId, filter, f, zoom, filterCache)) {
                featureBelongsToLayer = layer;
                let color, opacity, fill, stroke, strokeColor, style;
                const index = layerData.index;
                if (type == 3 && (layer.type == 'fill' || layer.type == 'fill-extrusion')) {
                    opacity = getValue(layer, 'paint', layer.type + '-opacity', zoom, f, functionCache, featureState);
                    if (layer.type + '-pattern' in paint) {
                        const fillIcon = getValue(layer, 'paint', layer.type + '-pattern', zoom, f, functionCache, featureState);
                        if (fillIcon) {
                            const icon = typeof fillIcon === 'string' ? fromTemplate(fillIcon, properties) : fillIcon.toString();
                            if (spriteImage && spriteData && spriteData[icon]) {
                                ++stylesLength;
                                style = styles[stylesLength];
                                if (!style || !style.getFill() || style.getStroke() || style.getText()) {
                                    style = new ol_style_Style_js__WEBPACK_IMPORTED_MODULE_4__({ fill: new ol_style_Fill_js__WEBPACK_IMPORTED_MODULE_1__() });
                                    styles[stylesLength] = style;
                                }
                                fill = style.getFill();
                                style.setZIndex(index);
                                const icon_cache_key = icon + '.' + opacity;
                                let pattern = patternCache[icon_cache_key];
                                if (!pattern) {
                                    const spriteImageData = spriteData[icon];
                                    const canvas = createCanvas(spriteImageData.width, spriteImageData.height);
                                    const ctx = canvas.getContext('2d');
                                    ctx.globalAlpha = opacity;
                                    ctx.drawImage(spriteImage, spriteImageData.x, spriteImageData.y, spriteImageData.width, spriteImageData.height, 0, 0, spriteImageData.width, spriteImageData.height);
                                    pattern = ctx.createPattern(canvas, 'repeat');
                                    patternCache[icon_cache_key] = pattern;
                                }
                                fill.setColor(pattern);
                            }
                        }
                    } else {
                        color = colorWithOpacity(getValue(layer, 'paint', layer.type + '-color', zoom, f, functionCache, featureState), opacity);
                        if (layer.type + '-outline-color' in paint) {
                            strokeColor = colorWithOpacity(getValue(layer, 'paint', layer.type + '-outline-color', zoom, f, functionCache, featureState), opacity);
                        }
                        if (!strokeColor) {
                            strokeColor = color;
                        }
                        if (color || strokeColor) {
                            ++stylesLength;
                            style = styles[stylesLength];
                            if (!style || color && !style.getFill() || !color && style.getFill() || strokeColor && !style.getStroke() || !strokeColor && style.getStroke() || style.getText()) {
                                style = new ol_style_Style_js__WEBPACK_IMPORTED_MODULE_4__({
                                    fill: color ? new ol_style_Fill_js__WEBPACK_IMPORTED_MODULE_1__() : undefined,
                                    stroke: strokeColor ? new ol_style_Stroke_js__WEBPACK_IMPORTED_MODULE_3__() : undefined
                                });
                                styles[stylesLength] = style;
                            }
                            if (color) {
                                fill = style.getFill();
                                fill.setColor(color);
                            }
                            if (strokeColor) {
                                stroke = style.getStroke();
                                stroke.setColor(strokeColor);
                                stroke.setWidth(0.5);
                            }
                            style.setZIndex(index);
                        }
                    }
                }
                if (type != 1 && layer.type == 'line') {
                    if (!('line-pattern' in paint)) {
                        color = colorWithOpacity(getValue(layer, 'paint', 'line-color', zoom, f, functionCache, featureState), getValue(layer, 'paint', 'line-opacity', zoom, f, functionCache, featureState));
                    } else {
                        color = undefined;
                    }
                    const width = getValue(layer, 'paint', 'line-width', zoom, f, functionCache, featureState);
                    if (color && width > 0) {
                        ++stylesLength;
                        style = styles[stylesLength];
                        if (!style || !style.getStroke() || style.getFill() || style.getText()) {
                            style = new ol_style_Style_js__WEBPACK_IMPORTED_MODULE_4__({ stroke: new ol_style_Stroke_js__WEBPACK_IMPORTED_MODULE_3__() });
                            styles[stylesLength] = style;
                        }
                        stroke = style.getStroke();
                        stroke.setLineCap(getValue(layer, 'layout', 'line-cap', zoom, f, functionCache, featureState));
                        stroke.setLineJoin(getValue(layer, 'layout', 'line-join', zoom, f, functionCache, featureState));
                        stroke.setMiterLimit(getValue(layer, 'layout', 'line-miter-limit', zoom, f, functionCache, featureState));
                        stroke.setColor(color);
                        stroke.setWidth(width);
                        stroke.setLineDash(paint['line-dasharray'] ? getValue(layer, 'paint', 'line-dasharray', zoom, f, functionCache, featureState).map(function (x) {
                            return x * width;
                        }) : null);
                        style.setZIndex(index);
                    }
                }
                let hasImage = false;
                let text = null;
                let placementAngle = 0;
                let icon, iconImg, skipLabel;
                if ((type == 1 || type == 2) && 'icon-image' in layout) {
                    const iconImage = getValue(layer, 'layout', 'icon-image', zoom, f, functionCache, featureState);
                    if (iconImage) {
                        icon = typeof iconImage === 'string' ? fromTemplate(iconImage, properties) : iconImage.toString();
                        let styleGeom = undefined;
                        const imageElement = getImage ? getImage(olLayer, icon) : undefined;
                        if (spriteImage && spriteData && spriteData[icon] || imageElement) {
                            const iconRotationAlignment = getValue(layer, 'layout', 'icon-rotation-alignment', zoom, f, functionCache, featureState);
                            if (type == 2) {
                                const geom = feature.getGeometry();
                                // ol package and ol-debug.js only
                                if (geom.getFlatMidpoint || geom.getFlatMidpoints) {
                                    const extent = geom.getExtent();
                                    const size = Math.sqrt(Math.max(Math.pow((extent[2] - extent[0]) / resolution, 2), Math.pow((extent[3] - extent[1]) / resolution, 2)));
                                    if (size > 150) {
                                        //FIXME Do not hard-code a size of 150
                                        const midpoint = geom.getType() === 'MultiLineString' ? geom.getFlatMidpoints() : geom.getFlatMidpoint();
                                        if (!renderFeature) {
                                            renderFeatureCoordinates = [
                                                NaN,
                                                NaN
                                            ];
                                            renderFeature = new ol_render_Feature_js__WEBPACK_IMPORTED_MODULE_34__["default"]('Point', renderFeatureCoordinates, [], 2, {}, undefined);
                                        }
                                        styleGeom = renderFeature;
                                        renderFeatureCoordinates[0] = midpoint[0];
                                        renderFeatureCoordinates[1] = midpoint[1];
                                        const placement = getValue(layer, 'layout', 'symbol-placement', zoom, f, functionCache, featureState);
                                        if (placement === 'line' && iconRotationAlignment === 'map') {
                                            const stride = geom.getStride();
                                            const coordinates = geom.getFlatCoordinates();
                                            for (let i = 0, ii = coordinates.length - stride; i < ii; i += stride) {
                                                const x1 = coordinates[i];
                                                const y1 = coordinates[i + 1];
                                                const x2 = coordinates[i + stride];
                                                const y2 = coordinates[i + stride + 1];
                                                const minX = Math.min(x1, x2);
                                                const minY = Math.min(y1, y2);
                                                const maxX = Math.max(x1, x2);
                                                const maxY = Math.max(y1, y2);
                                                if (midpoint[0] >= minX && midpoint[0] <= maxX && midpoint[1] >= minY && midpoint[1] <= maxY) {
                                                    placementAngle = Math.atan2(y1 - y2, x2 - x1);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (type !== 2 || styleGeom) {
                                const iconSize = getValue(layer, 'layout', 'icon-size', zoom, f, functionCache, featureState);
                                const iconColor = paint['icon-color'] !== undefined ? getValue(layer, 'paint', 'icon-color', zoom, f, functionCache, featureState) : null;
                                if (!iconColor || iconColor.a !== 0) {
                                    const haloColor = getValue(layer, 'paint', 'icon-halo-color', zoom, f, functionCache, featureState);
                                    const haloWidth = getValue(layer, 'paint', 'icon-halo-width', zoom, f, functionCache, featureState);
                                    let iconCacheKey = `${ icon }.${ iconSize }.${ haloWidth }.${ haloColor }`;
                                    if (iconColor !== null) {
                                        iconCacheKey += `.${ iconColor }`;
                                    }
                                    iconImg = iconImageCache[iconCacheKey];
                                    if (!iconImg) {
                                        const declutterMode = getDeclutterMode(layer, zoom, f, 'icon', functionCache);
                                        let displacement;
                                        if ('icon-offset' in layout) {
                                            displacement = getValue(layer, 'layout', 'icon-offset', zoom, f, functionCache, featureState).slice(0);
                                            displacement[0] *= iconSize;
                                            displacement[1] *= -iconSize;
                                        }
                                        let color = iconColor ? [
                                            iconColor.r * 255,
                                            iconColor.g * 255,
                                            iconColor.b * 255,
                                            iconColor.a
                                        ] : undefined;
                                        if (imageElement) {
                                            const iconOptions = {
                                                color: color,
                                                rotateWithView: iconRotationAlignment === 'map',
                                                displacement: displacement,
                                                declutterMode: declutterMode,
                                                scale: iconSize
                                            };
                                            if (typeof imageElement === 'string') {
                                                // it is a src URL
                                                iconOptions.src = imageElement;
                                            } else {
                                                iconOptions.img = imageElement;
                                                iconOptions.imgSize = [
                                                    imageElement.width,
                                                    imageElement.height
                                                ];
                                            }
                                            iconImg = new ol_style_Icon_js__WEBPACK_IMPORTED_MODULE_2__(iconOptions);
                                        } else {
                                            const spriteImageData = spriteData[icon];
                                            let img, size, offset;
                                            if (haloWidth) {
                                                if (spriteImageData.sdf) {
                                                    img = drawIconHalo(drawSDF(spriteImage, spriteImageData, iconColor), {
                                                        x: 0,
                                                        y: 0,
                                                        width: spriteImageData.width,
                                                        height: spriteImageData.height,
                                                        pixelRatio: spriteImageData.pixelRatio
                                                    }, haloWidth, haloColor);
                                                    color = undefined;    // do not tint haloed icons
                                                } else {
                                                    img = drawIconHalo(spriteImage, spriteImageData, haloWidth, haloColor);
                                                }
                                            } else {
                                                if (spriteImageData.sdf) {
                                                    if (!spriteImageUnSDFed) {
                                                        spriteImageUnSDFed = drawSDF(spriteImage, {
                                                            x: 0,
                                                            y: 0,
                                                            width: spriteImageSize[0],
                                                            height: spriteImageSize[1]
                                                        }, {
                                                            r: 1,
                                                            g: 1,
                                                            b: 1,
                                                            a: 1
                                                        });
                                                    }
                                                    img = spriteImageUnSDFed;
                                                } else {
                                                    img = spriteImage;
                                                }
                                                size = [
                                                    spriteImageData.width,
                                                    spriteImageData.height
                                                ];
                                                offset = [
                                                    spriteImageData.x,
                                                    spriteImageData.y
                                                ];
                                            }
                                            iconImg = new ol_style_Icon_js__WEBPACK_IMPORTED_MODULE_2__({
                                                color: color,
                                                img: img,
                                                // @ts-ignore
                                                imgSize: spriteImageSize,
                                                size: size,
                                                offset: offset,
                                                rotateWithView: iconRotationAlignment === 'map',
                                                scale: iconSize / spriteImageData.pixelRatio,
                                                displacement: displacement,
                                                declutterMode: declutterMode
                                            });
                                        }
                                        iconImageCache[iconCacheKey] = iconImg;
                                    }
                                }
                                if (iconImg) {
                                    ++stylesLength;
                                    style = styles[stylesLength];
                                    if (!style || !style.getImage() || style.getFill() || style.getStroke()) {
                                        style = new ol_style_Style_js__WEBPACK_IMPORTED_MODULE_4__();
                                        styles[stylesLength] = style;
                                    }
                                    style.setGeometry(styleGeom);
                                    iconImg.setRotation(placementAngle + deg2rad(getValue(layer, 'layout', 'icon-rotate', zoom, f, functionCache, featureState)));
                                    iconImg.setOpacity(getValue(layer, 'paint', 'icon-opacity', zoom, f, functionCache, featureState));
                                    iconImg.setAnchor(anchor[getValue(layer, 'layout', 'icon-anchor', zoom, f, functionCache, featureState)]);
                                    style.setImage(iconImg);
                                    text = style.getText();
                                    style.setText(undefined);
                                    style.setZIndex(index);
                                    hasImage = true;
                                    skipLabel = false;
                                }
                            } else {
                                skipLabel = true;
                            }
                        }
                    }
                }
                if (type == 1 && layer.type === 'circle') {
                    ++stylesLength;
                    style = styles[stylesLength];
                    if (!style || !style.getImage() || style.getFill() || style.getStroke()) {
                        style = new ol_style_Style_js__WEBPACK_IMPORTED_MODULE_4__();
                        styles[stylesLength] = style;
                    }
                    const circleRadius = 'circle-radius' in paint ? getValue(layer, 'paint', 'circle-radius', zoom, f, functionCache, featureState) : 5;
                    const circleStrokeColor = colorWithOpacity(getValue(layer, 'paint', 'circle-stroke-color', zoom, f, functionCache, featureState), getValue(layer, 'paint', 'circle-stroke-opacity', zoom, f, functionCache, featureState));
                    const circleTranslate = getValue(layer, 'paint', 'circle-translate', zoom, f, functionCache, featureState);
                    const circleColor = colorWithOpacity(getValue(layer, 'paint', 'circle-color', zoom, f, functionCache, featureState), getValue(layer, 'paint', 'circle-opacity', zoom, f, functionCache, featureState));
                    const circleStrokeWidth = getValue(layer, 'paint', 'circle-stroke-width', zoom, f, functionCache, featureState);
                    const cache_key = circleRadius + '.' + circleStrokeColor + '.' + circleColor + '.' + circleStrokeWidth + '.' + circleTranslate[0] + '.' + circleTranslate[1];
                    iconImg = iconImageCache[cache_key];
                    if (!iconImg) {
                        iconImg = new ol_style_Circle_js__WEBPACK_IMPORTED_MODULE_0__({
                            radius: circleRadius,
                            displacement: [
                                circleTranslate[0],
                                -circleTranslate[1]
                            ],
                            stroke: circleStrokeColor && circleStrokeWidth > 0 ? new ol_style_Stroke_js__WEBPACK_IMPORTED_MODULE_3__({
                                width: circleStrokeWidth,
                                color: circleStrokeColor
                            }) : undefined,
                            fill: circleColor ? new ol_style_Fill_js__WEBPACK_IMPORTED_MODULE_1__({ color: circleColor }) : undefined,
                            declutterMode: 'none'
                        });
                        iconImageCache[cache_key] = iconImg;
                    }
                    style.setImage(iconImg);
                    text = style.getText();
                    style.setText(undefined);
                    style.setGeometry(undefined);
                    style.setZIndex(index);
                    hasImage = true;
                }
                let label, font, textLineHeight, textSize, letterSpacing, maxTextWidth;
                if ('text-field' in layout) {
                    textSize = Math.round(getValue(layer, 'layout', 'text-size', zoom, f, functionCache, featureState));
                    const fontArray = getValue(layer, 'layout', 'text-font', zoom, f, functionCache, featureState);
                    textLineHeight = getValue(layer, 'layout', 'text-line-height', zoom, f, functionCache, featureState);
                    font = mb2css(getFonts ? getFonts(fontArray, glStyle.metadata ? glStyle.metadata['ol:webfonts'] : undefined) : fontArray, textSize, textLineHeight);
                    if (!font.includes('sans-serif')) {
                        font += ',sans-serif';
                    }
                    letterSpacing = getValue(layer, 'layout', 'text-letter-spacing', zoom, f, functionCache, featureState);
                    maxTextWidth = getValue(layer, 'layout', 'text-max-width', zoom, f, functionCache, featureState);
                    const textField = getValue(layer, 'layout', 'text-field', zoom, f, functionCache, featureState);
                    if (typeof textField === 'object' && textField.sections) {
                        if (textField.sections.length === 1) {
                            label = textField.toString();
                        } else {
                            label = textField.sections.reduce((acc, chunk, i) => {
                                const fonts = chunk.fontStack ? chunk.fontStack.split(',') : fontArray;
                                const chunkFont = mb2css(getFonts ? getFonts(fonts) : fonts, textSize * (chunk.scale || 1), textLineHeight);
                                let text = chunk.text;
                                if (text === '\n') {
                                    acc.push('\n', '');
                                    return acc;
                                }
                                if (type == 2) {
                                    acc.push(applyLetterSpacing(text, letterSpacing), chunkFont);
                                    return;
                                }
                                text = wrapText(text, chunkFont, maxTextWidth, letterSpacing).split('\n');
                                for (let i = 0, ii = text.length; i < ii; ++i) {
                                    if (i > 0) {
                                        acc.push('\n', '');
                                    }
                                    acc.push(text[i], chunkFont);
                                }
                                return acc;
                            }, []);
                        }
                    } else {
                        label = fromTemplate(textField, properties).trim();
                    }
                    opacity = getValue(layer, 'paint', 'text-opacity', zoom, f, functionCache, featureState);
                }
                if (label && opacity && !skipLabel) {
                    if (!hasImage) {
                        ++stylesLength;
                        style = styles[stylesLength];
                        if (!style || !style.getText() || style.getFill() || style.getStroke()) {
                            style = new ol_style_Style_js__WEBPACK_IMPORTED_MODULE_4__();
                            styles[stylesLength] = style;
                        }
                        style.setImage(undefined);
                        style.setGeometry(undefined);
                    }
                    const declutterMode = getDeclutterMode(layer, zoom, f, 'text', functionCache);
                    if (!style.getText()) {
                        style.setText(text);
                    }
                    text = style.getText();
                    if (!text || 'getDeclutterMode' in text && text.getDeclutterMode() !== declutterMode) {
                        text = new ol_style_Text_js__WEBPACK_IMPORTED_MODULE_5__({
                            padding: [
                                2,
                                2,
                                2,
                                2
                            ],
                            // @ts-ignore
                            declutterMode: declutterMode
                        });
                        style.setText(text);
                    }
                    const textTransform = getValue(layer, 'layout', 'text-transform', zoom, f, functionCache, featureState);
                    if (textTransform == 'uppercase') {
                        label = Array.isArray(label) ? label.map((t, i) => i % 2 ? t : t.toUpperCase()) : label.toUpperCase();
                    } else if (textTransform == 'lowercase') {
                        label = Array.isArray(label) ? label.map((t, i) => i % 2 ? t : t.toLowerCase()) : label.toLowerCase();
                    }
                    const wrappedLabel = Array.isArray(label) ? label : type == 2 ? applyLetterSpacing(label, letterSpacing) : wrapText(label, font, maxTextWidth, letterSpacing);
                    text.setText(wrappedLabel);
                    text.setFont(font);
                    text.setRotation(deg2rad(getValue(layer, 'layout', 'text-rotate', zoom, f, functionCache, featureState)));
                    const textAnchor = getValue(layer, 'layout', 'text-anchor', zoom, f, functionCache, featureState);
                    const placement = hasImage || type == 1 ? 'point' : getValue(layer, 'layout', 'symbol-placement', zoom, f, functionCache, featureState);
                    let textAlign;
                    if (placement === 'line-center') {
                        text.setPlacement('line');
                        textAlign = 'center';
                    } else {
                        text.setPlacement(placement);
                    }
                    if (placement === 'line' && typeof text.setRepeat === 'function') {
                        const symbolSpacing = getValue(layer, 'layout', 'symbol-spacing', zoom, f, functionCache, featureState);
                        text.setRepeat(symbolSpacing * 2);
                    }
                    text.setOverflow(placement === 'point');
                    let textHaloWidth = getValue(layer, 'paint', 'text-halo-width', zoom, f, functionCache, featureState);
                    const textOffset = getValue(layer, 'layout', 'text-offset', zoom, f, functionCache, featureState);
                    const textTranslate = getValue(layer, 'paint', 'text-translate', zoom, f, functionCache, featureState);
                    // Text offset has to take halo width and line height into account
                    let vOffset = 0;
                    let hOffset = 0;
                    if (placement == 'point') {
                        textAlign = 'center';
                        if (textAnchor.indexOf('left') !== -1) {
                            textAlign = 'left';
                            hOffset = textHaloWidth;
                        } else if (textAnchor.indexOf('right') !== -1) {
                            textAlign = 'right';
                            hOffset = -textHaloWidth;
                        }
                        const textRotationAlignment = getValue(layer, 'layout', 'text-rotation-alignment', zoom, f, functionCache, featureState);
                        text.setRotateWithView(textRotationAlignment == 'map');
                    } else {
                        text.setMaxAngle(deg2rad(getValue(layer, 'layout', 'text-max-angle', zoom, f, functionCache, featureState)) * label.length / wrappedLabel.length);
                        text.setRotateWithView(false);
                    }
                    text.setTextAlign(textAlign);
                    let textBaseline = 'middle';
                    if (textAnchor.indexOf('bottom') == 0) {
                        textBaseline = 'bottom';
                        vOffset = -textHaloWidth - 0.5 * (textLineHeight - 1) * textSize;
                    } else if (textAnchor.indexOf('top') == 0) {
                        textBaseline = 'top';
                        vOffset = textHaloWidth + 0.5 * (textLineHeight - 1) * textSize;
                    }
                    text.setTextBaseline(textBaseline);
                    const textJustify = getValue(layer, 'layout', 'text-justify', zoom, f, functionCache, featureState);
                    text.setJustify(textJustify === 'auto' ? undefined : textJustify);
                    text.setOffsetX(textOffset[0] * textSize + hOffset + textTranslate[0]);
                    text.setOffsetY(textOffset[1] * textSize + vOffset + textTranslate[1]);
                    textColor.setColor(colorWithOpacity(getValue(layer, 'paint', 'text-color', zoom, f, functionCache, featureState), opacity));
                    text.setFill(textColor);
                    const haloColor = colorWithOpacity(getValue(layer, 'paint', 'text-halo-color', zoom, f, functionCache, featureState), opacity);
                    if (haloColor && textHaloWidth > 0) {
                        textHalo.setColor(haloColor);
                        // spec here : https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-symbol-text-halo-width
                        // Halo width must be doubled because it is applied around the center of the text outline
                        textHaloWidth *= 2;
                        // 1/4 of text size (spec) x 2
                        const halfTextSize = 0.5 * textSize;
                        textHalo.setWidth(textHaloWidth <= halfTextSize ? textHaloWidth : halfTextSize);
                        text.setStroke(textHalo);
                    } else {
                        text.setStroke(undefined);
                    }
                    const textPadding = getValue(layer, 'layout', 'text-padding', zoom, f, functionCache, featureState);
                    const padding = text.getPadding();
                    if (textPadding !== padding[0]) {
                        padding[0] = textPadding;
                        padding[1] = textPadding;
                        padding[2] = textPadding;
                        padding[3] = textPadding;
                    }
                    style.setZIndex(index);
                }
            }
        }
        if (stylesLength > -1) {
            styles.length = stylesLength + 1;
            if (recordLayer) {
                if ('set' in feature) {
                    // ol/Feature
                    feature.set('mapbox-layer', featureBelongsToLayer);
                } else {
                    // ol/render/Feature
                    feature.getProperties()['mapbox-layer'] = featureBelongsToLayer;
                }
            }
            return styles;
        }
        return undefined;
    };
    olLayer.setStyle(styleFunction);
    olLayer.set('mapbox-source', mapboxSource);
    olLayer.set('mapbox-layers', mapboxLayers);
    olLayer.set('mapbox-featurestate', olLayer.get('mapbox-featurestate') || {});
    return styleFunction;
}
/**
 * Get the the style for a specific Mapbox layer only. This can be useful for creating a legend.
 * @param {import("ol/Feature").default|import("ol/render/Feature").default} feature OpenLayers feature.
 * @param {number} resolution View resolution.
 * @param {import("ol/layer").Vector|import("ol/layer").VectorTile} olLayer OpenLayers layer.
 * @param {string} layerId Id of the Mapbox layer to get the style for
 * @return {Array<import("ol/style").Style>} Styles for the provided Mapbox layer.
 */
function getStyleForLayer(feature, resolution, olLayer, layerId) {
    const evaluateStyle = olLayer.getStyleFunction();
    if (evaluateStyle.length === 3) {
        // @ts-ignore
        return evaluateStyle(feature, resolution, layerId);
    }
    return undefined;
}

/**
 * Generates a shaded relief image given elevation data.  Uses a 3x3
 * neighborhood for determining slope and aspect.
 * @param {Array<ImageData>} inputs Array of input images.
 * @param {Object} data Data added in the "beforeoperations" event.
 * @return {ImageData} Output image.
 */
function hillshade(inputs, data) {
    const elevationImage = inputs[0];
    const width = elevationImage.width;
    const height = elevationImage.height;
    const elevationData = elevationImage.data;
    const shadeData = new Uint8ClampedArray(elevationData.length);
    const dp = data.resolution * 2;
    const maxX = width - 1;
    const maxY = height - 1;
    const pixel = [
        0,
        0,
        0,
        0
    ];
    const twoPi = 2 * Math.PI;
    const halfPi = Math.PI / 2;
    const sunEl = Math.PI * data.sunEl / 180;
    const sunAz = Math.PI * data.sunAz / 180;
    const cosSunEl = Math.cos(sunEl);
    const sinSunEl = Math.sin(sunEl);
    const highlightColor = data.highlightColor;
    const shadowColor = data.shadowColor;
    const accentColor = data.accentColor;
    const encoding = data.encoding;
    let pixelX, pixelY, x0, x1, y0, y1, offset, z0, z1, dzdx, dzdy, slope, aspect, accent, scaled, shade, scaledAccentColor, compositeShadeColor, clamp, slopeScaleBase, scaledSlope, cosIncidence;
    function calculateElevation(pixel, encoding = 'mapbox') {
        // The method used to extract elevations from the DEM.
        //
        // The supported methods are the Mapbox format
        // (red * 256 * 256 + green * 256 + blue) * 0.1 - 10000
        // and the Terrarium format
        // (red * 256 + green + blue / 256) - 32768
        //
        if (encoding === 'mapbox') {
            return (pixel[0] * 256 * 256 + pixel[1] * 256 + pixel[2]) * 0.1 - 10000;
        }
        if (encoding === 'terrarium') {
            return pixel[0] * 256 + pixel[1] + pixel[2] / 256 - 32768;
        }
    }
    for (pixelY = 0; pixelY <= maxY; ++pixelY) {
        y0 = pixelY === 0 ? 0 : pixelY - 1;
        y1 = pixelY === maxY ? maxY : pixelY + 1;
        for (pixelX = 0; pixelX <= maxX; ++pixelX) {
            x0 = pixelX === 0 ? 0 : pixelX - 1;
            x1 = pixelX === maxX ? maxX : pixelX + 1;
            // determine elevation for (x0, pixelY)
            offset = (pixelY * width + x0) * 4;
            pixel[0] = elevationData[offset];
            pixel[1] = elevationData[offset + 1];
            pixel[2] = elevationData[offset + 2];
            pixel[3] = elevationData[offset + 3];
            z0 = data.vert * calculateElevation(pixel, encoding);
            // determine elevation for (x1, pixelY)
            offset = (pixelY * width + x1) * 4;
            pixel[0] = elevationData[offset];
            pixel[1] = elevationData[offset + 1];
            pixel[2] = elevationData[offset + 2];
            pixel[3] = elevationData[offset + 3];
            z1 = data.vert * calculateElevation(pixel, encoding);
            dzdx = (z1 - z0) / dp;
            // determine elevation for (pixelX, y0)
            offset = (y0 * width + pixelX) * 4;
            pixel[0] = elevationData[offset];
            pixel[1] = elevationData[offset + 1];
            pixel[2] = elevationData[offset + 2];
            pixel[3] = elevationData[offset + 3];
            z0 = data.vert * calculateElevation(pixel, encoding);
            // determine elevation for (pixelX, y1)
            offset = (y1 * width + pixelX) * 4;
            pixel[0] = elevationData[offset];
            pixel[1] = elevationData[offset + 1];
            pixel[2] = elevationData[offset + 2];
            pixel[3] = elevationData[offset + 3];
            z1 = data.vert * calculateElevation(pixel, encoding);
            dzdy = (z1 - z0) / dp;
            aspect = Math.atan2(dzdy, -dzdx);
            if (aspect < 0) {
                aspect = halfPi - aspect;
            } else if (aspect > halfPi) {
                aspect = twoPi - aspect + halfPi;
            } else {
                aspect = halfPi - aspect;
            }
            // Bootstrap slope and corresponding incident values
            slope = Math.atan(Math.sqrt(dzdx * dzdx + dzdy * dzdy));
            cosIncidence = sinSunEl * Math.cos(slope) + cosSunEl * Math.sin(slope) * Math.cos(sunAz - aspect);
            accent = Math.cos(slope);
            // 255 for Hex colors
            scaled = 255 * cosIncidence;
            /*
       * The following is heavily inspired
       * by [Maplibre's equivalent WebGL shader](https://github.com/maplibre/maplibre-gl-js/blob/main/src/shaders/hillshade.fragment.glsl)
       */
            // Forces given value to stay between two given extremes
            clamp = Math.min(Math.max(2 * data.sunEl, 0), 1);
            // Intensity basis for hillshade opacity
            slopeScaleBase = 1.875 - data.opacity * 1.75;
            // Intensity interpolation so that higher intensity values create more opaque hillshading
            scaledSlope = data.opacity !== 0.5 ? halfPi * ((Math.pow(slopeScaleBase, slope) - 1) / (Math.pow(slopeScaleBase, halfPi) - 1)) : slope;
            // Accent hillshade color with given accentColor to emphasize rougher terrain
            scaledAccentColor = {
                r: (1 - accent) * accentColor.r * clamp * 255,
                g: (1 - accent) * accentColor.g * clamp * 255,
                b: (1 - accent) * accentColor.b * clamp * 255,
                a: (1 - accent) * accentColor.a * clamp * 255
            };
            // Allows highlight vs shadow discrimination
            shade = Math.abs(((aspect + sunAz) / Math.PI + 0.5) % 2 - 1);
            // Creates a composite color mix between highlight & shadow colors to emphasize slopes
            compositeShadeColor = {
                r: (highlightColor.r * (1 - shade) + shadowColor.r * shade) * scaled,
                g: (highlightColor.g * (1 - shade) + shadowColor.g * shade) * scaled,
                b: (highlightColor.b * (1 - shade) + shadowColor.b * shade) * scaled,
                a: (highlightColor.a * (1 - shade) + shadowColor.a * shade) * scaled
            };
            // Fill in result color value
            offset = (pixelY * width + pixelX) * 4;
            shadeData[offset] = scaledAccentColor.r * (1 - shade) + compositeShadeColor.r;
            shadeData[offset + 1] = scaledAccentColor.g * (1 - shade) + compositeShadeColor.g;
            shadeData[offset + 2] = scaledAccentColor.b * (1 - shade) + compositeShadeColor.b;
            // Key opacity on the scaledSlope to improve legibility by increasing higher elevation rates' contrast
            shadeData[offset + 3] = elevationData[offset + 3] * data.opacity * clamp * Math.sin(scaledSlope);
        }
    }
    return new ImageData(shadeData, width, height);
}

/*
ol-mapbox-style - Use Mapbox Style objects with OpenLayers
Copyright 2016-present ol-mapbox-style contributors
License: https://raw.githubusercontent.com/openlayers/ol-mapbox-style/master/LICENSE
*/
/**
 * @typedef {Object} FeatureIdentifier
 * @property {string|number} id The feature id.
 * @property {string} source The source id.
 */
/**
 * @typedef {Object} Options
 * @property {string} [accessToken] Access token for 'mapbox://' urls.
 * @property {function(string, import("./util.js").ResourceType): (Request|string|Promise<Request|string>|void)} [transformRequest]
 * Function for controlling how `ol-mapbox-style` fetches resources. Can be used for modifying
 * the url, adding headers or setting credentials options. Called with the url and the resource
 * type as arguments, this function is supposed to return a `Request` or a url `string`, or a promise tehereof.
 * Without a return value the original request will not be modified.
 * @property {string} [projection='EPSG:3857'] Only useful when working with non-standard projections.
 * Code of a projection registered with OpenLayers. All sources of the style must be provided in this
 * projection. The projection must also have a valid extent defined, which will be used to determine the
 * origin and resolutions of the tile grid for all tiled sources of the style. When provided, the bbox
 * placeholder in tile and geojson urls changes: the default is `{bbox-epsg-3857}`, when projection is e.g.
 * set to `EPSG:4326`, the bbox placeholder will be `{bbox-epsg-4326}`.
 * @property {Array<number>} [resolutions] Only useful when working with non-standard projections.
 * Resolutions for mapping resolution to the `zoom` used in the Mapbox style.
 * @property {string} [styleUrl] URL of the Mapbox GL style. Required for styles that were provided
 * as object, when they contain a relative sprite url, or sources referencing data by relative url.
 * @property {function(VectorLayer|VectorTileLayer, string):HTMLImageElement|HTMLCanvasElement|string|undefined} [getImage=undefined]
 * Function that returns an image for an icon name. If the result is an HTMLImageElement, it must already be
 * loaded. The layer can be used to call layer.changed() when the loading and processing of the image has finished.
 * This function be used for icons not in the sprite or to override sprite icons.
 * @property {string} [accessTokenParam='access_token'] Access token param. For internal use.
 */
/**
 * @typedef {Object} ApplyStyleOptions
 * @property {string} [source=''] Source. Default is `''`, which causes the first source in the
 * style to be used.
 * @property {Array<string>} [layers] Layers. If no source is provided, the layers with the
 * provided ids will be used from the style's `layers` array. All layers need to use the same source.
 * @property {boolean} [updateSource=true] Update or create vector (tile) layer source with parameters
 * specified for the source in the mapbox style definition.
 */
/**
 * @param {import("ol/proj/Projection.js").default} projection Projection.
 * @param {number} [tileSize=512] Tile size.
 * @return {Array<number>} Resolutions.
 */
function getTileResolutions(projection, tileSize = 512) {
    return projection.getExtent() ? (0,ol_tilegrid_js__WEBPACK_IMPORTED_MODULE_31__.createXYZ)({
        extent: projection.getExtent(),
        tileSize: tileSize,
        maxZoom: 22
    }).getResolutions() : defaultResolutions;
}
/**
 * @param {string} styleUrl Style URL.
 * @param {Options} options Options.
 * @return {Options} Completed options with accessToken and accessTokenParam.
 */
function completeOptions(styleUrl, options) {
    if (!options.accessToken) {
        options = Object.assign({}, options);
        const searchParams = new URL(styleUrl).searchParams;
        // The last search parameter is the access token
        searchParams.forEach((value, key) => {
            options.accessToken = value;
            options.accessTokenParam = key;
        });
    }
    return options;
}
/**
 * Applies a style function to an `ol/layer/VectorTile` or `ol/layer/Vector`
 * with an `ol/source/VectorTile` or an `ol/source/Vector`. If the layer does not have a source
 * yet, it will be created and populated from the information in the `glStyle` (unless `updateSource` is
 * set to `false`).
 *
 * **Example:**
 * ```js
 * import {applyStyle} from 'ol-mapbox-style';
 * import {VectorTile} from 'ol/layer.js';
 *
 * const layer = new VectorTile({declutter: true});
 * applyStyle(layer, 'https://api.maptiler.com/maps/basic/style.json?key=YOUR_OPENMAPTILES_TOKEN');
 * ```
 *
 * The style function will render all layers from the `glStyle` object that use the source
 * of the first layer, the specified `source`, or a subset of layers from the same source. The
 * source needs to be a `"type": "vector"` or `"type": "geojson"` source.
 *
 * Two additional properties will be set on the provided layer:
 *
 *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the
 *    OpenLayers layer was created from. Usually `apply()` creates one
 *    OpenLayers layer per Mapbox Style source, unless the layer stack has
 *    layers from different sources in between.
 *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are
 *    included in the OpenLayers layer.
 *
 * @param {VectorTileLayer|VectorLayer} layer OpenLayers layer. When the layer has a source configured,
 * it will be modified to use the configuration from the glStyle's `source`. Options specified on the
 * layer's source will override those from the glStyle's `source`, except for `url` and
 * `tileUrlFunction`. When the source projection is the default (`EPSG:3857`), the `tileGrid` will
 * also be overridden. If you'd rather not have ol-mapbox-style modify the source, configure `applyStyle()`
 * with the `updateSource: false` option.
 * @param {string|Object} glStyle Mapbox Style object.
 * @param {string|Array<string>|Options&ApplyStyleOptions} [sourceOrLayersOrOptions] Options or
 * `source` key or an array of layer `id`s from the Mapbox Style object. When a `source` key is
 * provided, all layers for the specified source will be included in the style function. When layer
 * `id`s are provided, they must be from layers that use the same source. When not provided or a falsey
 * value, all layers using the first source specified in the glStyle will be rendered.
 * @param {Options&ApplyStyleOptions|string} [optionsOrPath] **Deprecated**. Options. Alternatively the path of the style file
 * (only required when a relative path is used for the `"sprite"` property of the style).
 * @param {Array<number>} [resolutions] **Deprecated**. Resolutions for mapping resolution to zoom level.
 * Only needed when working with non-standard tile grids or projections, can also be supplied with
 * options.
 * @return {Promise} Promise which will be resolved when the style can be used
 * for rendering.
 */
function applyStyle(layer, glStyle, sourceOrLayersOrOptions = '', optionsOrPath = {}, resolutions = undefined) {
    let styleUrl, sourceId;
    /** @type {Options&ApplyStyleOptions} */
    let options;
    let sourceOrLayers;
    let updateSource = true;
    if (typeof sourceOrLayersOrOptions !== 'string' && !Array.isArray(sourceOrLayersOrOptions)) {
        options = sourceOrLayersOrOptions;
        sourceOrLayers = options.source || options.layers;
        optionsOrPath = options;
    } else {
        sourceOrLayers = sourceOrLayersOrOptions;
    }
    if (typeof optionsOrPath === 'string') {
        styleUrl = optionsOrPath;
        options = {};
    } else {
        styleUrl = optionsOrPath.styleUrl;
        options = optionsOrPath;
    }
    if (options.updateSource === false) {
        updateSource = false;
    }
    if (!resolutions) {
        resolutions = options.resolutions;
    }
    if (!styleUrl && typeof glStyle === 'string' && !glStyle.trim().startsWith('{')) {
        styleUrl = glStyle;
    }
    if (styleUrl) {
        styleUrl = styleUrl.startsWith('data:') ? location.href : normalizeStyleUrl(styleUrl, options.accessToken);
        options = completeOptions(styleUrl, options);
    }
    return new Promise(function (resolve, reject) {
        // TODO: figure out where best place to check source type is
        // Note that the source arg is an array of gl layer ids and each must be
        // dereferenced to get source type to validate
        getGlStyle(glStyle, options).then(function (glStyle) {
            if (glStyle.version != 8) {
                return reject(new Error('glStyle version 8 required.'));
            }
            if (!(layer instanceof ol_layer_Vector_js__WEBPACK_IMPORTED_MODULE_24__ || layer instanceof ol_layer_VectorTile_js__WEBPACK_IMPORTED_MODULE_26__)) {
                return reject(new Error('Can only apply to VectorLayer or VectorTileLayer'));
            }
            const type = layer instanceof ol_layer_VectorTile_js__WEBPACK_IMPORTED_MODULE_26__ ? 'vector' : 'geojson';
            if (!sourceOrLayers) {
                sourceId = Object.keys(glStyle.sources).find(function (key) {
                    return glStyle.sources[key].type === type;
                });
                sourceOrLayers = sourceId;
            } else if (Array.isArray(sourceOrLayers)) {
                sourceId = glStyle.layers.find(function (layer) {
                    return layer.id === sourceOrLayers[0];
                }).source;
            } else {
                sourceId = sourceOrLayers;
            }
            if (!sourceId) {
                return reject(new Error(`No ${ type } source found in the glStyle.`));
            }
            function assignSource() {
                if (!updateSource) {
                    return Promise.resolve();
                }
                if (layer instanceof ol_layer_VectorTile_js__WEBPACK_IMPORTED_MODULE_26__) {
                    return setupVectorSource(glStyle.sources[sourceId], styleUrl, options).then(function (source) {
                        const targetSource = layer.getSource();
                        if (!targetSource) {
                            layer.setSource(source);
                        } else if (source !== targetSource) {
                            targetSource.setTileUrlFunction(source.getTileUrlFunction());
                            if (typeof targetSource.setUrls === 'function' && typeof source.getUrls === 'function') {
                                // to get correct keys for tile cache and queue
                                targetSource.setUrls(source.getUrls());
                            }
                            //@ts-ignore
                            if (!targetSource.format_) {
                                //@ts-ignore
                                targetSource.format_ = source.format_;
                            }
                            if (!targetSource.getAttributions()) {
                                targetSource.setAttributions(source.getAttributions());
                            }
                            if (targetSource.getTileLoadFunction() === ol_source_VectorTile_js__WEBPACK_IMPORTED_MODULE_27__.defaultLoadFunction) {
                                targetSource.setTileLoadFunction(source.getTileLoadFunction());
                            }
                            if ((0,ol_proj_js__WEBPACK_IMPORTED_MODULE_12__.equivalent)(targetSource.getProjection(), source.getProjection())) {
                                targetSource.tileGrid = source.getTileGrid();
                            }
                        }
                        if (!isFinite(layer.getMaxResolution()) && !isFinite(layer.getMinZoom())) {
                            const tileGrid = layer.getSource().getTileGrid();
                            layer.setMaxResolution(tileGrid.getResolution(tileGrid.getMinZoom()));
                        }
                    });
                }
                const glSource = glStyle.sources[sourceId];
                let source = layer.getSource();
                if (!source || source.get('mapbox-source') !== glSource) {
                    source = setupGeoJSONSource(glSource, styleUrl, options);
                }
                const targetSource = layer.getSource();
                if (!targetSource) {
                    layer.setSource(source);
                } else if (source !== targetSource) {
                    if (!targetSource.getAttributions()) {
                        targetSource.setAttributions(source.getAttributions());
                    }
                    //@ts-ignore
                    if (!targetSource.format_) {
                        //@ts-ignore
                        targetSource.format_ = source.getFormat();
                    }
                    //@ts-ignore
                    targetSource.url_ = source.getUrl();
                }
                return Promise.resolve();
            }
            let spriteScale, spriteData, spriteImageUrl, style;
            function onChange() {
                if (!style && (!glStyle.sprite || spriteData)) {
                    if (options.projection && !resolutions) {
                        const projection = (0,ol_proj_js__WEBPACK_IMPORTED_MODULE_12__.get)(options.projection);
                        const units = projection.getUnits();
                        if (units !== 'm') {
                            resolutions = defaultResolutions.map(resolution => resolution / ol_proj_Units_js__WEBPACK_IMPORTED_MODULE_29__.METERS_PER_UNIT[units]);
                        }
                    }
                    style = stylefunction(layer, glStyle, sourceOrLayers, resolutions, spriteData, spriteImageUrl, getFonts, options.getImage);
                    if (!layer.getStyle()) {
                        reject(new Error(`Nothing to show for source [${ sourceId }]`));
                    } else {
                        assignSource().then(resolve).catch(reject);
                    }
                } else if (style) {
                    layer.setStyle(style);
                    assignSource().then(resolve).catch(reject);
                } else {
                    reject(new Error('Something went wrong trying to apply style.'));
                }
            }
            if (glStyle.sprite) {
                const sprite = new URL(normalizeSpriteUrl(glStyle.sprite, options.accessToken, styleUrl || location.href));
                spriteScale = window.devicePixelRatio >= 1.5 ? 0.5 : 1;
                const sizeFactor = spriteScale == 0.5 ? '@2x' : '';
                let spriteUrl = sprite.origin + sprite.pathname + sizeFactor + '.json' + sprite.search;
                new Promise(function (resolve, reject) {
                    fetchResource('Sprite', spriteUrl, options).then(resolve).catch(function (error) {
                        spriteUrl = sprite.origin + sprite.pathname + '.json' + sprite.search;
                        fetchResource('Sprite', spriteUrl, options).then(resolve).catch(reject);
                    });
                }).then(function (spritesJson) {
                    if (spritesJson === undefined) {
                        reject(new Error('No sprites found.'));
                    }
                    spriteData = spritesJson;
                    spriteImageUrl = sprite.origin + sprite.pathname + sizeFactor + '.png' + sprite.search;
                    if (options.transformRequest) {
                        const transformed = options.transformRequest(spriteImageUrl, 'SpriteImage') || spriteImageUrl;
                        if (transformed instanceof Request || transformed instanceof Promise) {
                            spriteImageUrl = transformed;
                        }
                    }
                    onChange();
                }).catch(function (err) {
                    reject(new Error(`Sprites cannot be loaded: ${ spriteUrl }: ${ err.message }`));
                });
            } else {
                onChange();
            }
        }).catch(reject);
    });
}
const emptyObj = {};
function setFirstBackground(mapOrLayer, glStyle, options) {
    glStyle.layers.some(function (layer) {
        if (layer.type === 'background') {
            if (mapOrLayer instanceof ol_layer_Layer_js__WEBPACK_IMPORTED_MODULE_16__) {
                mapOrLayer.setBackground(function (resolution) {
                    return getBackgroundColor(layer, resolution, options, {});
                });
                return true;
            }
            if (mapOrLayer instanceof ol_Map_js__WEBPACK_IMPORTED_MODULE_19__ || mapOrLayer instanceof ol_layer_Group_js__WEBPACK_IMPORTED_MODULE_17__) {
                mapOrLayer.getLayers().insertAt(0, setupBackgroundLayer(layer, options, {}));
                return true;
            }
        }
    });
}
/**
 * Applies properties of the Mapbox Style's first `background` layer to the
 * provided map or layer (group).
 *
 * **Example:**
 * ```js
 * import {applyBackground} from 'ol-mapbox-style';
 * import {Map} from 'ol';
 *
 * const map = new Map({target: 'map'});
 * applyBackground(map, 'https://api.maptiler.com/maps/basic/style.json?key=YOUR_OPENMAPTILES_TOKEN');
 * ```
 * @param {Map|import("ol/layer/Base.js").default} mapOrLayer OpenLayers Map or layer (group).
 * @param {Object|string} glStyle Mapbox Style object or url.
 * @param {Options} options Options.
 * @return {Promise} Promise that resolves when the background is applied.
 */
function applyBackground(mapOrLayer, glStyle, options = {}) {
    return getGlStyle(glStyle, options).then(function (glStyle) {
        setFirstBackground(mapOrLayer, glStyle, options);
    });
}
function getSourceIdByRef(layers, ref) {
    let sourceId;
    layers.some(function (layer) {
        if (layer.id == ref) {
            sourceId = layer.source;
            return true;
        }
    });
    return sourceId;
}
function extentFromTileJSON(tileJSON, projection) {
    const bounds = tileJSON.bounds;
    if (bounds) {
        const ll = (0,ol_proj_js__WEBPACK_IMPORTED_MODULE_12__.fromLonLat)([
            bounds[0],
            bounds[1]
        ], projection);
        const tr = (0,ol_proj_js__WEBPACK_IMPORTED_MODULE_12__.fromLonLat)([
            bounds[2],
            bounds[3]
        ], projection);
        return [
            ll[0],
            ll[1],
            tr[0],
            tr[1]
        ];
    }
    return (0,ol_proj_js__WEBPACK_IMPORTED_MODULE_12__.get)(projection).getExtent();
}
function sourceOptionsFromTileJSON(glSource, tileJSON, options) {
    const tileJSONSource = new ol_source_TileJSON_js__WEBPACK_IMPORTED_MODULE_22__({
        tileJSON: tileJSON,
        tileSize: glSource.tileSize || tileJSON.tileSize || 512
    });
    const tileJSONDoc = tileJSONSource.getTileJSON();
    const tileGrid = tileJSONSource.getTileGrid();
    const projection = (0,ol_proj_js__WEBPACK_IMPORTED_MODULE_12__.get)(options.projection || 'EPSG:3857');
    const extent = extentFromTileJSON(tileJSONDoc, projection);
    const projectionExtent = projection.getExtent();
    const minZoom = tileJSONDoc.minzoom || 0;
    const maxZoom = tileJSONDoc.maxzoom || 22;
    /** @type {import("ol/source/VectorTile.js").Options} */
    const sourceOptions = {
        attributions: tileJSONSource.getAttributions(),
        projection: projection,
        tileGrid: new ol_tilegrid_TileGrid_js__WEBPACK_IMPORTED_MODULE_8__({
            origin: projectionExtent ? (0,ol_extent_js__WEBPACK_IMPORTED_MODULE_32__.getTopLeft)(projectionExtent) : tileGrid.getOrigin(0),
            extent: extent || tileGrid.getExtent(),
            minZoom: minZoom,
            resolutions: getTileResolutions(projection, tileJSON.tileSize).slice(0, maxZoom + 1),
            tileSize: tileGrid.getTileSize(0)
        })
    };
    if (Array.isArray(tileJSONDoc.tiles)) {
        sourceOptions.urls = tileJSONDoc.tiles;
    } else {
        sourceOptions.url = tileJSONDoc.tiles;
    }
    return sourceOptions;
}
function getBackgroundColor(glLayer, resolution, options, functionCache) {
    const background = {
        id: glLayer.id,
        type: glLayer.type
    };
    const layout = glLayer.layout || {};
    const paint = glLayer.paint || {};
    background['paint'] = paint;
    const zoom = getZoomForResolution(resolution, options.resolutions || defaultResolutions);
    let opacity;
    const bg = getValue(background, 'paint', 'background-color', zoom, emptyObj, functionCache);
    if (paint['background-opacity'] !== undefined) {
        opacity = getValue(background, 'paint', 'background-opacity', zoom, emptyObj, functionCache);
    }
    return layout.visibility == 'none' ? undefined : colorWithOpacity(bg, opacity);
}
/**
 * @param {Object} glLayer Mapbox Style layer object.
 * @param {Options} options Options.
 * @param {Object} functionCache Cache for functions.
 * @return {Layer} OpenLayers layer.
 */
function setupBackgroundLayer(glLayer, options, functionCache) {
    const div = document.createElement('div');
    div.className = 'ol-mapbox-style-background';
    div.style.position = 'absolute';
    div.style.width = '100%';
    div.style.height = '100%';
    return new ol_layer_Layer_js__WEBPACK_IMPORTED_MODULE_16__({
        source: new ol_source_Source_js__WEBPACK_IMPORTED_MODULE_21__({}),
        render(frameState) {
            const color = getBackgroundColor(glLayer, frameState.viewState.resolution, options, functionCache);
            div.style.backgroundColor = color;
            return div;
        }
    });
}
/**
 * Creates an OpenLayers VectorTile source for a gl source entry.
 * @param {Object} glSource "source" entry from a Mapbox Style object.
 * @param {string|undefined} styleUrl URL to use for the source. This is expected to be the complete http(s) url,
 * with access key applied.
 * @param {Options} options Options.
 * @return {Promise<import("ol/source/VectorTile").default>} Promise resolving to a VectorTile source.
 * @private
 */
function setupVectorSource(glSource, styleUrl, options) {
    return new Promise(function (resolve, reject) {
        getTileJson(glSource, styleUrl, options).then(function ({tileJson, tileLoadFunction}) {
            const sourceOptions = sourceOptionsFromTileJSON(glSource, tileJson, options);
            sourceOptions.tileLoadFunction = tileLoadFunction;
            sourceOptions.format = new ol_format_MVT_js__WEBPACK_IMPORTED_MODULE_18__();
            resolve(new ol_source_VectorTile_js__WEBPACK_IMPORTED_MODULE_27__(sourceOptions));
        }).catch(reject);
    });
}
function setupVectorLayer(glSource, styleUrl, options) {
    const layer = new ol_layer_VectorTile_js__WEBPACK_IMPORTED_MODULE_26__({
        declutter: true,
        visible: false
    });
    setupVectorSource(glSource, styleUrl, options).then(function (source) {
        source.set('mapbox-source', glSource);
        layer.setSource(source);
    }).catch(function (error) {
        layer.setSource(undefined);
    });
    return layer;
}
function getBboxTemplate(projection) {
    const projCode = projection ? projection.getCode() : 'EPSG:3857';
    return `{bbox-${ projCode.toLowerCase().replace(/[^a-z0-9]/g, '-') }}`;
}
function setupRasterSource(glSource, styleUrl, options) {
    return new Promise(function (resolve, reject) {
        getTileJson(glSource, styleUrl, options).then(function ({tileJson, tileLoadFunction}) {
            const source = new ol_source_TileJSON_js__WEBPACK_IMPORTED_MODULE_22__({
                interpolate: options.interpolate === undefined ? true : options.interpolate,
                transition: 0,
                crossOrigin: 'anonymous',
                tileJSON: tileJson
            });
            source.tileGrid = sourceOptionsFromTileJSON(glSource, tileJson, options).tileGrid;
            if (options.projection) {
                //@ts-ignore
                source.projection = (0,ol_proj_js__WEBPACK_IMPORTED_MODULE_12__.get)(options.projection);
            }
            const getTileUrl = source.getTileUrlFunction();
            if (tileLoadFunction) {
                source.setTileLoadFunction(tileLoadFunction);
            }
            source.setTileUrlFunction(function (tileCoord, pixelRatio, projection) {
                const bboxTemplate = getBboxTemplate(projection);
                let src = getTileUrl(tileCoord, pixelRatio, projection);
                if (src.indexOf(bboxTemplate) != -1) {
                    const bbox = source.getTileGrid().getTileCoordExtent(tileCoord);
                    src = src.replace(bboxTemplate, bbox.toString());
                }
                return src;
            });
            source.set('mapbox-source', glSource);
            resolve(source);
        }).catch(function (error) {
            reject(error);
        });
    });
}
function setupRasterLayer(glSource, styleUrl, options) {
    const layer = new ol_layer_Tile_js__WEBPACK_IMPORTED_MODULE_23__();
    setupRasterSource(glSource, styleUrl, options).then(function (source) {
        layer.setSource(source);
    }).catch(function () {
        layer.setSource(undefined);
    });
    return layer;
}
/**
 *
 * @param {Object} glSource "source" entry from a Mapbox Style object.
 * @param {string} styleUrl Style url
 * @param {Options} options ol-mapbox-style options.
 * @return {ImageLayer<Raster>} The raster layer
 */
function setupHillshadeLayer(glSource, styleUrl, options) {
    const tileLayer = setupRasterLayer(glSource, styleUrl, options);
    /** @type {ImageLayer<Raster>} */
    const layer = new ol_layer_Image_js__WEBPACK_IMPORTED_MODULE_15__({
        source: new ol_source_Raster_js__WEBPACK_IMPORTED_MODULE_20__({
            operationType: 'image',
            operation: hillshade,
            sources: [tileLayer]
        })
    });
    return layer;
}
/**
 * @param {Object} glSource glStyle source.
 * @param {string} styleUrl Style URL.
 * @param {Options} options Options.
 * @return {VectorSource} Configured vector source.
 */
function setupGeoJSONSource(glSource, styleUrl, options) {
    const geoJsonFormat = options.projection ? new ol_format_GeoJSON_js__WEBPACK_IMPORTED_MODULE_14__({ dataProjection: options.projection }) : new ol_format_GeoJSON_js__WEBPACK_IMPORTED_MODULE_14__();
    const data = glSource.data;
    const sourceOptions = {};
    if (typeof data == 'string') {
        const geoJsonUrl = normalizeSourceUrl(data, options.accessToken, options.accessTokenParam || 'access_token', styleUrl || location.href);
        if (/\{bbox-[0-9a-z-]+\}/.test(geoJsonUrl)) {
            const extentUrl = (extent, resolution, projection) => {
                const bboxTemplate = getBboxTemplate(projection);
                return geoJsonUrl.replace(bboxTemplate, `${ extent.join(',') }`);
            };
            const source = new ol_source_Vector_js__WEBPACK_IMPORTED_MODULE_25__({
                attributions: glSource.attribution,
                format: geoJsonFormat,
                loader: (extent, resolution, projection, success, failure) => {
                    const url = typeof extentUrl === 'function' ? extentUrl(extent, resolution, projection) : extentUrl;
                    fetchResource('GeoJSON', url, options).then(json => {
                        const features = source.getFormat().readFeatures(json, { featureProjection: projection });
                        source.addFeatures(features);
                        success(features);
                    }).catch(response => {
                        source.removeLoadedExtent(extent);
                        failure();
                    });
                },
                strategy: ol_loadingstrategy_js__WEBPACK_IMPORTED_MODULE_30__.bbox
            });
            source.set('mapbox-source', glSource);
            return source;
        }
        const source = new ol_source_Vector_js__WEBPACK_IMPORTED_MODULE_25__({
            attributions: glSource.attribution,
            format: geoJsonFormat,
            url: geoJsonUrl,
            loader: (extent, resolution, projection, success, failure) => {
                fetchResource('GeoJSON', geoJsonUrl, options).then(json => {
                    const features = source.getFormat().readFeatures(json, { featureProjection: projection });
                    source.addFeatures(features);
                    success(features);
                }).catch(response => {
                    source.removeLoadedExtent(extent);
                    failure();
                });
            }
        });
        return source;
    }
    sourceOptions.features = geoJsonFormat.readFeatures(data, { featureProjection: (0,ol_proj_js__WEBPACK_IMPORTED_MODULE_12__.getUserProjection)() || 'EPSG:3857' });
    const source = new ol_source_Vector_js__WEBPACK_IMPORTED_MODULE_25__(Object.assign({
        attributions: glSource.attribution,
        format: geoJsonFormat
    }, sourceOptions));
    source.set('mapbox-source', glSource);
    return source;
}
function setupGeoJSONLayer(glSource, styleUrl, options) {
    return new ol_layer_Vector_js__WEBPACK_IMPORTED_MODULE_24__({
        declutter: true,
        source: setupGeoJSONSource(glSource, styleUrl, options),
        visible: false
    });
}
function prerenderRasterLayer(glLayer, layer, functionCache) {
    let zoom = null;
    return function (event) {
        if (glLayer.paint && 'raster-opacity' in glLayer.paint && event.frameState.viewState.zoom !== zoom) {
            zoom = event.frameState.viewState.zoom;
            delete functionCache[glLayer.id];
            updateRasterLayerProperties(glLayer, layer, zoom, functionCache);
        }
    };
}
function updateRasterLayerProperties(glLayer, layer, zoom, functionCache) {
    const opacity = getValue(glLayer, 'paint', 'raster-opacity', zoom, emptyObj, functionCache);
    layer.setOpacity(opacity);
}
function manageVisibility(layer, mapOrGroup) {
    function onChange() {
        const glStyle = mapOrGroup.get('mapbox-style');
        if (!glStyle) {
            return;
        }
        const mapboxLayers = derefLayers(glStyle.layers);
        const layerMapboxLayerids = layer.get('mapbox-layers');
        const visible = mapboxLayers.filter(function (mapboxLayer) {
            return layerMapboxLayerids.includes(mapboxLayer.id);
        }).some(function (mapboxLayer) {
            return !mapboxLayer.layout || !mapboxLayer.layout.visibility || mapboxLayer.layout.visibility === 'visible';
        });
        if (layer.get('visible') !== visible) {
            layer.setVisible(visible);
        }
    }
    layer.on('change', onChange);
    onChange();
}
function setupLayer(glStyle, styleUrl, glLayer, options) {
    const functionCache = getFunctionCache(glStyle);
    const glLayers = glStyle.layers;
    const type = glLayer.type;
    const id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref);
    const glSource = glStyle.sources[id];
    let layer;
    if (type == 'background') {
        layer = setupBackgroundLayer(glLayer, options, functionCache);
    } else if (glSource.type == 'vector') {
        layer = setupVectorLayer(glSource, styleUrl, options);
    } else if (glSource.type == 'raster') {
        layer = setupRasterLayer(glSource, styleUrl, options);
        layer.setVisible(glLayer.layout ? glLayer.layout.visibility !== 'none' : true);
        layer.on('prerender', prerenderRasterLayer(glLayer, layer, functionCache));
    } else if (glSource.type == 'geojson') {
        layer = setupGeoJSONLayer(glSource, styleUrl, options);
    } else if (glSource.type == 'raster-dem' && glLayer.type == 'hillshade') {
        const hillshadeLayer = setupHillshadeLayer(glSource, styleUrl, options);
        layer = hillshadeLayer;
        hillshadeLayer.getSource().on('beforeoperations', function (event) {
            const data = event.data;
            data.resolution = event.resolution;
            const zoom = getZoomForResolution(event.resolution, options.resolutions || defaultResolutions);
            data.encoding = glSource.encoding;
            data.vert = 5 * getValue(glLayer, 'paint', 'hillshade-exaggeration', zoom, emptyObj, functionCache);
            data.sunAz = getValue(glLayer, 'paint', 'hillshade-illumination-direction', zoom, emptyObj, functionCache);
            data.sunEl = 35;
            data.opacity = 0.3;
            data.highlightColor = getValue(glLayer, 'paint', 'hillshade-highlight-color', zoom, emptyObj, functionCache);
            data.shadowColor = getValue(glLayer, 'paint', 'hillshade-shadow-color', zoom, emptyObj, functionCache);
            data.accentColor = getValue(glLayer, 'paint', 'hillshade-accent-color', zoom, emptyObj, functionCache);
        });
        layer.setVisible(glLayer.layout ? glLayer.layout.visibility !== 'none' : true);
    }
    const glSourceId = id;
    if (layer) {
        layer.set('mapbox-source', glSourceId);
    }
    return layer;
}
/**
 * @param {*} glStyle Mapbox Style.
 * @param {Map|LayerGroup} mapOrGroup Map or layer group.
 * @param {string} styleUrl Style URL.
 * @param {Options} options Options.
 * @return {Promise} Promise that resolves when the style is loaded.
 */
function processStyle(glStyle, mapOrGroup, styleUrl, options) {
    const promises = [];
    let view = null;
    if (mapOrGroup instanceof ol_Map_js__WEBPACK_IMPORTED_MODULE_19__) {
        view = mapOrGroup.getView();
        if (!view.isDef() && !view.getRotation() && !view.getResolutions()) {
            const projection = options.projection ? (0,ol_proj_js__WEBPACK_IMPORTED_MODULE_12__.get)(options.projection) : view.getProjection();
            view = new ol_View_js__WEBPACK_IMPORTED_MODULE_28__(Object.assign(view.getProperties(), {
                maxResolution: defaultResolutions[0] / ol_proj_Units_js__WEBPACK_IMPORTED_MODULE_29__.METERS_PER_UNIT[projection.getUnits()],
                projection: options.projection || view.getProjection()
            }));
            mapOrGroup.setView(view);
        }
        if ('center' in glStyle && !view.getCenter()) {
            view.setCenter((0,ol_proj_js__WEBPACK_IMPORTED_MODULE_12__.fromLonLat)(glStyle.center, view.getProjection()));
        }
        if ('zoom' in glStyle && view.getZoom() === undefined) {
            view.setResolution(defaultResolutions[0] / ol_proj_Units_js__WEBPACK_IMPORTED_MODULE_29__.METERS_PER_UNIT[view.getProjection().getUnits()] / Math.pow(2, glStyle.zoom));
        }
        if (!view.getCenter() || view.getZoom() === undefined) {
            view.fit(view.getProjection().getExtent(), {
                nearest: true,
                size: mapOrGroup.getSize()
            });
        }
    }
    mapOrGroup.set('mapbox-style', glStyle);
    mapOrGroup.set('mapbox-metadata', {
        styleUrl,
        options
    });
    const glLayers = glStyle.layers;
    let layerIds = [];
    let layer, glSourceId, id;
    for (let i = 0, ii = glLayers.length; i < ii; ++i) {
        const glLayer = glLayers[i];
        const type = glLayer.type;
        if (type == 'heatmap') {
            //FIXME Unsupported layer type
            // eslint-disable-next-line no-console
            console.debug(`layers[${ i }].type "${ type }" not supported`);
            continue;
        } else {
            id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref);
            // this technique assumes gl layers will be in a particular order
            if (!id || id != glSourceId) {
                if (layerIds.length) {
                    promises.push(finalizeLayer(layer, layerIds, glStyle, styleUrl, mapOrGroup, options));
                    layerIds = [];
                }
                layer = setupLayer(glStyle, styleUrl, glLayer, options);
                if (!(layer instanceof ol_layer_Vector_js__WEBPACK_IMPORTED_MODULE_24__ || layer instanceof ol_layer_VectorTile_js__WEBPACK_IMPORTED_MODULE_26__)) {
                    layerIds = [];
                }
                glSourceId = layer.get('mapbox-source');
            }
            layerIds.push(glLayer.id);
        }
    }
    promises.push(finalizeLayer(layer, layerIds, glStyle, styleUrl, mapOrGroup, options));
    return Promise.all(promises);
}
/**
 * Loads and applies a Mapbox Style object into an OpenLayers Map or LayerGroup.
 * This includes the map background, the layers, and for Map instances that did not
 * have a View defined yet also the center and the zoom.
 *
 * **Example:**
 * ```js
 * import apply from 'ol-mapbox-style';
 *
 * apply('map', 'mapbox://styles/mapbox/bright-v9', {accessToken: 'YOUR_MAPBOX_TOKEN'});
 * ```
 *
 * The center and zoom will only be set if present in the Mapbox Style document,
 * and if not already set on the OpenLayers map.
 *
 * Layers will be added to the OpenLayers map, without affecting any layers that
 * might already be set on the map.
 *
 * Layers added by `apply()` will have two additional properties:
 *
 *  * `mapbox-source`: The `id` of the Mapbox Style document's source that the
 *    OpenLayers layer was created from. Usually `apply()` creates one
 *    OpenLayers layer per Mapbox Style source, unless the layer stack has
 *    layers from different sources in between.
 *  * `mapbox-layers`: The `id`s of the Mapbox Style document's layers that are
 *    included in the OpenLayers layer.
 *
 * This function sets an additional `mapbox-style` property on the OpenLayers
 * Map or LayerGroup instance, which holds the Mapbox Style object.
 *
 * @param {Map|HTMLElement|string|LayerGroup} mapOrGroupOrElement Either an existing
 * OpenLayers Map instance, or a HTML element, or the id of a HTML element that will be
 * the target of a new OpenLayers Map, or a layer group. If layer group, styles
 * releated to the map and view will be ignored.
 * @param {string|Object} style JSON style object or style url pointing to a
 * Mapbox Style object. When using Mapbox APIs, the url is the `styleUrl`
 * shown in Mapbox Studio's "share" panel. In addition, the `accessToken` option
 * (see below) must be set.
 * When passed as JSON style object, all OpenLayers layers created by `apply()`
 * will be immediately available, but they may not have a source yet (i.e. when
 * they are defined by a TileJSON url in the Mapbox Style document). When passed
 * as style url, layers will be added to the map when the Mapbox Style document
 * is loaded and parsed.
 * @param {Options} options Options.
 * @return {Promise<Map|LayerGroup>} A promise that resolves after all layers have been added to
 * the OpenLayers Map instance or LayerGroup, their sources set, and their styles applied. The
 * `resolve` callback will be called with the OpenLayers Map instance or LayerGroup as
 * argument.
 */
function apply(mapOrGroupOrElement, style, options = {}) {
    let promise;
    /** @type {Map|LayerGroup} */
    let mapOrGroup;
    if (typeof mapOrGroupOrElement === 'string' || mapOrGroupOrElement instanceof HTMLElement) {
        mapOrGroup = new ol_Map_js__WEBPACK_IMPORTED_MODULE_19__({ target: mapOrGroupOrElement });
    } else {
        mapOrGroup = mapOrGroupOrElement;
    }
    if (typeof style === 'string') {
        const styleUrl = style.startsWith('data:') ? location.href : normalizeStyleUrl(style, options.accessToken);
        options = completeOptions(styleUrl, options);
        promise = new Promise(function (resolve, reject) {
            getGlStyle(style, options).then(function (glStyle) {
                processStyle(glStyle, mapOrGroup, styleUrl, options).then(function () {
                    resolve(mapOrGroup);
                }).catch(reject);
            }).catch(function (err) {
                reject(new Error(`Could not load ${ style }: ${ err.message }`));
            });
        });
    } else {
        promise = new Promise(function (resolve, reject) {
            processStyle(style, mapOrGroup, !options.styleUrl || options.styleUrl.startsWith('data:') ? location.href : normalizeStyleUrl(options.styleUrl, options.accessToken), options).then(function () {
                resolve(mapOrGroup);
            }).catch(reject);
        });
    }
    return promise;
}
/**
 * If layerIds is not empty, applies the style specified in glStyle to the layer,
 * and adds the layer to the map.
 *
 * The layer may not yet have a source when the function is called.  If so, the style
 * is applied to the layer via a once listener on the 'change:source' event.
 *
 * @param {Layer} layer An OpenLayers layer instance.
 * @param {Array<string>} layerIds Array containing layer ids of already-processed layers.
 * @param {Object} glStyle Style as a JSON object.
 * @param {string|undefined} styleUrl The original style URL. Only required
 * when a relative path is used with the `"sprite"` property of the style.
 * @param {Map|LayerGroup} mapOrGroup OpenLayers Map.
 * @param {Options} options Options.
 * @return {Promise} Returns a promise that resolves after the source has
 * been set on the specified layer, and the style has been applied.
 */
function finalizeLayer(layer, layerIds, glStyle, styleUrl, mapOrGroup, options = {}) {
    let minZoom = 24;
    let maxZoom = 0;
    const glLayers = glStyle.layers;
    for (let i = 0, ii = glLayers.length; i < ii; ++i) {
        const glLayer = glLayers[i];
        if (layerIds.indexOf(glLayer.id) !== -1) {
            minZoom = Math.min('minzoom' in glLayer ? glLayer.minzoom : 0, minZoom);
            maxZoom = Math.max('maxzoom' in glLayer ? glLayer.maxzoom : 24, maxZoom);
        }
    }
    return new Promise(function (resolve, reject) {
        const setStyle = function () {
            const source = layer.getSource();
            if (!source || source.getState() === 'error') {
                reject(new Error('Error accessing data for source ' + layer.get('mapbox-source')));
                return;
            }
            if ('getTileGrid' in source) {
                const tileGrid = /** @type {import("ol/source/Tile.js").default|import("ol/source/VectorTile.js").default} */
                source.getTileGrid();
                if (tileGrid) {
                    const sourceMinZoom = tileGrid.getMinZoom();
                    if (minZoom > 0 || sourceMinZoom > 0) {
                        layer.setMaxResolution(Math.min(defaultTileGrid.getResolution(minZoom), tileGrid.getResolution(sourceMinZoom)) + 1e-9);
                    }
                    if (maxZoom < 24) {
                        layer.setMinResolution(defaultTileGrid.getResolution(maxZoom) + 1e-9);
                    }
                }
            } else {
                if (minZoom > 0) {
                    layer.setMaxResolution(defaultTileGrid.getResolution(minZoom) + 1e-9);
                }
            }
            if (source instanceof ol_source_Vector_js__WEBPACK_IMPORTED_MODULE_25__ || source instanceof ol_source_VectorTile_js__WEBPACK_IMPORTED_MODULE_27__) {
                applyStyle(layer, glStyle, layerIds, Object.assign({ styleUrl: styleUrl }, options)).then(function () {
                    manageVisibility(layer, mapOrGroup);
                    resolve();
                }).catch(reject);
            } else {
                resolve();
            }
        };
        layer.set('mapbox-layers', layerIds);
        const layers = mapOrGroup.getLayers();
        if (layers.getArray().indexOf(layer) === -1) {
            layers.push(layer);
        }
        if (layer.getSource()) {
            setStyle();
        } else {
            layer.once('change:source', setStyle);
        }
    });
}
/**
 * Get the Mapbox Layer object for the provided `layerId`.
 * @param {Map|LayerGroup} mapOrGroup Map or LayerGroup.
 * @param {string} layerId Mapbox Layer id.
 * @return {Object} Mapbox Layer object.
 */
function getMapboxLayer(mapOrGroup, layerId) {
    const style = mapOrGroup.get('mapbox-style');
    const layerStyle = style.layers.find(function (layer) {
        return layer.id === layerId;
    });
    return layerStyle;
}
/**
 * Add a new Mapbox Layer object to the style. The map will be re-rendered.
 * @param {Map|LayerGroup} mapOrGroup The Map or LayerGroup `apply` was called on.
 * @param {Object} mapboxLayer Mapbox Layer object.
 * @param {string} [beforeLayerId] Optional id of the Mapbox Layer before the new layer that will be added.
 * @return {Promise<void>} Resolves when the added layer is available.
 */
function addMapboxLayer(mapOrGroup, mapboxLayer, beforeLayerId) {
    const glStyle = mapOrGroup.get('mapbox-style');
    const mapboxLayers = glStyle.layers;
    let spliceIndex;
    let sourceIndex = -1;
    if (beforeLayerId !== undefined) {
        const beforeMapboxLayer = getMapboxLayer(mapOrGroup, beforeLayerId);
        if (beforeMapboxLayer === undefined) {
            throw new Error(`Layer with id "${ beforeLayerId }" not found.`);
        }
        spliceIndex = mapboxLayers.indexOf(beforeMapboxLayer);
    } else {
        spliceIndex = mapboxLayers.length;
    }
    let sourceOffset;
    if (spliceIndex > 0 && mapboxLayers[spliceIndex - 1].source === mapboxLayer.source) {
        sourceIndex = spliceIndex - 1;
        sourceOffset = -1;
    } else if (spliceIndex < mapboxLayers.length && mapboxLayers[spliceIndex].source === mapboxLayer.source) {
        sourceIndex = spliceIndex;
        sourceOffset = 0;
    }
    if (sourceIndex === -1) {
        const {options, styleUrl} = mapOrGroup.get('mapbox-metadata');
        const layer = setupLayer(glStyle, styleUrl, mapboxLayer, options);
        if (beforeLayerId) {
            const beforeLayer = getLayer(mapOrGroup, beforeLayerId);
            const beforeLayerIndex = mapOrGroup.getLayers().getArray().indexOf(beforeLayer);
            mapOrGroup.getLayers().insertAt(beforeLayerIndex, layer);
        }
        mapboxLayers.splice(spliceIndex, 0, mapboxLayer);
        return finalizeLayer(layer, [mapboxLayer.id], glStyle, styleUrl, mapOrGroup, options);
    }
    if (mapboxLayers.some(layer => layer.id === mapboxLayer.id)) {
        throw new Error(`Layer with id "${ mapboxLayer.id }" already exists.`);
    }
    const sourceLayerId = mapboxLayers[sourceIndex].id;
    const args = styleFunctionArgs[getStyleFunctionKey(mapOrGroup.get('mapbox-style'), getLayer(mapOrGroup, sourceLayerId))];
    mapboxLayers.splice(spliceIndex, 0, mapboxLayer);
    if (args) {
        const [olLayer, glStyle, sourceOrLayers, resolutions, spriteData, spriteImageUrl, getFonts, getImage] = args;
        if (Array.isArray(sourceOrLayers)) {
            const layerIndex = sourceOrLayers.indexOf(sourceLayerId) + sourceOffset;
            sourceOrLayers.splice(layerIndex, 0, mapboxLayer.id);
        }
        stylefunction(olLayer, glStyle, sourceOrLayers, resolutions, spriteData, spriteImageUrl, getFonts, getImage);
    } else {
        getLayer(mapOrGroup, mapboxLayers[sourceIndex].id).changed();
    }
    return Promise.resolve();
}
/**
 * Update a Mapbox Layer object in the style. The map will be re-rendered with the new style.
 * @param {Map|LayerGroup} mapOrGroup The Map or LayerGroup `apply` was called on.
 * @param {Object} mapboxLayer Updated Mapbox Layer object.
 */
function updateMapboxLayer(mapOrGroup, mapboxLayer) {
    const glStyle = mapOrGroup.get('mapbox-style');
    const mapboxLayers = glStyle.layers;
    const index = mapboxLayers.findIndex(function (layer) {
        return layer.id === mapboxLayer.id;
    });
    if (index === -1) {
        throw new Error(`Layer with id "${ mapboxLayer.id }" not found.`);
    }
    const oldLayer = mapboxLayers[index];
    if (oldLayer.source !== mapboxLayer.source) {
        throw new Error('Updated layer and previous version must use the same source.');
    }
    delete getFunctionCache(glStyle)[mapboxLayer.id];
    delete getFilterCache(glStyle)[mapboxLayer.id];
    mapboxLayers[index] = mapboxLayer;
    const args = styleFunctionArgs[getStyleFunctionKey(mapOrGroup.get('mapbox-style'), getLayer(mapOrGroup, mapboxLayer.id))];
    if (args) {
        stylefunction.apply(undefined, args);
    } else {
        getLayer(mapOrGroup, mapboxLayer.id).changed();
    }
}
/**
 * Updates a Mapbox source object in the style. The according OpenLayers source will be replaced
 * and the map will be re-rendered.
 * @param {Map|LayerGroup} mapOrGroup The Map or LayerGroup `apply` was called on.
 * @param {string} id Key of the source in the `sources` object literal.
 * @param {Object} mapboxSource Mapbox source object.
 * @return {Promise<Source>} Promise that resolves when the source has been updated.
 */
function updateMapboxSource(mapOrGroup, id, mapboxSource) {
    const currentSource = getSource(mapOrGroup, id);
    const layers = mapOrGroup.getLayers().getArray().filter(function (layer) {
        return (layer instanceof ol_layer_Vector_js__WEBPACK_IMPORTED_MODULE_24__ || layer instanceof ol_layer_Tile_js__WEBPACK_IMPORTED_MODULE_23__ || layer instanceof ol_layer_VectorTile_js__WEBPACK_IMPORTED_MODULE_26__) && layer.getSource() === currentSource;
    });
    const metadata = mapOrGroup.get('mapbox-metadata');
    let newSourcePromise;
    switch (mapboxSource.type) {
    case 'vector':
        newSourcePromise = setupVectorSource(mapboxSource, metadata.styleUrl, metadata.options);
        break;
    case 'geojson':
        newSourcePromise = Promise.resolve(setupGeoJSONSource(mapboxSource, metadata.styleUrl, metadata.options));
        break;
    case 'raster':
    case 'raster-dem':
        newSourcePromise = setupRasterSource(mapboxSource, metadata.styleUrl, metadata.options);
        break;
    default:
        return Promise.reject(new Error('Unsupported source type ' + mapboxSource.type));
    }
    newSourcePromise.then(function (newSource) {
        layers.forEach(function (layer) {
            layer.setSource(newSource);
        });
    });
    return newSourcePromise;
}
/**
 * Remove a Mapbox Layer object from the style. The map will be re-rendered.
 * @param {Map|LayerGroup} mapOrGroup The Map or LayerGroup `apply` was called on.
 * @param {string|Object} mapboxLayerIdOrLayer Mapbox Layer id or Mapbox Layer object.
 */
function removeMapboxLayer(mapOrGroup, mapboxLayerIdOrLayer) {
    const mapboxLayerId = typeof mapboxLayerIdOrLayer === 'string' ? mapboxLayerIdOrLayer : mapboxLayerIdOrLayer.id;
    const layer = getLayer(mapOrGroup, mapboxLayerId);
    /** @type {Array<Object>} */
    const layerMapboxLayers = layer.get('mapbox-layers');
    if (layerMapboxLayers.length === 1) {
        throw new Error('Cannot remove last Mapbox layer from an OpenLayers layer.');
    }
    layerMapboxLayers.splice(layerMapboxLayers.indexOf(mapboxLayerId), 1);
    const glStyle = mapOrGroup.get('mapbox-style');
    const layers = glStyle.layers;
    layers.splice(layers.findIndex(layer => layer.id === mapboxLayerId), 1);
    const args = styleFunctionArgs[getStyleFunctionKey(glStyle, layer)];
    if (args) {
        const [olLayer, glStyle, sourceOrLayers, resolutions, spriteData, spriteImageUrl, getFonts, getImage] = args;
        if (Array.isArray(sourceOrLayers)) {
            sourceOrLayers.splice(sourceOrLayers.findIndex(layer => layer === mapboxLayerId), 1);
        }
        stylefunction(olLayer, glStyle, sourceOrLayers, resolutions, spriteData, spriteImageUrl, getFonts, getImage);
    } else {
        getLayer(mapOrGroup, mapboxLayerId).changed();
    }
}
/**
 * Get the OpenLayers layer instance that contains the provided Mapbox Style
 * `layer`. Note that multiple Mapbox Style layers are combined in a single
 * OpenLayers layer instance when they use the same Mapbox Style `source`.
 * @param {Map|LayerGroup} map OpenLayers Map or LayerGroup.
 * @param {string} layerId Mapbox Style layer id.
 * @return {Layer} OpenLayers layer instance.
 */
function getLayer(map, layerId) {
    const layers = map.getLayers().getArray();
    for (let i = 0, ii = layers.length; i < ii; ++i) {
        const mapboxLayers = layers[i].get('mapbox-layers');
        if (mapboxLayers && mapboxLayers.indexOf(layerId) !== -1) {
            return layers[i];
        }
    }
    return undefined;
}
/**
 * Get the OpenLayers layer instances for the provided Mapbox Style `source`.
 * @param {Map|LayerGroup} map OpenLayers Map or LayerGroup.
 * @param {string} sourceId Mapbox Style source id.
 * @return {Array<Layer>} OpenLayers layer instances.
 */
function getLayers(map, sourceId) {
    const result = [];
    const layers = map.getLayers().getArray();
    for (let i = 0, ii = layers.length; i < ii; ++i) {
        if (layers[i].get('mapbox-source') === sourceId) {
            result.push(layers[i]);
        }
    }
    return result;
}
/**
 * Get the OpenLayers source instance for the provided Mapbox Style `source`.
 * @param {Map|LayerGroup} map OpenLayers Map or LayerGroup.
 * @param {string} sourceId Mapbox Style source id.
 * @return {Source} OpenLayers source instance.
 */
function getSource(map, sourceId) {
    const layers = map.getLayers().getArray();
    for (let i = 0, ii = layers.length; i < ii; ++i) {
        const source = /** @type {Layer} */
        layers[i].getSource();
        if (layers[i].get('mapbox-source') === sourceId) {
            return source;
        }
    }
    return undefined;
}
/**
 * Sets or removes a feature state. The feature state is taken into account for styling,
 * just like the feature's properties, and can be used e.g. to conditionally render selected
 * features differently.
 *
 * The feature state will be stored on the OpenLayers layer matching the feature identifier, in the
 * `mapbox-featurestate` property.
 * @param {Map|VectorLayer|VectorTileLayer} mapOrLayer OpenLayers Map or layer to set the feature
 * state on.
 * @param {FeatureIdentifier} feature Feature identifier.
 * @param {Object|null} state Feature state. Set to `null` to remove the feature state.
 */
function setFeatureState(mapOrLayer, feature, state) {
    const layers = 'getLayers' in mapOrLayer ? getLayers(mapOrLayer, feature.source) : [mapOrLayer];
    for (let i = 0, ii = layers.length; i < ii; ++i) {
        const featureState = layers[i].get('mapbox-featurestate');
        if (featureState) {
            if (state) {
                featureState[feature.id] = state;
            } else {
                delete featureState[feature.id];
            }
            layers[i].changed();
        } else {
            throw new Error(`Map or layer for source "${ feature.source }" not found.`);
        }
    }
}
/**
 * Sets or removes a feature state. The feature state is taken into account for styling,
 * just like the feature's properties, and can be used e.g. to conditionally render selected
 * features differently.
 * @param {Map|VectorLayer|VectorTileLayer} mapOrLayer Map or layer to set the feature state on.
 * @param {FeatureIdentifier} feature Feature identifier.
 * @return {Object|null} Feature state or `null` when no feature state is set for the given
 * feature identifier.
 */
function getFeatureState(mapOrLayer, feature) {
    const layers = 'getLayers' in mapOrLayer ? getLayers(mapOrLayer, feature.source) : [mapOrLayer];
    for (let i = 0, ii = layers.length; i < ii; ++i) {
        const featureState = layers[i].get('mapbox-featurestate');
        if (featureState && featureState[feature.id]) {
            return featureState[feature.id];
        }
    }
    return undefined;
}

/** @typedef {import("ol/Map.js").default} Map */
/**
 * @classdesc
 * Event emitted on configuration or loading error.
 */
class ErrorEvent extends ol_events_Event_js__WEBPACK_IMPORTED_MODULE_33__ {
    /**
   * @param {Error} error error object.
   */
    constructor(error) {
        super(ol_events_EventType_js__WEBPACK_IMPORTED_MODULE_35__["default"].ERROR);
        /**
     * @type {Error}
     */
        this.error = error;
    }
}
/**
 * @typedef {Object} Options
 * @property {string} styleUrl The URL of the Mapbox style object to use for this layer.  For a
 * style created with Mapbox Studio and hosted on Mapbox, this will look like
 * 'mapbox://styles/you/your-style'.
 * @property {string} [accessToken] The access token for your Mapbox style. This has to be provided
 * for `mapbox://` style urls. For `https://` and other urls, any access key must be the last query
 * parameter of the style url.
 * @property {string} [source] If your style uses more than one source, you need to use either the
 * `source` property or the `layers` property to limit rendering to a single vector source.  The
 * `source` property corresponds to the id of a vector source in your Mapbox style.
 * @property {Array<string>} [layers] Limit rendering to the list of included layers.  All layers
 * must share the same vector source.  If your style uses more than one source, you need to use
 * either the `source` property or the `layers` property to limit rendering to a single vector
 * source.
 * @property {boolean} [declutter=true] Declutter images and text. Decluttering is applied to all
 * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
 * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
 * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
 * higher priority.
 *
 * As an optimization decluttered features from layers with the same `className` are rendered above
 * the fill and stroke styles of all of those layers regardless of z-index.  To opt out of this
 * behavior and place declutterd features with their own layer configure the layer with a `className`
 * other than `ol-layer`.
 * @property {import("ol/layer/Base.js").BackgroundColor|false} [background] Background color for the layer.
 * If not specified, the background from the Mapbox style object will be used. Set to `false` to prevent
 * the Mapbox style's background from being used.
 * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
 * @property {number} [opacity=1] Opacity (0, 1).
 * @property {boolean} [visible=true] Visibility.
 * @property {import("ol/extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
 * rendered outside of this extent.
 * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
 * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
 * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
 * method was used.
 * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
 * visible.
 * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
 * be visible. If neither `maxResolution` nor `minZoom` are defined, the layer's `maxResolution` will
 * match the style source's `minzoom`.
 * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will
 * be visible. If neither `maxResolution` nor `minZoom` are defined, the layer's `minZoom` will match
 * the style source's `minzoom`.
 * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
 * be visible.
 * @property {import("ol/render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
 * features before rendering. By default features are drawn in the order that they are created. Use
 * `null` to avoid the sort, but get an undefined draw order.
 * @property {number} [renderBuffer=100] The buffer in pixels around the tile extent used by the
 * renderer when getting features from the vector tile for the rendering or hit-detection.
 * Recommended value: Vector tiles are usually generated with a buffer, so this value should match
 * the largest possible buffer of the used tiles. It should be at least the size of the largest
 * point symbol or line width.
 * @property {import("ol/layer/VectorTile.js").VectorTileRenderType} [renderMode='hybrid'] Render mode for vector tiles:
 *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels are scaled during zoom
 *    animations. Point symbols and texts are accurately rendered as vectors and can stay upright on
 *    rotated views.
 *  * `'vector'`: Everything is rendered as vectors. Use this mode for improved performance on vector
 *    tile layers with only a few rendered features (e.g. for highlighting a subset of features of
 *    another layer with the same source).
 * @property {import("ol/Map.js").default} [map] Sets the layer as overlay on a map. The map will not manage
 * this layer in its layers collection, and the layer will be rendered on top. This is useful for
 * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
 * use `map.addLayer()`.
 * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will be
 * recreated during animations. This means that no vectors will be shown clipped, but the setting
 * will have a performance impact for large amounts of vector data. When set to `false`, batches
 * will be recreated when no animation is active.
 * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will be
 * recreated during interactions. See also `updateWhileAnimating`.
 * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
 * means no preloading.
 * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
 * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.
 */
/**
 * @classdesc
 * ```js
 * import {MapboxVectorLayer} from 'ol-mapbox-style';
 * ```
 * A vector tile layer based on a Mapbox style that uses a single vector source.  Configure
 * the layer with the `styleUrl` and `accessToken` shown in Mapbox Studio's share panel.
 * If the style uses more than one source, use the `source` property to choose a single
 * vector source.  If you want to render a subset of the layers in the style, use the `layers`
 * property (all layers must share the same vector source).  See the constructor options for
 * more detail.
 *
 *     const map = new Map({
 *       view: new View({
 *         center: [0, 0],
 *         zoom: 1,
 *       }),
 *       layers: [
 *         new MapboxVectorLayer({
 *           styleUrl: 'mapbox://styles/mapbox/bright-v9',
 *           accessToken: 'your-mapbox-access-token-here',
 *         }),
 *       ],
 *       target: 'map',
 *     });
 *
 * On configuration or loading error, the layer will trigger an `'error'` event.  Listeners
 * will receive an object with an `error` property that can be used to diagnose the problem.
 *
 * **Note for users of the full build**: The `MapboxVectorLayer` requires the
 * [ol-mapbox-style](https://github.com/openlayers/ol-mapbox-style) library to be loaded as well.
 *
 * @param {Options} options Options.
 * @extends {VectorTileLayer}
 * @fires module:ol/events/Event~BaseEvent#event:error
 * @api
 */
class MapboxVectorLayer extends ol_layer_VectorTile_js__WEBPACK_IMPORTED_MODULE_26__ {
    /**
   * @param {Options} options Layer options.  At a minimum, `styleUrl` and `accessToken`
   * must be provided.
   */
    constructor(options) {
        const declutter = 'declutter' in options ? options.declutter : true;
        const source = new ol_source_VectorTile_js__WEBPACK_IMPORTED_MODULE_27__({
            state: 'loading',
            format: new ol_format_MVT_js__WEBPACK_IMPORTED_MODULE_18__()
        });
        super({
            source: source,
            background: options.background,
            declutter: declutter,
            className: options.className,
            opacity: options.opacity,
            visible: options.visible,
            zIndex: options.zIndex,
            minResolution: options.minResolution,
            maxResolution: options.maxResolution,
            minZoom: options.minZoom,
            maxZoom: options.maxZoom,
            renderOrder: options.renderOrder,
            renderBuffer: options.renderBuffer,
            renderMode: options.renderMode,
            map: options.map,
            updateWhileAnimating: options.updateWhileAnimating,
            updateWhileInteracting: options.updateWhileInteracting,
            preload: options.preload,
            useInterimTilesOnError: options.useInterimTilesOnError,
            properties: options.properties
        });
        if (options.accessToken) {
            this.accessToken = options.accessToken;
        }
        const url = options.styleUrl;
        const promises = [applyStyle(this, url, options.layers || options.source, { accessToken: this.accessToken })];
        if (this.getBackground() === undefined) {
            promises.push(applyBackground(this, options.styleUrl, { accessToken: this.accessToken }));
        }
        Promise.all(promises).then(() => {
            source.setState('ready');
        }).catch(error => {
            this.dispatchEvent(new ErrorEvent(error));
            const source = this.getSource();
            source.setState('error');
        });
    }
}


//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/ol/Disposable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Disposable.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/Disposable
 */

/**
 * @classdesc
 * Objects that need to clean up after themselves.
 */
class Disposable {
  constructor() {
    /**
     * The object has already been disposed.
     * @type {boolean}
     * @protected
     */
    this.disposed = false;
  }

  /**
   * Clean up.
   */
  dispose() {
    if (!this.disposed) {
      this.disposed = true;
      this.disposeInternal();
    }
  }

  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {}
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Disposable);


/***/ }),

/***/ "./node_modules/ol/Feature.js":
/*!************************************!*\
  !*** ./node_modules/ol/Feature.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createStyleFunction: () => (/* binding */ createStyleFunction),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/**
 * @module ol/Feature
 */





/**
 * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
 */

/**
 * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
 */

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *   import("./Observable").OnSignature<import("./ObjectEventType").Types|'change:geometry', import("./Object").ObjectEvent, Return> &
 *   import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types
 *     |'change:geometry', Return>} FeatureOnSignature
 */

/***
 * @template {import("./geom/Geometry.js").default} [Geometry=import("./geom/Geometry.js").default]
 * @typedef {Object<string, *> & { geometry?: Geometry }} ObjectWithGeometry
 */

/**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link module:ol/Object~BaseObject} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 *
 * import Feature from 'ol/Feature.js';
 * import Polygon from 'ol/geom/Polygon.js';
 * import Point from 'ol/geom/Point.js';
 *
 * const feature = new Feature({
 *   geometry: new Polygon(polyCoords),
 *   labelPoint: new Point(labelCoords),
 *   name: 'My Polygon',
 * });
 *
 * // get the polygon geometry
 * const poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * const point = feature.getGeometry();
 * ```
 *
 * @api
 * @template {import("./geom/Geometry.js").default} [Geometry=import("./geom/Geometry.js").default]
 */
class Feature extends _Object_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */
  constructor(geometryOrProperties) {
    super();

    /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */
    this.on;

    /***
     * @type {FeatureOnSignature<import("./events").EventsKey>}
     */
    this.once;

    /***
     * @type {FeatureOnSignature<void>}
     */
    this.un;

    /**
     * @private
     * @type {number|string|undefined}
     */
    this.id_ = undefined;

    /**
     * @type {string}
     * @private
     */
    this.geometryName_ = 'geometry';

    /**
     * User provided style.
     * @private
     * @type {import("./style/Style.js").StyleLike}
     */
    this.style_ = null;

    /**
     * @private
     * @type {import("./style/Style.js").StyleFunction|undefined}
     */
    this.styleFunction_ = undefined;

    /**
     * @private
     * @type {?import("./events.js").EventsKey}
     */
    this.geometryChangeKey_ = null;

    this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);

    if (geometryOrProperties) {
      if (
        typeof (
          /** @type {?} */ (geometryOrProperties).getSimplifiedGeometry
        ) === 'function'
      ) {
        const geometry = /** @type {Geometry} */ (geometryOrProperties);
        this.setGeometry(geometry);
      } else {
        /** @type {Object<string, *>} */
        const properties = geometryOrProperties;
        this.setProperties(properties);
      }
    }
  }

  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */
  clone() {
    const clone = /** @type {Feature<Geometry>} */ (
      new Feature(this.hasProperties() ? this.getProperties() : null)
    );
    clone.setGeometryName(this.getGeometryName());
    const geometry = this.getGeometry();
    if (geometry) {
      clone.setGeometry(/** @type {Geometry} */ (geometry.clone()));
    }
    const style = this.getStyle();
    if (style) {
      clone.setStyle(style);
    }
    return clone;
  }

  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */
  getGeometry() {
    return /** @type {Geometry|undefined} */ (this.get(this.geometryName_));
  }

  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }

  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */
  getGeometryName() {
    return this.geometryName_;
  }

  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */
  getStyle() {
    return this.style_;
  }

  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }

  /**
   * @private
   */
  handleGeometryChange_() {
    this.changed();
  }

  /**
   * @private
   */
  handleGeometryChanged_() {
    if (this.geometryChangeKey_) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.unlistenByKey)(this.geometryChangeKey_);
      this.geometryChangeKey_ = null;
    }
    const geometry = this.getGeometry();
    if (geometry) {
      this.geometryChangeKey_ = (0,_events_js__WEBPACK_IMPORTED_MODULE_1__.listen)(
        geometry,
        _events_EventType_js__WEBPACK_IMPORTED_MODULE_2__["default"].CHANGE,
        this.handleGeometryChange_,
        this
      );
    }
    this.changed();
  }

  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */
  setGeometry(geometry) {
    this.set(this.geometryName_, geometry);
  }

  /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setStyle(style) {
    this.style_ = style;
    this.styleFunction_ = !style ? undefined : createStyleFunction(style);
    this.changed();
  }

  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setId(id) {
    this.id_ = id;
    this.changed();
  }

  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */
  setGeometryName(name) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
    this.geometryName_ = name;
    this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
    this.handleGeometryChanged_();
  }
}

/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of Style or single style objects wrapped
 * in a new feature style function.
 * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {import("./style/Style.js").StyleFunction} A style function.
 */
function createStyleFunction(obj) {
  if (typeof obj === 'function') {
    return obj;
  }
  /**
   * @type {Array<import("./style/Style.js").default>}
   */
  let styles;
  if (Array.isArray(obj)) {
    styles = obj;
  } else {
    (0,_asserts_js__WEBPACK_IMPORTED_MODULE_3__.assert)(
      typeof (/** @type {?} */ (obj).getZIndex) === 'function',
      'Expected an `ol/style/Style` or an array of `ol/style/Style.js`'
    );
    const style = /** @type {import("./style/Style.js").default} */ (obj);
    styles = [style];
  }
  return function () {
    return styles;
  };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Feature);


/***/ }),

/***/ "./node_modules/ol/Object.js":
/*!***********************************!*\
  !*** ./node_modules/ol/Object.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ObjectEvent: () => (/* binding */ ObjectEvent),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _events_Event_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ObjectEventType.js */ "./node_modules/ol/ObjectEventType.js");
/* harmony import */ var _Observable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Observable.js */ "./node_modules/ol/Observable.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/Object
 */






/**
 * @classdesc
 * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
 */
class ObjectEvent extends _events_Event_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(type, key, oldValue) {
    super(type);

    /**
     * The name of the property whose value is changing.
     * @type {string}
     * @api
     */
    this.key = key;

    /**
     * The old value. To get the new value use `e.target.get(e.key)` where
     * `e` is the event object.
     * @type {*}
     * @api
     */
    this.oldValue = oldValue;
  }
}

/***
 * @template Return
 * @typedef {import("./Observable").OnSignature<import("./Observable").EventTypes, import("./events/Event.js").default, Return> &
 *    import("./Observable").OnSignature<import("./ObjectEventType").Types, ObjectEvent, Return> &
 *    import("./Observable").CombinedOnSignature<import("./Observable").EventTypes|import("./ObjectEventType").Types, Return>} ObjectOnSignature
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link module:ol/Observable~Observable} with observable
 * properties, where each property is observable as well as the object as a
 * whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link module:ol/Map~Map} has a `target` property, accessed with
 * `getTarget()` and changed with `setTarget()`. Not all properties are however
 * settable. There are also general-purpose accessors `get()` and `set()`. For
 * example, `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link module:ol/View~View} has a
 * `center` property, so `view.on('change:center', function(evt) {...});` would
 * call the function whenever the value of the center property changes. Within
 * the function, `evt.target` would be the view, so `evt.target.getCenter()`
 * would return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link module:ol/Object~BaseObject#getProperties}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @fires ObjectEvent
 * @api
 */
class BaseObject extends _Observable_js__WEBPACK_IMPORTED_MODULE_1__["default"] {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(values) {
    super();

    /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */
    this.on;

    /***
     * @type {ObjectOnSignature<import("./events").EventsKey>}
     */
    this.once;

    /***
     * @type {ObjectOnSignature<void>}
     */
    this.un;

    // Call {@link module:ol/util.getUid} to ensure that the order of objects' ids is
    // the same as the order in which they were created.  This also helps to
    // ensure that object properties are always added in the same order, which
    // helps many JavaScript engines generate faster code.
    (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.getUid)(this);

    /**
     * @private
     * @type {Object<string, *>|null}
     */
    this.values_ = null;

    if (values !== undefined) {
      this.setProperties(values);
    }
  }

  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(key) {
    let value;
    if (this.values_ && this.values_.hasOwnProperty(key)) {
      value = this.values_[key];
    }
    return value;
  }

  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return (this.values_ && Object.keys(this.values_)) || [];
  }

  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return (this.values_ && Object.assign({}, this.values_)) || {};
  }

  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.values_;
  }

  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }

  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(key, oldValue) {
    let eventType;
    eventType = `change:${key}`;
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
    eventType = _ObjectEventType_js__WEBPACK_IMPORTED_MODULE_3__["default"].PROPERTYCHANGE;
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
  }

  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(key, listener) {
    this.addEventListener(`change:${key}`, listener);
  }

  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(key, listener) {
    this.removeEventListener(`change:${key}`, listener);
  }

  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(key, value, silent) {
    const values = this.values_ || (this.values_ = {});
    if (silent) {
      values[key] = value;
    } else {
      const oldValue = values[key];
      values[key] = value;
      if (oldValue !== value) {
        this.notify(key, oldValue);
      }
    }
  }

  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(values, silent) {
    for (const key in values) {
      this.set(key, values[key], silent);
    }
  }

  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(source) {
    if (!source.values_) {
      return;
    }
    Object.assign(this.values_ || (this.values_ = {}), source.values_);
  }

  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(key, silent) {
    if (this.values_ && key in this.values_) {
      const oldValue = this.values_[key];
      delete this.values_[key];
      if ((0,_obj_js__WEBPACK_IMPORTED_MODULE_4__.isEmpty)(this.values_)) {
        this.values_ = null;
      }
      if (!silent) {
        this.notify(key, oldValue);
      }
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseObject);


/***/ }),

/***/ "./node_modules/ol/ObjectEventType.js":
/*!********************************************!*\
  !*** ./node_modules/ol/ObjectEventType.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/ObjectEventType
 */

/**
 * @enum {string}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: 'propertychange',
});

/**
 * @typedef {'propertychange'} Types
 */


/***/ }),

/***/ "./node_modules/ol/Observable.js":
/*!***************************************!*\
  !*** ./node_modules/ol/Observable.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   unByKey: () => (/* binding */ unByKey)
/* harmony export */ });
/* harmony import */ var _events_Target_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events/Target.js */ "./node_modules/ol/events/Target.js");
/* harmony import */ var _events_EventType_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events/EventType.js */ "./node_modules/ol/events/EventType.js");
/* harmony import */ var _events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./events.js */ "./node_modules/ol/events.js");
/**
 * @module ol/Observable
 */




/***
 * @template {string} Type
 * @template {Event|import("./events/Event.js").default} EventClass
 * @template Return
 * @typedef {(type: Type, listener: (event: EventClass) => ?) => Return} OnSignature
 */

/***
 * @template {string} Type
 * @template Return
 * @typedef {(type: Type[], listener: (event: Event|import("./events/Event").default) => ?) => Return extends void ? void : Return[]} CombinedOnSignature
 */

/**
 * @typedef {'change'|'error'} EventTypes
 */

/***
 * @template Return
 * @typedef {OnSignature<EventTypes, import("./events/Event.js").default, Return> & CombinedOnSignature<EventTypes, Return>} ObservableOnSignature
 */

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link module:ol/Observable~Observable#changed}.
 *
 * @fires import("./events/Event.js").default
 * @api
 */
class Observable extends _events_Target_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super();

    this.on =
      /** @type {ObservableOnSignature<import("./events").EventsKey>} */ (
        this.onInternal
      );

    this.once =
      /** @type {ObservableOnSignature<import("./events").EventsKey>} */ (
        this.onceInternal
      );

    this.un = /** @type {ObservableOnSignature<void>} */ (this.unInternal);

    /**
     * @private
     * @type {number}
     */
    this.revision_ = 0;
  }

  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_;
    this.dispatchEvent(_events_EventType_js__WEBPACK_IMPORTED_MODULE_1__["default"].CHANGE);
  }

  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }

  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(type, listener) {
    if (Array.isArray(type)) {
      const len = type.length;
      const keys = new Array(len);
      for (let i = 0; i < len; ++i) {
        keys[i] = (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listen)(this, type[i], listener);
      }
      return keys;
    }
    return (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listen)(this, /** @type {string} */ (type), listener);
  }

  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(type, listener) {
    let key;
    if (Array.isArray(type)) {
      const len = type.length;
      key = new Array(len);
      for (let i = 0; i < len; ++i) {
        key[i] = (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listenOnce)(this, type[i], listener);
      }
    } else {
      key = (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.listenOnce)(this, /** @type {string} */ (type), listener);
    }
    /** @type {Object} */ (listener).ol_key = key;
    return key;
  }

  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(type, listener) {
    const key = /** @type {Object} */ (listener).ol_key;
    if (key) {
      unByKey(key);
    } else if (Array.isArray(type)) {
      for (let i = 0, ii = type.length; i < ii; ++i) {
        this.removeEventListener(type[i], listener);
      }
    } else {
      this.removeEventListener(type, listener);
    }
  }
}

/**
 * Listen for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */
Observable.prototype.on;

/**
 * Listen once for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */
Observable.prototype.once;

/**
 * Unlisten for a certain type of event.
 * @function
 * @param {string|Array<string>} type The event type or array of event types.
 * @param {function((Event|import("./events/Event").default)): ?} listener The listener function.
 * @api
 */
Observable.prototype.un;

/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */
function unByKey(key) {
  if (Array.isArray(key)) {
    for (let i = 0, ii = key.length; i < ii; ++i) {
      (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.unlistenByKey)(key[i]);
    }
  } else {
    (0,_events_js__WEBPACK_IMPORTED_MODULE_2__.unlistenByKey)(/** @type {import("./events.js").EventsKey} */ (key));
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Observable);


/***/ }),

/***/ "./node_modules/ol/array.js":
/*!**********************************!*\
  !*** ./node_modules/ol/array.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ascending: () => (/* binding */ ascending),
/* harmony export */   binarySearch: () => (/* binding */ binarySearch),
/* harmony export */   descending: () => (/* binding */ descending),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   isSorted: () => (/* binding */ isSorted),
/* harmony export */   linearFindNearest: () => (/* binding */ linearFindNearest),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   reverseSubArray: () => (/* binding */ reverseSubArray),
/* harmony export */   stableSort: () => (/* binding */ stableSort)
/* harmony export */ });
/**
 * @module ol/array
 */

/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function} [comparator] Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */
function binarySearch(haystack, needle, comparator) {
  let mid, cmp;
  comparator = comparator || ascending;
  let low = 0;
  let high = haystack.length;
  let found = false;

  while (low < high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + ((high - low) >> 1);
    cmp = +comparator(haystack[mid], needle);

    if (cmp < 0.0) {
      /* Too low. */
      low = mid + 1;
    } else {
      /* Key found or too high */
      high = mid;
      found = !cmp;
    }
  }

  /* Key not found. */
  return found ? low : ~low;
}

/**
 * Compare function sorting arrays in ascending order.  Safe to use for numeric values.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */
function ascending(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}

/**
 * Compare function sorting arrays in descending order.  Safe to use for numeric values.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is greater than, equal to, or less than the second.
 */
function descending(a, b) {
  return a < b ? 1 : a > b ? -1 : 0;
}

/**
 * {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution} can use a function
 * of this type to determine which nearest resolution to use.
 *
 * This function takes a `{number}` representing a value between two array entries,
 * a `{number}` representing the value of the nearest higher entry and
 * a `{number}` representing the value of the nearest lower entry
 * as arguments and returns a `{number}`. If a negative number or zero is returned
 * the lower value will be used, if a positive number is returned the higher value
 * will be used.
 * @typedef {function(number, number, number): number} NearestDirectionFunction
 * @api
 */

/**
 * @param {Array<number>} arr Array in descending order.
 * @param {number} target Target.
 * @param {number|NearestDirectionFunction} direction
 *    0 means return the nearest,
 *    > 0 means return the largest nearest,
 *    < 0 means return the smallest nearest.
 * @return {number} Index.
 */
function linearFindNearest(arr, target, direction) {
  if (arr[0] <= target) {
    return 0;
  }

  const n = arr.length;
  if (target <= arr[n - 1]) {
    return n - 1;
  }

  if (typeof direction === 'function') {
    for (let i = 1; i < n; ++i) {
      const candidate = arr[i];
      if (candidate === target) {
        return i;
      }
      if (candidate < target) {
        if (direction(target, arr[i - 1], candidate) > 0) {
          return i - 1;
        }
        return i;
      }
    }
    return n - 1;
  }

  if (direction > 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] < target) {
        return i - 1;
      }
    }
    return n - 1;
  }

  if (direction < 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] <= target) {
        return i;
      }
    }
    return n - 1;
  }

  for (let i = 1; i < n; ++i) {
    if (arr[i] == target) {
      return i;
    }
    if (arr[i] < target) {
      if (arr[i - 1] - target < target - arr[i]) {
        return i - 1;
      }
      return i;
    }
  }
  return n - 1;
}

/**
 * @param {Array<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    const tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}

/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
 * @template VALUE
 */
function extend(arr, data) {
  const extension = Array.isArray(data) ? data : [data];
  const length = extension.length;
  for (let i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}

/**
 * @param {Array<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */
function remove(arr, obj) {
  const i = arr.indexOf(obj);
  const found = i > -1;
  if (found) {
    arr.splice(i, 1);
  }
  return found;
}

/**
 * @param {Array<any>|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array<any>|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */
function equals(arr1, arr2) {
  const len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (let i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}

/**
 * Sort the passed array such that the relative order of equal elements is preserved.
 * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.
 * @param {Array<*>} arr The array to sort (modifies original).
 * @param {!function(*, *): number} compareFnc Comparison function.
 * @api
 */
function stableSort(arr, compareFnc) {
  const length = arr.length;
  const tmp = Array(arr.length);
  let i;
  for (i = 0; i < length; i++) {
    tmp[i] = {index: i, value: arr[i]};
  }
  tmp.sort(function (a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });
  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
}

/**
 * @param {Array<*>} arr The array to test.
 * @param {Function} [func] Comparison function.
 * @param {boolean} [strict] Strictly sorted (default false).
 * @return {boolean} Return index.
 */
function isSorted(arr, func, strict) {
  const compare = func || ascending;
  return arr.every(function (currentVal, index) {
    if (index === 0) {
      return true;
    }
    const res = compare(arr[index - 1], currentVal);
    return !(res > 0 || (strict && res === 0));
  });
}


/***/ }),

/***/ "./node_modules/ol/asserts.js":
/*!************************************!*\
  !*** ./node_modules/ol/asserts.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assert: () => (/* binding */ assert)
/* harmony export */ });
/**
 * @module ol/asserts
 */

/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {string} errorMessage Error message.
 */
function assert(assertion, errorMessage) {
  if (!assertion) {
    throw new Error(errorMessage);
  }
}


/***/ }),

/***/ "./node_modules/ol/console.js":
/*!************************************!*\
  !*** ./node_modules/ol/console.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   setLevel: () => (/* binding */ setLevel),
/* harmony export */   warn: () => (/* binding */ warn)
/* harmony export */ });
/**
 * @module ol/console
 */

/**
 * @typedef {'info'|'warn'|'error'|'none'} Level
 */

/**
 * @type {Object<Level, number>}
 */
const levels = {
  info: 1,
  warn: 2,
  error: 3,
  none: 4,
};

/**
 * @type {number}
 */
let level = levels.info;

/**
 * Set the logging level.  By default, the level is set to 'info' and all
 * messages will be logged.  Set to 'warn' to only display warnings and errors.
 * Set to 'error' to only display errors.  Set to 'none' to silence all messages.
 *
 * @param {Level} l The new level.
 */
function setLevel(l) {
  level = levels[l];
}

/**
 * @param  {...any} args Arguments to log
 */
function log(...args) {
  if (level > levels.info) {
    return;
  }
  console.log(...args); // eslint-disable-line no-console
}

/**
 * @param  {...any} args Arguments to log
 */
function warn(...args) {
  if (level > levels.warn) {
    return;
  }
  console.warn(...args); // eslint-disable-line no-console
}

/**
 * @param  {...any} args Arguments to log
 */
function error(...args) {
  if (level > levels.error) {
    return;
  }
  console.error(...args); // eslint-disable-line no-console
}


/***/ }),

/***/ "./node_modules/ol/coordinate.js":
/*!***************************************!*\
  !*** ./node_modules/ol/coordinate.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   closestOnCircle: () => (/* binding */ closestOnCircle),
/* harmony export */   closestOnSegment: () => (/* binding */ closestOnSegment),
/* harmony export */   createStringXY: () => (/* binding */ createStringXY),
/* harmony export */   degreesToStringHDMS: () => (/* binding */ degreesToStringHDMS),
/* harmony export */   distance: () => (/* binding */ distance),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   getWorldsAway: () => (/* binding */ getWorldsAway),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   squaredDistance: () => (/* binding */ squaredDistance),
/* harmony export */   squaredDistanceToSegment: () => (/* binding */ squaredDistanceToSegment),
/* harmony export */   toStringHDMS: () => (/* binding */ toStringHDMS),
/* harmony export */   toStringXY: () => (/* binding */ toStringXY),
/* harmony export */   wrapX: () => (/* binding */ wrapX)
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string.js */ "./node_modules/ol/string.js");
/**
 * @module ol/coordinate
 */




/**
 * An array of numbers representing an `xy`, `xyz` or `xyzm` coordinate.
 * Example: `[16, 48]`.
 * @typedef {Array<number>} Coordinate
 * @api
 */

/**
 * A function that takes a {@link module:ol/coordinate~Coordinate} and
 * transforms it into a `{string}`.
 *
 * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
 * @api
 */

/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {add} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {Coordinate} delta Delta.
 * @return {Coordinate} The input coordinate adjusted by
 * the given delta.
 * @api
 */
function add(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}

/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {import("./geom/Circle.js").default} circle The circle.
 * @return {Coordinate} Closest point on the circumference.
 */
function closestOnCircle(coordinate, circle) {
  const r = circle.getRadius();
  const center = circle.getCenter();
  const x0 = center[0];
  const y0 = center[1];
  const x1 = coordinate[0];
  const y1 = coordinate[1];

  let dx = x1 - x0;
  const dy = y1 - y0;
  if (dx === 0 && dy === 0) {
    dx = 1;
  }
  const d = Math.sqrt(dx * dx + dy * dy);

  const x = x0 + (r * dx) / d;
  const y = y0 + (r * dy) / d;

  return [x, y];
}

/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {Coordinate} coordinate The coordinate.
 * @param {Array<Coordinate>} segment The two coordinates
 * of the segment.
 * @return {Coordinate} The foot of the perpendicular of
 * the coordinate to the segment.
 */
function closestOnSegment(coordinate, segment) {
  const x0 = coordinate[0];
  const y0 = coordinate[1];
  const start = segment[0];
  const end = segment[1];
  const x1 = start[0];
  const y1 = start[1];
  const x2 = end[0];
  const y2 = end[1];
  const dx = x2 - x1;
  const dy = y2 - y1;
  const along =
    dx === 0 && dy === 0
      ? 0
      : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
  let x, y;
  if (along <= 0) {
    x = x1;
    y = y1;
  } else if (along >= 1) {
    x = x2;
    y = y2;
  } else {
    x = x1 + along * dx;
    y = y1 + along * dy;
  }
  return [x, y];
}

/**
 * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
 * used to format
 * a {Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const stringifyFunc = createStringXY();
 *     const out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     import {createStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const stringifyFunc = createStringXY(2);
 *     const out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {CoordinateFormat} Coordinate format.
 * @api
 */
function createStringXY(fractionDigits) {
  return (
    /**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */
    function (coordinate) {
      return toStringXY(coordinate, fractionDigits);
    }
  );
}

/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */
function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {
  const normalizedDegrees = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.modulo)(degrees + 180, 360) - 180;
  const x = Math.abs(3600 * normalizedDegrees);
  const decimals = fractionDigits || 0;

  let deg = Math.floor(x / 3600);
  let min = Math.floor((x - deg * 3600) / 60);
  let sec = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toFixed)(x - deg * 3600 - min * 60, decimals);

  if (sec >= 60) {
    sec = 0;
    min += 1;
  }

  if (min >= 60) {
    min = 0;
    deg += 1;
  }

  let hdms = deg + '\u00b0';
  if (min !== 0 || sec !== 0) {
    hdms += ' ' + (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.padNumber)(min, 2) + '\u2032';
  }
  if (sec !== 0) {
    hdms += ' ' + (0,_string_js__WEBPACK_IMPORTED_MODULE_1__.padNumber)(sec, 2, decimals) + '\u2033';
  }
  if (normalizedDegrees !== 0) {
    hdms += ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);
  }

  return hdms;
}

/**
 * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
 * using the given string template. The strings `{x}` and `{y}` in the template
 * will be replaced with the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const template = 'Coordinate is ({x}|{y}).';
 *     const out = format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     import {format} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const template = 'Coordinate is ({x}|{y}).';
 *     const out = format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */
function format(coordinate, template, fractionDigits) {
  if (coordinate) {
    return template
      .replace('{x}', coordinate[0].toFixed(fractionDigits))
      .replace('{y}', coordinate[1].toFixed(fractionDigits));
  }
  return '';
}

/**
 * @param {Coordinate} coordinate1 First coordinate.
 * @param {Coordinate} coordinate2 Second coordinate.
 * @return {boolean} The two coordinates are equal.
 */
function equals(coordinate1, coordinate2) {
  let equals = true;
  for (let i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals = false;
      break;
    }
  }
  return equals;
}

/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     import {rotate} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const rotateRadians = Math.PI / 2; // 90 degrees
 *     rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {Coordinate} Coordinate.
 * @api
 */
function rotate(coordinate, angle) {
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);
  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}

/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     import {scale as scaleCoordinate} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const scale = 1.2;
 *     scaleCoordinate(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {Coordinate} Coordinate.
 */
function scale(coordinate, scale) {
  coordinate[0] *= scale;
  coordinate[1] *= scale;
  return coordinate;
}

/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */
function squaredDistance(coord1, coord2) {
  const dx = coord1[0] - coord2[0];
  const dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
}

/**
 * @param {Coordinate} coord1 First coordinate.
 * @param {Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */
function distance(coord1, coord2) {
  return Math.sqrt(squaredDistance(coord1, coord2));
}

/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {Coordinate} coordinate Coordinate of the point.
 * @param {Array<Coordinate>} segment Line segment (2
 * coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */
function squaredDistanceToSegment(coordinate, segment) {
  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));
}

/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringHDMS} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringHDMS} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */
function toStringHDMS(coordinate, fractionDigits) {
  if (coordinate) {
    return (
      degreesToStringHDMS('NS', coordinate[1], fractionDigits) +
      ' ' +
      degreesToStringHDMS('EW', coordinate[0], fractionDigits)
    );
  }
  return '';
}

/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     import {toStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     import {toStringXY} from 'ol/coordinate.js';
 *
 *     const coord = [7.85, 47.983333];
 *     const out = toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {number} [fractionDigits] The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */
function toStringXY(coordinate, fractionDigits) {
  return format(coordinate, '{x}, {y}', fractionDigits);
}

/**
 * Modifies the provided coordinate in-place to be within the real world
 * extent. The lower projection extent boundary is inclusive, the upper one
 * exclusive.
 *
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @return {Coordinate} The coordinate within the real world extent.
 */
function wrapX(coordinate, projection) {
  if (projection.canWrapX()) {
    const worldWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(projection.getExtent());
    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);
    if (worldsAway) {
      coordinate[0] -= worldsAway * worldWidth;
    }
  }
  return coordinate;
}
/**
 * @param {Coordinate} coordinate Coordinate.
 * @param {import("./proj/Projection.js").default} projection Projection.
 * @param {number} [sourceExtentWidth] Width of the source extent.
 * @return {number} Offset in world widths.
 */
function getWorldsAway(coordinate, projection, sourceExtentWidth) {
  const projectionExtent = projection.getExtent();
  let worldsAway = 0;
  if (
    projection.canWrapX() &&
    (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])
  ) {
    sourceExtentWidth = sourceExtentWidth || (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getWidth)(projectionExtent);
    worldsAway = Math.floor(
      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth
    );
  }
  return worldsAway;
}


/***/ }),

/***/ "./node_modules/ol/events.js":
/*!***********************************!*\
  !*** ./node_modules/ol/events.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   listen: () => (/* binding */ listen),
/* harmony export */   listenOnce: () => (/* binding */ listenOnce),
/* harmony export */   unlistenByKey: () => (/* binding */ unlistenByKey)
/* harmony export */ });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/events
 */


/**
 * Key to use with {@link module:ol/Observable.unByKey}.
 * @typedef {Object} EventsKey
 * @property {ListenerFunction} listener Listener.
 * @property {import("./events/Target.js").EventTargetLike} target Target.
 * @property {string} type Type.
 * @api
 */

/**
 * Listener function. This function is called with an event object as argument.
 * When the function returns `false`, event propagation will stop.
 *
 * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
 * @api
 */

/**
 * @typedef {Object} ListenerObject
 * @property {ListenerFunction} handleEvent HandleEvent listener function.
 */

/**
 * @typedef {ListenerFunction|ListenerObject} Listener
 */

/**
 * Registers an event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link module:ol/events.unlistenByKey}.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [thisArg] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean} [once] If true, add the listener as one-off listener.
 * @return {EventsKey} Unique key for the listener.
 */
function listen(target, type, listener, thisArg, once) {
  if (thisArg && thisArg !== target) {
    listener = listener.bind(thisArg);
  }
  if (once) {
    const originalListener = listener;
    listener = function () {
      target.removeEventListener(type, listener);
      originalListener.apply(this, arguments);
    };
  }
  const eventsKey = {
    target: target,
    type: type,
    listener: listener,
  };
  target.addEventListener(type, listener);
  return eventsKey;
}

/**
 * Registers a one-off event listener on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link module:ol/events.unlistenByKey} in case the listener needs to be
 * unregistered before it is called.
 *
 * When {@link module:ol/events.listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {import("./events/Target.js").EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ListenerFunction} listener Listener.
 * @param {Object} [thisArg] Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {EventsKey} Key for unlistenByKey.
 */
function listenOnce(target, type, listener, thisArg) {
  return listen(target, type, listener, thisArg, true);
}

/**
 * Unregisters event listeners on an event target. Inspired by
 * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
 *
 * The argument passed to this function is the key returned from
 * {@link module:ol/events.listen} or {@link module:ol/events.listenOnce}.
 *
 * @param {EventsKey} key The key.
 */
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    (0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.clear)(key);
  }
}


/***/ }),

/***/ "./node_modules/ol/events/Event.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/events/Event.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   preventDefault: () => (/* binding */ preventDefault),
/* harmony export */   stopPropagation: () => (/* binding */ stopPropagation)
/* harmony export */ });
/**
 * @module ol/events/Event
 */

/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link module:ol/events/Target~Target}.
 */
class BaseEvent {
  /**
   * @param {string} type Type.
   */
  constructor(type) {
    /**
     * @type {boolean}
     */
    this.propagationStopped;

    /**
     * @type {boolean}
     */
    this.defaultPrevented;

    /**
     * The event type.
     * @type {string}
     * @api
     */
    this.type = type;

    /**
     * The event target.
     * @type {Object}
     * @api
     */
    this.target = null;
  }

  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = true;
  }

  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = true;
  }
}

/**
 * @param {Event|import("./Event.js").default} evt Event
 */
function stopPropagation(evt) {
  evt.stopPropagation();
}

/**
 * @param {Event|import("./Event.js").default} evt Event
 */
function preventDefault(evt) {
  evt.preventDefault();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseEvent);


/***/ }),

/***/ "./node_modules/ol/events/EventType.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/events/EventType.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/events/EventType
 */

/**
 * @enum {string}
 * @const
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: 'change',

  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: 'error',

  BLUR: 'blur',
  CLEAR: 'clear',
  CONTEXTMENU: 'contextmenu',
  CLICK: 'click',
  DBLCLICK: 'dblclick',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DROP: 'drop',
  FOCUS: 'focus',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  LOAD: 'load',
  RESIZE: 'resize',
  TOUCHMOVE: 'touchmove',
  WHEEL: 'wheel',
});


/***/ }),

/***/ "./node_modules/ol/events/Target.js":
/*!******************************************!*\
  !*** ./node_modules/ol/events/Target.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Disposable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Disposable.js */ "./node_modules/ol/Disposable.js");
/* harmony import */ var _Event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Event.js */ "./node_modules/ol/events/Event.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/events/Target
 */





/**
 * @typedef {EventTarget|Target} EventTargetLike
 */

/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 */
class Target extends _Disposable_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(target) {
    super();

    /**
     * @private
     * @type {*}
     */
    this.eventTarget_ = target;

    /**
     * @private
     * @type {Object<string, number>|null}
     */
    this.pendingRemovals_ = null;

    /**
     * @private
     * @type {Object<string, number>|null}
     */
    this.dispatching_ = null;

    /**
     * @private
     * @type {Object<string, Array<import("../events.js").Listener>>|null}
     */
    this.listeners_ = null;
  }

  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(type, listener) {
    if (!type || !listener) {
      return;
    }
    const listeners = this.listeners_ || (this.listeners_ = {});
    const listenersForType = listeners[type] || (listeners[type] = []);
    if (!listenersForType.includes(listener)) {
      listenersForType.push(listener);
    }
  }

  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(event) {
    const isString = typeof event === 'string';
    const type = isString ? event : event.type;
    const listeners = this.listeners_ && this.listeners_[type];
    if (!listeners) {
      return;
    }

    const evt = isString ? new _Event_js__WEBPACK_IMPORTED_MODULE_1__["default"](event) : /** @type {Event} */ (event);
    if (!evt.target) {
      evt.target = this.eventTarget_ || this;
    }
    const dispatching = this.dispatching_ || (this.dispatching_ = {});
    const pendingRemovals =
      this.pendingRemovals_ || (this.pendingRemovals_ = {});
    if (!(type in dispatching)) {
      dispatching[type] = 0;
      pendingRemovals[type] = 0;
    }
    ++dispatching[type];
    let propagate;
    for (let i = 0, ii = listeners.length; i < ii; ++i) {
      if ('handleEvent' in listeners[i]) {
        propagate = /** @type {import("../events.js").ListenerObject} */ (
          listeners[i]
        ).handleEvent(evt);
      } else {
        propagate = /** @type {import("../events.js").ListenerFunction} */ (
          listeners[i]
        ).call(this, evt);
      }
      if (propagate === false || evt.propagationStopped) {
        propagate = false;
        break;
      }
    }
    if (--dispatching[type] === 0) {
      let pr = pendingRemovals[type];
      delete pendingRemovals[type];
      while (pr--) {
        this.removeEventListener(type, _functions_js__WEBPACK_IMPORTED_MODULE_2__.VOID);
      }
      delete dispatching[type];
    }
    return propagate;
  }

  /**
   * Clean up.
   */
  disposeInternal() {
    this.listeners_ && (0,_obj_js__WEBPACK_IMPORTED_MODULE_3__.clear)(this.listeners_);
  }

  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(type) {
    return (this.listeners_ && this.listeners_[type]) || undefined;
  }

  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(type) {
    if (!this.listeners_) {
      return false;
    }
    return type
      ? type in this.listeners_
      : Object.keys(this.listeners_).length > 0;
  }

  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(type, listener) {
    if (!this.listeners_) {
      return;
    }
    const listeners = this.listeners_[type];
    if (!listeners) {
      return;
    }
    const index = listeners.indexOf(listener);
    if (index !== -1) {
      if (this.pendingRemovals_ && type in this.pendingRemovals_) {
        // make listener a no-op, and remove later in #dispatchEvent()
        listeners[index] = _functions_js__WEBPACK_IMPORTED_MODULE_2__.VOID;
        ++this.pendingRemovals_[type];
      } else {
        listeners.splice(index, 1);
        if (listeners.length === 0) {
          delete this.listeners_[type];
        }
      }
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Target);


/***/ }),

/***/ "./node_modules/ol/extent.js":
/*!***********************************!*\
  !*** ./node_modules/ol/extent.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyTransform: () => (/* binding */ applyTransform),
/* harmony export */   approximatelyEquals: () => (/* binding */ approximatelyEquals),
/* harmony export */   boundingExtent: () => (/* binding */ boundingExtent),
/* harmony export */   buffer: () => (/* binding */ buffer),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   closestSquaredDistanceXY: () => (/* binding */ closestSquaredDistanceXY),
/* harmony export */   containsCoordinate: () => (/* binding */ containsCoordinate),
/* harmony export */   containsExtent: () => (/* binding */ containsExtent),
/* harmony export */   containsXY: () => (/* binding */ containsXY),
/* harmony export */   coordinateRelationship: () => (/* binding */ coordinateRelationship),
/* harmony export */   createEmpty: () => (/* binding */ createEmpty),
/* harmony export */   createOrUpdate: () => (/* binding */ createOrUpdate),
/* harmony export */   createOrUpdateEmpty: () => (/* binding */ createOrUpdateEmpty),
/* harmony export */   createOrUpdateFromCoordinate: () => (/* binding */ createOrUpdateFromCoordinate),
/* harmony export */   createOrUpdateFromCoordinates: () => (/* binding */ createOrUpdateFromCoordinates),
/* harmony export */   createOrUpdateFromFlatCoordinates: () => (/* binding */ createOrUpdateFromFlatCoordinates),
/* harmony export */   createOrUpdateFromRings: () => (/* binding */ createOrUpdateFromRings),
/* harmony export */   equals: () => (/* binding */ equals),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   extendCoordinate: () => (/* binding */ extendCoordinate),
/* harmony export */   extendCoordinates: () => (/* binding */ extendCoordinates),
/* harmony export */   extendFlatCoordinates: () => (/* binding */ extendFlatCoordinates),
/* harmony export */   extendRings: () => (/* binding */ extendRings),
/* harmony export */   extendXY: () => (/* binding */ extendXY),
/* harmony export */   forEachCorner: () => (/* binding */ forEachCorner),
/* harmony export */   getArea: () => (/* binding */ getArea),
/* harmony export */   getBottomLeft: () => (/* binding */ getBottomLeft),
/* harmony export */   getBottomRight: () => (/* binding */ getBottomRight),
/* harmony export */   getCenter: () => (/* binding */ getCenter),
/* harmony export */   getCorner: () => (/* binding */ getCorner),
/* harmony export */   getEnlargedArea: () => (/* binding */ getEnlargedArea),
/* harmony export */   getForViewAndSize: () => (/* binding */ getForViewAndSize),
/* harmony export */   getHeight: () => (/* binding */ getHeight),
/* harmony export */   getIntersection: () => (/* binding */ getIntersection),
/* harmony export */   getIntersectionArea: () => (/* binding */ getIntersectionArea),
/* harmony export */   getMargin: () => (/* binding */ getMargin),
/* harmony export */   getRotatedViewport: () => (/* binding */ getRotatedViewport),
/* harmony export */   getSize: () => (/* binding */ getSize),
/* harmony export */   getTopLeft: () => (/* binding */ getTopLeft),
/* harmony export */   getTopRight: () => (/* binding */ getTopRight),
/* harmony export */   getWidth: () => (/* binding */ getWidth),
/* harmony export */   intersects: () => (/* binding */ intersects),
/* harmony export */   intersectsSegment: () => (/* binding */ intersectsSegment),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty),
/* harmony export */   returnOrUpdate: () => (/* binding */ returnOrUpdate),
/* harmony export */   scaleFromCenter: () => (/* binding */ scaleFromCenter),
/* harmony export */   wrapAndSliceX: () => (/* binding */ wrapAndSliceX),
/* harmony export */   wrapX: () => (/* binding */ wrapX)
/* harmony export */ });
/* harmony import */ var _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./extent/Relationship.js */ "./node_modules/ol/extent/Relationship.js");
/**
 * @module ol/extent
 */


/**
 * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
 * @typedef {Array<number>} Extent
 * @api
 */

/**
 * Extent corner.
 * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner
 */

/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Bounding extent.
 * @api
 */
function boundingExtent(coordinates) {
  const extent = createEmpty();
  for (let i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}

/**
 * @param {Array<number>} xs Xs.
 * @param {Array<number>} ys Ys.
 * @param {Extent} [dest] Destination extent.
 * @private
 * @return {Extent} Extent.
 */
function _boundingExtentXYs(xs, ys, dest) {
  const minX = Math.min.apply(null, xs);
  const minY = Math.min.apply(null, ys);
  const maxX = Math.max.apply(null, xs);
  const maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, dest);
}

/**
 * Return extent increased by the provided value.
 * @param {Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 * @api
 */
function buffer(extent, value, dest) {
  if (dest) {
    dest[0] = extent[0] - value;
    dest[1] = extent[1] - value;
    dest[2] = extent[2] + value;
    dest[3] = extent[3] + value;
    return dest;
  }
  return [
    extent[0] - value,
    extent[1] - value,
    extent[2] + value,
    extent[3] + value,
  ];
}

/**
 * Creates a clone of an extent.
 *
 * @param {Extent} extent Extent to clone.
 * @param {Extent} [dest] Extent.
 * @return {Extent} The clone.
 */
function clone(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent.slice();
}

/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */
function closestSquaredDistanceXY(extent, x, y) {
  let dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}

/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}

/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */
function containsExtent(extent1, extent2) {
  return (
    extent1[0] <= extent2[0] &&
    extent2[2] <= extent1[2] &&
    extent1[1] <= extent2[1] &&
    extent2[3] <= extent1[3]
  );
}

/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}

/**
 * Get the relationship between a coordinate and extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
 * @return {import("./extent/Relationship.js").default} The relationship (bitwise compare with
 *     import("./extent/Relationship.js").Relationship).
 */
function coordinateRelationship(extent, coordinate) {
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const x = coordinate[0];
  const y = coordinate[1];
  let relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].UNKNOWN;
  if (x < minX) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].LEFT;
  } else if (x > maxX) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].RIGHT;
  }
  if (y < minY) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].BELOW;
  } else if (y > maxY) {
    relationship = relationship | _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABOVE;
  }
  if (relationship === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].UNKNOWN) {
    relationship = _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERSECTING;
  }
  return relationship;
}

/**
 * Create an empty extent.
 * @return {Extent} Empty extent.
 * @api
 */
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}

/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {Extent} [dest] Destination extent.
 * @return {Extent} Extent.
 */
function createOrUpdate(minX, minY, maxX, maxY, dest) {
  if (dest) {
    dest[0] = minX;
    dest[1] = minY;
    dest[2] = maxX;
    dest[3] = maxY;
    return dest;
  }
  return [minX, minY, maxX, maxY];
}

/**
 * Create a new empty extent or make the provided one empty.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateEmpty(dest) {
  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
}

/**
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromCoordinate(coordinate, dest) {
  const x = coordinate[0];
  const y = coordinate[1];
  return createOrUpdate(x, y, x, y, dest);
}

/**
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromCoordinates(coordinates, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendCoordinates(extent, coordinates);
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromFlatCoordinates(
  flatCoordinates,
  offset,
  end,
  stride,
  dest
) {
  const extent = createOrUpdateEmpty(dest);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}

/**
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function createOrUpdateFromRings(rings, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendRings(extent, rings);
}

/**
 * Determine if two extents are equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */
function equals(extent1, extent2) {
  return (
    extent1[0] == extent2[0] &&
    extent1[2] == extent2[2] &&
    extent1[1] == extent2[1] &&
    extent1[3] == extent2[3]
  );
}

/**
 * Determine if two extents are approximately equivalent.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {number} tolerance Tolerance in extent coordinate units.
 * @return {boolean} The two extents differ by less than the tolerance.
 */
function approximatelyEquals(extent1, extent2, tolerance) {
  return (
    Math.abs(extent1[0] - extent2[0]) < tolerance &&
    Math.abs(extent1[2] - extent2[2]) < tolerance &&
    Math.abs(extent1[1] - extent2[1]) < tolerance &&
    Math.abs(extent1[3] - extent2[3]) < tolerance
  );
}

/**
 * Modify an extent to include another extent.
 * @param {Extent} extent1 The extent to be modified.
 * @param {Extent} extent2 The extent that will be included in the first.
 * @return {Extent} A reference to the first (extended) extent.
 * @api
 */
function extend(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}

/**
 * @param {Extent} extent Extent.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 */
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}

/**
 * @param {Extent} extent Extent.
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
 * @return {Extent} Extent.
 */
function extendCoordinates(extent, coordinates) {
  for (let i = 0, ii = coordinates.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates[i]);
  }
  return extent;
}

/**
 * @param {Extent} extent Extent.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Extent} Extent.
 */
function extendFlatCoordinates(
  extent,
  flatCoordinates,
  offset,
  end,
  stride
) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
}

/**
 * @param {Extent} extent Extent.
 * @param {Array<Array<import("./coordinate.js").Coordinate>>} rings Rings.
 * @return {Extent} Extent.
 */
function extendRings(extent, rings) {
  for (let i = 0, ii = rings.length; i < ii; ++i) {
    extendCoordinates(extent, rings[i]);
  }
  return extent;
}

/**
 * @param {Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */
function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}

/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {Extent} extent Extent.
 * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
 * @return {S|boolean} Value.
 * @template S
 */
function forEachCorner(extent, callback) {
  let val;
  val = callback(getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback(getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}

/**
 * Get the size of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Area.
 * @api
 */
function getArea(extent) {
  let area = 0;
  if (!isEmpty(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }
  return area;
}

/**
 * Get the bottom left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
 * @api
 */
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}

/**
 * Get the bottom right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
 * @api
 */
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}

/**
 * Get the center coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Center.
 * @api
 */
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}

/**
 * Get a corner coordinate of an extent.
 * @param {Extent} extent Extent.
 * @param {Corner} corner Corner.
 * @return {import("./coordinate.js").Coordinate} Corner coordinate.
 */
function getCorner(extent, corner) {
  let coordinate;
  if (corner === 'bottom-left') {
    coordinate = getBottomLeft(extent);
  } else if (corner === 'bottom-right') {
    coordinate = getBottomRight(extent);
  } else if (corner === 'top-left') {
    coordinate = getTopLeft(extent);
  } else if (corner === 'top-right') {
    coordinate = getTopRight(extent);
  } else {
    throw new Error('Invalid corner');
  }
  return coordinate;
}

/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */
function getEnlargedArea(extent1, extent2) {
  const minX = Math.min(extent1[0], extent2[0]);
  const minY = Math.min(extent1[1], extent2[1]);
  const maxX = Math.max(extent1[2], extent2[2]);
  const maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
}

/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @param {Extent} [dest] Destination extent.
 * @return {Extent} Extent.
 */
function getForViewAndSize(center, resolution, rotation, size, dest) {
  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(
    center,
    resolution,
    rotation,
    size
  );
  return createOrUpdate(
    Math.min(x0, x1, x2, x3),
    Math.min(y0, y1, y2, y3),
    Math.max(x0, x1, x2, x3),
    Math.max(y0, y1, y2, y3),
    dest
  );
}

/**
 * @param {import("./coordinate.js").Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {import("./size.js").Size} size Size.
 * @return {Array<number>} Linear ring representing the viewport.
 */
function getRotatedViewport(center, resolution, rotation, size) {
  const dx = (resolution * size[0]) / 2;
  const dy = (resolution * size[1]) / 2;
  const cosRotation = Math.cos(rotation);
  const sinRotation = Math.sin(rotation);
  const xCos = dx * cosRotation;
  const xSin = dx * sinRotation;
  const yCos = dy * cosRotation;
  const ySin = dy * sinRotation;
  const x = center[0];
  const y = center[1];
  return [
    x - xCos + ySin,
    y - xSin - yCos,
    x - xCos - ySin,
    y - xSin + yCos,
    x + xCos - ySin,
    y + xSin + yCos,
    x + xCos + ySin,
    y + xSin - yCos,
    x - xCos + ySin,
    y - xSin - yCos,
  ];
}

/**
 * Get the height of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Height.
 * @api
 */
function getHeight(extent) {
  return extent[3] - extent[1];
}

/**
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */
function getIntersectionArea(extent1, extent2) {
  const intersection = getIntersection(extent1, extent2);
  return getArea(intersection);
}

/**
 * Get the intersection of two extents.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent 2.
 * @param {Extent} [dest] Optional extent to populate with intersection.
 * @return {Extent} Intersecting extent.
 * @api
 */
function getIntersection(extent1, extent2, dest) {
  const intersection = dest ? dest : createEmpty();
  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}

/**
 * @param {Extent} extent Extent.
 * @return {number} Margin.
 */
function getMargin(extent) {
  return getWidth(extent) + getHeight(extent);
}

/**
 * Get the size (width, height) of an extent.
 * @param {Extent} extent The extent.
 * @return {import("./size.js").Size} The extent size.
 * @api
 */
function getSize(extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
}

/**
 * Get the top left coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top left coordinate.
 * @api
 */
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}

/**
 * Get the top right coordinate of an extent.
 * @param {Extent} extent Extent.
 * @return {import("./coordinate.js").Coordinate} Top right coordinate.
 * @api
 */
function getTopRight(extent) {
  return [extent[2], extent[3]];
}

/**
 * Get the width of an extent.
 * @param {Extent} extent Extent.
 * @return {number} Width.
 * @api
 */
function getWidth(extent) {
  return extent[2] - extent[0];
}

/**
 * Determine if one extent intersects another.
 * @param {Extent} extent1 Extent 1.
 * @param {Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */
function intersects(extent1, extent2) {
  return (
    extent1[0] <= extent2[2] &&
    extent1[2] >= extent2[0] &&
    extent1[1] <= extent2[3] &&
    extent1[3] >= extent2[1]
  );
}

/**
 * Determine if an extent is empty.
 * @param {Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */
function isEmpty(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}

/**
 * @param {Extent} extent Extent.
 * @param {Extent} [dest] Extent.
 * @return {Extent} Extent.
 */
function returnOrUpdate(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent;
}

/**
 * @param {Extent} extent Extent.
 * @param {number} value Value.
 */
function scaleFromCenter(extent, value) {
  const deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);
  const deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
}

/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {Extent} extent The extent.
 * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
 * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */
function intersectsSegment(extent, start, end) {
  let intersects = false;
  const startRel = coordinateRelationship(extent, start);
  const endRel = coordinateRelationship(extent, end);
  if (
    startRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERSECTING ||
    endRel === _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].INTERSECTING
  ) {
    intersects = true;
  } else {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const startX = start[0];
    const startY = start[1];
    const endX = end[0];
    const endY = end[1];
    const slope = (endY - startY) / (endX - startX);
    let x, y;
    if (!!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABOVE) && !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].ABOVE)) {
      // potentially intersects top
      x = endX - (endY - maxY) / slope;
      intersects = x >= minX && x <= maxX;
    }
    if (
      !intersects &&
      !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].RIGHT) &&
      !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].RIGHT)
    ) {
      // potentially intersects right
      y = endY - (endX - maxX) * slope;
      intersects = y >= minY && y <= maxY;
    }
    if (
      !intersects &&
      !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].BELOW) &&
      !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].BELOW)
    ) {
      // potentially intersects bottom
      x = endX - (endY - minY) / slope;
      intersects = x >= minX && x <= maxX;
    }
    if (
      !intersects &&
      !!(endRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].LEFT) &&
      !(startRel & _extent_Relationship_js__WEBPACK_IMPORTED_MODULE_0__["default"].LEFT)
    ) {
      // potentially intersects left
      y = endY - (endX - minX) * slope;
      intersects = y >= minY && y <= maxY;
    }
  }
  return intersects;
}

/**
 * Apply a transform function to the extent.
 * @param {Extent} extent Extent.
 * @param {import("./proj.js").TransformFunction} transformFn Transform function.
 * Called with `[minX, minY, maxX, maxY]` extent coordinates.
 * @param {Extent} [dest] Destination extent.
 * @param {number} [stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {Extent} Extent.
 * @api
 */
function applyTransform(extent, transformFn, dest, stops) {
  if (isEmpty(extent)) {
    return createOrUpdateEmpty(dest);
  }
  let coordinates = [];
  if (stops > 1) {
    const width = extent[2] - extent[0];
    const height = extent[3] - extent[1];
    for (let i = 0; i < stops; ++i) {
      coordinates.push(
        extent[0] + (width * i) / stops,
        extent[1],
        extent[2],
        extent[1] + (height * i) / stops,
        extent[2] - (width * i) / stops,
        extent[3],
        extent[0],
        extent[3] - (height * i) / stops
      );
    }
  } else {
    coordinates = [
      extent[0],
      extent[1],
      extent[2],
      extent[1],
      extent[2],
      extent[3],
      extent[0],
      extent[3],
    ];
  }
  transformFn(coordinates, coordinates, 2);
  const xs = [];
  const ys = [];
  for (let i = 0, l = coordinates.length; i < l; i += 2) {
    xs.push(coordinates[i]);
    ys.push(coordinates[i + 1]);
  }
  return _boundingExtentXYs(xs, ys, dest);
}

/**
 * Modifies the provided extent in-place to be within the real world
 * extent.
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Extent} The extent within the real world extent.
 */
function wrapX(extent, projection) {
  const projectionExtent = projection.getExtent();
  const center = getCenter(extent);
  if (
    projection.canWrapX() &&
    (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])
  ) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.floor(
      (center[0] - projectionExtent[0]) / worldWidth
    );
    const offset = worldsAway * worldWidth;
    extent[0] -= offset;
    extent[2] -= offset;
  }
  return extent;
}

/**
 * Fits the extent to the real world
 *
 * If the extent does not cross the anti meridian, this will return the extent in an array
 * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the
 * real world
 *
 *
 * @param {Extent} extent Extent.
 * @param {import("./proj/Projection.js").default} projection Projection
 * @return {Array<Extent>} The extent within the real world extent.
 */
function wrapAndSliceX(extent, projection) {
  if (projection.canWrapX()) {
    const projectionExtent = projection.getExtent();

    if (!isFinite(extent[0]) || !isFinite(extent[2])) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }

    wrapX(extent, projection);
    const worldWidth = getWidth(projectionExtent);

    if (getWidth(extent) > worldWidth) {
      // the extent wraps around on itself
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    if (extent[0] < projectionExtent[0]) {
      // the extent crosses the anti meridian, so it needs to be sliced
      return [
        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2], extent[3]],
      ];
    }
    if (extent[2] > projectionExtent[2]) {
      // the extent crosses the anti meridian, so it needs to be sliced
      return [
        [extent[0], extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]],
      ];
    }
  }

  return [extent];
}


/***/ }),

/***/ "./node_modules/ol/extent/Relationship.js":
/*!************************************************!*\
  !*** ./node_modules/ol/extent/Relationship.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @module ol/extent/Relationship
 */

/**
 * Relationship to an extent.
 * @enum {number}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16,
});


/***/ }),

/***/ "./node_modules/ol/functions.js":
/*!**************************************!*\
  !*** ./node_modules/ol/functions.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FALSE: () => (/* binding */ FALSE),
/* harmony export */   TRUE: () => (/* binding */ TRUE),
/* harmony export */   VOID: () => (/* binding */ VOID),
/* harmony export */   memoizeOne: () => (/* binding */ memoizeOne),
/* harmony export */   toPromise: () => (/* binding */ toPromise)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/ol/array.js");
/**
 * @module ol/functions
 */



/**
 * Always returns true.
 * @return {boolean} true.
 */
function TRUE() {
  return true;
}

/**
 * Always returns false.
 * @return {boolean} false.
 */
function FALSE() {
  return false;
}

/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {void} Nothing.
 */
function VOID() {}

/**
 * Wrap a function in another function that remembers the last return.  If the
 * returned function is called twice in a row with the same arguments and the same
 * this object, it will return the value from the first call in the second call.
 *
 * @param {function(...any): ReturnType} fn The function to memoize.
 * @return {function(...any): ReturnType} The memoized function.
 * @template ReturnType
 */
function memoizeOne(fn) {
  let called = false;

  /** @type {ReturnType} */
  let lastResult;

  /** @type {Array<any>} */
  let lastArgs;

  let lastThis;

  return function () {
    const nextArgs = Array.prototype.slice.call(arguments);
    if (!called || this !== lastThis || !(0,_array_js__WEBPACK_IMPORTED_MODULE_0__.equals)(nextArgs, lastArgs)) {
      called = true;
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }
    return lastResult;
  };
}

/**
 * @template T
 * @param {function(): (T | Promise<T>)} getter A function that returns a value or a promise for a value.
 * @return {Promise<T>} A promise for the value.
 */
function toPromise(getter) {
  function promiseGetter() {
    let value;
    try {
      value = getter();
    } catch (err) {
      return Promise.reject(err);
    }
    if (value instanceof Promise) {
      return value;
    }
    return Promise.resolve(value);
  }
  return promiseGetter();
}


/***/ }),

/***/ "./node_modules/ol/geom/Geometry.js":
/*!******************************************!*\
  !*** ./node_modules/ol/geom/Geometry.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Object_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Object.js */ "./node_modules/ol/Object.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/**
 * @module ol/geom/Geometry
 */








/**
 * @typedef {'XY' | 'XYZ' | 'XYM' | 'XYZM'} GeometryLayout
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available.
 */

/**
 * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString' | 'MultiPolygon' | 'GeometryCollection' | 'Circle'} Type
 * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, or `'Circle'`.
 */

/**
 * @type {import("../transform.js").Transform}
 */
const tmpTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.create)();

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @abstract
 * @api
 */
class Geometry extends _Object_js__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super();

    /**
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.extent_ = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.createEmpty)();

    /**
     * @private
     * @type {number}
     */
    this.extentRevision_ = -1;

    /**
     * @protected
     * @type {number}
     */
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;

    /**
     * @protected
     * @type {number}
     */
    this.simplifiedGeometryRevision = 0;

    /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} revision The geometry revision.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */
    this.simplifyTransformedInternal = (0,_functions_js__WEBPACK_IMPORTED_MODULE_4__.memoizeOne)(
      (revision, squaredTolerance, transform) => {
        if (!transform) {
          return this.getSimplifiedGeometry(squaredTolerance);
        }
        const clone = this.clone();
        clone.applyTransform(transform);
        return clone.getSimplifiedGeometry(squaredTolerance);
      }
    );
  }

  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(squaredTolerance, transform) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      squaredTolerance,
      transform
    );
  }

  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(x, y) {
    const coord = this.getClosestPoint([x, y]);
    return coord[0] === x && coord[1] === y;
  }

  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(point, closestPoint) {
    closestPoint = closestPoint ? closestPoint : [NaN, NaN];
    this.closestPointXY(point[0], point[1], closestPoint, Infinity);
    return closestPoint;
  }

  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(coordinate) {
    return this.containsXY(coordinate[0], coordinate[1]);
  }

  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(extent) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(extent) {
    if (this.extentRevision_ != this.getRevision()) {
      const extent = this.computeExtent(this.extent_);
      if (isNaN(extent[0]) || isNaN(extent[1])) {
        (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.createOrUpdateEmpty)(extent);
      }
      this.extentRevision_ = this.getRevision();
    }
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.returnOrUpdate)(this.extent_, extent);
  }

  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(angle, anchor) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(sx, sy, anchor) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(tolerance) {
    return this.getSimplifiedGeometry(tolerance * tolerance);
  }

  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(squaredTolerance) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(transformFn) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(extent) {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(deltaX, deltaY) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_5__.abstract)();
  }

  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {Geometry} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(source, destination) {
    /** @type {import("../proj/Projection.js").default} */
    const sourceProj = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(source);
    const transformFn =
      sourceProj.getUnits() == 'tile-pixels'
        ? function (inCoordinates, outCoordinates, stride) {
            const pixelExtent = sourceProj.getExtent();
            const projectedExtent = sourceProj.getWorldExtent();
            const scale = (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getHeight)(projectedExtent) / (0,_extent_js__WEBPACK_IMPORTED_MODULE_3__.getHeight)(pixelExtent);
            (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.compose)(
              tmpTransform,
              projectedExtent[0],
              projectedExtent[3],
              scale,
              -scale,
              0,
              0,
              0
            );
            (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_6__.transform2D)(
              inCoordinates,
              0,
              inCoordinates.length,
              stride,
              tmpTransform,
              outCoordinates
            );
            return (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransform)(sourceProj, destination)(
              inCoordinates,
              outCoordinates,
              stride
            );
          }
        : (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.getTransform)(sourceProj, destination);
    this.applyTransform(transformFn);
    return this;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Geometry);


/***/ }),

/***/ "./node_modules/ol/geom/LineString.js":
/*!********************************************!*\
  !*** ./node_modules/ol/geom/LineString.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _flat_segments_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/segments.js */ "./node_modules/ol/geom/flat/segments.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_interpolate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/interpolate.js */ "./node_modules/ol/geom/flat/interpolate.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _flat_length_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/length.js */ "./node_modules/ol/geom/flat/length.js");
/**
 * @module ol/geom/LineString
 */












/**
 * @classdesc
 * Linestring geometry.
 *
 * @api
 */
class LineString extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(coordinates, layout) {
    super();

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */
    this.flatMidpoint_ = null;

    /**
     * @private
     * @type {number}
     */
    this.flatMidpointRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    if (layout !== undefined && !Array.isArray(coordinates[0])) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */ (coordinates)
      );
    } else {
      this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */ (
          coordinates
        ),
        layout
      );
    }
  }

  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */
  appendCoordinate(coordinate) {
    (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(this.flatCoordinates, coordinate);
    this.changed();
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @api
   */
  clone() {
    const lineString = new LineString(
      this.flatCoordinates.slice(),
      this.layout
    );
    lineString.applyProperties(this);
    return lineString;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__.maxSquaredDelta)(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__.assignClosestPoint)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      false,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }

  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */
  forEachSegment(callback) {
    return (0,_flat_segments_js__WEBPACK_IMPORTED_MODULE_4__.forEach)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      callback
    );
  }

  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(m, extrapolate) {
    if (this.layout != 'XYM' && this.layout != 'XYZM') {
      return null;
    }
    extrapolate = extrapolate !== undefined ? extrapolate : false;
    return (0,_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_5__.lineStringCoordinateAtM)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      m,
      extrapolate
    );
  }

  /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__.inflateCoordinates)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }

  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */
  getCoordinateAt(fraction, dest) {
    return (0,_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_5__.interpolatePoint)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      fraction,
      dest,
      this.stride
    );
  }

  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */
  getLength() {
    return (0,_flat_length_js__WEBPACK_IMPORTED_MODULE_7__.lineStringLength)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }

  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    if (this.flatMidpointRevision_ != this.getRevision()) {
      this.flatMidpoint_ = this.getCoordinateAt(
        0.5,
        this.flatMidpoint_ ?? undefined
      );
      this.flatMidpointRevision_ = this.getRevision();
    }
    return /** @type {Array<number>} */ (this.flatMidpoint_);
  }

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} Simplified LineString.
   * @protected
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    /** @type {Array<number>} */
    const simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = (0,_flat_simplify_js__WEBPACK_IMPORTED_MODULE_8__.douglasPeucker)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0
    );
    return new LineString(simplifiedFlatCoordinates, 'XY');
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return 'LineString';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    return (0,_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_9__.intersectsLineString)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      extent
    );
  }

  /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(coordinates, layout) {
    this.setLayout(layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_10__.deflateCoordinates)(
      this.flatCoordinates,
      0,
      coordinates,
      this.stride
    );
    this.changed();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LineString);


/***/ }),

/***/ "./node_modules/ol/geom/LinearRing.js":
/*!********************************************!*\
  !*** ./node_modules/ol/geom/LinearRing.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_area_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/**
 * @module ol/geom/LinearRing
 */








/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @api
 */
class LinearRing extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(coordinates, layout) {
    super();

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    if (layout !== undefined && !Array.isArray(coordinates[0])) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */ (coordinates)
      );
    } else {
      this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */ (
          coordinates
        ),
        layout
      );
    }
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */
  clone() {
    return new LinearRing(this.flatCoordinates.slice(), this.layout);
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_2__.maxSquaredDelta)(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_2__.assignClosestPoint)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }

  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return (0,_flat_area_js__WEBPACK_IMPORTED_MODULE_3__.linearRing)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }

  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinates)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    /** @type {Array<number>} */
    const simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = (0,_flat_simplify_js__WEBPACK_IMPORTED_MODULE_5__.douglasPeucker)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0
    );
    return new LinearRing(simplifiedFlatCoordinates, 'XY');
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return 'LinearRing';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    return false;
  }

  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(coordinates, layout) {
    this.setLayout(layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__.deflateCoordinates)(
      this.flatCoordinates,
      0,
      coordinates,
      this.stride
    );
    this.changed();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LinearRing);


/***/ }),

/***/ "./node_modules/ol/geom/MultiLineString.js":
/*!*************************************************!*\
  !*** ./node_modules/ol/geom/MultiLineString.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _LineString_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./LineString.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_interpolate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/interpolate.js */ "./node_modules/ol/geom/flat/interpolate.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/**
 * @module ol/geom/MultiLineString
 */











/**
 * @classdesc
 * Multi-linestring geometry.
 *
 * @api
 */
class MultiLineString extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Flat coordinate ends for internal use.
   */
  constructor(coordinates, layout, ends) {
    super();

    /**
     * @type {Array<number>}
     * @private
     */
    this.ends_ = [];

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    if (Array.isArray(coordinates[0])) {
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ (
          coordinates
        ),
        layout
      );
    } else if (layout !== undefined && ends) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */ (coordinates)
      );
      this.ends_ = ends;
    } else {
      const lineStrings = /** @type {Array<LineString>} */ (coordinates);
      /** @type {Array<number>} */
      const flatCoordinates = [];
      const ends = [];
      for (let i = 0, ii = lineStrings.length; i < ii; ++i) {
        const lineString = lineStrings[i];
        (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(flatCoordinates, lineString.getFlatCoordinates());
        ends.push(flatCoordinates.length);
      }
      const layout =
        lineStrings.length === 0
          ? this.getLayout()
          : lineStrings[0].getLayout();
      this.setFlatCoordinates(layout, flatCoordinates);
      this.ends_ = ends;
    }
  }

  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */
  appendLineString(lineString) {
    (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(this.flatCoordinates, lineString.getFlatCoordinates().slice());
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @api
   */
  clone() {
    const multiLineString = new MultiLineString(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    multiLineString.applyProperties(this);
    return multiLineString;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__.arrayMaxSquaredDelta)(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__.assignClosestArrayPoint)(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      false,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }

  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @param {boolean} [interpolate] Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(m, extrapolate, interpolate) {
    if (
      (this.layout != 'XYM' && this.layout != 'XYZM') ||
      this.flatCoordinates.length === 0
    ) {
      return null;
    }
    extrapolate = extrapolate !== undefined ? extrapolate : false;
    interpolate = interpolate !== undefined ? interpolate : false;
    return (0,_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_4__.lineStringsCoordinateAtM)(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      m,
      extrapolate,
      interpolate
    );
  }

  /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates() {
    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_5__.inflateCoordinatesArray)(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride
    );
  }

  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }

  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */
  getLineString(index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }
    return new _LineString_js__WEBPACK_IMPORTED_MODULE_6__["default"](
      this.flatCoordinates.slice(
        index === 0 ? 0 : this.ends_[index - 1],
        this.ends_[index]
      ),
      this.layout
    );
  }

  /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */
  getLineStrings() {
    const flatCoordinates = this.flatCoordinates;
    const ends = this.ends_;
    const layout = this.layout;
    /** @type {Array<LineString>} */
    const lineStrings = [];
    let offset = 0;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      const lineString = new _LineString_js__WEBPACK_IMPORTED_MODULE_6__["default"](
        flatCoordinates.slice(offset, end),
        layout
      );
      lineStrings.push(lineString);
      offset = end;
    }
    return lineStrings;
  }

  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    /** @type {Array<number>} */
    const midpoints = [];
    const flatCoordinates = this.flatCoordinates;
    let offset = 0;
    const ends = this.ends_;
    const stride = this.stride;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      const midpoint = (0,_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_4__.interpolatePoint)(
        flatCoordinates,
        offset,
        end,
        stride,
        0.5
      );
      (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(midpoints, midpoint);
      offset = end;
    }
    return midpoints;
  }

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiLineString} Simplified MultiLineString.
   * @protected
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    /** @type {Array<number>} */
    const simplifiedFlatCoordinates = [];
    /** @type {Array<number>} */
    const simplifiedEnds = [];
    simplifiedFlatCoordinates.length = (0,_flat_simplify_js__WEBPACK_IMPORTED_MODULE_7__.douglasPeuckerArray)(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0,
      simplifiedEnds
    );
    return new MultiLineString(simplifiedFlatCoordinates, 'XY', simplifiedEnds);
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return 'MultiLineString';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    return (0,_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_8__.intersectsLineStringArray)(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      extent
    );
  }

  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(coordinates, layout) {
    this.setLayout(layout, coordinates, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const ends = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_9__.deflateCoordinatesArray)(
      this.flatCoordinates,
      0,
      coordinates,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MultiLineString);


/***/ }),

/***/ "./node_modules/ol/geom/MultiPoint.js":
/*!********************************************!*\
  !*** ./node_modules/ol/geom/MultiPoint.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/MultiPoint
 */








/**
 * @classdesc
 * Multi-point geometry.
 *
 * @api
 */
class MultiPoint extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(coordinates, layout) {
    super();
    if (layout && !Array.isArray(coordinates[0])) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */ (coordinates)
      );
    } else {
      this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */ (
          coordinates
        ),
        layout
      );
    }
  }

  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */
  appendPoint(point) {
    (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(this.flatCoordinates, point.getFlatCoordinates());
    this.changed();
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @api
   */
  clone() {
    const multiPoint = new MultiPoint(
      this.flatCoordinates.slice(),
      this.layout
    );
    multiPoint.applyProperties(this);
    return multiPoint;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    const flatCoordinates = this.flatCoordinates;
    const stride = this.stride;
    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      const squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.squaredDistance)(
        x,
        y,
        flatCoordinates[i],
        flatCoordinates[i + 1]
      );
      if (squaredDistance < minSquaredDistance) {
        minSquaredDistance = squaredDistance;
        for (let j = 0; j < stride; ++j) {
          closestPoint[j] = flatCoordinates[i + j];
        }
        closestPoint.length = stride;
      }
    }
    return minSquaredDistance;
  }

  /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_4__.inflateCoordinates)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }

  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */
  getPoint(index) {
    const n = this.flatCoordinates.length / this.stride;
    if (index < 0 || n <= index) {
      return null;
    }
    return new _Point_js__WEBPACK_IMPORTED_MODULE_5__["default"](
      this.flatCoordinates.slice(
        index * this.stride,
        (index + 1) * this.stride
      ),
      this.layout
    );
  }

  /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */
  getPoints() {
    const flatCoordinates = this.flatCoordinates;
    const layout = this.layout;
    const stride = this.stride;
    /** @type {Array<Point>} */
    const points = [];
    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      const point = new _Point_js__WEBPACK_IMPORTED_MODULE_5__["default"](flatCoordinates.slice(i, i + stride), layout);
      points.push(point);
    }
    return points;
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return 'MultiPoint';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    const flatCoordinates = this.flatCoordinates;
    const stride = this.stride;
    for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
      const x = flatCoordinates[i];
      const y = flatCoordinates[i + 1];
      if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsXY)(extent, x, y)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(coordinates, layout) {
    this.setLayout(layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__.deflateCoordinates)(
      this.flatCoordinates,
      0,
      coordinates,
      this.stride
    );
    this.changed();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MultiPoint);


/***/ }),

/***/ "./node_modules/ol/geom/MultiPolygon.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/MultiPolygon.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _MultiPoint_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./MultiPoint.js */ "./node_modules/ol/geom/MultiPoint.js");
/* harmony import */ var _Polygon_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Polygon.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./flat/interiorpoint.js */ "./node_modules/ol/geom/flat/interiorpoint.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _flat_orient_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/orient.js */ "./node_modules/ol/geom/flat/orient.js");
/* harmony import */ var _flat_area_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/* harmony import */ var _flat_center_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/center.js */ "./node_modules/ol/geom/flat/center.js");
/* harmony import */ var _flat_contains_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/contains.js */ "./node_modules/ol/geom/flat/contains.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/**
 * @module ol/geom/MultiPolygon
 */
















/**
 * @classdesc
 * Multi-polygon geometry.
 *
 * @api
 */
class MultiPolygon extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
   */
  constructor(coordinates, layout, endss) {
    super();

    /**
     * @type {Array<Array<number>>}
     * @private
     */
    this.endss_ = [];

    /**
     * @private
     * @type {number}
     */
    this.flatInteriorPointsRevision_ = -1;

    /**
     * @private
     * @type {Array<number>|null}
     */
    this.flatInteriorPoints_ = null;

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.orientedRevision_ = -1;

    /**
     * @private
     * @type {Array<number>|null}
     */
    this.orientedFlatCoordinates_ = null;

    if (!endss && !Array.isArray(coordinates[0])) {
      const polygons = /** @type {Array<Polygon>} */ (coordinates);
      /** @type {Array<number>} */
      const flatCoordinates = [];
      const thisEndss = [];
      for (let i = 0, ii = polygons.length; i < ii; ++i) {
        const polygon = polygons[i];
        const offset = flatCoordinates.length;
        const ends = polygon.getEnds();
        for (let j = 0, jj = ends.length; j < jj; ++j) {
          ends[j] += offset;
        }
        (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(flatCoordinates, polygon.getFlatCoordinates());
        thisEndss.push(ends);
      }
      layout =
        polygons.length === 0 ? this.getLayout() : polygons[0].getLayout();
      coordinates = flatCoordinates;
      endss = thisEndss;
    }
    if (layout !== undefined && endss) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */ (coordinates)
      );
      this.endss_ = endss;
    } else {
      this.setCoordinates(
        /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */ (
          coordinates
        ),
        layout
      );
    }
  }

  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */
  appendPolygon(polygon) {
    /** @type {Array<number>} */
    let ends;
    if (!this.flatCoordinates) {
      this.flatCoordinates = polygon.getFlatCoordinates().slice();
      ends = polygon.getEnds().slice();
      this.endss_.push();
    } else {
      const offset = this.flatCoordinates.length;
      (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(this.flatCoordinates, polygon.getFlatCoordinates());
      ends = polygon.getEnds().slice();
      for (let i = 0, ii = ends.length; i < ii; ++i) {
        ends[i] += offset;
      }
    }
    this.endss_.push(ends);
    this.changed();
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @api
   */
  clone() {
    const len = this.endss_.length;
    const newEndss = new Array(len);
    for (let i = 0; i < len; ++i) {
      newEndss[i] = this.endss_[i].slice();
    }

    const multiPolygon = new MultiPolygon(
      this.flatCoordinates.slice(),
      this.layout,
      newEndss
    );
    multiPolygon.applyProperties(this);

    return multiPolygon;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__.multiArrayMaxSquaredDelta)(
          this.flatCoordinates,
          0,
          this.endss_,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__.assignClosestMultiArrayPoint)(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(x, y) {
    return (0,_flat_contains_js__WEBPACK_IMPORTED_MODULE_4__.linearRingssContainsXY)(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      x,
      y
    );
  }

  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return (0,_flat_area_js__WEBPACK_IMPORTED_MODULE_5__.linearRingss)(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride
    );
  }

  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @api
   */
  getCoordinates(right) {
    let flatCoordinates;
    if (right !== undefined) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      (0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_6__.orientLinearRingsArray)(
        flatCoordinates,
        0,
        this.endss_,
        this.stride,
        right
      );
    } else {
      flatCoordinates = this.flatCoordinates;
    }

    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__.inflateMultiCoordinatesArray)(
      flatCoordinates,
      0,
      this.endss_,
      this.stride
    );
  }

  /**
   * @return {Array<Array<number>>} Endss.
   */
  getEndss() {
    return this.endss_;
  }

  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      const flatCenters = (0,_flat_center_js__WEBPACK_IMPORTED_MODULE_8__.linearRingss)(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride
      );
      this.flatInteriorPoints_ = (0,_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_9__.getInteriorPointsOfMultiArray)(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        flatCenters
      );
      this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return /** @type {Array<number>} */ (this.flatInteriorPoints_);
  }

  /**
   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoints() {
    return new _MultiPoint_js__WEBPACK_IMPORTED_MODULE_10__["default"](this.getFlatInteriorPoints().slice(), 'XYM');
  }

  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const flatCoordinates = this.flatCoordinates;
      if (
        (0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_6__.linearRingssAreOriented)(flatCoordinates, 0, this.endss_, this.stride)
      ) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = (0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_6__.orientLinearRingsArray)(
          this.orientedFlatCoordinates_,
          0,
          this.endss_,
          this.stride
        );
      }
      this.orientedRevision_ = this.getRevision();
    }
    return /** @type {Array<number>} */ (this.orientedFlatCoordinates_);
  }

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiPolygon} Simplified MultiPolygon.
   * @protected
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    /** @type {Array<number>} */
    const simplifiedFlatCoordinates = [];
    /** @type {Array<Array<number>>} */
    const simplifiedEndss = [];
    simplifiedFlatCoordinates.length = (0,_flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__.quantizeMultiArray)(
      this.flatCoordinates,
      0,
      this.endss_,
      this.stride,
      Math.sqrt(squaredTolerance),
      simplifiedFlatCoordinates,
      0,
      simplifiedEndss
    );
    return new MultiPolygon(simplifiedFlatCoordinates, 'XY', simplifiedEndss);
  }

  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */
  getPolygon(index) {
    if (index < 0 || this.endss_.length <= index) {
      return null;
    }
    let offset;
    if (index === 0) {
      offset = 0;
    } else {
      const prevEnds = this.endss_[index - 1];
      offset = prevEnds[prevEnds.length - 1];
    }
    const ends = this.endss_[index].slice();
    const end = ends[ends.length - 1];
    if (offset !== 0) {
      for (let i = 0, ii = ends.length; i < ii; ++i) {
        ends[i] -= offset;
      }
    }
    return new _Polygon_js__WEBPACK_IMPORTED_MODULE_12__["default"](
      this.flatCoordinates.slice(offset, end),
      this.layout,
      ends
    );
  }

  /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */
  getPolygons() {
    const layout = this.layout;
    const flatCoordinates = this.flatCoordinates;
    const endss = this.endss_;
    const polygons = [];
    let offset = 0;
    for (let i = 0, ii = endss.length; i < ii; ++i) {
      const ends = endss[i].slice();
      const end = ends[ends.length - 1];
      if (offset !== 0) {
        for (let j = 0, jj = ends.length; j < jj; ++j) {
          ends[j] -= offset;
        }
      }
      const polygon = new _Polygon_js__WEBPACK_IMPORTED_MODULE_12__["default"](
        flatCoordinates.slice(offset, end),
        layout,
        ends
      );
      polygons.push(polygon);
      offset = end;
    }
    return polygons;
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return 'MultiPolygon';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    return (0,_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_13__.intersectsLinearRingMultiArray)(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      extent
    );
  }

  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(coordinates, layout) {
    this.setLayout(layout, coordinates, 3);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const endss = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_14__.deflateMultiCoordinatesArray)(
      this.flatCoordinates,
      0,
      coordinates,
      this.stride,
      this.endss_
    );
    if (endss.length === 0) {
      this.flatCoordinates.length = 0;
    } else {
      const lastEnds = endss[endss.length - 1];
      this.flatCoordinates.length =
        lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
    }
    this.changed();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MultiPolygon);


/***/ }),

/***/ "./node_modules/ol/geom/Point.js":
/*!***************************************!*\
  !*** ./node_modules/ol/geom/Point.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/Point
 */





/**
 * @classdesc
 * Point geometry.
 *
 * @api
 */
class Point extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(coordinates, layout) {
    super();
    this.setCoordinates(coordinates, layout);
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */
  clone() {
    const point = new Point(this.flatCoordinates.slice(), this.layout);
    point.applyProperties(this);
    return point;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    const flatCoordinates = this.flatCoordinates;
    const squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.squaredDistance)(
      x,
      y,
      flatCoordinates[0],
      flatCoordinates[1]
    );
    if (squaredDistance < minSquaredDistance) {
      const stride = this.stride;
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[i];
      }
      closestPoint.length = stride;
      return squaredDistance;
    }
    return minSquaredDistance;
  }

  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   */
  getCoordinates() {
    return this.flatCoordinates.slice();
  }

  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(extent) {
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createOrUpdateFromCoordinate)(this.flatCoordinates, extent);
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return 'Point';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.containsXY)(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
  }

  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(coordinates, layout) {
    this.setLayout(layout, coordinates, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_3__.deflateCoordinate)(
      this.flatCoordinates,
      0,
      coordinates,
      this.stride
    );
    this.changed();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Point);


/***/ }),

/***/ "./node_modules/ol/geom/Polygon.js":
/*!*****************************************!*\
  !*** ./node_modules/ol/geom/Polygon.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   circular: () => (/* binding */ circular),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   fromCircle: () => (/* binding */ fromCircle),
/* harmony export */   fromExtent: () => (/* binding */ fromExtent),
/* harmony export */   makeRegular: () => (/* binding */ makeRegular)
/* harmony export */ });
/* harmony import */ var _LinearRing_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./LinearRing.js */ "./node_modules/ol/geom/LinearRing.js");
/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Point.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimpleGeometry.js */ "./node_modules/ol/geom/SimpleGeometry.js");
/* harmony import */ var _flat_closest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/closest.js */ "./node_modules/ol/geom/flat/closest.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_deflate_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./flat/deflate.js */ "./node_modules/ol/geom/flat/deflate.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./flat/interiorpoint.js */ "./node_modules/ol/geom/flat/interiorpoint.js");
/* harmony import */ var _flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./flat/inflate.js */ "./node_modules/ol/geom/flat/inflate.js");
/* harmony import */ var _flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./flat/intersectsextent.js */ "./node_modules/ol/geom/flat/intersectsextent.js");
/* harmony import */ var _flat_orient_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./flat/orient.js */ "./node_modules/ol/geom/flat/orient.js");
/* harmony import */ var _flat_area_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./flat/area.js */ "./node_modules/ol/geom/flat/area.js");
/* harmony import */ var _flat_contains_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flat/contains.js */ "./node_modules/ol/geom/flat/contains.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/* harmony import */ var _sphere_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../sphere.js */ "./node_modules/ol/sphere.js");
/**
 * @module ol/geom/Polygon
 */

















/**
 * @classdesc
 * Polygon geometry.
 *
 * @api
 */
class Polygon extends _SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(coordinates, layout, ends) {
    super();

    /**
     * @type {Array<number>}
     * @private
     */
    this.ends_ = [];

    /**
     * @private
     * @type {number}
     */
    this.flatInteriorPointRevision_ = -1;

    /**
     * @private
     * @type {import("../coordinate.js").Coordinate|null}
     */
    this.flatInteriorPoint_ = null;

    /**
     * @private
     * @type {number}
     */
    this.maxDelta_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.maxDeltaRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.orientedRevision_ = -1;

    /**
     * @private
     * @type {Array<number>|null}
     */
    this.orientedFlatCoordinates_ = null;

    if (layout !== undefined && ends) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */ (coordinates)
      );
      this.ends_ = ends;
    } else {
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ (
          coordinates
        ),
        layout
      );
    }
  }

  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(linearRing) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = linearRing.getFlatCoordinates().slice();
    } else {
      (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(this.flatCoordinates, linearRing.getFlatCoordinates());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  }

  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   */
  clone() {
    const polygon = new Polygon(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    polygon.applyProperties(this);
    return polygon;
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.closestSquaredDistanceXY)(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__.arrayMaxSquaredDelta)(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return (0,_flat_closest_js__WEBPACK_IMPORTED_MODULE_3__.assignClosestArrayPoint)(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }

  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(x, y) {
    return (0,_flat_contains_js__WEBPACK_IMPORTED_MODULE_4__.linearRingsContainsXY)(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      x,
      y
    );
  }

  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return (0,_flat_area_js__WEBPACK_IMPORTED_MODULE_5__.linearRings)(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }

  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates(right) {
    let flatCoordinates;
    if (right !== undefined) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      (0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_6__.orientLinearRings)(flatCoordinates, 0, this.ends_, this.stride, right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }

    return (0,_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__.inflateCoordinatesArray)(flatCoordinates, 0, this.ends_, this.stride);
  }

  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }

  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const flatCenter = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getCenter)(this.getExtent());
      this.flatInteriorPoint_ = (0,_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_8__.getInteriorPointOfArray)(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        flatCenter,
        0
      );
      this.flatInteriorPointRevision_ = this.getRevision();
    }
    return /** @type {import("../coordinate.js").Coordinate} */ (
      this.flatInteriorPoint_
    );
  }

  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new _Point_js__WEBPACK_IMPORTED_MODULE_9__["default"](this.getFlatInteriorPoint(), 'XYM');
  }

  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }

  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }
    return new _LinearRing_js__WEBPACK_IMPORTED_MODULE_10__["default"](
      this.flatCoordinates.slice(
        index === 0 ? 0 : this.ends_[index - 1],
        this.ends_[index]
      ),
      this.layout
    );
  }

  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const layout = this.layout;
    const flatCoordinates = this.flatCoordinates;
    const ends = this.ends_;
    const linearRings = [];
    let offset = 0;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      const linearRing = new _LinearRing_js__WEBPACK_IMPORTED_MODULE_10__["default"](
        flatCoordinates.slice(offset, end),
        layout
      );
      linearRings.push(linearRing);
      offset = end;
    }
    return linearRings;
  }

  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const flatCoordinates = this.flatCoordinates;
      if ((0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_6__.linearRingsAreOriented)(flatCoordinates, 0, this.ends_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = (0,_flat_orient_js__WEBPACK_IMPORTED_MODULE_6__.orientLinearRings)(
          this.orientedFlatCoordinates_,
          0,
          this.ends_,
          this.stride
        );
      }
      this.orientedRevision_ = this.getRevision();
    }
    return /** @type {Array<number>} */ (this.orientedFlatCoordinates_);
  }

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    /** @type {Array<number>} */
    const simplifiedFlatCoordinates = [];
    /** @type {Array<number>} */
    const simplifiedEnds = [];
    simplifiedFlatCoordinates.length = (0,_flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__.quantizeArray)(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(squaredTolerance),
      simplifiedFlatCoordinates,
      0,
      simplifiedEnds
    );
    return new Polygon(simplifiedFlatCoordinates, 'XY', simplifiedEnds);
  }

  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return 'Polygon';
  }

  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(extent) {
    return (0,_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_12__.intersectsLinearRingArray)(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      extent
    );
  }

  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(coordinates, layout) {
    this.setLayout(layout, coordinates, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const ends = (0,_flat_deflate_js__WEBPACK_IMPORTED_MODULE_13__.deflateCoordinatesArray)(
      this.flatCoordinates,
      0,
      coordinates,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Polygon);

/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {import("../coordinate.js").Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices in meters.
 * @param {number} [n] Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @param {number} [sphereRadius] Optional radius for the sphere (defaults to
 *     the Earth's mean radius using the WGS84 ellipsoid).
 * @return {Polygon} The "circular" polygon.
 * @api
 */
function circular(center, radius, n, sphereRadius) {
  n = n ? n : 32;
  /** @type {Array<number>} */
  const flatCoordinates = [];
  for (let i = 0; i < n; ++i) {
    (0,_array_js__WEBPACK_IMPORTED_MODULE_1__.extend)(
      flatCoordinates,
      (0,_sphere_js__WEBPACK_IMPORTED_MODULE_14__.offset)(center, radius, (2 * Math.PI * i) / n, sphereRadius)
    );
  }
  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);
}

/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {import("../extent.js").Extent} extent The extent.
 * @return {Polygon} The polygon.
 * @api
 */
function fromExtent(extent) {
  if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.isEmpty)(extent)) {
    throw new Error('Cannot create polygon from empty extent');
  }
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const flatCoordinates = [
    minX,
    minY,
    minX,
    maxY,
    maxX,
    maxY,
    maxX,
    minY,
    minX,
    minY,
  ];
  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);
}

/**
 * Create a regular polygon from a circle.
 * @param {import("./Circle.js").default} circle Circle geometry.
 * @param {number} [sides] Number of sides of the polygon. Default is 32.
 * @param {number} [angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 * @return {Polygon} Polygon geometry.
 * @api
 */
function fromCircle(circle, sides, angle) {
  sides = sides ? sides : 32;
  const stride = circle.getStride();
  const layout = circle.getLayout();
  const center = circle.getCenter();
  const arrayLength = stride * (sides + 1);
  const flatCoordinates = new Array(arrayLength);
  for (let i = 0; i < arrayLength; i += stride) {
    flatCoordinates[i] = 0;
    flatCoordinates[i + 1] = 0;
    for (let j = 2; j < stride; j++) {
      flatCoordinates[i + j] = center[j];
    }
  }
  const ends = [flatCoordinates.length];
  const polygon = new Polygon(flatCoordinates, layout, ends);
  makeRegular(polygon, center, circle.getRadius(), angle);
  return polygon;
}

/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {Polygon} polygon Polygon geometry.
 * @param {import("../coordinate.js").Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number} [angle] Start angle for the first vertex of the polygon in
 *     counter-clockwise radians. 0 means East. Default is 0.
 */
function makeRegular(polygon, center, radius, angle) {
  const flatCoordinates = polygon.getFlatCoordinates();
  const stride = polygon.getStride();
  const sides = flatCoordinates.length / stride - 1;
  const startAngle = angle ? angle : 0;
  for (let i = 0; i <= sides; ++i) {
    const offset = i * stride;
    const angle = startAngle + ((0,_math_js__WEBPACK_IMPORTED_MODULE_15__.modulo)(i, sides) * 2 * Math.PI) / sides;
    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);
    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);
  }
  polygon.changed();
}


/***/ }),

/***/ "./node_modules/ol/geom/SimpleGeometry.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/SimpleGeometry.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getLayoutForStride: () => (/* binding */ getLayoutForStride),
/* harmony export */   getStrideForLayout: () => (/* binding */ getStrideForLayout),
/* harmony export */   transformGeom2D: () => (/* binding */ transformGeom2D)
/* harmony export */ });
/* harmony import */ var _Geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometry.js */ "./node_modules/ol/geom/Geometry.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ "./node_modules/ol/util.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _flat_transform_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/**
 * @module ol/geom/SimpleGeometry
 */





/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @abstract
 * @api
 */
class SimpleGeometry extends _Geometry_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor() {
    super();

    /**
     * @protected
     * @type {import("./Geometry.js").GeometryLayout}
     */
    this.layout = 'XY';

    /**
     * @protected
     * @type {number}
     */
    this.stride = 2;

    /**
     * @protected
     * @type {Array<number>}
     */
    this.flatCoordinates;
  }

  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(extent) {
    return (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.createOrUpdateFromFlatCoordinates)(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      extent
    );
  }

  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.abstract)();
  }

  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }

  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }

  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }

  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }

  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   */
  getSimplifiedGeometry(squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    // If squaredTolerance is negative or if we know that simplification will not
    // have any effect then just return this.
    if (
      squaredTolerance < 0 ||
      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&
        squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)
    ) {
      return this;
    }

    const simplifiedGeometry =
      this.getSimplifiedGeometryInternal(squaredTolerance);
    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
      return simplifiedGeometry;
    }
    // Simplification did not actually remove any coordinates.  We now know
    // that any calls to getSimplifiedGeometry with a squaredTolerance less
    // than or equal to the current squaredTolerance will also not have any
    // effect.  This allows us to short circuit simplification (saving CPU
    // cycles) and prevents the cache of simplified geometries from filling
    // up with useless identical copies of this geometry (saving memory).
    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
    return this;
  }

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    return this;
  }

  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }

  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(layout, flatCoordinates) {
    this.stride = getStrideForLayout(layout);
    this.layout = layout;
    this.flatCoordinates = flatCoordinates;
  }

  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(coordinates, layout) {
    (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.abstract)();
  }

  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(layout, coordinates, nesting) {
    let stride;
    if (layout) {
      stride = getStrideForLayout(layout);
    } else {
      for (let i = 0; i < nesting; ++i) {
        if (coordinates.length === 0) {
          this.layout = 'XY';
          this.stride = 2;
          return;
        }
        coordinates = /** @type {Array<unknown>} */ (coordinates[0]);
      }
      stride = coordinates.length;
      layout = getLayoutForStride(stride);
    }
    this.layout = layout;
    this.stride = stride;
  }

  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(transformFn) {
    if (this.flatCoordinates) {
      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
      this.changed();
    }
  }

  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(angle, anchor) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.rotate)(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        angle,
        anchor,
        flatCoordinates
      );
      this.changed();
    }
  }

  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(sx, sy, anchor) {
    if (sy === undefined) {
      sy = sx;
    }
    if (!anchor) {
      anchor = (0,_extent_js__WEBPACK_IMPORTED_MODULE_1__.getCenter)(this.getExtent());
    }
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.scale)(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        sx,
        sy,
        anchor,
        flatCoordinates
      );
      this.changed();
    }
  }

  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(deltaX, deltaY) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.translate)(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        deltaX,
        deltaY,
        flatCoordinates
      );
      this.changed();
    }
  }
}

/**
 * @param {number} stride Stride.
 * @return {import("./Geometry.js").GeometryLayout} layout Layout.
 */
function getLayoutForStride(stride) {
  let layout;
  if (stride == 2) {
    layout = 'XY';
  } else if (stride == 3) {
    layout = 'XYZ';
  } else if (stride == 4) {
    layout = 'XYZM';
  }
  return /** @type {import("./Geometry.js").GeometryLayout} */ (layout);
}

/**
 * @param {import("./Geometry.js").GeometryLayout} layout Layout.
 * @return {number} Stride.
 */
function getStrideForLayout(layout) {
  let stride;
  if (layout == 'XY') {
    stride = 2;
  } else if (layout == 'XYZ' || layout == 'XYM') {
    stride = 3;
  } else if (layout == 'XYZM') {
    stride = 4;
  }
  return /** @type {number} */ (stride);
}

/**
 * @param {SimpleGeometry} simpleGeometry Simple geometry.
 * @param {import("../transform.js").Transform} transform Transform.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed flat coordinates.
 */
function transformGeom2D(simpleGeometry, transform, dest) {
  const flatCoordinates = simpleGeometry.getFlatCoordinates();
  if (!flatCoordinates) {
    return null;
  }
  const stride = simpleGeometry.getStride();
  return (0,_flat_transform_js__WEBPACK_IMPORTED_MODULE_3__.transform2D)(
    flatCoordinates,
    0,
    flatCoordinates.length,
    stride,
    transform,
    dest
  );
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SimpleGeometry);


/***/ }),

/***/ "./node_modules/ol/geom/flat/area.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/geom/flat/area.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   linearRing: () => (/* binding */ linearRing),
/* harmony export */   linearRings: () => (/* binding */ linearRings),
/* harmony export */   linearRingss: () => (/* binding */ linearRingss)
/* harmony export */ });
/**
 * @module ol/geom/flat/area
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRing(flatCoordinates, offset, end, stride) {
  let twiceArea = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }
  return twiceArea / 2;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRings(flatCoordinates, offset, ends, stride) {
  let area = 0;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    area += linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }
  return area;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
function linearRingss(flatCoordinates, offset, endss, stride) {
  let area = 0;
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    area += linearRings(flatCoordinates, offset, ends, stride);
    offset = ends[ends.length - 1];
  }
  return area;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/center.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/geom/flat/center.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   linearRingss: () => (/* binding */ linearRingss)
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/**
 * @module ol/geom/flat/center
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array<number>} Flat centers.
 */
function linearRingss(flatCoordinates, offset, endss, stride) {
  const flatCenters = [];
  let extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createEmpty)();
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    extent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createOrUpdateFromFlatCoordinates)(
      flatCoordinates,
      offset,
      ends[0],
      stride
    );
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset = ends[ends.length - 1];
  }
  return flatCenters;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/closest.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/closest.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrayMaxSquaredDelta: () => (/* binding */ arrayMaxSquaredDelta),
/* harmony export */   assignClosestArrayPoint: () => (/* binding */ assignClosestArrayPoint),
/* harmony export */   assignClosestMultiArrayPoint: () => (/* binding */ assignClosestMultiArrayPoint),
/* harmony export */   assignClosestPoint: () => (/* binding */ assignClosestPoint),
/* harmony export */   maxSquaredDelta: () => (/* binding */ maxSquaredDelta),
/* harmony export */   multiArrayMaxSquaredDelta: () => (/* binding */ multiArrayMaxSquaredDelta)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/closest
 */


/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 */
function assignClosest(
  flatCoordinates,
  offset1,
  offset2,
  stride,
  x,
  y,
  closestPoint
) {
  const x1 = flatCoordinates[offset1];
  const y1 = flatCoordinates[offset1 + 1];
  const dx = flatCoordinates[offset2] - x1;
  const dy = flatCoordinates[offset2 + 1] - y1;
  let offset;
  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.lerp)(
          flatCoordinates[offset1 + i],
          flatCoordinates[offset2 + i],
          t
        );
      }
      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }
  for (let i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset + i];
  }
  closestPoint.length = stride;
}

/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  for (offset += stride; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    const squaredDelta = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(x1, y1, x2, y2);
    if (squaredDelta > max) {
      max = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function arrayMaxSquaredDelta(
  flatCoordinates,
  offset,
  ends,
  stride,
  max
) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
    offset = end;
  }
  return max;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} max Max squared delta.
 * @return {number} Max squared delta.
 */
function multiArrayMaxSquaredDelta(
  flatCoordinates,
  offset,
  endss,
  stride,
  max
) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
    offset = ends[ends.length - 1];
  }
  return max;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestPoint(
  flatCoordinates,
  offset,
  end,
  stride,
  maxDelta,
  isRing,
  x,
  y,
  closestPoint,
  minSquaredDistance,
  tmpPoint
) {
  if (offset == end) {
    return minSquaredDistance;
  }
  let i, squaredDistance;
  if (maxDelta === 0) {
    // All points are identical, so just test the first point.
    squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(
      x,
      y,
      flatCoordinates[offset],
      flatCoordinates[offset + 1]
    );
    if (squaredDistance < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }
      closestPoint.length = stride;
      return squaredDistance;
    }
    return minSquaredDistance;
  }
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  let index = offset + stride;
  while (index < end) {
    assignClosest(
      flatCoordinates,
      index - stride,
      index,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      // Skip ahead multiple points, because we know that all the skipped
      // points cannot be any closer than the closest point we have found so
      // far.  We know this because we know how close the current point is, how
      // close the closest point we have found so far is, and the maximum
      // distance between consecutive points.  For example, if we're currently
      // at distance 10, the best we've found so far is 3, and that the maximum
      // distance between consecutive points is 2, then we'll need to skip at
      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
      // finding a closer point.  We use Math.max(..., 1) to ensure that we
      // always advance at least one point, to avoid an infinite loop.
      index +=
        stride *
        Math.max(
          ((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /
            maxDelta) |
            0,
          1
        );
    }
  }
  if (isRing) {
    // Check the closing segment.
    assignClosest(
      flatCoordinates,
      end - stride,
      offset,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestArrayPoint(
  flatCoordinates,
  offset,
  ends,
  stride,
  maxDelta,
  isRing,
  x,
  y,
  closestPoint,
  minSquaredDistance,
  tmpPoint
) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    minSquaredDistance = assignClosestPoint(
      flatCoordinates,
      offset,
      end,
      stride,
      maxDelta,
      isRing,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint
    );
    offset = end;
  }
  return minSquaredDistance;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array<number>} [tmpPoint] Temporary point object.
 * @return {number} Minimum squared distance.
 */
function assignClosestMultiArrayPoint(
  flatCoordinates,
  offset,
  endss,
  stride,
  maxDelta,
  isRing,
  x,
  y,
  closestPoint,
  minSquaredDistance,
  tmpPoint
) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    minSquaredDistance = assignClosestArrayPoint(
      flatCoordinates,
      offset,
      ends,
      stride,
      maxDelta,
      isRing,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint
    );
    offset = ends[ends.length - 1];
  }
  return minSquaredDistance;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/contains.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/contains.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   linearRingContainsExtent: () => (/* binding */ linearRingContainsExtent),
/* harmony export */   linearRingContainsXY: () => (/* binding */ linearRingContainsXY),
/* harmony export */   linearRingsContainsXY: () => (/* binding */ linearRingsContainsXY),
/* harmony export */   linearRingssContainsXY: () => (/* binding */ linearRingssContainsXY)
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/**
 * @module ol/geom/flat/contains
 */


/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} Contains extent.
 */
function linearRingContainsExtent(
  flatCoordinates,
  offset,
  end,
  stride,
  extent
) {
  const outside = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.forEachCorner)(
    extent,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function (coordinate) {
      return !linearRingContainsXY(
        flatCoordinates,
        offset,
        end,
        stride,
        coordinate[0],
        coordinate[1]
      );
    }
  );
  return !outside;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingContainsXY(
  flatCoordinates,
  offset,
  end,
  stride,
  x,
  y
) {
  // https://geomalgorithms.com/a03-_inclusion.html
  // Copyright 2000 softSurfer, 2012 Dan Sunday
  // This code may be freely used and modified for any purpose
  // providing that this copyright notice is included with it.
  // SoftSurfer makes no warranty for this code, and cannot be held
  // liable for any real or imagined damage resulting from its use.
  // Users of this code must verify correctness for their application.
  let wn = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingsContainsXY(
  flatCoordinates,
  offset,
  ends,
  stride,
  x,
  y
) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (
      linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)
    ) {
      return false;
    }
  }
  return true;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
function linearRingssContainsXY(
  flatCoordinates,
  offset,
  endss,
  stride,
  x,
  y
) {
  if (endss.length === 0) {
    return false;
  }
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/deflate.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/deflate.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   deflateCoordinate: () => (/* binding */ deflateCoordinate),
/* harmony export */   deflateCoordinates: () => (/* binding */ deflateCoordinates),
/* harmony export */   deflateCoordinatesArray: () => (/* binding */ deflateCoordinatesArray),
/* harmony export */   deflateMultiCoordinatesArray: () => (/* binding */ deflateMultiCoordinatesArray)
/* harmony export */ });
/**
 * @module ol/geom/flat/deflate
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (let i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }
  return offset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
function deflateCoordinates(
  flatCoordinates,
  offset,
  coordinates,
  stride
) {
  for (let i = 0, ii = coordinates.length; i < ii; ++i) {
    const coordinate = coordinates[i];
    for (let j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }
  return offset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array<number>} [ends] Ends.
 * @return {Array<number>} Ends.
 */
function deflateCoordinatesArray(
  flatCoordinates,
  offset,
  coordinatess,
  stride,
  ends
) {
  ends = ends ? ends : [];
  let i = 0;
  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {
    const end = deflateCoordinates(
      flatCoordinates,
      offset,
      coordinatess[j],
      stride
    );
    ends[i++] = end;
    offset = end;
  }
  ends.length = i;
  return ends;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array<Array<number>>} [endss] Endss.
 * @return {Array<Array<number>>} Endss.
 */
function deflateMultiCoordinatesArray(
  flatCoordinates,
  offset,
  coordinatesss,
  stride,
  endss
) {
  endss = endss ? endss : [];
  let i = 0;
  for (let j = 0, jj = coordinatesss.length; j < jj; ++j) {
    const ends = deflateCoordinatesArray(
      flatCoordinates,
      offset,
      coordinatesss[j],
      stride,
      endss[i]
    );
    if (ends.length === 0) {
      ends[0] = offset;
    }
    endss[i++] = ends;
    offset = ends[ends.length - 1];
  }
  endss.length = i;
  return endss;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/inflate.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/inflate.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   inflateCoordinates: () => (/* binding */ inflateCoordinates),
/* harmony export */   inflateCoordinatesArray: () => (/* binding */ inflateCoordinatesArray),
/* harmony export */   inflateMultiCoordinatesArray: () => (/* binding */ inflateMultiCoordinatesArray)
/* harmony export */ });
/**
 * @module ol/geom/flat/inflate
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array<import("../../coordinate.js").Coordinate>} [coordinates] Coordinates.
 * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
 */
function inflateCoordinates(
  flatCoordinates,
  offset,
  end,
  stride,
  coordinates
) {
  coordinates = coordinates !== undefined ? coordinates : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    coordinates[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates.length = i;
  return coordinates;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<Array<import("../../coordinate.js").Coordinate>>} [coordinatess] Coordinatess.
 * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
 */
function inflateCoordinatesArray(
  flatCoordinates,
  offset,
  ends,
  stride,
  coordinatess
) {
  coordinatess = coordinatess !== undefined ? coordinatess : [];
  let i = 0;
  for (let j = 0, jj = ends.length; j < jj; ++j) {
    const end = ends[j];
    coordinatess[i++] = inflateCoordinates(
      flatCoordinates,
      offset,
      end,
      stride,
      coordinatess[i]
    );
    offset = end;
  }
  coordinatess.length = i;
  return coordinatess;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} [coordinatesss]
 *     Coordinatesss.
 * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
 */
function inflateMultiCoordinatesArray(
  flatCoordinates,
  offset,
  endss,
  stride,
  coordinatesss
) {
  coordinatesss = coordinatesss !== undefined ? coordinatesss : [];
  let i = 0;
  for (let j = 0, jj = endss.length; j < jj; ++j) {
    const ends = endss[j];
    coordinatesss[i++] =
      ends.length === 1 && ends[0] === offset
        ? []
        : inflateCoordinatesArray(
            flatCoordinates,
            offset,
            ends,
            stride,
            coordinatesss[i]
          );
    offset = ends[ends.length - 1];
  }
  coordinatesss.length = i;
  return coordinatesss;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/interiorpoint.js":
/*!****************************************************!*\
  !*** ./node_modules/ol/geom/flat/interiorpoint.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getInteriorPointOfArray: () => (/* binding */ getInteriorPointOfArray),
/* harmony export */   getInteriorPointsOfMultiArray: () => (/* binding */ getInteriorPointsOfMultiArray)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contains.js */ "./node_modules/ol/geom/flat/contains.js");
/**
 * @module ol/geom/flat/interiorpoint
 */



/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointOfArray(
  flatCoordinates,
  offset,
  ends,
  stride,
  flatCenters,
  flatCentersOffset,
  dest
) {
  let i, ii, x, x1, x2, y1, y2;
  const y = flatCenters[flatCentersOffset + 1];
  /** @type {Array<number>} */
  const intersections = [];
  // Calculate intersections with the horizontal line
  for (let r = 0, rr = ends.length; r < rr; ++r) {
    const end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {
        x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  // Find the longest segment of the horizontal line that has its center point
  // inside the linear ring.
  let pointX = NaN;
  let maxSegmentLength = -Infinity;
  intersections.sort(_array_js__WEBPACK_IMPORTED_MODULE_0__.ascending);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    const segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if ((0,_contains_js__WEBPACK_IMPORTED_MODULE_1__.linearRingsContainsXY)(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    // There is no horizontal line that has its center point inside the linear
    // ring.  Use the center of the the linear ring's extent.
    pointX = flatCenters[flatCentersOffset];
  }
  if (dest) {
    dest.push(pointX, y, maxSegmentLength);
    return dest;
  }
  return [pointX, y, maxSegmentLength];
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array<number>} flatCenters Flat centers.
 * @return {Array<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
function getInteriorPointsOfMultiArray(
  flatCoordinates,
  offset,
  endss,
  stride,
  flatCenters
) {
  /** @type {Array<number>} */
  let interiorPoints = [];
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    interiorPoints = getInteriorPointOfArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      flatCenters,
      2 * i,
      interiorPoints
    );
    offset = ends[ends.length - 1];
  }
  return interiorPoints;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/interpolate.js":
/*!**************************************************!*\
  !*** ./node_modules/ol/geom/flat/interpolate.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   interpolatePoint: () => (/* binding */ interpolatePoint),
/* harmony export */   lineStringCoordinateAtM: () => (/* binding */ lineStringCoordinateAtM),
/* harmony export */   lineStringsCoordinateAtM: () => (/* binding */ lineStringsCoordinateAtM)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/interpolate
 */



/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array<number>} [dest] Destination.
 * @param {number} [dimension] Destination dimension (default is `2`)
 * @return {Array<number>} Destination.
 */
function interpolatePoint(
  flatCoordinates,
  offset,
  end,
  stride,
  fraction,
  dest,
  dimension
) {
  let o, t;
  const n = (end - offset) / stride;
  if (n === 1) {
    o = offset;
  } else if (n === 2) {
    o = offset;
    t = fraction;
  } else if (n !== 0) {
    let x1 = flatCoordinates[offset];
    let y1 = flatCoordinates[offset + 1];
    let length = 0;
    const cumulativeLengths = [0];
    for (let i = offset + stride; i < end; i += stride) {
      const x2 = flatCoordinates[i];
      const y2 = flatCoordinates[i + 1];
      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length);
      x1 = x2;
      y1 = y2;
    }
    const target = fraction * length;
    const index = (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.binarySearch)(cumulativeLengths, target);
    if (index < 0) {
      t =
        (target - cumulativeLengths[-index - 2]) /
        (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
      o = offset + (-index - 2) * stride;
    } else {
      o = offset + index * stride;
    }
  }
  dimension = dimension > 1 ? dimension : 2;
  dest = dest ? dest : new Array(dimension);
  for (let i = 0; i < dimension; ++i) {
    dest[i] =
      o === undefined
        ? NaN
        : t === undefined
        ? flatCoordinates[o + i]
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.lerp)(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
  }
  return dest;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
 */
function lineStringCoordinateAtM(
  flatCoordinates,
  offset,
  end,
  stride,
  m,
  extrapolate
) {
  if (end == offset) {
    return null;
  }
  let coordinate;
  if (m < flatCoordinates[offset + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset, offset + stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  if (flatCoordinates[end - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  // FIXME use O(1) search
  if (m == flatCoordinates[offset + stride - 1]) {
    return flatCoordinates.slice(offset, offset + stride);
  }
  let lo = offset / stride;
  let hi = end / stride;
  while (lo < hi) {
    const mid = (lo + hi) >> 1;
    if (m < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  const m0 = flatCoordinates[lo * stride - 1];
  if (m == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }
  const m1 = flatCoordinates[(lo + 1) * stride - 1];
  const t = (m - m0) / (m1 - m0);
  coordinate = [];
  for (let i = 0; i < stride - 1; ++i) {
    coordinate.push(
      (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.lerp)(
        flatCoordinates[(lo - 1) * stride + i],
        flatCoordinates[lo * stride + i],
        t
      )
    );
  }
  coordinate.push(m);
  return coordinate;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {import("../../coordinate.js").Coordinate|null} Coordinate.
 */
function lineStringsCoordinateAtM(
  flatCoordinates,
  offset,
  ends,
  stride,
  m,
  extrapolate,
  interpolate
) {
  if (interpolate) {
    return lineStringCoordinateAtM(
      flatCoordinates,
      offset,
      ends[ends.length - 1],
      stride,
      m,
      extrapolate
    );
  }
  let coordinate;
  if (m < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  if (flatCoordinates[flatCoordinates.length - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    if (offset == end) {
      continue;
    }
    if (m < flatCoordinates[offset + stride - 1]) {
      return null;
    }
    if (m <= flatCoordinates[end - 1]) {
      return lineStringCoordinateAtM(
        flatCoordinates,
        offset,
        end,
        stride,
        m,
        false
      );
    }
    offset = end;
  }
  return null;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/intersectsextent.js":
/*!*******************************************************!*\
  !*** ./node_modules/ol/geom/flat/intersectsextent.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   intersectsLineString: () => (/* binding */ intersectsLineString),
/* harmony export */   intersectsLineStringArray: () => (/* binding */ intersectsLineStringArray),
/* harmony export */   intersectsLinearRing: () => (/* binding */ intersectsLinearRing),
/* harmony export */   intersectsLinearRingArray: () => (/* binding */ intersectsLinearRingArray),
/* harmony export */   intersectsLinearRingMultiArray: () => (/* binding */ intersectsLinearRingMultiArray)
/* harmony export */ });
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _segments_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./segments.js */ "./node_modules/ol/geom/flat/segments.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contains.js */ "./node_modules/ol/geom/flat/contains.js");
/**
 * @module ol/geom/flat/intersectsextent
 */




/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLineString(
  flatCoordinates,
  offset,
  end,
  stride,
  extent
) {
  const coordinatesExtent = (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.extendFlatCoordinates)(
    (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.createEmpty)(),
    flatCoordinates,
    offset,
    end,
    stride
  );
  if (!(0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.intersects)(extent, coordinatesExtent)) {
    return false;
  }
  if ((0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.containsExtent)(extent, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return (0,_segments_js__WEBPACK_IMPORTED_MODULE_1__.forEach)(
    flatCoordinates,
    offset,
    end,
    stride,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function (point1, point2) {
      return (0,_extent_js__WEBPACK_IMPORTED_MODULE_0__.intersectsSegment)(extent, point1, point2);
    }
  );
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLineStringArray(
  flatCoordinates,
  offset,
  ends,
  stride,
  extent
) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    if (
      intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)
    ) {
      return true;
    }
    offset = ends[i];
  }
  return false;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRing(
  flatCoordinates,
  offset,
  end,
  stride,
  extent
) {
  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }
  if (
    (0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsXY)(
      flatCoordinates,
      offset,
      end,
      stride,
      extent[0],
      extent[1]
    )
  ) {
    return true;
  }
  if (
    (0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsXY)(
      flatCoordinates,
      offset,
      end,
      stride,
      extent[0],
      extent[3]
    )
  ) {
    return true;
  }
  if (
    (0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsXY)(
      flatCoordinates,
      offset,
      end,
      stride,
      extent[2],
      extent[1]
    )
  ) {
    return true;
  }
  if (
    (0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsXY)(
      flatCoordinates,
      offset,
      end,
      stride,
      extent[2],
      extent[3]
    )
  ) {
    return true;
  }
  return false;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRingArray(
  flatCoordinates,
  offset,
  ends,
  stride,
  extent
) {
  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (
      (0,_contains_js__WEBPACK_IMPORTED_MODULE_2__.linearRingContainsExtent)(
        flatCoordinates,
        ends[i - 1],
        ends[i],
        stride,
        extent
      )
    ) {
      if (
        !intersectsLineString(
          flatCoordinates,
          ends[i - 1],
          ends[i],
          stride,
          extent
        )
      ) {
        return false;
      }
    }
  }
  return true;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {import("../../extent.js").Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
function intersectsLinearRingMultiArray(
  flatCoordinates,
  offset,
  endss,
  stride,
  extent
) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    if (
      intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)
    ) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/length.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/geom/flat/length.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   lineStringLength: () => (/* binding */ lineStringLength),
/* harmony export */   linearRingLength: () => (/* binding */ linearRingLength)
/* harmony export */ });
/**
 * @module ol/geom/flat/length
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */
function lineStringLength(flatCoordinates, offset, end, stride) {
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  let length = 0;
  for (let i = offset + stride; i < end; i += stride) {
    const x2 = flatCoordinates[i];
    const y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }
  return length;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */
function linearRingLength(flatCoordinates, offset, end, stride) {
  let perimeter = lineStringLength(flatCoordinates, offset, end, stride);
  const dx = flatCoordinates[end - stride] - flatCoordinates[offset];
  const dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
  perimeter += Math.sqrt(dx * dx + dy * dy);
  return perimeter;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/orient.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/geom/flat/orient.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   inflateEnds: () => (/* binding */ inflateEnds),
/* harmony export */   linearRingIsClockwise: () => (/* binding */ linearRingIsClockwise),
/* harmony export */   linearRingsAreOriented: () => (/* binding */ linearRingsAreOriented),
/* harmony export */   linearRingssAreOriented: () => (/* binding */ linearRingssAreOriented),
/* harmony export */   orientLinearRings: () => (/* binding */ orientLinearRings),
/* harmony export */   orientLinearRingsArray: () => (/* binding */ orientLinearRingsArray)
/* harmony export */ });
/* harmony import */ var _reverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reverse.js */ "./node_modules/ol/geom/flat/reverse.js");
/**
 * @module ol/geom/flat/orient
 */


/**
 * Is the linear ring oriented clockwise in a coordinate system with a bottom-left
 * coordinate origin? For a coordinate system with a top-left coordinate origin,
 * the ring's orientation is clockwise when this function returns false.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean|undefined} Is clockwise.
 */
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
  // https://stackoverflow.com/q/1165647/clockwise-method#1165943
  // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp
  let edge = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge === 0 ? undefined : edge > 0;
}

/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
function linearRingsAreOriented(
  flatCoordinates,
  offset,
  ends,
  stride,
  right
) {
  right = right !== undefined ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    if (i === 0) {
      if ((right && isClockwise) || (!right && !isClockwise)) {
        return false;
      }
    } else {
      if ((right && !isClockwise) || (!right && isClockwise)) {
        return false;
      }
    }
    offset = end;
  }
  return true;
}

/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
function linearRingssAreOriented(
  flatCoordinates,
  offset,
  endss,
  stride,
  right
) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {
      return false;
    }
    if (ends.length) {
      offset = ends[ends.length - 1];
    }
  }
  return true;
}

/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean} [right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */
function orientLinearRings(
  flatCoordinates,
  offset,
  ends,
  stride,
  right
) {
  right = right !== undefined ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    const reverse =
      i === 0
        ? (right && isClockwise) || (!right && !isClockwise)
        : (right && !isClockwise) || (!right && isClockwise);
    if (reverse) {
      (0,_reverse_js__WEBPACK_IMPORTED_MODULE_0__.coordinates)(flatCoordinates, offset, end, stride);
    }
    offset = end;
  }
  return offset;
}

/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `right` argument.
 *
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean} [right] Follow the right-hand rule for orientation.
 * @return {number} End.
 */
function orientLinearRingsArray(
  flatCoordinates,
  offset,
  endss,
  stride,
  right
) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    offset = orientLinearRings(
      flatCoordinates,
      offset,
      endss[i],
      stride,
      right
    );
  }
  return offset;
}

/**
 * Return a two-dimensional endss
 * @param {Array<number>} flatCoordinates Flat coordinates
 * @param {Array<number>} ends Linear ring end indexes
 * @return {Array<Array<number>>} Two dimensional endss array that can
 * be used to construct a MultiPolygon
 */
function inflateEnds(flatCoordinates, ends) {
  const endss = [];
  let offset = 0;
  let prevEndIndex = 0;
  let startOrientation;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    // classifies an array of rings into polygons with outer rings and holes
    const orientation = linearRingIsClockwise(flatCoordinates, offset, end, 2);
    if (startOrientation === undefined) {
      startOrientation = orientation;
    }
    if (orientation === startOrientation) {
      endss.push(ends.slice(prevEndIndex, i + 1));
    } else {
      if (endss.length === 0) {
        continue;
      }
      endss[endss.length - 1].push(ends[prevEndIndex]);
    }
    prevEndIndex = i + 1;
    offset = end;
  }
  return endss;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/reverse.js":
/*!**********************************************!*\
  !*** ./node_modules/ol/geom/flat/reverse.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   coordinates: () => (/* binding */ coordinates)
/* harmony export */ });
/**
 * @module ol/geom/flat/reverse
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */
function coordinates(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    for (let i = 0; i < stride; ++i) {
      const tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset += stride;
    end -= stride;
  }
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/segments.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/segments.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forEach: () => (/* binding */ forEach)
/* harmony export */ });
/**
 * @module ol/geom/flat/segments
 */

/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
 *     called for each segment.
 * @return {T|boolean} Value.
 * @template T
 */
function forEach(flatCoordinates, offset, end, stride, callback) {
  let ret;
  offset += stride;
  for (; offset < end; offset += stride) {
    ret = callback(
      flatCoordinates.slice(offset - stride, offset),
      flatCoordinates.slice(offset, offset + stride)
    );
    if (ret) {
      return ret;
    }
  }
  return false;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/simplify.js":
/*!***********************************************!*\
  !*** ./node_modules/ol/geom/flat/simplify.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   douglasPeucker: () => (/* binding */ douglasPeucker),
/* harmony export */   douglasPeuckerArray: () => (/* binding */ douglasPeuckerArray),
/* harmony export */   douglasPeuckerMultiArray: () => (/* binding */ douglasPeuckerMultiArray),
/* harmony export */   quantize: () => (/* binding */ quantize),
/* harmony export */   quantizeArray: () => (/* binding */ quantizeArray),
/* harmony export */   quantizeMultiArray: () => (/* binding */ quantizeMultiArray),
/* harmony export */   radialDistance: () => (/* binding */ radialDistance),
/* harmony export */   simplifyLineString: () => (/* binding */ simplifyLineString),
/* harmony export */   snap: () => (/* binding */ snap)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/geom/flat/simplify
 */
// Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.



/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat
 *     coordinates.
 * @return {Array<number>} Simplified line string.
 */
function simplifyLineString(
  flatCoordinates,
  offset,
  end,
  stride,
  squaredTolerance,
  highQuality,
  simplifiedFlatCoordinates
) {
  simplifiedFlatCoordinates =
    simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];
  if (!highQuality) {
    end = radialDistance(
      flatCoordinates,
      offset,
      end,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0
    );
    flatCoordinates = simplifiedFlatCoordinates;
    offset = 0;
    stride = 2;
  }
  simplifiedFlatCoordinates.length = douglasPeucker(
    flatCoordinates,
    offset,
    end,
    stride,
    squaredTolerance,
    simplifiedFlatCoordinates,
    0
  );
  return simplifiedFlatCoordinates;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function douglasPeucker(
  flatCoordinates,
  offset,
  end,
  stride,
  squaredTolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset
) {
  const n = (end - offset) / stride;
  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] =
        flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  /** @type {Array<number>} */
  const markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  /** @type {Array<number>} */
  const stack = [offset, end - stride];
  let index = 0;
  while (stack.length > 0) {
    const last = stack.pop();
    const first = stack.pop();
    let maxSquaredDistance = 0;
    const x1 = flatCoordinates[first];
    const y1 = flatCoordinates[first + 1];
    const x2 = flatCoordinates[last];
    const y2 = flatCoordinates[last + 1];
    for (let i = first + stride; i < last; i += stride) {
      const x = flatCoordinates[i];
      const y = flatCoordinates[i + 1];
      const squaredDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredSegmentDistance)(x, y, x1, y1, x2, y2);
      if (squaredDistance > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;
      if (first + stride < index) {
        stack.push(first, index);
      }
      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }
  for (let i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] =
        flatCoordinates[offset + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] =
        flatCoordinates[offset + i * stride + 1];
    }
  }
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
function douglasPeuckerArray(
  flatCoordinates,
  offset,
  ends,
  stride,
  squaredTolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset,
  simplifiedEnds
) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = douglasPeucker(
      flatCoordinates,
      offset,
      end,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
function douglasPeuckerMultiArray(
  flatCoordinates,
  offset,
  endss,
  stride,
  squaredTolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset,
  simplifiedEndss
) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    /** @type {Array<number>} */
    const simplifiedEnds = [];
    simplifiedOffset = douglasPeuckerArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset,
      simplifiedEnds
    );
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function radialDistance(
  flatCoordinates,
  offset,
  end,
  stride,
  squaredTolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset
) {
  if (end <= offset + stride) {
    // zero or one point, no simplification possible, so copy and return
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] =
        flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  // copy first point
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  let x2 = x1;
  let y2 = y1;
  for (offset += stride; offset < end; offset += stride) {
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.squaredDistance)(x1, y1, x2, y2) > squaredTolerance) {
      // copy point at offset
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
    }
  }
  if (x2 != x1 || y2 != y1) {
    // copy last point
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  }
  return simplifiedOffset;
}

/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}

/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
function quantize(
  flatCoordinates,
  offset,
  end,
  stride,
  tolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset
) {
  // do nothing if the line is empty
  if (offset == end) {
    return simplifiedOffset;
  }
  // snap the first coordinate (P1)
  let x1 = snap(flatCoordinates[offset], tolerance);
  let y1 = snap(flatCoordinates[offset + 1], tolerance);
  offset += stride;
  // add the first coordinate to the output
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  // find the next coordinate that does not snap to the same value as the first
  // coordinate (P2)
  let x2, y2;
  do {
    x2 = snap(flatCoordinates[offset], tolerance);
    y2 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (offset == end) {
      // all coordinates snap to the same value, the line collapses to a point
      // push the last snapped value anyway to ensure that the output contains
      // at least two points
      // FIXME should we really return at least two points anyway?
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset < end) {
    // snap the next coordinate (P3)
    const x3 = snap(flatCoordinates[offset], tolerance);
    const y3 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    // skip P3 if it is equal to P2
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    // calculate the delta between P1 and P2
    const dx1 = x2 - x1;
    const dy1 = y2 - y1;
    // calculate the delta between P3 and P1
    const dx2 = x3 - x1;
    const dy2 = y3 - y1;
    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
    // P1 in the same direction then P2 is on the straight line between P1 and
    // P3
    if (
      dx1 * dy2 == dy1 * dx2 &&
      ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&
      ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))
    ) {
      // discard P2 and set P2 = P3
      x2 = x3;
      y2 = y3;
      continue;
    }
    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
    // between P3 and P1 or on the opposite half of the line to P2.  add P2,
    // and continue with P1 = P2 and P2 = P3
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  // add the last point (P2)
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
function quantizeArray(
  flatCoordinates,
  offset,
  ends,
  stride,
  tolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset,
  simplifiedEnds
) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = quantize(
      flatCoordinates,
      offset,
      end,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array<Array<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
function quantizeMultiArray(
  flatCoordinates,
  offset,
  endss,
  stride,
  tolerance,
  simplifiedFlatCoordinates,
  simplifiedOffset,
  simplifiedEndss
) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    /** @type {Array<number>} */
    const simplifiedEnds = [];
    simplifiedOffset = quantizeArray(
      flatCoordinates,
      offset,
      ends,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset,
      simplifiedEnds
    );
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
}


/***/ }),

/***/ "./node_modules/ol/geom/flat/transform.js":
/*!************************************************!*\
  !*** ./node_modules/ol/geom/flat/transform.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   transform2D: () => (/* binding */ transform2D),
/* harmony export */   translate: () => (/* binding */ translate)
/* harmony export */ });
/**
 * @module ol/geom/flat/transform
 */

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {import("../../transform.js").Transform} transform Transform.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function transform2D(
  flatCoordinates,
  offset,
  end,
  stride,
  transform,
  dest
) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const x = flatCoordinates[j];
    const y = flatCoordinates[j + 1];
    dest[i++] = transform[0] * x + transform[2] * y + transform[4];
    dest[i++] = transform[1] * x + transform[3] * y + transform[5];
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array<number>} anchor Rotation anchor point.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function rotate(
  flatCoordinates,
  offset,
  end,
  stride,
  angle,
  anchor,
  dest
) {
  dest = dest ? dest : [];
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

/**
 * Scale the coordinates.
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array<number>} anchor Scale anchor point.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function scale(
  flatCoordinates,
  offset,
  end,
  stride,
  sx,
  sy,
  anchor,
  dest
) {
  dest = dest ? dest : [];
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}

/**
 * @param {Array<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array<number>} [dest] Destination.
 * @return {Array<number>} Transformed coordinates.
 */
function translate(
  flatCoordinates,
  offset,
  end,
  stride,
  deltaX,
  deltaY,
  dest
) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}


/***/ }),

/***/ "./node_modules/ol/has.js":
/*!********************************!*\
  !*** ./node_modules/ol/has.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CREATE_IMAGE_BITMAP: () => (/* binding */ CREATE_IMAGE_BITMAP),
/* harmony export */   DEVICE_PIXEL_RATIO: () => (/* binding */ DEVICE_PIXEL_RATIO),
/* harmony export */   FIREFOX: () => (/* binding */ FIREFOX),
/* harmony export */   IMAGE_DECODE: () => (/* binding */ IMAGE_DECODE),
/* harmony export */   MAC: () => (/* binding */ MAC),
/* harmony export */   PASSIVE_EVENT_LISTENERS: () => (/* binding */ PASSIVE_EVENT_LISTENERS),
/* harmony export */   SAFARI: () => (/* binding */ SAFARI),
/* harmony export */   SAFARI_BUG_237906: () => (/* binding */ SAFARI_BUG_237906),
/* harmony export */   WEBKIT: () => (/* binding */ WEBKIT),
/* harmony export */   WORKER_OFFSCREEN_CANVAS: () => (/* binding */ WORKER_OFFSCREEN_CANVAS)
/* harmony export */ });
/**
 * @module ol/has
 */

const ua =
  typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined'
    ? navigator.userAgent.toLowerCase()
    : '';

/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */
const FIREFOX = ua.includes('firefox');

/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */
const SAFARI = ua.includes('safari') && !ua.includes('chrom');

/**
 * https://bugs.webkit.org/show_bug.cgi?id=237906
 * @type {boolean}
 */
const SAFARI_BUG_237906 =
  SAFARI &&
  (ua.includes('version/15.4') ||
    /cpu (os|iphone os) 15_4 like mac os x/.test(ua));

/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */
const WEBKIT = ua.includes('webkit') && !ua.includes('edge');

/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */
const MAC = ua.includes('macintosh');

/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */
const DEVICE_PIXEL_RATIO =
  typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;

/**
 * The execution context is a worker with OffscreenCanvas available.
 * @const
 * @type {boolean}
 */
const WORKER_OFFSCREEN_CANVAS =
  typeof WorkerGlobalScope !== 'undefined' &&
  typeof OffscreenCanvas !== 'undefined' &&
  self instanceof WorkerGlobalScope; //eslint-disable-line

/**
 * Image.prototype.decode() is supported.
 * @type {boolean}
 */
const IMAGE_DECODE =
  typeof Image !== 'undefined' && Image.prototype.decode;

/**
 * createImageBitmap() is supported.
 * @type {boolean}
 */
const CREATE_IMAGE_BITMAP = typeof createImageBitmap === 'function';

/**
 * @type {boolean}
 */
const PASSIVE_EVENT_LISTENERS = (function () {
  let passive = false;
  try {
    const options = Object.defineProperty({}, 'passive', {
      get: function () {
        passive = true;
      },
    });

    // @ts-ignore Ignore invalid event type '_'
    window.addEventListener('_', null, options);
    // @ts-ignore Ignore invalid event type '_'
    window.removeEventListener('_', null, options);
  } catch (error) {
    // passive not supported
  }
  return passive;
})();


/***/ }),

/***/ "./node_modules/ol/math.js":
/*!*********************************!*\
  !*** ./node_modules/ol/math.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   clamp: () => (/* binding */ clamp),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   lerp: () => (/* binding */ lerp),
/* harmony export */   modulo: () => (/* binding */ modulo),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   solveLinearSystem: () => (/* binding */ solveLinearSystem),
/* harmony export */   squaredDistance: () => (/* binding */ squaredDistance),
/* harmony export */   squaredSegmentDistance: () => (/* binding */ squaredSegmentDistance),
/* harmony export */   toDegrees: () => (/* binding */ toDegrees),
/* harmony export */   toFixed: () => (/* binding */ toFixed),
/* harmony export */   toRadians: () => (/* binding */ toRadians)
/* harmony export */ });
/**
 * @module ol/math
 */

/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return squaredDistance(x, y, x1, y1);
}

/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
function squaredDistance(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return dx * dx + dy * dy;
}

/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array<number>|null} The resulting vector.
 */
function solveLinearSystem(mat) {
  const n = mat.length;

  for (let i = 0; i < n; i++) {
    // Find max in the i-th column (ignoring i - 1 first rows)
    let maxRow = i;
    let maxEl = Math.abs(mat[i][i]);
    for (let r = i + 1; r < n; r++) {
      const absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }

    if (maxEl === 0) {
      return null; // matrix is singular
    }

    // Swap max row with i-th (current) row
    const tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;

    // Subtract the i-th row to make all the remaining rows 0 in the i-th column
    for (let j = i + 1; j < n; j++) {
      const coef = -mat[j][i] / mat[i][i];
      for (let k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }

  // Solve Ax=b for upper triangular matrix A (mat)
  const x = new Array(n);
  for (let l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (let m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
}

/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
function toDegrees(angleInRadians) {
  return (angleInRadians * 180) / Math.PI;
}

/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
function toRadians(angleInDegrees) {
  return (angleInDegrees * Math.PI) / 180;
}

/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */
function modulo(a, b) {
  const r = a % b;
  return r * b < 0 ? r + b : r;
}

/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */
function lerp(a, b, x) {
  return a + x * (b - a);
}

/**
 * Returns a number with a limited number of decimal digits.
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The input number with a limited number of decimal digits.
 */
function toFixed(n, decimals) {
  const factor = Math.pow(10, decimals);
  return Math.round(n * factor) / factor;
}

/**
 * Rounds a number to the nearest integer value considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The nearest integer.
 */
function round(n, decimals) {
  return Math.round(toFixed(n, decimals));
}

/**
 * Rounds a number to the next smaller integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next smaller integer.
 */
function floor(n, decimals) {
  return Math.floor(toFixed(n, decimals));
}

/**
 * Rounds a number to the next bigger integer considering only the given number
 * of decimal digits (with rounding on the final digit).
 * @param {number} n The input number.
 * @param {number} decimals The maximum number of decimal digits.
 * @return {number} The next bigger integer.
 */
function ceil(n, decimals) {
  return Math.ceil(toFixed(n, decimals));
}


/***/ }),

/***/ "./node_modules/ol/obj.js":
/*!********************************!*\
  !*** ./node_modules/ol/obj.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clear: () => (/* binding */ clear),
/* harmony export */   isEmpty: () => (/* binding */ isEmpty)
/* harmony export */ });
/**
 * @module ol/obj
 */

/**
 * Removes all properties from an object.
 * @param {Object<string, unknown>} object The object to clear.
 */
function clear(object) {
  for (const property in object) {
    delete object[property];
  }
}

/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */
function isEmpty(object) {
  let property;
  for (property in object) {
    return false;
  }
  return !property;
}


/***/ }),

/***/ "./node_modules/ol/proj.js":
/*!*********************************!*\
  !*** ./node_modules/ol/proj.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   METERS_PER_UNIT: () => (/* reexport safe */ _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT),
/* harmony export */   Projection: () => (/* reexport safe */ _proj_Projection_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   addCommon: () => (/* binding */ addCommon),
/* harmony export */   addCoordinateTransforms: () => (/* binding */ addCoordinateTransforms),
/* harmony export */   addEquivalentProjections: () => (/* binding */ addEquivalentProjections),
/* harmony export */   addEquivalentTransforms: () => (/* binding */ addEquivalentTransforms),
/* harmony export */   addProjection: () => (/* binding */ addProjection),
/* harmony export */   addProjections: () => (/* binding */ addProjections),
/* harmony export */   clearAllProjections: () => (/* binding */ clearAllProjections),
/* harmony export */   clearUserProjection: () => (/* binding */ clearUserProjection),
/* harmony export */   cloneTransform: () => (/* binding */ cloneTransform),
/* harmony export */   createProjection: () => (/* binding */ createProjection),
/* harmony export */   createSafeCoordinateTransform: () => (/* binding */ createSafeCoordinateTransform),
/* harmony export */   createTransformFromCoordinateTransform: () => (/* binding */ createTransformFromCoordinateTransform),
/* harmony export */   disableCoordinateWarning: () => (/* binding */ disableCoordinateWarning),
/* harmony export */   equivalent: () => (/* binding */ equivalent),
/* harmony export */   fromLonLat: () => (/* binding */ fromLonLat),
/* harmony export */   fromUserCoordinate: () => (/* binding */ fromUserCoordinate),
/* harmony export */   fromUserExtent: () => (/* binding */ fromUserExtent),
/* harmony export */   fromUserResolution: () => (/* binding */ fromUserResolution),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   getPointResolution: () => (/* binding */ getPointResolution),
/* harmony export */   getTransform: () => (/* binding */ getTransform),
/* harmony export */   getTransformFromProjections: () => (/* binding */ getTransformFromProjections),
/* harmony export */   getUserProjection: () => (/* binding */ getUserProjection),
/* harmony export */   identityTransform: () => (/* binding */ identityTransform),
/* harmony export */   setUserProjection: () => (/* binding */ setUserProjection),
/* harmony export */   toLonLat: () => (/* binding */ toLonLat),
/* harmony export */   toUserCoordinate: () => (/* binding */ toUserCoordinate),
/* harmony export */   toUserExtent: () => (/* binding */ toUserExtent),
/* harmony export */   toUserResolution: () => (/* binding */ toUserResolution),
/* harmony export */   transform: () => (/* binding */ transform),
/* harmony export */   transformExtent: () => (/* binding */ transformExtent),
/* harmony export */   transformWithProjections: () => (/* binding */ transformWithProjections),
/* harmony export */   useGeographic: () => (/* binding */ useGeographic)
/* harmony export */ });
/* harmony import */ var _proj_Projection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./proj/Projection.js */ "./node_modules/ol/proj/Projection.js");
/* harmony import */ var _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./proj/epsg3857.js */ "./node_modules/ol/proj/epsg3857.js");
/* harmony import */ var _proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./proj/epsg4326.js */ "./node_modules/ol/proj/epsg4326.js");
/* harmony import */ var _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./proj/Units.js */ "./node_modules/ol/proj/Units.js");
/* harmony import */ var _proj_projections_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./proj/projections.js */ "./node_modules/ol/proj/projections.js");
/* harmony import */ var _proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proj/transforms.js */ "./node_modules/ol/proj/transforms.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/* harmony import */ var _coordinate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coordinate.js */ "./node_modules/ol/coordinate.js");
/* harmony import */ var _sphere_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./sphere.js */ "./node_modules/ol/sphere.js");
/* harmony import */ var _console_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./console.js */ "./node_modules/ol/console.js");
/**
 * @module ol/proj
 */

/**
 * The ol/proj module stores:
 * * a list of {@link module:ol/proj/Projection~Projection}
 * objects, one for each projection supported by the application
 * * a list of transform functions needed to convert coordinates in one projection
 * into another.
 *
 * The static functions are the methods used to maintain these.
 * Each transform function can handle not only simple coordinate pairs, but also
 * large arrays of coordinates such as vector geometries.
 *
 * When loaded, the library adds projection objects for EPSG:4326 (WGS84
 * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used
 * for example by Bing Maps or OpenStreetMap), together with the relevant
 * transform functions.
 *
 * Additional transforms may be added by using the http://proj4js.org/
 * library (version 2.2 or later). You can use the full build supplied by
 * Proj4js, or create a custom build to support those projections you need; see
 * the Proj4js website for how to do this. You also need the Proj4js definitions
 * for the required projections. These definitions can be obtained from
 * https://epsg.io/, and are a JS function, so can be loaded in a script
 * tag (as in the examples) or pasted into your application.
 *
 * After all required projection definitions are added to proj4's registry (by
 * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`
 * package. Existing transforms are not changed by this function. See
 * examples/wms-image-custom-proj for an example of this.
 *
 * Additional projection definitions can be registered with `proj4.defs()` any
 * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't
 * know in advance what projections are needed, you can initially load minimal
 * support and then load whichever are requested.
 *
 * Note that Proj4js does not support projection extents. If you want to add
 * one for creating default tile grids, you can add it after the Projection
 * object has been created with `setExtent`, for example,
 * `get('EPSG:1234').setExtent(extent)`.
 *
 * In addition to Proj4js support, any transform functions can be added with
 * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create
 * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with
 * {@link module:ol/proj.addProjection}. You can then add the forward and inverse
 * functions with {@link module:ol/proj.addCoordinateTransforms}. See
 * examples/wms-custom-proj for an example of this.
 *
 * Note that if no transforms are needed and you only need to define the
 * projection, just add a {@link module:ol/proj/Projection~Projection} with
 * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of
 * this.
 */












/**
 * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier
 * string or undefined.
 * @typedef {Projection|string|undefined} ProjectionLike
 * @api
 */

/**
 * A transform function accepts an array of input coordinate values, an optional
 * output array, and an optional dimension (default should be 2).  The function
 * transforms the input coordinate values, populates the output array, and
 * returns the output array.
 *
 * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction
 * @api
 */





let showCoordinateWarning = true;

/**
 * @param {boolean} [disable = true] Disable console info about `useGeographic()`
 */
function disableCoordinateWarning(disable) {
  const hide = disable === undefined ? true : disable;
  showCoordinateWarning = !hide;
}

/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @return {Array<number>} Output coordinate array (new array, same coordinate
 *     values).
 */
function cloneTransform(input, output) {
  if (output !== undefined) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    output = output;
  } else {
    output = input.slice();
  }
  return output;
}

/**
 * @param {Array<number>} input Input coordinate array.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @return {Array<number>} Input coordinate array (same array as input).
 */
function identityTransform(input, output) {
  if (output !== undefined && input !== output) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    input = output;
  }
  return input;
}

/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {Projection} projection Projection instance.
 * @api
 */
function addProjection(projection) {
  (0,_proj_projections_js__WEBPACK_IMPORTED_MODULE_2__.add)(projection.getCode(), projection);
  (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(projection, projection, cloneTransform);
}

/**
 * @param {Array<Projection>} projections Projections.
 */
function addProjections(projections) {
  projections.forEach(addProjection);
}

/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {Projection|null} Projection object, or null if not in list.
 * @api
 */
function get(projectionLike) {
  return typeof projectionLike === 'string'
    ? (0,_proj_projections_js__WEBPACK_IMPORTED_MODULE_2__.get)(/** @type {string} */ (projectionLike))
    : /** @type {Projection} */ (projectionLike) || null;
}

/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the `point` pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link module:ol/proj/Projection~Projection} constructor or by using
 * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
 * @param {import("./proj/Units.js").Units} [units] Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */
function getPointResolution(projection, resolution, point, units) {
  projection = get(projection);
  let pointResolution;
  const getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
    if (units && units !== projection.getUnits()) {
      const metersPerUnit = projection.getMetersPerUnit();
      if (metersPerUnit) {
        pointResolution =
          (pointResolution * metersPerUnit) / _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[units];
      }
    }
  } else {
    const projUnits = projection.getUnits();
    if ((projUnits == 'degrees' && !units) || units == 'degrees') {
      pointResolution = resolution;
    } else {
      // Estimate point resolution by transforming the center pixel to EPSG:4326,
      // measuring its width and height on the normal sphere, and taking the
      // average of the width and height.
      const toEPSG4326 = getTransformFromProjections(
        projection,
        get('EPSG:4326')
      );
      if (toEPSG4326 === identityTransform && projUnits !== 'degrees') {
        // no transform is available
        pointResolution = resolution * projection.getMetersPerUnit();
      } else {
        let vertices = [
          point[0] - resolution / 2,
          point[1],
          point[0] + resolution / 2,
          point[1],
          point[0],
          point[1] - resolution / 2,
          point[0],
          point[1] + resolution / 2,
        ];
        vertices = toEPSG4326(vertices, vertices, 2);
        const width = (0,_sphere_js__WEBPACK_IMPORTED_MODULE_4__.getDistance)(vertices.slice(0, 2), vertices.slice(2, 4));
        const height = (0,_sphere_js__WEBPACK_IMPORTED_MODULE_4__.getDistance)(vertices.slice(4, 6), vertices.slice(6, 8));
        pointResolution = (width + height) / 2;
      }
      const metersPerUnit = units
        ? _proj_Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[units]
        : projection.getMetersPerUnit();
      if (metersPerUnit !== undefined) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}

/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array<Projection>} projections Projections.
 * @api
 */
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function (source) {
    projections.forEach(function (destination) {
      if (source !== destination) {
        (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(source, destination, cloneTransform);
      }
    });
  });
}

/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array<Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array<Projection>} projections2 Projections with equal
 *     meaning.
 * @param {TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */
function addEquivalentTransforms(
  projections1,
  projections2,
  forwardTransform,
  inverseTransform
) {
  projections1.forEach(function (projection1) {
    projections2.forEach(function (projection2) {
      (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(projection1, projection2, forwardTransform);
      (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(projection2, projection1, inverseTransform);
    });
  });
}

/**
 * Clear all cached projections and transforms.
 */
function clearAllProjections() {
  (0,_proj_projections_js__WEBPACK_IMPORTED_MODULE_2__.clear)();
  (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.clear)();
}

/**
 * @param {Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {Projection} Projection.
 */
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get(defaultCode);
  }
  if (typeof projection === 'string') {
    return get(projection);
  }
  return /** @type {Projection} */ (projection);
}

/**
 * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
 *     transform.
 * @return {TransformFunction} Transform function.
 */
function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimension.
     * @return {Array<number>} Output.
     */
    function (input, output, dimension) {
      const length = input.length;
      dimension = dimension !== undefined ? dimension : 2;
      output = output !== undefined ? output : new Array(length);
      for (let i = 0; i < length; i += dimension) {
        const point = coordTransform(input.slice(i, i + dimension));
        const pointLength = point.length;
        for (let j = 0, jj = dimension; j < jj; ++j) {
          output[i + j] = j >= pointLength ? input[i + j] : point[j];
        }
      }
      return output;
    }
  );
}

/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ProjectionLike} source Source projection.
 * @param {ProjectionLike} destination Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
 *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only
 *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate
 *     with only the length it can transform. The other dimensions will be taken unchanged from the
 *     source.
 * @api
 */
function addCoordinateTransforms(source, destination, forward, inverse) {
  const sourceProj = get(source);
  const destProj = get(destination);
  (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(
    sourceProj,
    destProj,
    createTransformFromCoordinateTransform(forward)
  );
  (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.add)(
    destProj,
    sourceProj,
    createTransformFromCoordinateTransform(inverse)
  );
}

/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ProjectionLike} [projection] Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate projected to the target projection.
 * @api
 */
function fromLonLat(coordinate, projection) {
  disableCoordinateWarning();
  return transform(
    coordinate,
    'EPSG:4326',
    projection !== undefined ? projection : 'EPSG:3857'
  );
}

/**
 * Transforms a coordinate to longitude/latitude.
 * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
 * @param {ProjectionLike} [projection] Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */
function toLonLat(coordinate, projection) {
  const lonLat = transform(
    coordinate,
    projection !== undefined ? projection : 'EPSG:3857',
    'EPSG:4326'
  );
  const lon = lonLat[0];
  if (lon < -180 || lon > 180) {
    lonLat[0] = (0,_math_js__WEBPACK_IMPORTED_MODULE_5__.modulo)(lon + 180, 360) - 180;
  }
  return lonLat;
}

/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {Projection} projection1 Projection 1.
 * @param {Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  const equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  }
  const transformFunc = getTransformFromProjections(projection1, projection2);
  return transformFunc === cloneTransform && equalUnits;
}

/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {Projection} sourceProjection Source Projection object.
 * @param {Projection} destinationProjection Destination Projection
 *     object.
 * @return {TransformFunction} Transform function.
 */
function getTransformFromProjections(
  sourceProjection,
  destinationProjection
) {
  const sourceCode = sourceProjection.getCode();
  const destinationCode = destinationProjection.getCode();
  let transformFunc = (0,_proj_transforms_js__WEBPACK_IMPORTED_MODULE_3__.get)(sourceCode, destinationCode);
  if (!transformFunc) {
    transformFunc = identityTransform;
  }
  return transformFunc;
}

/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ProjectionLike} source Source.
 * @param {ProjectionLike} destination Destination.
 * @return {TransformFunction} Transform function.
 * @api
 */
function getTransform(source, destination) {
  const sourceProjection = get(source);
  const destinationProjection = get(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}

/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link module:ol/proj.transformExtent} for extent transformation.
 * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
 * subclasses for geometry transforms.
 *
 * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @return {import("./coordinate.js").Coordinate} Coordinate.
 * @api
 */
function transform(coordinate, source, destination) {
  const transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, undefined, coordinate.length);
}

/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {import("./extent.js").Extent} extent The extent to transform.
 * @param {ProjectionLike} source Source projection-like.
 * @param {ProjectionLike} destination Destination projection-like.
 * @param {number} [stops] Number of stops per side used for the transform.
 * By default only the corners are used.
 * @return {import("./extent.js").Extent} The transformed extent.
 * @api
 */
function transformExtent(extent, source, destination, stops) {
  const transformFunc = getTransform(source, destination);
  return (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.applyTransform)(extent, transformFunc, undefined, stops);
}

/**
 * Transforms the given point to the destination projection.
 *
 * @param {import("./coordinate.js").Coordinate} point Point.
 * @param {Projection} sourceProjection Source projection.
 * @param {Projection} destinationProjection Destination projection.
 * @return {import("./coordinate.js").Coordinate} Point.
 */
function transformWithProjections(
  point,
  sourceProjection,
  destinationProjection
) {
  const transformFunc = getTransformFromProjections(
    sourceProjection,
    destinationProjection
  );
  return transformFunc(point);
}

/**
 * @type {Projection|null}
 */
let userProjection = null;

/**
 * Set the projection for coordinates supplied from and returned by API methods.
 * This includes all API methods except for those interacting with tile grids,
 * plus {@link import("./Map.js").FrameState} and {@link import("./View.js").State}.
 * @param {ProjectionLike} projection The user projection.
 * @api
 */
function setUserProjection(projection) {
  userProjection = get(projection);
}

/**
 * Clear the user projection if set.
 * @api
 */
function clearUserProjection() {
  userProjection = null;
}

/**
 * Get the projection for coordinates supplied from and returned by API methods.
 * @return {Projection|null} The user projection (or null if not set).
 * @api
 */
function getUserProjection() {
  return userProjection;
}

/**
 * Use geographic coordinates (WGS-84 datum) in API methods.
 * This includes all API methods except for those interacting with tile grids,
 * plus {@link import("./Map.js").FrameState} and {@link import("./View.js").State}.
 * @api
 */
function useGeographic() {
  setUserProjection('EPSG:4326');
}

/**
 * Return a coordinate transformed into the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} sourceProjection The input coordinate projection.
 * @return {Array<number>} The input coordinate in the user projection.
 */
function toUserCoordinate(coordinate, sourceProjection) {
  if (!userProjection) {
    return coordinate;
  }
  return transform(coordinate, sourceProjection, userProjection);
}

/**
 * Return a coordinate transformed from the user projection.  If no user projection
 * is set, the original coordinate is returned.
 * @param {Array<number>} coordinate Input coordinate.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {Array<number>} The input coordinate transformed.
 */
function fromUserCoordinate(coordinate, destProjection) {
  if (!userProjection) {
    if (
      showCoordinateWarning &&
      !(0,_coordinate_js__WEBPACK_IMPORTED_MODULE_7__.equals)(coordinate, [0, 0]) &&
      coordinate[0] >= -180 &&
      coordinate[0] <= 180 &&
      coordinate[1] >= -90 &&
      coordinate[1] <= 90
    ) {
      showCoordinateWarning = false;
      (0,_console_js__WEBPACK_IMPORTED_MODULE_8__.warn)(
        'Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.'
      );
    }
    return coordinate;
  }
  return transform(coordinate, userProjection, destProjection);
}

/**
 * Return an extent transformed into the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} sourceProjection The input extent projection.
 * @return {import("./extent.js").Extent} The input extent in the user projection.
 */
function toUserExtent(extent, sourceProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, sourceProjection, userProjection);
}

/**
 * Return an extent transformed from the user projection.  If no user projection
 * is set, the original extent is returned.
 * @param {import("./extent.js").Extent} extent Input extent.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {import("./extent.js").Extent} The input extent transformed.
 */
function fromUserExtent(extent, destProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, userProjection, destProjection);
}

/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in input projection units per pixel.
 * @param {ProjectionLike} sourceProjection The input projection.
 * @return {number} Resolution in user projection units per pixel.
 */
function toUserResolution(resolution, sourceProjection) {
  if (!userProjection) {
    return resolution;
  }
  const sourceMetersPerUnit = get(sourceProjection).getMetersPerUnit();
  const userMetersPerUnit = userProjection.getMetersPerUnit();
  return sourceMetersPerUnit && userMetersPerUnit
    ? (resolution * sourceMetersPerUnit) / userMetersPerUnit
    : resolution;
}

/**
 * Return the resolution in user projection units per pixel. If no user projection
 * is set, or source or user projection are missing units, the original resolution
 * is returned.
 * @param {number} resolution Resolution in user projection units per pixel.
 * @param {ProjectionLike} destProjection The destination projection.
 * @return {number} Resolution in destination projection units per pixel.
 */
function fromUserResolution(resolution, destProjection) {
  if (!userProjection) {
    return resolution;
  }
  const destMetersPerUnit = get(destProjection).getMetersPerUnit();
  const userMetersPerUnit = userProjection.getMetersPerUnit();
  return destMetersPerUnit && userMetersPerUnit
    ? (resolution * userMetersPerUnit) / destMetersPerUnit
    : resolution;
}

/**
 * Creates a safe coordinate transform function from a coordinate transform function.
 * "Safe" means that it can handle wrapping of x-coordinates for global projections,
 * and that coordinates exceeding the source projection validity extent's range will be
 * clamped to the validity range.
 * @param {Projection} sourceProj Source projection.
 * @param {Projection} destProj Destination projection.
 * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} transform Transform function (source to destination).
 * @return {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} Safe transform function (source to destination).
 */
function createSafeCoordinateTransform(sourceProj, destProj, transform) {
  return function (coord) {
    let transformed, worldsAway;
    if (sourceProj.canWrapX()) {
      const sourceExtent = sourceProj.getExtent();
      const sourceExtentWidth = (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.getWidth)(sourceExtent);
      coord = coord.slice(0);
      worldsAway = (0,_coordinate_js__WEBPACK_IMPORTED_MODULE_7__.getWorldsAway)(coord, sourceProj, sourceExtentWidth);
      if (worldsAway) {
        // Move x to the real world
        coord[0] = coord[0] - worldsAway * sourceExtentWidth;
      }
      coord[0] = (0,_math_js__WEBPACK_IMPORTED_MODULE_5__.clamp)(coord[0], sourceExtent[0], sourceExtent[2]);
      coord[1] = (0,_math_js__WEBPACK_IMPORTED_MODULE_5__.clamp)(coord[1], sourceExtent[1], sourceExtent[3]);
      transformed = transform(coord);
    } else {
      transformed = transform(coord);
    }
    if (worldsAway && destProj.canWrapX()) {
      // Move transformed coordinate back to the offset world
      transformed[0] += worldsAway * (0,_extent_js__WEBPACK_IMPORTED_MODULE_6__.getWidth)(destProj.getExtent());
    }
    return transformed;
  };
}

/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `clearAllProjections()` is called (e.g. in tests).
 */
function addCommon() {
  // Add transformations that don't alter coordinates to convert within set of
  // projections with equal meaning.
  addEquivalentProjections(_proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_9__.PROJECTIONS);
  addEquivalentProjections(_proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_10__.PROJECTIONS);
  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
  // coordinates and back.
  addEquivalentTransforms(
    _proj_epsg4326_js__WEBPACK_IMPORTED_MODULE_10__.PROJECTIONS,
    _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_9__.PROJECTIONS,
    _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_9__.fromEPSG4326,
    _proj_epsg3857_js__WEBPACK_IMPORTED_MODULE_9__.toEPSG4326
  );
}

addCommon();


/***/ }),

/***/ "./node_modules/ol/proj/Projection.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/Projection.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Units_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Units.js */ "./node_modules/ol/proj/Units.js");
/**
 * @module ol/proj/Projection
 */


/**
 * @typedef {Object} Options
 * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
 * @property {import("./Units.js").Units} [units] Units. Required unless a
 * proj4 projection is defined for `code`.
 * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
 * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
 * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
 * @property {number} [metersPerUnit] The meters per unit for the SRS.
 * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}
 * lookup table.
 * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
 * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
 * Function to determine resolution at a point. The function is called with a
 * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns
 * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,
 * the default {@link module:ol/proj.getPointResolution} function will be used.
 */

/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link module:ol/proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link module:ol/proj.get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
 * be added using `proj4.defs()`. After all required projection definitions are
 * added, call the {@link module:ol/proj/proj4.register} function.
 *
 * @api
 */
class Projection {
  /**
   * @param {Options} options Projection options.
   */
  constructor(options) {
    /**
     * @private
     * @type {string}
     */
    this.code_ = options.code;

    /**
     * Units of projected coordinates. When set to `TILE_PIXELS`, a
     * `this.extent_` and `this.worldExtent_` must be configured properly for each
     * tile.
     * @private
     * @type {import("./Units.js").Units}
     */
    this.units_ = /** @type {import("./Units.js").Units} */ (options.units);

    /**
     * Validity extent of the projection in projected coordinates. For projections
     * with `TILE_PIXELS` units, this is the extent of the tile in
     * tile pixel space.
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.extent_ = options.extent !== undefined ? options.extent : null;

    /**
     * Extent of the world in EPSG:4326. For projections with
     * `TILE_PIXELS` units, this is the extent of the tile in
     * projected coordinate space.
     * @private
     * @type {import("../extent.js").Extent}
     */
    this.worldExtent_ =
      options.worldExtent !== undefined ? options.worldExtent : null;

    /**
     * @private
     * @type {string}
     */
    this.axisOrientation_ =
      options.axisOrientation !== undefined ? options.axisOrientation : 'enu';

    /**
     * @private
     * @type {boolean}
     */
    this.global_ = options.global !== undefined ? options.global : false;

    /**
     * @private
     * @type {boolean}
     */
    this.canWrapX_ = !!(this.global_ && this.extent_);

    /**
     * @private
     * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
     */
    this.getPointResolutionFunc_ = options.getPointResolution;

    /**
     * @private
     * @type {import("../tilegrid/TileGrid.js").default}
     */
    this.defaultTileGrid_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.metersPerUnit_ = options.metersPerUnit;
  }

  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }

  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }

  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }

  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }

  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || _Units_js__WEBPACK_IMPORTED_MODULE_0__.METERS_PER_UNIT[this.units_];
  }

  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }

  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }

  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }

  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(global) {
    this.global_ = global;
    this.canWrapX_ = !!(global && this.extent_);
  }

  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }

  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(tileGrid) {
    this.defaultTileGrid_ = tileGrid;
  }

  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(extent) {
    this.extent_ = extent;
    this.canWrapX_ = !!(this.global_ && extent);
  }

  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(worldExtent) {
    this.worldExtent_ = worldExtent;
  }

  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(func) {
    this.getPointResolutionFunc_ = func;
  }

  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Projection);


/***/ }),

/***/ "./node_modules/ol/proj/Units.js":
/*!***************************************!*\
  !*** ./node_modules/ol/proj/Units.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   METERS_PER_UNIT: () => (/* binding */ METERS_PER_UNIT),
/* harmony export */   fromCode: () => (/* binding */ fromCode)
/* harmony export */ });
/**
 * @module ol/proj/Units
 */

/**
 * @typedef {'radians' | 'degrees' | 'ft' | 'm' | 'pixels' | 'tile-pixels' | 'us-ft'} Units
 * Projection units.
 */

/**
 * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt
 * @type {Object<number, Units>}
 */
const unitByCode = {
  '9001': 'm',
  '9002': 'ft',
  '9003': 'us-ft',
  '9101': 'radians',
  '9102': 'degrees',
};

/**
 * @param {number} code Unit code.
 * @return {Units} Units.
 */
function fromCode(code) {
  return unitByCode[code];
}

/**
 * @typedef {Object} MetersPerUnitLookup
 * @property {number} radians Radians
 * @property {number} degrees Degrees
 * @property {number} ft  Feet
 * @property {number} m Meters
 * @property {number} us-ft US feet
 */

/**
 * Meters per unit lookup table.
 * @const
 * @type {MetersPerUnitLookup}
 * @api
 */
const METERS_PER_UNIT = {
  // use the radius of the Normal sphere
  'radians': 6370997 / (2 * Math.PI),
  'degrees': (2 * Math.PI * 6370997) / 360,
  'ft': 0.3048,
  'm': 1,
  'us-ft': 1200 / 3937,
};


/***/ }),

/***/ "./node_modules/ol/proj/epsg3857.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg3857.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EXTENT: () => (/* binding */ EXTENT),
/* harmony export */   HALF_SIZE: () => (/* binding */ HALF_SIZE),
/* harmony export */   MAX_SAFE_Y: () => (/* binding */ MAX_SAFE_Y),
/* harmony export */   PROJECTIONS: () => (/* binding */ PROJECTIONS),
/* harmony export */   RADIUS: () => (/* binding */ RADIUS),
/* harmony export */   WORLD_EXTENT: () => (/* binding */ WORLD_EXTENT),
/* harmony export */   fromEPSG4326: () => (/* binding */ fromEPSG4326),
/* harmony export */   toEPSG4326: () => (/* binding */ toEPSG4326)
/* harmony export */ });
/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Projection.js */ "./node_modules/ol/proj/Projection.js");
/**
 * @module ol/proj/epsg3857
 */


/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */
const RADIUS = 6378137;

/**
 * @const
 * @type {number}
 */
const HALF_SIZE = Math.PI * RADIUS;

/**
 * @const
 * @type {import("../extent.js").Extent}
 */
const EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];

/**
 * @const
 * @type {import("../extent.js").Extent}
 */
const WORLD_EXTENT = [-180, -85, 180, 85];

/**
 * Maximum safe value in y direction
 * @const
 * @type {number}
 */
const MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));

/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 */
class EPSG3857Projection extends _Projection_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {string} code Code.
   */
  constructor(code) {
    super({
      code: code,
      units: 'm',
      extent: EXTENT,
      global: true,
      worldExtent: WORLD_EXTENT,
      getPointResolution: function (resolution, point) {
        return resolution / Math.cosh(point[1] / RADIUS);
      },
    });
  }
}

/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
const PROJECTIONS = [
  new EPSG3857Projection('EPSG:3857'),
  new EPSG3857Projection('EPSG:102100'),
  new EPSG3857Projection('EPSG:102113'),
  new EPSG3857Projection('EPSG:900913'),
  new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'),
  new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857'),
];

/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */
function fromEPSG4326(input, output, dimension) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += dimension) {
    output[i] = (HALF_SIZE * input[i]) / 180;
    let y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));
    if (y > MAX_SAFE_Y) {
      y = MAX_SAFE_Y;
    } else if (y < -MAX_SAFE_Y) {
      y = -MAX_SAFE_Y;
    }
    output[i + 1] = y;
  }
  return output;
}

/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array<number>} input Input array of coordinate values.
 * @param {Array<number>} [output] Output array of coordinate values.
 * @param {number} [dimension] Dimension (default is `2`).
 * @return {Array<number>} Output array of coordinate values.
 */
function toEPSG4326(input, output, dimension) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += dimension) {
    output[i] = (180 * input[i]) / HALF_SIZE;
    output[i + 1] =
      (360 * Math.atan(Math.exp(input[i + 1] / RADIUS))) / Math.PI - 90;
  }
  return output;
}


/***/ }),

/***/ "./node_modules/ol/proj/epsg4326.js":
/*!******************************************!*\
  !*** ./node_modules/ol/proj/epsg4326.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EXTENT: () => (/* binding */ EXTENT),
/* harmony export */   METERS_PER_UNIT: () => (/* binding */ METERS_PER_UNIT),
/* harmony export */   PROJECTIONS: () => (/* binding */ PROJECTIONS),
/* harmony export */   RADIUS: () => (/* binding */ RADIUS)
/* harmony export */ });
/* harmony import */ var _Projection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Projection.js */ "./node_modules/ol/proj/Projection.js");
/**
 * @module ol/proj/epsg4326
 */


/**
 * Semi-major radius of the WGS84 ellipsoid.
 *
 * @const
 * @type {number}
 */
const RADIUS = 6378137;

/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {import("../extent.js").Extent}
 */
const EXTENT = [-180, -90, 180, 90];

/**
 * @const
 * @type {number}
 */
const METERS_PER_UNIT = (Math.PI * RADIUS) / 180;

/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 */
class EPSG4326Projection extends _Projection_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(code, axisOrientation) {
    super({
      code: code,
      units: 'degrees',
      extent: EXTENT,
      axisOrientation: axisOrientation,
      global: true,
      metersPerUnit: METERS_PER_UNIT,
      worldExtent: EXTENT,
    });
  }
}

/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array<import("./Projection.js").default>}
 */
const PROJECTIONS = [
  new EPSG4326Projection('CRS:84'),
  new EPSG4326Projection('EPSG:4326', 'neu'),
  new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),
  new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),
  new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'),
  new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
  new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu'),
];


/***/ }),

/***/ "./node_modules/ol/proj/projections.js":
/*!*********************************************!*\
  !*** ./node_modules/ol/proj/projections.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   clear: () => (/* binding */ clear),
/* harmony export */   get: () => (/* binding */ get)
/* harmony export */ });
/**
 * @module ol/proj/projections
 */

/**
 * @type {Object<string, import("./Projection.js").default>}
 */
let cache = {};

/**
 * Clear the projections cache.
 */
function clear() {
  cache = {};
}

/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {import("./Projection.js").default} The projection (if cached).
 */
function get(code) {
  return (
    cache[code] ||
    cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, 'EPSG:$3')] ||
    null
  );
}

/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {import("./Projection.js").default} projection The projection to cache.
 */
function add(code, projection) {
  cache[code] = projection;
}


/***/ }),

/***/ "./node_modules/ol/proj/transforms.js":
/*!********************************************!*\
  !*** ./node_modules/ol/proj/transforms.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   clear: () => (/* binding */ clear),
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   remove: () => (/* binding */ remove)
/* harmony export */ });
/* harmony import */ var _obj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../obj.js */ "./node_modules/ol/obj.js");
/**
 * @module ol/proj/transforms
 */


/**
 * @private
 * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
 */
let transforms = {};

/**
 * Clear the transform cache.
 */
function clear() {
  transforms = {};
}

/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {import("./Projection.js").default} source Source.
 * @param {import("./Projection.js").default} destination Destination.
 * @param {import("../proj.js").TransformFunction} transformFn Transform.
 */
function add(source, destination, transformFn) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}

/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {import("./Projection.js").default} source Source projection.
 * @param {import("./Projection.js").default} destination Destination projection.
 * @return {import("../proj.js").TransformFunction} transformFn The unregistered transform.
 */
function remove(source, destination) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  const transform = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];
  if ((0,_obj_js__WEBPACK_IMPORTED_MODULE_0__.isEmpty)(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }
  return transform;
}

/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
 */
function get(sourceCode, destinationCode) {
  let transform;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform = transforms[sourceCode][destinationCode];
  }
  return transform;
}


/***/ }),

/***/ "./node_modules/ol/render/Feature.js":
/*!*******************************************!*\
  !*** ./node_modules/ol/render/Feature.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   toFeature: () => (/* binding */ toFeature),
/* harmony export */   toGeometry: () => (/* binding */ toGeometry)
/* harmony export */ });
/* harmony import */ var _Feature_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../Feature.js */ "./node_modules/ol/Feature.js");
/* harmony import */ var _geom_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../geom.js */ "./node_modules/ol/geom/Point.js");
/* harmony import */ var _geom_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geom.js */ "./node_modules/ol/geom/MultiPoint.js");
/* harmony import */ var _geom_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../geom.js */ "./node_modules/ol/geom/LineString.js");
/* harmony import */ var _geom_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../geom.js */ "./node_modules/ol/geom/MultiLineString.js");
/* harmony import */ var _geom_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../geom.js */ "./node_modules/ol/geom/MultiPolygon.js");
/* harmony import */ var _geom_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../geom.js */ "./node_modules/ol/geom/Polygon.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transform.js */ "./node_modules/ol/transform.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../extent.js */ "./node_modules/ol/extent.js");
/* harmony import */ var _geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../geom/flat/simplify.js */ "./node_modules/ol/geom/flat/simplify.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../array.js */ "./node_modules/ol/array.js");
/* harmony import */ var _geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geom/flat/interiorpoint.js */ "./node_modules/ol/geom/flat/interiorpoint.js");
/* harmony import */ var _proj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../proj.js */ "./node_modules/ol/proj.js");
/* harmony import */ var _geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geom/flat/orient.js */ "./node_modules/ol/geom/flat/orient.js");
/* harmony import */ var _geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geom/flat/interpolate.js */ "./node_modules/ol/geom/flat/interpolate.js");
/* harmony import */ var _geom_flat_center_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geom/flat/center.js */ "./node_modules/ol/geom/flat/center.js");
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../functions.js */ "./node_modules/ol/functions.js");
/* harmony import */ var _geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../geom/flat/transform.js */ "./node_modules/ol/geom/flat/transform.js");
/**
 * @module ol/render/Feature
 */














/**
 * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString'} Type
 * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'` or 'MultiLineString'`.
 */

/**
 * @type {import("../transform.js").Transform}
 */
const tmpTransform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.create)();

/**
 * Lightweight, read-only, {@link module:ol/Feature~Feature} and {@link module:ol/geom/Geometry~Geometry} like
 * structure, optimized for vector tile rendering and styling. Geometry access
 * through the API is limited to getting the type and extent of the geometry.
 */
class RenderFeature {
  /**
   * @param {Type} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */
  constructor(type, flatCoordinates, ends, stride, properties, id) {
    /**
     * @type {import("../style/Style.js").StyleFunction|undefined}
     */
    this.styleFunction;

    /**
     * @private
     * @type {import("../extent.js").Extent|undefined}
     */
    this.extent_;

    /**
     * @private
     * @type {number|string|undefined}
     */
    this.id_ = id;

    /**
     * @private
     * @type {Type}
     */
    this.type_ = type;

    /**
     * @private
     * @type {Array<number>}
     */
    this.flatCoordinates_ = flatCoordinates;

    /**
     * @private
     * @type {Array<number>}
     */
    this.flatInteriorPoints_ = null;

    /**
     * @private
     * @type {Array<number>}
     */
    this.flatMidpoints_ = null;

    /**
     * @private
     * @type {Array<number>}
     */
    this.ends_ = ends;

    /**
     * @private
     * @type {Object<string, *>}
     */
    this.properties_ = properties;

    /**
     * @type {number}
     */
    this.squaredTolerance_;

    /**
     * @type {number}
     */
    this.stride_ = stride;

    /**
     * @private
     * @type {RenderFeature}
     */
    this.simplifiedGeometry_;
  }

  /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */
  get(key) {
    return this.properties_[key];
  }

  /**
   * Get the extent of this feature's geometry.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    if (!this.extent_) {
      this.extent_ =
        this.type_ === 'Point'
          ? (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createOrUpdateFromCoordinate)(this.flatCoordinates_)
          : (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.createOrUpdateFromFlatCoordinates)(
              this.flatCoordinates_,
              0,
              this.flatCoordinates_.length,
              2
            );
    }
    return this.extent_;
  }

  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoint() {
    if (!this.flatInteriorPoints_) {
      const flatCenter = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getCenter)(this.getExtent());
      this.flatInteriorPoints_ = (0,_geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_3__.getInteriorPointOfArray)(
        this.flatCoordinates_,
        0,
        /** @type {Array<number>} */ (this.ends_),
        2,
        flatCenter,
        0
      );
    }
    return this.flatInteriorPoints_;
  }

  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (!this.flatInteriorPoints_) {
      const ends = (0,_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_4__.inflateEnds)(this.flatCoordinates_, this.ends_);
      const flatCenters = (0,_geom_flat_center_js__WEBPACK_IMPORTED_MODULE_5__.linearRingss)(this.flatCoordinates_, 0, ends, 2);
      this.flatInteriorPoints_ = (0,_geom_flat_interiorpoint_js__WEBPACK_IMPORTED_MODULE_3__.getInteriorPointsOfMultiArray)(
        this.flatCoordinates_,
        0,
        ends,
        2,
        flatCenters
      );
    }
    return this.flatInteriorPoints_;
  }

  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = (0,_geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_6__.interpolatePoint)(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        0.5
      );
    }
    return this.flatMidpoints_;
  }

  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      const flatCoordinates = this.flatCoordinates_;
      let offset = 0;
      const ends = /** @type {Array<number>} */ (this.ends_);
      for (let i = 0, ii = ends.length; i < ii; ++i) {
        const end = ends[i];
        const midpoint = (0,_geom_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_6__.interpolatePoint)(flatCoordinates, offset, end, 2, 0.5);
        (0,_array_js__WEBPACK_IMPORTED_MODULE_7__.extend)(this.flatMidpoints_, midpoint);
        offset = end;
      }
    }
    return this.flatMidpoints_;
  }

  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is set when reading data from a remote source.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }

  /**
   * @return {Array<number>} Flat coordinates.
   */
  getOrientedFlatCoordinates() {
    return this.flatCoordinates_;
  }

  /**
   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
   * determining the geometry type in style function (see {@link #getType}).
   * @return {RenderFeature} Feature.
   * @api
   */
  getGeometry() {
    return this;
  }

  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {RenderFeature} Simplified geometry.
   */
  getSimplifiedGeometry(squaredTolerance) {
    return this;
  }

  /**
   * Get a transformed and simplified version of the geometry.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {RenderFeature} Simplified geometry.
   */
  simplifyTransformed(squaredTolerance, transform) {
    return this;
  }

  /**
   * Get the feature properties.
   * @return {Object<string, *>} Feature properties.
   * @api
   */
  getProperties() {
    return this.properties_;
  }

  /**
   * Get an object of all property names and values.  This has the same behavior as getProperties,
   * but is here to conform with the {@link module:ol/Feature~Feature} interface.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.properties_;
  }

  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride_;
  }

  /**
   * @return {import('../style/Style.js').StyleFunction|undefined} Style
   */
  getStyleFunction() {
    return this.styleFunction;
  }

  /**
   * Get the type of this feature's geometry.
   * @return {Type} Geometry type.
   * @api
   */
  getType() {
    return this.type_;
  }

  /**
   * Transform geometry coordinates from tile pixel space to projected.
   *
   * @param {import("../proj.js").ProjectionLike} projection The data projection
   */
  transform(projection) {
    projection = (0,_proj_js__WEBPACK_IMPORTED_MODULE_0__.get)(projection);
    const pixelExtent = projection.getExtent();
    const projectedExtent = projection.getWorldExtent();
    if (pixelExtent && projectedExtent) {
      const scale = (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getHeight)(projectedExtent) / (0,_extent_js__WEBPACK_IMPORTED_MODULE_2__.getHeight)(pixelExtent);
      (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.compose)(
        tmpTransform,
        projectedExtent[0],
        projectedExtent[3],
        scale,
        -scale,
        0,
        0,
        0
      );
      (0,_geom_flat_transform_js__WEBPACK_IMPORTED_MODULE_8__.transform2D)(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        tmpTransform,
        this.flatCoordinates_
      );
    }
  }

  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   */
  applyTransform(transformFn) {
    transformFn(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
  }

  /**
   * @return {RenderFeature} A cloned render feature.
   */
  clone() {
    return new RenderFeature(
      this.type_,
      this.flatCoordinates_.slice(),
      this.ends_.slice(),
      this.stride_,
      Object.assign({}, this.properties_),
      this.id_
    );
  }

  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }

  /**
   * Add transform and resolution based geometry simplification to this instance.
   * @return {RenderFeature} This render feature.
   */
  enableSimplifyTransformed() {
    this.simplifyTransformed = (0,_functions_js__WEBPACK_IMPORTED_MODULE_9__.memoizeOne)((squaredTolerance, transform) => {
      if (squaredTolerance === this.squaredTolerance_) {
        return this.simplifiedGeometry_;
      }
      this.simplifiedGeometry_ = this.clone();
      if (transform) {
        this.simplifiedGeometry_.applyTransform(transform);
      }
      const simplifiedFlatCoordinates =
        this.simplifiedGeometry_.getFlatCoordinates();
      let simplifiedEnds;
      switch (this.type_) {
        case 'LineString':
          simplifiedFlatCoordinates.length = (0,_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_10__.douglasPeucker)(
            simplifiedFlatCoordinates,
            0,
            this.simplifiedGeometry_.flatCoordinates_.length,
            this.simplifiedGeometry_.stride_,
            squaredTolerance,
            simplifiedFlatCoordinates,
            0
          );
          simplifiedEnds = [simplifiedFlatCoordinates.length];
          break;
        case 'MultiLineString':
          simplifiedEnds = [];
          simplifiedFlatCoordinates.length = (0,_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_10__.douglasPeuckerArray)(
            simplifiedFlatCoordinates,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            squaredTolerance,
            simplifiedFlatCoordinates,
            0,
            simplifiedEnds
          );
          break;
        case 'Polygon':
          simplifiedEnds = [];
          simplifiedFlatCoordinates.length = (0,_geom_flat_simplify_js__WEBPACK_IMPORTED_MODULE_10__.quantizeArray)(
            simplifiedFlatCoordinates,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            Math.sqrt(squaredTolerance),
            simplifiedFlatCoordinates,
            0,
            simplifiedEnds
          );
          break;
        default:
      }
      if (simplifiedEnds) {
        this.simplifiedGeometry_ = new RenderFeature(
          this.type_,
          simplifiedFlatCoordinates,
          simplifiedEnds,
          2,
          this.properties_,
          this.id_
        );
      }
      this.squaredTolerance_ = squaredTolerance;
      return this.simplifiedGeometry_;
    });
    return this;
  }
}

/**
 * @return {Array<number>} Flat coordinates.
 */
RenderFeature.prototype.getFlatCoordinates =
  RenderFeature.prototype.getOrientedFlatCoordinates;

/**
 * Create a geometry from an `ol/render/Feature`
 * @param {RenderFeature} renderFeature
 * Render Feature
 * @return {Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon}
 * New geometry instance.
 * @api
 */
function toGeometry(renderFeature) {
  const geometryType = renderFeature.getType();
  switch (geometryType) {
    case 'Point':
      return new _geom_js__WEBPACK_IMPORTED_MODULE_11__["default"](renderFeature.getFlatCoordinates());
    case 'MultiPoint':
      return new _geom_js__WEBPACK_IMPORTED_MODULE_12__["default"](renderFeature.getFlatCoordinates(), 'XY');
    case 'LineString':
      return new _geom_js__WEBPACK_IMPORTED_MODULE_13__["default"](renderFeature.getFlatCoordinates(), 'XY');
    case 'MultiLineString':
      return new _geom_js__WEBPACK_IMPORTED_MODULE_14__["default"](
        renderFeature.getFlatCoordinates(),
        'XY',
        /** @type {Array<number>} */ (renderFeature.getEnds())
      );
    case 'Polygon':
      const flatCoordinates = renderFeature.getFlatCoordinates();
      const ends = /** @type {Array<number>} */ (renderFeature.getEnds());
      const endss = (0,_geom_flat_orient_js__WEBPACK_IMPORTED_MODULE_4__.inflateEnds)(flatCoordinates, ends);
      return endss.length > 1
        ? new _geom_js__WEBPACK_IMPORTED_MODULE_15__["default"](flatCoordinates, 'XY', endss)
        : new _geom_js__WEBPACK_IMPORTED_MODULE_16__["default"](flatCoordinates, 'XY', ends);
    default:
      throw new Error('Invalid geometry type:' + geometryType);
  }
}

/**
 * Create an `ol/Feature` from an `ol/render/Feature`
 * @param {RenderFeature} renderFeature RenderFeature
 * @param {string} [geometryName='geometry'] Geometry name to use
 * when creating the Feature.
 * @return {Feature} Newly constructed `ol/Feature` with properties,
 * geometry, and id copied over.
 * @api
 */
function toFeature(renderFeature, geometryName) {
  const id = renderFeature.getId();
  const geometry = toGeometry(renderFeature);
  const properties = renderFeature.getProperties();
  const feature = new _Feature_js__WEBPACK_IMPORTED_MODULE_17__["default"]();
  if (geometryName !== undefined) {
    feature.setGeometryName(geometryName);
  }
  feature.setGeometry(geometry);
  if (id !== undefined) {
    feature.setId(id);
  }
  feature.setProperties(properties, true);
  return feature;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RenderFeature);


/***/ }),

/***/ "./node_modules/ol/sphere.js":
/*!***********************************!*\
  !*** ./node_modules/ol/sphere.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_RADIUS: () => (/* binding */ DEFAULT_RADIUS),
/* harmony export */   getArea: () => (/* binding */ getArea),
/* harmony export */   getDistance: () => (/* binding */ getDistance),
/* harmony export */   getLength: () => (/* binding */ getLength),
/* harmony export */   offset: () => (/* binding */ offset)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/ol/math.js");
/**
 * @module ol/sphere
 */


/**
 * Object literal with options for the {@link getLength} or {@link getArea}
 * functions.
 * @typedef {Object} SphereMetricOptions
 * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857']
 * Projection of the  geometry.  By default, the geometry is assumed to be in
 * Web Mercator.
 * @property {number} [radius=6371008.8] Sphere radius.  By default, the
 * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)
 * for the WGS84 ellipsoid is used.
 */

/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */
const DEFAULT_RADIUS = 6371008.8;

/**
 * Get the great circle distance (in meters) between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {number} The great circle distance between the points (in meters).
 * @api
 */
function getDistance(c1, c2, radius) {
  radius = radius || DEFAULT_RADIUS;
  const lat1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c1[1]);
  const lat2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c2[1]);
  const deltaLatBy2 = (lat2 - lat1) / 2;
  const deltaLonBy2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c2[0] - c1[0]) / 2;
  const a =
    Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +
    Math.sin(deltaLonBy2) *
      Math.sin(deltaLonBy2) *
      Math.cos(lat1) *
      Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */
function getLengthInternal(coordinates, radius) {
  let length = 0;
  for (let i = 0, ii = coordinates.length; i < ii - 1; ++i) {
    length += getDistance(coordinates[i], coordinates[i + 1], radius);
  }
  return length;
}

/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [options] Options for the
 * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 * You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */
function getLength(geometry, options) {
  options = options || {};
  const radius = options.radius || DEFAULT_RADIUS;
  const projection = options.projection || 'EPSG:3857';
  const type = geometry.getType();
  if (type !== 'GeometryCollection') {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  let length = 0;
  let coordinates, coords, i, ii, j, jj;
  switch (type) {
    case 'Point':
    case 'MultiPoint': {
      break;
    }
    case 'LineString':
    case 'LinearRing': {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (
        geometry
      ).getCoordinates();
      length = getLengthInternal(coordinates, radius);
      break;
    }
    case 'MultiLineString':
    case 'Polygon': {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (
        geometry
      ).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        length += getLengthInternal(coordinates[i], radius);
      }
      break;
    }
    case 'MultiPolygon': {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (
        geometry
      ).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        coords = coordinates[i];
        for (j = 0, jj = coords.length; j < jj; ++j) {
          length += getLengthInternal(coords[j], radius);
        }
      }
      break;
    }
    case 'GeometryCollection': {
      const geometries =
        /** @type {import("./geom/GeometryCollection.js").default} */ (
          geometry
        ).getGeometries();
      for (i = 0, ii = geometries.length; i < ii; ++i) {
        length += getLength(geometries[i], options);
      }
      break;
    }
    default: {
      throw new Error('Unsupported geometry type: ' + type);
    }
  }
  return length;
}

/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array<import("./coordinate.js").Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */
function getAreaInternal(coordinates, radius) {
  let area = 0;
  const len = coordinates.length;
  let x1 = coordinates[len - 1][0];
  let y1 = coordinates[len - 1][1];
  for (let i = 0; i < len; i++) {
    const x2 = coordinates[i][0];
    const y2 = coordinates[i][1];
    area +=
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(x2 - x1) *
      (2 + Math.sin((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(y1)) + Math.sin((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(y2)));
    x1 = x2;
    y1 = y2;
  }
  return (area * radius * radius) / 2.0;
}

/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {import("./geom/Geometry.js").default} geometry A geometry.
 * @param {SphereMetricOptions} [options] Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */
function getArea(geometry, options) {
  options = options || {};
  const radius = options.radius || DEFAULT_RADIUS;
  const projection = options.projection || 'EPSG:3857';
  const type = geometry.getType();
  if (type !== 'GeometryCollection') {
    geometry = geometry.clone().transform(projection, 'EPSG:4326');
  }
  let area = 0;
  let coordinates, coords, i, ii, j, jj;
  switch (type) {
    case 'Point':
    case 'MultiPoint':
    case 'LineString':
    case 'MultiLineString':
    case 'LinearRing': {
      break;
    }
    case 'Polygon': {
      coordinates = /** @type {import("./geom/Polygon.js").default} */ (
        geometry
      ).getCoordinates();
      area = Math.abs(getAreaInternal(coordinates[0], radius));
      for (i = 1, ii = coordinates.length; i < ii; ++i) {
        area -= Math.abs(getAreaInternal(coordinates[i], radius));
      }
      break;
    }
    case 'MultiPolygon': {
      coordinates = /** @type {import("./geom/SimpleGeometry.js").default} */ (
        geometry
      ).getCoordinates();
      for (i = 0, ii = coordinates.length; i < ii; ++i) {
        coords = coordinates[i];
        area += Math.abs(getAreaInternal(coords[0], radius));
        for (j = 1, jj = coords.length; j < jj; ++j) {
          area -= Math.abs(getAreaInternal(coords[j], radius));
        }
      }
      break;
    }
    case 'GeometryCollection': {
      const geometries =
        /** @type {import("./geom/GeometryCollection.js").default} */ (
          geometry
        ).getGeometries();
      for (i = 0, ii = geometries.length; i < ii; ++i) {
        area += getArea(geometries[i], options);
      }
      break;
    }
    default: {
      throw new Error('Unsupported geometry type: ' + type);
    }
  }
  return area;
}

/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {import("./coordinate.js").Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's
 *     mean radius using the WGS84 ellipsoid.
 * @return {import("./coordinate.js").Coordinate} The target point.
 */
function offset(c1, distance, bearing, radius) {
  radius = radius || DEFAULT_RADIUS;
  const lat1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c1[1]);
  const lon1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toRadians)(c1[0]);
  const dByR = distance / radius;
  const lat = Math.asin(
    Math.sin(lat1) * Math.cos(dByR) +
      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing)
  );
  const lon =
    lon1 +
    Math.atan2(
      Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),
      Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat)
    );
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toDegrees)(lon), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.toDegrees)(lat)];
}


/***/ }),

/***/ "./node_modules/ol/string.js":
/*!***********************************!*\
  !*** ./node_modules/ol/string.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   compareVersions: () => (/* binding */ compareVersions),
/* harmony export */   padNumber: () => (/* binding */ padNumber)
/* harmony export */ });
/**
 * @module ol/string
 */

/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number} [precision] Precision of the output string (i.e. number of decimal places)
 * @return {string} Formatted string
 */
function padNumber(number, width, precision) {
  const numberString =
    precision !== undefined ? number.toFixed(precision) : '' + number;
  let decimal = numberString.indexOf('.');
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width
    ? numberString
    : new Array(1 + width - decimal).join('0') + numberString;
}

/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @return {number} Value
 */
function compareVersions(v1, v2) {
  const s1 = ('' + v1).split('.');
  const s2 = ('' + v2).split('.');

  for (let i = 0; i < Math.max(s1.length, s2.length); i++) {
    const n1 = parseInt(s1[i] || '0', 10);
    const n2 = parseInt(s2[i] || '0', 10);

    if (n1 > n2) {
      return 1;
    }
    if (n2 > n1) {
      return -1;
    }
  }

  return 0;
}


/***/ }),

/***/ "./node_modules/ol/transform.js":
/*!**************************************!*\
  !*** ./node_modules/ol/transform.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   apply: () => (/* binding */ apply),
/* harmony export */   compose: () => (/* binding */ compose),
/* harmony export */   composeCssTransform: () => (/* binding */ composeCssTransform),
/* harmony export */   create: () => (/* binding */ create),
/* harmony export */   determinant: () => (/* binding */ determinant),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   makeInverse: () => (/* binding */ makeInverse),
/* harmony export */   makeScale: () => (/* binding */ makeScale),
/* harmony export */   multiply: () => (/* binding */ multiply),
/* harmony export */   reset: () => (/* binding */ reset),
/* harmony export */   rotate: () => (/* binding */ rotate),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   set: () => (/* binding */ set),
/* harmony export */   setFromArray: () => (/* binding */ setFromArray),
/* harmony export */   toString: () => (/* binding */ toString),
/* harmony export */   translate: () => (/* binding */ translate)
/* harmony export */ });
/* harmony import */ var _has_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./has.js */ "./node_modules/ol/has.js");
/* harmony import */ var _asserts_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asserts.js */ "./node_modules/ol/asserts.js");
/**
 * @module ol/transform
 */



/**
 * An array representing an affine 2d transformation for use with
 * {@link module:ol/transform} functions. The array has 6 elements.
 * @typedef {!Array<number>} Transform
 * @api
 */

/**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3×3 matrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */

/**
 * @private
 * @type {Transform}
 */
const tmp_ = new Array(6);

/**
 * Create an identity transform.
 * @return {!Transform} Identity transform.
 */
function create() {
  return [1, 0, 0, 1, 0, 0];
}

/**
 * Resets the given transform to an identity transform.
 * @param {!Transform} transform Transform.
 * @return {!Transform} Transform.
 */
function reset(transform) {
  return set(transform, 1, 0, 0, 1, 0, 0);
}

/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!Transform} transform1 Transform parameters of matrix 1.
 * @param {!Transform} transform2 Transform parameters of matrix 2.
 * @return {!Transform} transform1 multiplied with transform2.
 */
function multiply(transform1, transform2) {
  const a1 = transform1[0];
  const b1 = transform1[1];
  const c1 = transform1[2];
  const d1 = transform1[3];
  const e1 = transform1[4];
  const f1 = transform1[5];
  const a2 = transform2[0];
  const b2 = transform2[1];
  const c2 = transform2[2];
  const d2 = transform2[3];
  const e2 = transform2[4];
  const f2 = transform2[5];

  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;

  return transform1;
}

/**
 * Set the transform components a-f on a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!Transform} Matrix with transform applied.
 */
function set(transform, a, b, c, d, e, f) {
  transform[0] = a;
  transform[1] = b;
  transform[2] = c;
  transform[3] = d;
  transform[4] = e;
  transform[5] = f;
  return transform;
}

/**
 * Set transform on one matrix from another matrix.
 * @param {!Transform} transform1 Matrix to set transform to.
 * @param {!Transform} transform2 Matrix to set transform from.
 * @return {!Transform} transform1 with transform from transform2 applied.
 */
function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}

/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {Transform} transform The transformation.
 * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
 * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
 *     chained together.
 */
function apply(transform, coordinate) {
  const x = coordinate[0];
  const y = coordinate[1];
  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
  return coordinate;
}

/**
 * Applies rotation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!Transform} The rotated transform.
 */
function rotate(transform, angle) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));
}

/**
 * Applies scale to a given transform.
 * @param {!Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scaled transform.
 */
function scale(transform, x, y) {
  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
}

/**
 * Creates a scale transform.
 * @param {!Transform} target Transform to overwrite.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!Transform} The scale transform.
 */
function makeScale(target, x, y) {
  return set(target, x, 0, 0, y, 0, 0);
}

/**
 * Applies translation to the given transform.
 * @param {!Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!Transform} The translated transform.
 */
function translate(transform, dx, dy) {
  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
}

/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!Transform} The composite transform.
 */
function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
  const sin = Math.sin(angle);
  const cos = Math.cos(angle);
  transform[0] = sx * cos;
  transform[1] = sy * sin;
  transform[2] = -sx * sin;
  transform[3] = sy * cos;
  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform;
}

/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative). The resulting transform
 * string can be applied as `transform` property of an HTMLElement's style.
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {string} The composite css transform.
 * @api
 */
function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
  return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
}

/**
 * Invert the given transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (source) transform.
 */
function invert(source) {
  return makeInverse(source, source);
}

/**
 * Invert the given transform.
 * @param {!Transform} target Transform to be set as the inverse of
 *     the source transform.
 * @param {!Transform} source The source transform to invert.
 * @return {!Transform} The inverted (target) transform.
 */
function makeInverse(target, source) {
  const det = determinant(source);
  (0,_asserts_js__WEBPACK_IMPORTED_MODULE_0__.assert)(det !== 0, 'Transformation matrix cannot be inverted');

  const a = source[0];
  const b = source[1];
  const c = source[2];
  const d = source[3];
  const e = source[4];
  const f = source[5];

  target[0] = d / det;
  target[1] = -b / det;
  target[2] = -c / det;
  target[3] = a / det;
  target[4] = (c * f - d * e) / det;
  target[5] = -(a * f - b * e) / det;

  return target;
}

/**
 * Returns the determinant of the given matrix.
 * @param {!Transform} mat Matrix.
 * @return {number} Determinant.
 */
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}

/**
 * @type {HTMLElement}
 * @private
 */
let transformStringDiv;

/**
 * A rounded string version of the transform.  This can be used
 * for CSS transforms.
 * @param {!Transform} mat Matrix.
 * @return {string} The transform as a string.
 */
function toString(mat) {
  const transformString = 'matrix(' + mat.join(', ') + ')';
  if (_has_js__WEBPACK_IMPORTED_MODULE_1__.WORKER_OFFSCREEN_CANVAS) {
    return transformString;
  }
  const node =
    transformStringDiv || (transformStringDiv = document.createElement('div'));
  node.style.transform = transformString;
  return node.style.transform;
}


/***/ }),

/***/ "./node_modules/ol/util.js":
/*!*********************************!*\
  !*** ./node_modules/ol/util.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   abstract: () => (/* binding */ abstract),
/* harmony export */   getUid: () => (/* binding */ getUid)
/* harmony export */ });
/**
 * @module ol/util
 */

/**
 * @return {never} Any return.
 */
function abstract() {
  throw new Error('Unimplemented abstract method.');
}

/**
 * Counter for getUid.
 * @type {number}
 * @private
 */
let uidCounter_ = 0;

/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {string} The unique ID for the object.
 * @api
 */
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}

/**
 * OpenLayers version.
 * @type {string}
 */
const VERSION = '8.2.0';


/***/ }),

/***/ "./node_modules/geoportal-access-lib/package.json":
/*!********************************************************!*\
  !*** ./node_modules/geoportal-access-lib/package.json ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"geoportal-access-lib","version":"3.4.1","date":"16/04/2024","description":"French Geoportal resources access library","module":"src/Gp.js","main":"dist/GpServices-src.js","homepage":"https://github.com/IGNF/geoportal-access-lib#readme","scripts":{"clean":"echo \\"Warning: no yet implemented!\\" && exit 0","setup":"npm install","cover":"nyc --reporter=lcov --reporter=text npm run test","eslint":"eslint src/","build":"webpack --mode=none","build:prod":"webpack --mode=production","build:dev":"webpack --mode=development","test":"mocha-webpack --reporter mochawesome --reporter-options reportDir=test-report,reportFilename=index --webpack-config ./test/webpack/webpack.test.js --glob \\"test_*.js\\" test/spec/","test:serve":"webpack-dev-server --hot --config ./test/webpack/webpack.test.serve.js","test:serve:docker":"webpack-dev-server --hot --config ./test/webpack/webpack.test.serve.docker.js","test:end-to-end:serve":"webpack-dev-server --hot --config ./test/webpack/webpack.end-to-end.serve.js","test:end-to-end:serve:docker":"webpack-dev-server --hot --config ./test/webpack/webpack.end-to-end.serve.docker.js","sample":"npm run sample:serve","sample:serve":"webpack-dev-server --mode=none --open-page samples/index-src.html --https --content-base . --output-public-path \'/dist/\' --port 9001 --open","sample:serve:prod":"webpack-dev-server --mode=production --open-page samples/index-prod.html --content-base . --output-public-path \'/dist/\' --port 9001 --open","sample:serve:dev":"webpack-dev-server --mode=development --open-page samples/index-map.html --content-base . --output-public-path \'/dist/\' --port 9001 --open","doc":"npm run doc:serve","doc:serve":"webpack-dev-server --content-base jsdoc --port 9001 --open"},"nyc":{"include":["src/**/*.js"],"instrument":false,"sourceMap":false},"repository":{"type":"git","url":"https://github.com/IGNF/geoportal-access-lib.git"},"keywords":["geoplateforme","geoportail","webservice","javascript","es6"],"author":"IGNF","license":"CECILL-B","dependencies":{"es6-promise":"^4.2.4","node-fetch":"^2.6.1","@xmldom/xmldom":"^0.8.10"},"devDependencies":{"@babel/core":"^7.12.10","@babel/plugin-transform-template-literals":"^7.12.1","@babel/preset-env":"^7.12.11","babel-loader":"^8.2.2","chai":"^4.1.2","clean-webpack-plugin":"^3.0.0","copy-webpack-plugin":"^5.1.2","eslint":"^7.18.0","eslint-config-standard":"^16.0.2","eslint-loader":"^4.0.2","eslint-plugin-import":"^2.22.1","eslint-plugin-node":"^11.1.0","eslint-plugin-promise":"^4.2.1","eslint-plugin-standard":"^5.0.0","glob":"^7.1.2","handlebars-layouts":"^3.1.4","handlebars-webpack-plugin":"^1.4.1","html-webpack-plugin":"^4.5.1","istanbul-instrumenter-loader":"^3.0.1","jsdoc-webpack-plugin":"^0.3.0","loglevel":"^1.6.1","mocha":"^7.2.0","mocha-loader":"^5.1.5","mocha-webpack":"^2.0.0-beta.0","mochawesome":"^6.2.1","nyc":"^15.1.0","path":"^0.12.7","replace-bundle-webpack-plugin":"^1.0.0","sinon":"^9.2.4","sinon-es6":"0.0.3","speed-measure-webpack-plugin":"^1.4.2","string-template":"^1.0.0","terser-webpack-plugin":"^2.3.8","webpack":"^4.46.0","webpack-cli":"^3.3.12","webpack-dev-server":"^3.11.2","webpack-node-externals":"^2.5.2","webpack-shell-plugin":"^0.5.0"},"bundledDependencies":[],"peerDependencies":{},"optionalDependencies":{}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************************************************!*\
  !*** ./src/packages/Controls/LayerImport/LayerImport.js ***!
  \**********************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CSS_Controls_LayerImport_GPFlayerImport_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../CSS/Controls/LayerImport/GPFlayerImport.css */ "./src/packages/CSS/Controls/LayerImport/GPFlayerImport.css");
/* harmony import */ var _Control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Control */ "./src/packages/Controls/Control.js");
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ol/Observable */ "ol/Observable");
/* harmony import */ var ol_Observable__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ol_Observable__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var ol_Collection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ol/Collection */ "ol/Collection");
/* harmony import */ var ol_Collection__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ol_Collection__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var ol_Feature__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ol/Feature */ "ol/Feature");
/* harmony import */ var ol_Feature__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ol_Feature__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var ol_tilegrid_WMTS__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ol/tilegrid/WMTS */ "ol/tilegrid/WMTS");
/* harmony import */ var ol_tilegrid_WMTS__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ol_tilegrid_WMTS__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ol/proj */ "ol/proj");
/* harmony import */ var ol_proj__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ol_proj__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var ol_format_MVT__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ol/format/MVT */ "ol/format/MVT");
/* harmony import */ var ol_format_MVT__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(ol_format_MVT__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var ol_format_WMSCapabilities__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ol/format/WMSCapabilities */ "ol/format/WMSCapabilities");
/* harmony import */ var ol_format_WMSCapabilities__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(ol_format_WMSCapabilities__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var ol_format_WMTSCapabilities__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ol/format/WMTSCapabilities */ "ol/format/WMTSCapabilities");
/* harmony import */ var ol_format_WMTSCapabilities__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(ol_format_WMTSCapabilities__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var ol_layer_VectorTile__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ol/layer/VectorTile */ "ol/layer/VectorTile");
/* harmony import */ var ol_layer_VectorTile__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(ol_layer_VectorTile__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ol/layer/Vector */ "ol/layer/Vector");
/* harmony import */ var ol_layer_Vector__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(ol_layer_Vector__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var ol_layer_Tile__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ol/layer/Tile */ "ol/layer/Tile");
/* harmony import */ var ol_layer_Tile__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(ol_layer_Tile__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var ol_source_VectorTile__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ol/source/VectorTile */ "ol/source/VectorTile");
/* harmony import */ var ol_source_VectorTile__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(ol_source_VectorTile__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ol/source/Vector */ "ol/source/Vector");
/* harmony import */ var ol_source_Vector__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(ol_source_Vector__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var ol_source_TileWMS__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ol/source/TileWMS */ "ol/source/TileWMS");
/* harmony import */ var ol_source_TileWMS__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(ol_source_TileWMS__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var ol_source_WMTS__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ol/source/WMTS */ "ol/source/WMTS");
/* harmony import */ var ol_source_WMTS__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(ol_source_WMTS__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var ol_source_TileJSON__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ol/source/TileJSON */ "ol/source/TileJSON");
/* harmony import */ var ol_source_TileJSON__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(ol_source_TileJSON__WEBPACK_IMPORTED_MODULE_17__);
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ol/style */ "ol/style");
/* harmony import */ var ol_style__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(ol_style__WEBPACK_IMPORTED_MODULE_18__);
/* harmony import */ var ol_mapbox_style__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ol-mapbox-style */ "./node_modules/ol-mapbox-style/dist/index.js");
/* harmony import */ var geoportal_access_lib__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! geoportal-access-lib */ "./node_modules/geoportal-access-lib/src/Gp.js");
/* harmony import */ var _Editor_Editor__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../Editor/Editor */ "./src/packages/Controls/Editor/Editor.js");
/* harmony import */ var _Utils_Markers__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../Utils/Markers */ "./src/packages/Controls/Utils/Markers.js");
/* harmony import */ var _Utils_Draggable__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../../Utils/Draggable */ "./src/packages/Utils/Draggable.js");
/* harmony import */ var _Utils_Interactions__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../Utils/Interactions */ "./src/packages/Controls/Utils/Interactions.js");
/* harmony import */ var _Utils_Helper__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../../Utils/Helper */ "./src/packages/Utils/Helper.js");
/* harmony import */ var _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../../Utils/LoggerByDefault */ "./src/packages/Utils/LoggerByDefault.js");
/* harmony import */ var _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../../Utils/SelectorID */ "./src/packages/Utils/SelectorID.js");
/* harmony import */ var _Utils_ProxyUtils__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../../Utils/ProxyUtils */ "./src/packages/Utils/ProxyUtils.js");
/* harmony import */ var _LayerImportDOM__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./LayerImportDOM */ "./src/packages/Controls/LayerImport/LayerImportDOM.js");
/* harmony import */ var _Formats_KML__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ../../Formats/KML */ "./src/packages/Formats/KML.js");
/* harmony import */ var _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ../../Formats/GeoJSON */ "./src/packages/Formats/GeoJSON.js");
/* harmony import */ var _Formats_GPX__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ../../Formats/GPX */ "./src/packages/Formats/GPX.js");
/* harmony import */ var _LayerSwitcher_LayerSwitcher__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ../LayerSwitcher/LayerSwitcher */ "./src/packages/Controls/LayerSwitcher/LayerSwitcher.js");
/* harmony import */ var _Route_Route__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ../Route/Route */ "./src/packages/Controls/Route/Route.js");
/* harmony import */ var _Isocurve_Isocurve__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ../Isocurve/Isocurve */ "./src/packages/Controls/Isocurve/Isocurve.js");
/* harmony import */ var _ElevationPath_ElevationPath__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ../ElevationPath/ElevationPath */ "./src/packages/Controls/ElevationPath/ElevationPath.js");
var _LayerImport;
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// import CSS

// import "../../CSS/Controls/LayerImport/GPFlayerImportStyle.css";
// import OpenLayers
// import Control from "ol/control/Control";





// import { createXYZ as olCreateXYZTileGrid } from "ol/tilegrid"; // FIXME olCreateXYZTileGrid !?













// import olms : module ES6

// import olms : bundle
// import olms from "ol-mapbox-style";
// import geoportal library access

// import local








// DOM

// import local with ol dependencies







var logger = _Utils_LoggerByDefault__WEBPACK_IMPORTED_MODULE_26__["default"].getLogger("layerimport");

/**
 * @classdesc
 *
 * LayerImport Control. Allows users to add geographical data in standards formats from their own sources to the map.
 *
 * @constructor
 * @alias ol.control.LayerImport
 * @extends {ol.control.Control}
 * @type {ol.control.LayerImport}
 * @param {Object} options - options for function call.
 * @param {Boolean} [options.collapsed = true] - Specify if LayerImport control should be collapsed at startup. Default is true.
 * @param {Boolean} [options.draggable = false] - Specify if widget is draggable
 * @param {Array} [options.layerTypes = ["KML", "GPX", "GeoJSON", "WMS", "WMTS", "MAPBOX"]] - data types that could be imported : "KML", "GPX", "GeoJSON", "WMS", "WMTS" and "MAPBOX". Values will be displayed in the same order in widget list.
 * @param {Object} [options.webServicesOptions = {}] - Options to import WMS or WMTS layers
 * @param {String} [options.webServicesOptions.proxyUrl] - Proxy URL to avoid cross-domain problems. Mandatory to import WMS and WMTS layer.
 * @param {Array.<String>} [options.webServicesOptions.noProxyDomains] - Proxy will not be used for this list of domain names. Only use if you know what you're doing.
 * @param {Object} [options.vectorStyleOptions] - Options for imported vector layer styling (KML, GPX, GeoJSON)
 * @param {Object} [options.vectorStyleOptions.KML] - Options for KML layer styling
 * @param {Boolean} [options.vectorStyleOptions.KML.extractStyles = true] - Extract styles from the KML. Default is true.
 * @param {Boolean} [options.vectorStyleOptions.KML.showPointNames = true] - Show names as labels for KML placemarks which contain points. Default is true.
 * @param {Object} [options.vectorStyleOptions.KML.defaultStyle] - default style to be applied to KML imports in case no style is defined. defaultStyle is an {@link http://openlayers.org/en/latest/apidoc/ol.style.Style.html ol.style.Style} object.
 * @param {Object} [options.vectorStyleOptions.GPX] - Options for GPX layer styling
 * @param {Object} [options.vectorStyleOptions.GPX.defaultStyle] - default style to be applied to GPX imports in case no style is defined. defaultStyle is an {@link http://openlayers.org/en/latest/apidoc/ol.style.Style.html ol.style.Style} object.
 * @param {Object} [options.vectorStyleOptions.GeoJSON] - Options for GeoJSON layer styling
 * @param {Object} [options.vectorStyleOptions.GeoJSON.defaultStyle] - default style to be applied to GeoJSON imports in case no style is defined. defaultStyle is an {@link http://openlayers.org/en/latest/apidoc/ol.style.Style.html ol.style.Style} object.
 * @param {Object} [options.vectorStyleOptions.MapBox] - Options for MapBox layer styling
 * @param {Object} [options.vectorStyleOptions.MapBox.defaultStyle] - default style to be applied to MapBox imports in case no style is defined. defaultStyle is an {@link http://openlayers.org/en/latest/apidoc/ol.style.Style.html ol.style.Style} object.
 * @param {Object} [options.vectorStyleOptions.MapBox.editor] - options for tools editor
 * @param {Boolean} [options.vectorStyleOptions.MapBox.display = true] - display tools editor
 * @example
 *  var LayerImport = new ol.control.LayerImport({
 *      "collapsed" : false,
 *      "draggable" : true,
 *      "layerTypes" : ["KML", "GPX"],
 *      "webServicesOptions" : {
 *          "proxyUrl" : "http://localhost/proxy/php/proxy.php?url=",
 *          "noProxyDomains" : []
 *      },
 *      "vectorStyleOptions" : {
 *          "KML" : {
 *              extractStyles : true,
 *              defaultStyle : new ol.style.Style({
 *                  image : new ol.style.Icon({
 *                       src : "data:image/png;base64....",
 *                       size : [51, 38],
 *                  }),
 *                  stroke : new ol.style.Stroke({
 *                       color : "#ffffff",
 *                       width : 7
 *                  }),
 *                  fill : new ol.style.Fill({
 *                       color : "rgba(255, 183, 152, 0.2)"
 *                  }),
 *                  text : new ol.style.Text({
 *                      font : "16px Sans",
 *                      textAlign : "left",
 *                      fill : new ol.style.Fill({
 *                          color : "rgba(255, 255, 255, 1)"
 *                      }),
 *                      stroke : new ol.style.Stroke({
 *                          color : "rgba(0, 0, 0, 1)",
 *                          width : 2
 *                      })
 *                  })
 *              })
 *          },
 *          "GPX" : {
 *              defaultStyle : new ol.style.Style({
 *                  image : new ol.style.Icon({
 *                       src : "path/to/my/icon.png",
 *                       size : [51, 38],
 *                  }),
 *                  stroke : new ol.style.Stroke({
 *                       color : "#ffffff",
 *                       width : 7
 *                  })
 *              })
 *          }
 *      }
 *  });
 */
var LayerImport = (_LayerImport = /*#__PURE__*/function (_Control) {
  /**
   * See {@link ol.control.LayerImport}
   * @module LayerImport
   * @alias module:~controls/LayerImport
   * @param {*} options - options
   * @example
   * import LayerImport from "gpf-ext-ol/controls/LayerImport"
   * ou 
   * import { LayerImport } from "gpf-ext-ol"
   */
  function LayerImport(options) {
    var _this;
    _classCallCheck(this, LayerImport);
    options = options || {};

    // call ol.control.Control constructor
    _this = _callSuper(this, LayerImport, [{
      element: options.element,
      target: options.target,
      render: options.render
    }]);
    if (!(_this instanceof LayerImport)) {
      throw new TypeError("ERROR CLASS_CONSTRUCTOR");
    }
    _this._initialize(options);

    // init control DOM container
    _this._container = _this._initContainer(options);

    // ajout du container
    _this.element ? _this.element.appendChild(_this._container) : _this.element = _this._container;
    return _possibleConstructorReturn(_this, _this);
  }
  _inherits(LayerImport, _Control);
  return _createClass(LayerImport, [{
    key: "setMap",
    value:
    // ################################################################### //
    // ############## public methods (getters, setters) ################## //
    // ################################################################### //

    /**
     * Overwrite OpenLayers setMap method
     *
     * @param {ol.Map} map - Map.
     */
    function setMap(map) {
      // ajout de la patience pour le chargement des tuiles
      if (map) {
        // Animation au centre de la carte ?
        // var center = this._loadingContainer = this._createLoadingElement();
        // map.getViewport().appendChild(center);

        var self = this;
        map.getLayers().on("remove", function (e) {
          // import de type layerimport:MapBox ?
          if (e.element.gpResultLayerId === "layerimport:MAPBOX") {
            // layer ayant un editor ID associé ?
            if (e.element.gpEditorId) {
              // le panneau des résultats existe t il ?
              if (self._mapBoxPanel && self._importPanel) {
                self.cleanMapBoxResults(e.element.gpEditorId);
                self._mapBoxPanel.style.display = "none";
                self._importPanel.style.display = "";
              }
            }
          }
        }, self);

        // mode "draggable"
        if (this.draggable) {
          _Utils_Draggable__WEBPACK_IMPORTED_MODULE_23__["default"].dragElement(this._importPanel, this._importPanelHeader, this.options.position ? null : map.getTargetElement());

          // panneau draggable pour les resultats ?
          _Utils_Draggable__WEBPACK_IMPORTED_MODULE_23__["default"].dragElement(this._getCapPanel, this._getCapPanelHeader, map.getTargetElement());
          _Utils_Draggable__WEBPACK_IMPORTED_MODULE_23__["default"].dragElement(this._mapBoxPanel, this._mapBoxPanelHeader, map.getTargetElement());
        }
        // mode "collapsed"
        if (!this.collapsed) {
          this._showImportButton.setAttribute("aria-pressed", true);
        }
      }

      // on appelle la méthode setMap originale d'OpenLayers
      _get(_getPrototypeOf(LayerImport.prototype), "setMap", this).call(this, map);

      // position
      if (this.options.position) {
        this.setPosition(this.options.position);
      }
    }

    /**
     * Returns true if widget is collapsed (minimized), false otherwise
     *
     * @returns {Boolean} collapsed - true if widget is collapsed
     */
  }, {
    key: "getCollapsed",
    value: function getCollapsed() {
      return this.collapsed;
    }

    /**
     * Collapse or display widget main container
     *
     * @param {Boolean} collapsed - True to collapse widget, False to display it
     */
  }, {
    key: "setCollapsed",
    value: function setCollapsed(collapsed) {
      if (collapsed === undefined) {
        logger.error("[ERROR] LayerImport:setCollapsed - missing collapsed parameter");
        return;
      }
      if (collapsed && this.collapsed || !collapsed && !this.collapsed) {
        return;
      }
      if (collapsed) {
        this._panelCloseButton.click();
      } else {
        this._showImportButton.click();
      }
      this.collapsed = collapsed;
    }

    /**
     * Returns content of a static import (KML, GPX or GeoJSON)
     *
     * @returns {String} contentStatic  - content static
     */
  }, {
    key: "getStaticImportContent",
    value: function getStaticImportContent() {
      return this.contentStatic;
    }

    /**
     * Returns content of a service import (GetCapabilities)
     *
     * @returns {String} contentService  - content service
     */
  }, {
    key: "getServiceImportContent",
    value: function getServiceImportContent() {
      return this.contentService;
    }

    /**
     * Returns layer name
     *
     * @returns {String} name - layer name
     */
  }, {
    key: "getName",
    value: function getName() {
      return this._name;
    }

    // ################################################################### //
    // ##################### init component ############################## //
    // ################################################################### //

    /**
     * Initialize LayerImport control (called by LayerImport constructor)
     *
     * @param {Object} options - constructor options
     * @private
     */
  }, {
    key: "_initialize",
    value: function _initialize(options) {
      // ############################################################ //
      // ################### Options du composant ################### //

      // check input options format
      this._checkInputOptions(options);

      // set default options
      this.options = {
        collapsed: true,
        draggable: false,
        layerTypes: ["KML", "GPX", "GeoJSON", "WMS", "WMTS", "MAPBOX"],
        webServicesOptions: {},
        vectorStyleOptions: {
          KML: {
            extractStyles: true,
            showPointNames: true,
            defaultStyle: {}
          },
          GPX: {
            defaultStyle: {}
          },
          GeoJSON: {
            defaultStyle: {}
          },
          MapBox: {
            defaultStyle: {},
            editor: {}
          }
        }
      };

      // TODO gestion du proxy

      // set extractStyles parameter
      if (options.vectorStyleOptions && options.vectorStyleOptions.KML && options.vectorStyleOptions.KML.extractStyles) {
        this.options.vectorStyleOptions.KML.extractStyles = options.vectorStyleOptions.KML.extractStyles;
      } // TODO
      // set showPointNames parameter
      if (options.vectorStyleOptions && options.vectorStyleOptions.KML && options.vectorStyleOptions.KML.showPointNames) {
        this.options.vectorStyleOptions.KML.showPointNames = options.vectorStyleOptions.KML.showPointNames;
      }

      // set vector layers default styles (KML, GPX, GeoJSON, MapBox)
      if (options.vectorStyleOptions && options.vectorStyleOptions.KML && options.vectorStyleOptions.KML.defaultStyle) {
        // get from options if specified
        this.options.vectorStyleOptions.KML.defaultStyle = options.vectorStyleOptions.KML.defaultStyle;
      } else {
        // get from control default options otherwise
        this.options.vectorStyleOptions.KML.defaultStyle = new ol_style__WEBPACK_IMPORTED_MODULE_18__.Style({
          image: LayerImport.DefaultStyles.image,
          stroke: LayerImport.DefaultStyles.stroke,
          fill: LayerImport.DefaultStyles.fill,
          text: LayerImport.DefaultStyles.text
        });
      }
      if (options.vectorStyleOptions && options.vectorStyleOptions.GPX && options.vectorStyleOptions.GPX.defaultStyle) {
        // get from options if specified
        this.options.vectorStyleOptions.GPX.defaultStyle = options.vectorStyleOptions.GPX.defaultStyle;
      } else {
        // get from control default options otherwise
        this.options.vectorStyleOptions.GPX.defaultStyle = new ol_style__WEBPACK_IMPORTED_MODULE_18__.Style({
          image: LayerImport.DefaultStyles.image,
          stroke: LayerImport.DefaultStyles.stroke,
          fill: LayerImport.DefaultStyles.fill,
          text: LayerImport.DefaultStyles.text
        });
      }
      if (options.vectorStyleOptions && options.vectorStyleOptions.GeoJSON && options.vectorStyleOptions.GeoJSON.defaultStyle) {
        // get from options if specified
        this.options.vectorStyleOptions.GeoJSON.defaultStyle = options.vectorStyleOptions.GeoJSON.defaultStyle;
      } else {
        // get from control default options otherwise
        this.options.vectorStyleOptions.GeoJSON.defaultStyle = new ol_style__WEBPACK_IMPORTED_MODULE_18__.Style({
          image: LayerImport.DefaultStyles.image,
          stroke: LayerImport.DefaultStyles.stroke,
          fill: LayerImport.DefaultStyles.fill,
          text: LayerImport.DefaultStyles.text
        });
      }
      // FIXME tester les styles par defaut sur une couche vecteur tuilé sans style !
      if (options.vectorStyleOptions && options.vectorStyleOptions.MapBox && options.vectorStyleOptions.MapBox.defaultStyle) {
        // get from options if specified
        this.options.vectorStyleOptions.MapBox.defaultStyle = options.vectorStyleOptions.MapBox.defaultStyle;
      } else {
        // get from control default options otherwise
        this.options.vectorStyleOptions.MapBox.defaultStyle = new ol_style__WEBPACK_IMPORTED_MODULE_18__.Style({
          image: LayerImport.DefaultStyles.image,
          stroke: LayerImport.DefaultStyles.stroke,
          fill: LayerImport.DefaultStyles.fill,
          text: LayerImport.DefaultStyles.text
        });
      }
      if (options.vectorStyleOptions && options.vectorStyleOptions.MapBox && options.vectorStyleOptions.MapBox.editor) {
        // get from options if specified
        this.options.vectorStyleOptions.MapBox.editor = options.vectorStyleOptions.MapBox.editor;
      } else {
        this.options.vectorStyleOptions.MapBox.editor = {
          title: true,
          collapse: false,
          themes: false,
          layers: true,
          style: true,
          filter: false,
          legend: true,
          group: false
        };
      }
      if (options.vectorStyleOptions && options.vectorStyleOptions.MapBox && options.vectorStyleOptions.MapBox.hasOwnProperty("display")) {
        this.options.vectorStyleOptions.MapBox.display = options.vectorStyleOptions.MapBox.display;
      } else {
        this.options.vectorStyleOptions.MapBox.display = true;
      }

      // merge layer types
      if (Array.isArray(options.layerTypes)) {
        var layerTypes = [];
        for (var i = 0; i < options.layerTypes.length; i++) {
          layerTypes.push(options.layerTypes[i]);
        }
        this.options.layerTypes = layerTypes;
      }

      // merge with user options
      _Utils_Helper__WEBPACK_IMPORTED_MODULE_25__["default"].mergeParams(this.options, options);

      /** {Boolean} specify if LayerImport control is collapsed (true) or not (false) */
      this.collapsed = this.options.collapsed;

      /** {Boolean} specify if LayerImport control is draggable (true) or not (false) */
      this.draggable = this.options.draggable;

      // identifiant du contrôle : utile pour suffixer les identifiants CSS (pour gérer le cas où il y en a plusieurs dans la même page)
      this._uid = _Utils_SelectorID__WEBPACK_IMPORTED_MODULE_27__["default"].generate();

      // si une requête est en cours ou non
      this._waiting = false;
      // timer pour cacher la patience après un certain temps
      this._timer = null;

      // initialisation des types d'import
      this._initImportTypes();
      // initialisation des styles par défaut
      this._initDefaultStyles();

      // ################################################################## //
      // ################### Elements principaux du DOM ################### //

      // containers principaux (FIXME : tous utiles ?)
      this._showImportButton = null;
      this._importPanel = null;
      this._panelCloseButton = null;
      this._importPanelHeader = null;
      this._formContainer = null;
      this._staticLocalImportInput = null;
      this._staticUrlImportInput = null;
      this._serviceUrlImportInput = null;
      this._getCapPanel = null;
      this._getCapPanelHeader = null;
      this._getCapResultsListContainer = null;
      this._mapBoxPanel = null;
      this._mapBoxPanelHeader = null;
      this._mapBoxResultsListContainer = null;
      this._waitingContainer = null;
      this._loadingContainer = null;

      // ################################################################## //
      // ################ Interrogation du GetCapabilities ################ //

      this._getCapRequestUrl = null;
      this._getCapResponseWMS = null;
      this._getCapResponseWMSLayers = [];
      this._getCapResponseWMTS = null;
      this._getCapResponseWMTSLayers = [];

      // ################################################################## //
      // ########################### MapBox ############################### //
      this._hasMapBoxResults = false;

      // ################################################################## //
      // ########################### file or url ########################## //
      this.contentStatic = null;
      this._url = null;
      this._file = null;
      this._name = null;
    }

    /**
     * this method is called by this.initialize()
     * and makes sure input options are correctly formated
     *
     * @param {Object} options - control input options
     * @private
     */
  }, {
    key: "_checkInputOptions",
    value: function _checkInputOptions(options) {
      // on vérifie le tableau des types
      if (options.layerTypes) {
        var layerTypes = options.layerTypes;
        // on vérifie que la liste des types est bien un tableau
        if (!Array.isArray(layerTypes)) {
          logger.warn("[ol.control.LayerImport] 'options.layerTypes' parameter should be an array. Set default values [\"KML\", \"GPX\", \"GeoJSON\", \"WMS\", \"WMTS\"]");
          options.layerTypes = ["KML", "GPX", "GeoJSON", "WMS", "WMTS", "MAPBOX"];
        } else {
          var typesList = ["KML", "GPX", "GEOJSON", "WMS", "WMTS", "WFS", "MAPBOX"];
          var wrongTypesIndexes = [];
          for (var i = 0; i < layerTypes.length; i++) {
            if (typeof layerTypes[i] !== "string") {
              // si l'élément du tableau n'est pas une chaine de caractères, on stocke l'index pour le retirer du tableau
              wrongTypesIndexes.push(i);
              logger.warn("[ol.control.LayerImport] 'options.layerTypes' elements should be of type string (" + layerTypes[i] + ")");
            } else {
              // on passe en majuscules pour comparer
              layerTypes[i] = layerTypes[i].toUpperCase();
              if (typesList.indexOf(layerTypes[i]) === -1) {
                // si le type n'est pas référencé, on stocke son index pour le retirer du tableau (après avoir terminé de parcourir le tableau)
                wrongTypesIndexes.push(i);
                logger.log("[ol.control.LayerImport] options.layerTypes : " + layerTypes[i] + " is not a supported type");
              }
              // cas spécial du GeoJSON qu'on ne laisse pas en majuscules
              if (layerTypes[i] === "GEOJSON") {
                layerTypes[i] = "GeoJSON";
              }
              if (layerTypes[i] === "MAPBOX") {
                layerTypes[i] = "MAPBOX";
              }
            }
          }
          // on retire les types non référencés qu'on a pu rencontrer
          if (wrongTypesIndexes.length !== 0) {
            for (var j = wrongTypesIndexes.length - 1; j >= 0; j--) {
              layerTypes.splice(wrongTypesIndexes[j], 1);
            }
          }
        }
      }
    }

    /**
     * this method is called by this.initialize()
     * and initializes default styles for vector layers (KML/GPX/GeoJSON)
     *
     * @private
     */
  }, {
    key: "_initDefaultStyles",
    value: function _initDefaultStyles() {
      var kmlDefaultStyles = this.options.vectorStyleOptions.KML.defaultStyle;
      this._defaultKMLStyle = new ol_style__WEBPACK_IMPORTED_MODULE_18__.Style({
        image: kmlDefaultStyles.image,
        stroke: kmlDefaultStyles.stroke,
        fill: kmlDefaultStyles.fill,
        text: kmlDefaultStyles.text
      });
      var gpxDefaultStyles = this.options.vectorStyleOptions.GPX.defaultStyle;
      this._defaultGPXStyle = new ol_style__WEBPACK_IMPORTED_MODULE_18__.Style({
        image: gpxDefaultStyles.image,
        stroke: gpxDefaultStyles.stroke,
        fill: gpxDefaultStyles.fill,
        text: gpxDefaultStyles.text
      });
      var geoJSONDefaultStyles = this.options.vectorStyleOptions.GeoJSON.defaultStyle;
      this._defaultGeoJSONStyle = new ol_style__WEBPACK_IMPORTED_MODULE_18__.Style({
        image: geoJSONDefaultStyles.image,
        stroke: geoJSONDefaultStyles.stroke,
        fill: geoJSONDefaultStyles.fill,
        text: geoJSONDefaultStyles.text
      });
      var MapBoxDefaultStyles = this.options.vectorStyleOptions.MapBox.defaultStyle;
      this._defaultMapBoxStyle = new ol_style__WEBPACK_IMPORTED_MODULE_18__.Style({
        image: MapBoxDefaultStyles.image,
        stroke: MapBoxDefaultStyles.stroke,
        fill: MapBoxDefaultStyles.fill,
        text: MapBoxDefaultStyles.text
      });
    }

    /**
     * this method is called by this.initialize()
     * and initializes import types parameter
     *
     * @private
     */
  }, {
    key: "_initImportTypes",
    value: function _initImportTypes() {
      this._currentImportType = this.options.layerTypes[0] || "KML";
      if (this._currentImportType === "KML" || this._currentImportType === "GPX" || this._currentImportType === "GeoJSON" || this._currentImportType === "MAPBOX") {
        this._isCurrentImportTypeStatic = true;
      } else if (this._currentImportType === "WMS" || this._currentImportType === "WMTS" || this._currentImportType === "WFS") {
        this._isCurrentImportTypeStatic = false;
      }
      this._currentStaticImportType = "local";
    }

    /**
     * Create control main container (DOM initialize)
     *
     * @private
     * @returns {DOMElement} container - control main container
     */
  }, {
    key: "_initContainer",
    value: function _initContainer() {
      // create main container
      var container = this._createMainContainerElement();

      // create Import picto
      var picto = this._showImportButton = this._createShowImportPictoElement();
      container.appendChild(picto);

      // panel
      var importPanel = this._importPanel = this._createImportPanelElement();
      var importPanelPanelDiv = this._createImportPanelDivElement();
      importPanel.appendChild(importPanelPanelDiv);

      // header
      var panelHeader = this._importPanelHeader = this._createImportPanelHeaderElement();

      // panel title
      var panelTitle = this._createImportPanelTitleElement();
      panelHeader.appendChild(panelTitle);
      // close picto
      var panelClose = this._panelCloseButton = this._createImportPanelCloseElement();
      panelHeader.appendChild(panelClose);
      importPanelPanelDiv.appendChild(panelHeader);

      // form : initialisation du formulaire d'import des couches (types d'import et saisie de l'url / du fichier)
      var importForm = this._formContainer = this._initInputFormElement();
      importPanelPanelDiv.appendChild(importForm);

      // results (dans le panel)
      var getCapPanel = this._getCapPanel = this._createImportGetCapPanelElement();
      var getCapPanelHeader = this._getCapPanelHeader = this._createImportGetCapPanelHeaderElement();
      getCapPanel.appendChild(getCapPanelHeader);
      var importGetCapResultsList = this._getCapResultsListContainer = this._createImportGetCapResultsContainer();
      getCapPanel.appendChild(importGetCapResultsList);
      importPanelPanelDiv.appendChild(getCapPanel);

      // mapbox panel results
      var mapBoxPanel = this._mapBoxPanel = this._createImportMapBoxPanelElement();
      var mapBoxPanelHeader = this._mapBoxPanelHeader = this._createImportMapBoxPanelHeaderElement();
      mapBoxPanel.appendChild(mapBoxPanelHeader);
      var importMapBoxResultsList = this._mapBoxResultsListContainer = this._createImportMapBoxResultsContainer();
      mapBoxPanel.appendChild(importMapBoxResultsList);

      // loading element mapbox
      var loading = this._loadingContainer = this._createLoadingElement();
      mapBoxPanel.appendChild(loading);
      importPanelPanelDiv.appendChild(mapBoxPanel);

      // waiting
      var waiting = this._waitingContainer = this._createImportWaitingElement();
      importPanelPanelDiv.appendChild(waiting);
      container.appendChild(importPanel);
      return container;
    }

    /**
     * Create control main container (DOM initialize)
     *
     * @private
     * @returns {DOMElement} importForm - form main container
     */
  }, {
    key: "_initInputFormElement",
    value: function _initInputFormElement() {
      // form main container
      var importForm = this._createImportPanelFormElement();

      // Format choice
      var importTypeChoiceDiv = this._createImportTypeLineElement(this.options.layerTypes);
      importForm.appendChild(importTypeChoiceDiv);

      // params for KML/GPX/GeoJSON

      var importStaticParamsContainer = this._createImportStaticParamsContainer(this.options.layerTypes[0]);
      // static file name
      var staticNameLabel = this._createStaticNameLabel();
      importStaticParamsContainer.appendChild(staticNameLabel);
      // static import choice (local / url)
      var staticImportChoice = this._createStaticModeChoiceDiv();
      // TODO : passer un paramètre "checked" ??
      var staticLocalImportChoice = this._createStaticLocalChoiceDiv();
      staticImportChoice.appendChild(staticLocalImportChoice);
      var staticUrlImportChoice = this._createStaticUrlChoiceDiv();
      staticImportChoice.appendChild(staticUrlImportChoice);
      importStaticParamsContainer.appendChild(staticImportChoice);

      // div for local file import
      var staticLocalInputDiv = this._createStaticLocalInputDiv();
      // label
      staticLocalInputDiv.appendChild(this._createStaticLocalInputLabel());
      // file input
      this._staticLocalImportInput = this._createStaticLocalInput();
      staticLocalInputDiv.appendChild(this._staticLocalImportInput);
      // append div to params container
      importStaticParamsContainer.appendChild(staticLocalInputDiv);

      // div for url input (info: séparation pour récupérer l'élément input)
      var staticUrlInputDiv = this._createStaticUrlInputDiv();
      // label
      staticUrlInputDiv.appendChild(this._createStaticUrlInputLabel());
      // url input
      this._staticUrlImportInput = this._createStaticUrlInput();
      staticUrlInputDiv.appendChild(this._staticUrlImportInput);
      // append div to params container
      importStaticParamsContainer.appendChild(staticUrlInputDiv);

      // append static params container to form container
      importForm.appendChild(importStaticParamsContainer);

      // params for WMS/WMTS/WFS

      var importServiceParamsContainer = this._createServiceParamsContainer(this.options.layerTypes[0]);
      // div for service url
      var importServiceUrlDiv = this._createServiceUrlDiv();
      // label
      importServiceUrlDiv.appendChild(this._createServiceUrlInputLabel());
      // input
      this._serviceUrlImportInput = this._createServiceUrlInput();
      importServiceUrlDiv.appendChild(this._serviceUrlImportInput);
      // append div to params container
      importServiceParamsContainer.appendChild(importServiceUrlDiv);
      // append service params container to form container
      importForm.appendChild(importServiceParamsContainer);

      // submit (bouton "Importer")
      var submit = this._createImportSubmitFormElement();
      importForm.appendChild(submit);
      return importForm;
    }

    // ################################################################### //
    // ######################### DOM events ############################## //
    // ################################################################### //

    /**
     * this method is called by event 'click' on 'GPshowImportPicto' picto
     * (cf. LayerImportDOM._createShowImportPictoElement),
     * and dispatch event change:collapsed (for tools listening this property)
     *
     * @private
     */
  }, {
    key: "_onShowImportClick",
    value: function _onShowImportClick() {
      var map = this.getMap();
      // on supprime toutes les interactions
      _Utils_Interactions__WEBPACK_IMPORTED_MODULE_24__["default"].unset(map);
      // info : on génère nous même l'evenement OpenLayers de changement de propriété
      // (utiliser ol.control.LayerImport.on("change:collapsed", function ) pour s'abonner à cet évènement)
      var opened = this._showImportButton.ariaPressed;
      this.collapsed = !(opened === "true");
      this.dispatchEvent("change:collapsed");
      // on affiche les resultats d'une couche MapBox
      if (this._hasMapBoxResults) {
        this._mapBoxPanel.style.display = "block";
      } else {
        this._formContainer.style.display = "block";
        this._importPanelHeader.style.display = "";
      }
    }

    /**
     * this method is called by event 'change' on 'GPimportType' tag form
     * (cf. LayerImportDOM._createImportTypeLineElement),
     * and change current import type
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "_onImportTypeChange",
    value: function _onImportTypeChange(e) {
      this._currentImportType = e.target.value;
      if (this._currentImportType === "KML" || this._currentImportType === "GPX" || this._currentImportType === "GeoJSON" || this._currentImportType === "MAPBOX") {
        this._isCurrentImportTypeStatic = true;
      } else if (this._currentImportType === "WMS" || this._currentImportType === "WMTS" || this._currentImportType === "WFS") {
        this._isCurrentImportTypeStatic = false;
      }
    }

    /**
     * this method is called by event 'change' on 'GPimportType' tag form
     * (cf. LayerImportDOM._createImportTypeLineElement),
     * and change current import type
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "_onStaticImportTypeChange",
    value: function _onStaticImportTypeChange(e) {
      this._currentStaticImportType = e.target.value;
    }

    /**
     * this method is called by event 'click' on 'GPimportGetCapPanelClose' tag form
     * (cf. LayerImportDOM._createImportGetCapPanelHeaderElement),
     * and reset getCapabilities information
     *
     * @private
     */
  }, {
    key: "_onGetCapPanelClose",
    value: function _onGetCapPanelClose() {
      // this._clearGetCapParams();
      if (this._currentImportType === "WMS" || this._currentImportType === "WMTS" || this._currentImportType === "WFS") {
        this.cleanGetCapResultsList();
      }
    }

    /**
     * this method is called by event 'click' on 'GPimportMapBoxPanelClose' tag form
     * (cf. LayerImportDOM._createImportMapBoxPanelHeaderElement),
     * and reset mapbox information
     *
     * @private
     */
  }, {
    key: "_onMapBoxPanelClose",
    value: function _onMapBoxPanelClose() {
      this.cleanMapBoxResultsList();
      this._loadingContainer.className = "";
    }

    /**
     * this method is called by event 'click' on 'GPimportMapBoxPanelReturnPicto' tag form
     * (cf. LayerImportDOM._createImportMapBoxPanelHeaderElement),
     * and return to information
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "_onMapBoxReturnPictoClick",
    value: function _onMapBoxReturnPictoClick(e) {
      // on bascule sur l'icone d'ouverture du composant
      this._mapBoxPanel.style.display = "none";
      this._loadingContainer.className = "";
    }

    // ################################################################### //
    // ######################## Submit form ############################## //
    // ################################################################### //

    /**
     * this method is called by event 'submit' on 'GPimportForm' tag form
     * (cf. LayerImportDOM._createImportPanelFormElement),
     * and import static layer or call getCap service (according to import type)
     *
     * @private
     */
  }, {
    key: "_onImportSubmit",
    value: function _onImportSubmit() {
      logger.log("import d'une couche de type : " + this._currentImportType);

      // reinitialisation du contenu d'un import de type
      // - static (KML ou GPX ou GeoJSON)
      this.contentStatic = null;
      // - service (WMS, ...)
      this.contentService = null;
      if (this._isCurrentImportTypeStatic) {
        this._importStaticLayer();
      } else {
        this._importServiceLayers();
      }
    }

    // ################################################################### //
    // ############## Import KML/GPX/GeoJSON/MapBox layers ############### //
    // ################################################################### //

    /**
     * this method is called by this_onImportSubmit method
     * and import static layer (KML/GPX/GeoJSON) from url or file
     *
     * @private
     */
  }, {
    key: "_importStaticLayer",
    value: function _importStaticLayer() {
      var layerName;
      var staticImportNameInput = document.getElementById(this._addUID("GPimportName"));
      if (staticImportNameInput) {
        layerName = staticImportNameInput.value || "";
        logger.log("import layer name : " + layerName);
      }
      if (this._currentStaticImportType === "local") {
        logger.log("import static layer from local file");
        this._importStaticLayerFromLocalFile(layerName);
      } else if (this._currentStaticImportType === "url") {
        logger.log("import static layer from url");
        this._importStaticLayerFromUrl(layerName);
      }
    }

    /**
     * this method is called by _importStaticLayer method
     * and import static layer (KML/GPX/GeoJSON) from url
     *
     * @param {String} layerName - imported layer name
     * @private
     */
  }, {
    key: "_importStaticLayerFromUrl",
    value: function _importStaticLayerFromUrl(layerName) {
      // 1. Récupération de l'url
      var url = this._staticUrlImportInput.value;
      logger.log("url : ", url);
      if (url.length === 0) {
        logger.error("[ol.control.LayerImport] url parameter is mandatory");
        return;
      }
      // on supprime les éventuels espaces avant ou après
      if (url.trim) {
        url = url.trim();
      }

      // sauvegarde
      this._url = url;

      // si le nom n'est pas renseigné, on extrait le nom du fichier
      if (!layerName) {
        layerName = this._url.substring(this._url.lastIndexOf("/") + 1, this._url.lastIndexOf("."));
      }

      // sauvegarde
      this._name = layerName;

      // 2. récupération proxy
      if (this.options.webServicesOptions && this.options.webServicesOptions.proxyUrl) {
        url = _Utils_ProxyUtils__WEBPACK_IMPORTED_MODULE_28__["default"].proxifyUrl(url, this.options.webServicesOptions);
      }

      // FIXME pb de surcharge en mode UMD !? ça ne marche pas...
      // this._hideWaitingContainer();
      // this._addFeaturesFromImportStaticLayerUrl(url, layerName);

      var context = this;
      geoportal_access_lib__WEBPACK_IMPORTED_MODULE_20__["default"].Protocols.XHR.call({
        url: url,
        method: "GET",
        timeOut: 15000,
        // on success callback : display results in container
        onResponse: function onResponse(response) {
          context._hideWaitingContainer();
          context._addFeaturesFromImportStaticLayer(response, layerName);
        },
        // on error callback : log error
        onFailure: function onFailure(error) {
          // en cas d'erreur, on revient au panel initial et on cache la patience
          context._hideWaitingContainer();
          logger.error("[ol.control.LayerImport] KML/GPX/GeoJSON/MapBox request failed : ", error);
        }
      });
    }

    /**
     * this method is called by _importStaticLayer method
     * and import static layer (KML/GPX/GeoJSON) from local file
     *
     * @param {String} layerName - imported layer name
     * @private
     */
  }, {
    key: "_importStaticLayerFromLocalFile",
    value: function _importStaticLayerFromLocalFile(layerName) {
      var file = this._staticLocalImportInput.files[0];
      if (!file) {
        logger.warn("[ol.control.LayerImport] missing file");
        return;
      }

      // sauvegarde
      this._file = file;

      // si le nom n'est pas renseigné, on extrait le nom du fichier
      if (!layerName) {
        layerName = this._file.name.substring(this._file.name.lastIndexOf("/") + 1, this._file.name.lastIndexOf("."));
      }

      // sauvegarde
      this._name = layerName;

      // Création d'un objet FileReader qui permet de lire le contenu du fichier chargé
      var fReader = new FileReader();

      // Définition des fonctions de callbacks associées au reader,
      // notamment la fonction onload qui affichera les entités chargées à la carte
      var context = this;
      // on readAsText error
      fReader.onerror = function (e) {
        // en cas d'erreur, on revient au panel initial et on cache la patience
        context._hideWaitingContainer();
        logger.error("error fileReader : ", e);
      };
      /** on readAsText progress */
      fReader.onprogress = function () {
        logger.log("onprogress");
      };
      /** on load start */
      fReader.onloadstart = function () {
        // affichage d'une patience le temps du chargement
        context._displayWaitingContainer();
        logger.log("onloadstart");
      };
      /** on readAsText abort */
      fReader.onabort = function () {
        // en cas d'erreur, on revient au panel initial et on cache la patience
        context._hideWaitingContainer();
        logger.log("onabort");
      };
      // on readAsText loadend
      fReader.onloadend = function (e) {
        // fReader = null ?
        // en cas d'erreur, on revient au panel initial et on cache la patience
        // context._hideWaitingContainer();
        // TODO : replier le formulaire ?
        logger.log("onloadend : ", e);
      };
      // on readAsText load
      fReader.onload = function (e) {
        logger.log("fileReader onload - file content : ", e.target.result);

        // on cache la patience
        context._hideWaitingContainer();
        context._addFeaturesFromImportStaticLayer(e.target.result, layerName);
      };

      // Lecture du fichier chargé à l'aide de fileReader
      fReader.readAsText(file);
    }

    /**
     * this method is called by _importStaticLayerFom* method
     * and add features to the map
     *
     * @param {String} fileContent - content file
     * @param {String} layerName - imported layer name
     * @private
     */
  }, {
    key: "_addFeaturesFromImportStaticLayer",
    value: function _addFeaturesFromImportStaticLayer(fileContent, layerName) {
      // récupération du contenu du fichier
      var map = this.getMap();
      if (!map || !fileContent) {
        return;
      }
      var vectorLayer = null;
      var vectorSource = null;
      var vectorFormat = null;
      var vectorStyle = null;

      // sauvegarde du content KML/GPX/GeoJSON/MapBox
      this.contentStatic = fileContent;
      if (this._currentImportType === "MAPBOX") {
        // INFO
        // on ne nettoie pas délibérément la liste de résultats de type MapBox
        // car on souhaite pouvoir interagir sur les couches (editeur).
        // du coup, à chaque import, on empile les éditeurs.
        this._hasMapBoxResults = true;

        // contexte
        var self = this;

        // style mapbox
        var _glStyles = JSON.parse(fileContent);

        // liste des sources
        var _glSources = _glStyles.sources;

        // FIXME a t on du multi-sources ?
        // mais comment doit on les traiter ?
        // EXPERIMENTAL !
        var _multiSources = Object.keys(_glSources).length > 1 ? 1 : 0;
        for (var _glSourceId in _glSources) {
          if (_glSources.hasOwnProperty(_glSourceId)) {
            var _title = "";
            var _description = "";
            var _quicklookUrl = null;
            var _legends = null;
            var _metadata = null;
            var _originators = null;

            // lecture des informations dans le style
            // ex. metadata : {
            //    geoportail:[title | description | quicklookUrl | legends | originators | metadata]
            // }
            if (_glStyles.metadata) {
              for (var ns in _glStyles.metadata) {
                if (_glStyles.metadata.hasOwnProperty(ns)) {
                  var _keys = ns.split(":");
                  if (_keys[0] === "geoportail") {
                    var key = _keys[1];
                    if (key === "title") {
                      _title = _glStyles.metadata[ns];
                      continue;
                    }
                    if (key === "description") {
                      _description = _glStyles.metadata[ns];
                      continue;
                    }
                    if (key === "quicklookUrl") {
                      _quicklookUrl = _glStyles.metadata[ns];
                      continue;
                    }
                    if (key === "legends") {
                      _legends = _glStyles.metadata[ns];
                      continue;
                    }
                    if (key === "metadata") {
                      _metadata = _glStyles.metadata[ns];
                      continue;
                    }
                    if (key === "originators") {
                      _originators = _glStyles.metadata[ns];
                      continue;
                    }
                  }
                }
              }
            }

            // titre par defaut
            if (!_title) {
              _title = "Couche MapBox";
            }
            // description par defaut
            if (!_description) {
              _description = "Couche MapBox";
            }
            // cas des multisources
            _title = _multiSources ? _title + "(" + _glSourceId + ")" : _title;

            // source mapbox
            var _glSource = _glSources[_glSourceId];

            // construction de la couche en fonction du type
            var _glType = _glSource.type;
            if (_glType === "vector") {
              // url du tilejson ou flux mapbox
              var _glUrl = _glSource.url;
              // url du service tuilé
              var _glTiles = _glSource.tiles;
              // sprites
              var _glSprite = _glStyles.sprite;

              // FIXME si on a un import par fichier local (this._file),
              // - comment passe t on la clef / le token ?
              // - comment remplacer un flux mapbox sur une url de service tuilé avec un import local ?
              if (_glUrl && _glUrl.indexOf("mapbox://") === 0) {
                var _urlService = this._url; // FIXME si fichier local !?
                if (_urlService) {
                  _glTiles = ["a", "b", "c", "d"].map(function (host) {
                    var path = _glUrl.replace("mapbox://", "");
                    var accessToken = _urlService.split("?")[1];
                    return "https://" + host + ".tiles.mapbox.com/v4/" + path + "/{z}/{x}/{y}.vector.pbf?" + accessToken;
                  });
                  // conversion des sprites sur un autre scheme que "mapbox://"
                  if (_glSprite.indexOf("mapbox://") === 0) {
                    var s = _urlService.split("?"); // FIXME si fichier local !?
                    _glStyles.sprite = s[0] + "/sprite" + "?" + s[1];
                  }
                } else {
                  logger.warn("Not yet implemented, can't use the local import scheme with a 'mapbox://' in the file.!");
                }
              }
              if (_glTiles) {
                // service tuilé et/ou mapbox
                vectorFormat = new (ol_format_MVT__WEBPACK_IMPORTED_MODULE_7___default())({
                  featureClass: (ol_Feature__WEBPACK_IMPORTED_MODULE_4___default())
                });
                vectorSource = new (ol_source_VectorTile__WEBPACK_IMPORTED_MODULE_13___default())({
                  attributions: _glSource.attribution,
                  format: vectorFormat,
                  // INFO 
                  // on supprime la grille pour forcer l'utilisation par defaut des tuiles en 512
                  // sur du vecteur tuilé
                  // tileGrid : olCreateXYZTileGrid({ // TODO scheme tms ?
                  //     extent : _glSource.bounds, // [minx, miny, maxx, maxy]
                  //     maxZoom : _glSource.maxzoom || 22,
                  //     minZoom : _glSource.minzoom || 1,
                  //     tileSize : _glSource.tileSize || 256
                  // }),
                  urls: _glTiles
                });
                vectorSource._title = _title;
                vectorSource._description = _description;
                vectorSource._quicklookUrl = _quicklookUrl;
                vectorSource._metadata = _metadata;
                vectorSource._legends = _legends;
                vectorSource._originators = _originators;
                // waiting
                vectorSource.on("tileloadstart", function (e) {
                  self._loadingContainer.className = "GPmapLoadingVisible";
                });
                vectorSource.on("tileloadend", function (e) {
                  self._loadingContainer.className = "";
                });
                vectorSource.on("tileloaderror", function (e) {
                  self._loadingContainer.className = "";
                });
                vectorLayer = new (ol_layer_VectorTile__WEBPACK_IMPORTED_MODULE_10___default())({
                  source: vectorSource,
                  visible: false,
                  // zIndex: 0, // FIXME gerer l'ordre sur des multisources ?
                  declutter: true // TODO utile ?
                });
                vectorLayer.id = _glSourceId;
                vectorLayer.gpResultLayerId = "layerimport:" + this._currentImportType;
              } else if (_glUrl) {
                // service avec un tilejson
                vectorFormat = new (ol_format_MVT__WEBPACK_IMPORTED_MODULE_7___default())({
                  featureClass: (ol_Feature__WEBPACK_IMPORTED_MODULE_4___default())
                });
                vectorLayer = new (ol_layer_VectorTile__WEBPACK_IMPORTED_MODULE_10___default())({
                  visible: false,
                  // zIndex : 0
                  declutter: true
                });
                vectorLayer.id = _glSourceId;
                vectorLayer.gpResultLayerId = "layerimport:" + this._currentImportType;
                var vectorTileJson = new (ol_source_TileJSON__WEBPACK_IMPORTED_MODULE_17___default())({
                  url: _glUrl
                });
                // lecture du tilejson avec extension IGN
                // les extensions sont enregistrées
                // dans les propriétés de la couche : layer.set(mapbox-extension)
                // pour une utilisation ulterieur (ex. editeur)
                var _key = vectorTileJson.on("change", function () {
                  if (vectorTileJson.getState() === "ready") {
                    var _tileJSONDoc = vectorTileJson.getTileJSON();
                    var tiles = Array.isArray(_tileJSONDoc.tiles) ? _tileJSONDoc.tiles : [_tileJSONDoc.tiles];
                    for (var i = 0; i < tiles.length; i++) {
                      var tile = tiles[i];
                      if (tile.indexOf("http") !== 0) {
                        tiles[i] = _glUrl + tile;
                      }
                    }
                    vectorSource = new (ol_source_VectorTile__WEBPACK_IMPORTED_MODULE_13___default())({
                      attributions: vectorTileJson.getAttributions() || _tileJSONDoc.attribution,
                      format: vectorFormat,
                      // tileGrid : olCreateXYZTileGrid({
                      //     extent : _glSource.bounds, // [minx, miny, maxx, maxy]
                      //     maxZoom : _glSource.maxzoom || 22,
                      //     minZoom : _glSource.minzoom || 1,
                      //     tileSize : _glSource.tileSize || 256
                      // }),
                      urls: tiles
                    });
                    vectorSource._title = _title;
                    vectorSource._description = _description;
                    vectorSource._quicklookUrl = _quicklookUrl;
                    vectorSource._metadata = _metadata;
                    vectorSource._legends = _legends;
                    vectorSource._originators = _originators;
                    // waiting
                    vectorSource.on("tileloadstart", function (e) {
                      self._loadingContainer.className = "GPmapLoadingVisible";
                    });
                    vectorSource.on("tileloadend", function (e) {
                      self._loadingContainer.className = "";
                    });
                    vectorLayer.setSource(vectorSource);
                    vectorLayer.set("mapbox-extension", _tileJSONDoc["vector_layers"]);
                    (0,ol_Observable__WEBPACK_IMPORTED_MODULE_2__.unByKey)(_key);
                  }
                });
              }
            } else if (_glType === "geojson") {
              // FIXME
              // - cas avec un objet de type features ?
              // - cas avec une url relative ?
              var _glData = _glSource.data;
              vectorFormat = new _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_31__["default"]();
              vectorSource = new (ol_source_VectorTile__WEBPACK_IMPORTED_MODULE_13___default())({
                attributions: _glSource.attribution,
                format: vectorFormat,
                url: _glData
              });
              vectorSource._title = _title;
              vectorSource._description = _description;
              vectorSource._quicklookUrl = _quicklookUrl;
              vectorSource._metadata = _metadata;
              vectorSource._legends = _legends;
              vectorSource._originators = _originators;
              vectorLayer = new (ol_layer_VectorTile__WEBPACK_IMPORTED_MODULE_10___default())({
                source: vectorSource,
                visible: false,
                // zIndex: 0, // FIXME gerer l'ordre sur des multisources ?
                declutter: true // TODO utile ?
              });
              vectorLayer.id = _glSourceId;
              vectorLayer.gpResultLayerId = "layerimport:" + this._currentImportType;
            } else {
              logger.warn("Type MapBox format unknown !");
              return;
            }

            // clone
            var _glStyle = JSON.parse(JSON.stringify(_glStyles));
            // cas du multi source
            if (_multiSources) {
              // on supprime les layers inutiles
              var _glLayers = _glStyle.layers;
              for (var ii = 0; ii < _glLayers.length; ii++) {
                var _glLayer = _glLayers[ii];
                if (_glLayer.source !== _glSourceId) {
                  _glLayers.splice(ii, 1);
                  continue;
                }
              }
              // on supprime les sources inutiles
              for (var keySource in _glStyle.sources) {
                if (_glStyle.sources.hasOwnProperty(keySource)) {
                  if (keySource !== _glSourceId) {
                    delete _glStyle.sources[keySource];
                  }
                }
              }
            }

            // parametre à transmettre à la fonction auto-invoquée
            var params = {
              id: _glSourceId,
              styles: _glStyle,
              layer: vectorLayer,
              options: {
                title: layerName || _title,
                description: _description,
                quicklookUrl: _quicklookUrl,
                metadata: _metadata,
                legends: _legends,
                originators: _originators
              }
            };
            // fonction auto-invoquée
            (function (p) {
              // TODO ajouter le style de type background !
              // fonction de style de la couche
              var setStyle = function setStyle() {
                (0,ol_mapbox_style__WEBPACK_IMPORTED_MODULE_19__.applyStyle)(p.layer, p.styles, p.id).then(function () {
                  var visibility = true;
                  p.layer.setVisible(visibility);
                  var opacity = 1;
                  p.layer.setOpacity(opacity);
                }).then(function () {
                  // gestion du centre sur la carte si center renseigné !
                  var projCode = map.getView().getProjection().getCode();
                  if (map.getView() && p.styles.center && p.styles.center.length) {
                    map.getView().setCenter((0,ol_proj__WEBPACK_IMPORTED_MODULE_6__.transform)(p.styles.center, "EPSG:4326", projCode));
                  }

                  // gestion du zoom sur la carte si zoom renseigné !
                  if (map.getView() && (p.styles.zoom || p.styles.zoom === 0)) {
                    map.getView().setZoom(p.styles.zoom);
                  }

                  // zoom sur l'étendue des entités récupérées (si possible)
                  var source = p.layer.getSource();
                  if (map.getView() && map.getSize() && source.getExtent) {
                    var sourceExtent = source.getExtent();
                    if (sourceExtent && sourceExtent[0] !== Infinity) {
                      map.getView().fit(source.getExtent(), map.getSize());
                    }
                  }
                }).then(function () {
                  // on cache le panneau principal des imports
                  self._formContainer.style.display = "none";
                  self._importPanelHeader.style.display = "none";

                  // editeur de styles
                  var editor = new _Editor_Editor__WEBPACK_IMPORTED_MODULE_21__["default"]({
                    target: self._mapBoxResultsListContainer,
                    style: JSON.parse(JSON.stringify(p.styles)),
                    // clone
                    scope: this,
                    events: {
                      "editor:onloaded": self._onLoadedMapBox,
                      // utile ?
                      "editor:layer:onclickvisibility": self._onChangeVisibilitySourceMapBox,
                      "editor:style:scale:onchangemin": self._onChangeScaleMinSourceMapBox,
                      "editor:style:scale:onchangemax": self._onChangeScaleMaxSourceMapBox,
                      "editor:legend:onchangevalue": self._onChangeLegendValueSourceMapBox,
                      "editor:legend:onclickedition": self._onDisplayLayerSourceMapBox
                    },
                    tools: self.options.vectorStyleOptions.MapBox.editor
                  });
                  editor.setContext("map", map);
                  editor.setContext("layer", p.layer);
                  // creation de l'editeur
                  return editor.createElement().then(function () {
                    // exception...
                    if (editor.getLayers().length === 0) {
                      throw new Error("Il n'existe pas de styles pour la source demandée !?");
                    }
                  }).then(function () {
                    // affichage du panneau des couches accessibles à l'edition
                    if (self.options.vectorStyleOptions.MapBox.display) {
                      self._mapBoxPanel.style.display = "block";
                    }
                  }).then(function () {
                    // hack pour modifier le titre de la couche de fond
                    var elements = self._mapBoxResultsListContainer.getElementsByClassName("GPEditorMapBoxLayerTitleLabel");
                    for (var index = 0; index < elements.length; index++) {
                      var element = elements[index];
                      if (element.textContent === "bckgrd") {
                        element.textContent = "Couleur de remplissage";
                      }
                    }
                  }).then(function () {
                    // association entre le layer et l'editeur via l'id
                    p.layer.set("mapbox-editor", editor.getID());
                    // envoi d'un evenement
                    // un peu en décalé pour laisser le temps au DOM de faire le job...
                    setTimeout(function () {
                      map.dispatchEvent({
                        id: editor.getID(),
                        type: "editor:loaded",
                        style: p.styles,
                        layer: p.layer
                      });
                    }, 100);
                  })["catch"](function (e) {
                    // on propage l'exception
                    throw e;
                  });
                }).then(function () {
                  // envoi d'un evenement !
                  map.dispatchEvent({
                    id: p.id,
                    type: "render:success",
                    style: p.styles
                  });
                })["catch"](function (e) {
                  logger.error(e);
                  // envoi d'un evenement !
                  map.dispatchEvent({
                    id: p.id,
                    type: "render:failure",
                    error: e
                  });
                });
              };

              // etat des layers en cours
              logger.warn(p.layer);

              // ajout des styles dans la carte pour une utilisation
              // eventuelle (ex. editeur)
              // > map.set("mapbox-styles")
              var styles = map.get("mapbox-styles") || {};
              var id = p.id; // FIXME : construction d'un id unique
              styles[id] = p.styles;
              map.set("mapbox-styles", styles);

              // ajout des differents styles de la couche
              // pour une utilisation eventuelle (ex. editeur)
              // > layer.set("mapbox-styles")
              p.layer.set("mapbox-styles", p.styles);

              // ajout du layer sur la carte
              map.addLayer(p.layer);

              // application du style
              if (p.layer.getSource()) {
                setStyle();
              } else {
                p.layer.once("change:source", setStyle);
              }

              // maj du gestionnaire de couche
              map.getControls().forEach(function (control) {
                if (control instanceof _LayerSwitcher_LayerSwitcher__WEBPACK_IMPORTED_MODULE_33__["default"]) {
                  control.addLayer(p.layer, p.options);
                }
              });
            })(params);
          }
        }

        // TODO style par defaut au cas où l'application du style échoue !
        // TODO au niveau de la couche : minResolution et maxResolution
        // FIXME bug avec le geojson, très bizarre !?
        //      Si on desactive l'editeur, OK
        //      Sinon NOK !?
      } else {
        if (this._currentImportType === "KML") {
          // lecture du fichier KML : création d'un format ol.format.KML, qui possède une méthode readFeatures (et readProjection)
          vectorStyle = this.options.vectorStyleOptions.KML.defaultStyle;
          vectorFormat = new _Formats_KML__WEBPACK_IMPORTED_MODULE_30__["default"]({
            showPointNames: this.options.vectorStyleOptions.KML.showPointNames,
            extractStyles: this.options.vectorStyleOptions.KML.extractStyles,
            defaultStyle: [vectorStyle]
          });
        } else if (this._currentImportType === "GPX") {
          // lecture du fichier GPX : création d'un format ol.format.GPX, qui possède une méthode readFeatures (et readProjection)
          vectorStyle = this.options.vectorStyleOptions.GPX.defaultStyle;
          vectorFormat = new _Formats_GPX__WEBPACK_IMPORTED_MODULE_32__["default"]({
            defaultStyle: vectorStyle
          });
        } else if (this._currentImportType === "GeoJSON") {
          // lecture du fichier GeoJSON : création d'un format ol.format.GeoJSON, qui possède une méthode readFeatures (et readProjection)
          vectorStyle = this.options.vectorStyleOptions.GeoJSON.defaultStyle;
          vectorFormat = new _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_31__["default"]({
            defaultStyle: vectorStyle
          });
        }

        // lecture de la géométrie des entités à partir du fichier, pour éventuelle reprojection.
        var fileProj = vectorFormat.readProjection(fileContent);
        // récupération de la projection de la carte pour reprojection des géométries
        var mapProj = this._getMapProjectionCode();

        // récupération des entités avec reprojection éventuelle des géométries
        var features = null;
        features = vectorFormat.readFeatures(fileContent, {
          dataProjection: fileProj,
          featureProjection: mapProj
        });
        logger.log("loaded features : ", features);

        // création d'une couche vectorielle à partir de ces features
        vectorSource = new (ol_source_Vector__WEBPACK_IMPORTED_MODULE_14___default())({
          features: new (ol_Collection__WEBPACK_IMPORTED_MODULE_3___default())()
        });
        vectorSource.addFeatures(features);
        logger.trace(vectorSource);

        // ajout des informations pour le layerSwitcher (titre, description)
        vectorSource._title = vectorSource._description = layerName;
        vectorLayer = new (ol_layer_Vector__WEBPACK_IMPORTED_MODULE_11___default())({
          source: vectorSource,
          style: vectorStyle
        });

        // on rajoute le champ gpResultLayerId permettant d'identifier une couche crée par le composant.
        vectorLayer.gpResultLayerId = "layerimport:" + this._currentImportType;

        // cette couche est elle une couche de calcul ?
        var configControl = vectorFormat.readRootExtensions("geoportail:compute");
        if (configControl && Object.keys(configControl).length !== 0) {
          // identifier le type de calcul authorisé :
          // * route
          // * isocurve
          // * elevationpath
          var authorizedControls = {
            route: {
              "class": _Route_Route__WEBPACK_IMPORTED_MODULE_34__["default"],
              name: "itineraire"
            },
            isocurve: {
              "class": _Isocurve_Isocurve__WEBPACK_IMPORTED_MODULE_35__["default"],
              name: "isocurve"
            },
            elevationpath: {
              "class": _ElevationPath_ElevationPath__WEBPACK_IMPORTED_MODULE_36__["default"],
              name: "profil altimetrique"
            }
          };
          // information à transmettre à la couche
          var typeControl = configControl.type;
          var graphControl = configControl.transport;
          if (typeControl) {
            // la classe du controle
            var nameControl = authorizedControls[typeControl].name;
            var titleControl = graphControl ? nameControl + " (" + graphControl + ")" : nameControl;
            var classControl = authorizedControls[typeControl]["class"];
            if (classControl) {
              // on est bien sur une couche de calcul authorisé !
              vectorLayer.gpResultLayerId = "layerimport:COMPUTE";
              // on transmet les infomations utiles
              vectorLayer.set("control", typeControl);
              vectorLayer.set("name", nameControl);
              vectorLayer.set("graph", graphControl);
              vectorLayer.set("data", configControl);
              vectorLayer.set("title", titleControl);
              var formatGeoJSON = new _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_31__["default"]({
                defaultStyle: vectorStyle
              });
              var geojson = formatGeoJSON.writeFeatures(features, {
                dataProjection: "EPSG:4326",
                featureProjection: "EPSG:3857"
              });
              vectorLayer.set("geojson", geojson);
              // recherche et initialiser le controle
              this.getMap().getControls().forEach(function (control) {
                if (control instanceof classControl) {
                  control.setData(configControl);
                  control.setLayer(vectorLayer);
                  control.init();
                }
              });
            }
          }
        }
        map.addLayer(vectorLayer);

        // TODO : appeler fonction commune
        // zoom sur l'étendue des entités récupérées (si possible)
        if (map.getView() && map.getSize() && vectorSource.getExtent) {
          var sourceExtent = vectorSource.getExtent();
          if (sourceExtent && sourceExtent[0] !== Infinity) {
            map.getView().fit(vectorSource.getExtent(), map.getSize());
          }
        }
      }
    }

    /**
     * NOT USE : this method is called by _importStaticLayerFom* method
     * and add features to the map
     *
     * @param {String} url - url
     * @param {String} layerName - imported layer name
     * @private
     */
  }, {
    key: "_addFeaturesFromImportStaticLayerUrl",
    value: function _addFeaturesFromImportStaticLayerUrl(url, layerName) {
      // récupération du contenu du fichier
      var map = this.getMap();
      if (!map || !url) {
        return;
      }
      var vectorSource;
      var vectorLayer;
      var vectorFormat;
      if (this._currentImportType === "MAPBOX") {
        // TODO
        logger.trace("Not yet implemented !");
      } else {
        if (this._currentImportType === "KML") {
          // lecture du fichier KML : création d'un format ol.format.KML, qui possède une méthode readFeatures (et readProjection)
          vectorFormat = new _Formats_KML__WEBPACK_IMPORTED_MODULE_30__["default"]({
            showPointNames: true,
            // FIXME option !
            extractStyles: this.options.vectorStyleOptions.KML.extractStyles,
            defaultStyle: [this.options.vectorStyleOptions.KML.defaultStyle]
          });
        } else if (this._currentImportType === "GPX") {
          // lecture du fichier GPX : création d'un format ol.format.GPX, qui possède une méthode readFeatures (et readProjection)
          vectorFormat = new _Formats_GPX__WEBPACK_IMPORTED_MODULE_32__["default"]({
            defaultStyle: this.options.vectorStyleOptions.GPX.defaultStyle
          });
        } else if (this._currentImportType === "GeoJSON") {
          // lecture du fichier GeoJSON : création d'un format ol.format.GeoJSON, qui possède une méthode readFeatures (et readProjection)
          vectorFormat = new _Formats_GeoJSON__WEBPACK_IMPORTED_MODULE_31__["default"]({
            defaultStyle: this.options.vectorStyleOptions.GeoJSON.defaultStyle
          });
        }

        // création d'une couche vectorielle à partir de ces features
        vectorSource = new (ol_source_Vector__WEBPACK_IMPORTED_MODULE_14___default())({
          url: url,
          format: vectorFormat
        });
        if (this._currentImportType === "GPX") {
          vectorSource.forEachFeature(function (feature) {
            // si aucun style n'est associé au feature
            if (feature.getStyle() == null) {
              logger.log("[ol.control.LayerImport] set default style for GPX feature");
              feature.setStyle(this.options.vectorStyleOptions.GPX.defaultStyle);
            }
          });
        }
        if (this._currentImportType === "GeoJSON") {
          vectorSource.forEachFeature(function (feature) {
            // si aucun style n'est associé au feature
            if (feature.getStyle() == null) {
              logger.log("[ol.control.LayerImport] set default style for GeoJSON feature");
              feature.setStyle(this.options.vectorStyleOptions.GeoJSON.defaultStyle);
            }
          });
        }

        // ajout des informations pour le layerSwitcher (titre, description)
        vectorSource._title = vectorSource._description = layerName;
        vectorLayer = new (ol_layer_Vector__WEBPACK_IMPORTED_MODULE_11___default())({
          source: vectorSource
        });
      }

      // on rajoute le champ gpResultLayerId permettant d'identifier une couche crée par le composant. (pour layerSwitcher par ex)
      vectorLayer.gpResultLayerId = "layerimport:" + this._currentImportType;
      map.addLayer(vectorLayer);

      // TODO : appeler fonction commune
      // zoom sur l'étendue des entités récupérées (si possible)
      if (map.getView() && map.getSize() && vectorSource.getExtent) {
        var sourceExtent = vectorSource.getExtent();
        if (sourceExtent && sourceExtent[0] !== Infinity) {
          map.getView().fit(vectorSource.getExtent(), map.getSize());
        }
      }
    }

    // Events MapBox DOM

    /**
     * this method is called when the editor is loaded
     *
     * @param {Object} e - editor
     */
  }, {
    key: "_onLoadedMapBox",
    value: function _onLoadedMapBox(e) {
      var data = e.target.data.obj;
      var layer = this.getContext("layer");
      if (layer.get("mapbox-source") === data.source && layer.get("mapbox-editor") === e.target.editorID) {
        // some stuff..
      }
    }

    /**
     * this method is called on '_addImportMapBoxVisibilitySource' input click
     * and change visibility source to map
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "_onChangeVisibilitySourceMapBox",
    value: function _onChangeVisibilitySourceMapBox(e) {
      var data = e.target.data.obj;
      var target = e.target.srcElement;
      var layer = this.getContext("layer");

      // logger.trace(layer);
      if (layer.get("mapbox-source") === data.source && layer.get("mapbox-editor") === e.target.editorID) {
        // reload style with new param : layout.visibility : "visible" or "none"...
        var styles = layer.get("mapbox-styles");
        var layers = styles.layers;
        for (var i = 0; i < layers.length; i++) {
          if (layers[i].id === data.id) {
            var layout = layers[i].layout;
            if (layout) {
              layout.visibility = target.checked ? "visible" : "none";
            } else {
              layers[i].layout = {
                visibility: target.checked ? "visible" : "none"
              };
            }
            break;
          }
        }
        (0,ol_mapbox_style__WEBPACK_IMPORTED_MODULE_19__.applyStyle)(layer, styles, data.source).then(function () {})["catch"](function (error) {
          logger.error(error);
        });
      }
    }

    /**
     * this method is called on '_addImportMapBoxScaleSource' input slide
     * and change zoom source to map
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "_onChangeScaleMinSourceMapBox",
    value: function _onChangeScaleMinSourceMapBox(e) {
      var data = e.target.data.obj;
      var target = e.target.srcElement;
      var layer = this.getContext("layer");
      if (layer.get("mapbox-source") === data.source && layer.get("mapbox-editor") === e.target.editorID) {
        // reload style with new param : minZoom = ...
        var styles = layer.get("mapbox-styles");
        var layers = styles.layers;
        for (var i = 0; i < layers.length; i++) {
          if (layers[i].id === data.id) {
            layers[i].minzoom = target.value;
            target.title = target.value;
            break;
          }
        }
        (0,ol_mapbox_style__WEBPACK_IMPORTED_MODULE_19__.applyStyle)(layer, styles, data.source).then(function () {})["catch"](function (error) {
          logger.error(error);
        });
      }
    }

    /**
     * this method is called on '_addImportMapBoxScaleSource' input slide
     * and change zoom source to map
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "_onChangeScaleMaxSourceMapBox",
    value: function _onChangeScaleMaxSourceMapBox(e) {
      var data = e.target.data.obj;
      var target = e.target.srcElement;
      var layer = this.getContext("layer");

      // logger.trace(layer);
      if (layer.get("mapbox-source") === data.source && layer.get("mapbox-editor") === e.target.editorID) {
        // reload style with new param : minZoom = ...
        var styles = layer.get("mapbox-styles");
        var layers = styles.layers;
        for (var i = 0; i < layers.length; i++) {
          if (layers[i].id === data.id) {
            layers[i].maxzoom = target.value;
            target.title = target.value;
            break;
          }
        }
        (0,ol_mapbox_style__WEBPACK_IMPORTED_MODULE_19__.applyStyle)(layer, styles, data.source).then(function () {})["catch"](function (error) {
          logger.error(error);
        });
      }
    }

    /**
     * this method is called on ''
     * and change zoom source to map
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "_onChangeLegendValueSourceMapBox",
    value: function _onChangeLegendValueSourceMapBox(e) {
      var data = e.target.data.obj;
      var target = e.target.srcElement;
      var layer = this.getContext("layer");

      // logger.trace(layer);
      if (layer.get("mapbox-source") === data.source && layer.get("mapbox-editor") === e.target.editorID) {
        // reload style with new param :
        var styles = layer.get("mapbox-styles");
        var layers = styles.layers;
        for (var i = 0; i < layers.length; i++) {
          if (layers[i].id === data.id) {
            var paint = layers[i].paint;
            if (paint) {
              paint[target.dataset.id] = target.value;
            }
            break;
          }
        }
        (0,ol_mapbox_style__WEBPACK_IMPORTED_MODULE_19__.applyStyle)(layer, styles, data.source).then(function () {})["catch"](function (error) {
          logger.error(error);
        });
      }
    }

    /**
     * this method is called on ''
     * and change zoom source to map
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "_onDisplayLayerSourceMapBox",
    value: function _onDisplayLayerSourceMapBox(e) {
      var data = e.target.data.obj;
      var layer = this.getContext("layer");
      if (layer.get("mapbox-source") === data.source && layer.get("mapbox-editor") === e.target.editorID) {
        var idDOM = e.target.currentTarget.parentNode.id;
        var id = idDOM.substring(idDOM.indexOf("-") + 1, idDOM.indexOf("_"));
        var l = this.getLayer(id);
        l.collapse();
      }
    }

    // ################################################################### //
    // #################### Import WMS/WMTS layers ####################### //
    // ################################################################### //

    /**
     * this method is called by this_onImportSubmit method
     * and call getCap service from specified url, then display layers list in new panel
     *
     * @private
     */
  }, {
    key: "_importServiceLayers",
    value: function _importServiceLayers() {
      if (this._currentImportType === "WFS") {
        logger.warn("[ol.control.LayerImport] WFS layer import is not implemented yet");
        return;
      }

      // 0. on vide d'éventuels résultats précédents dans le panel GetCapResults
      this.cleanGetCapResultsList();

      // 1. récupération de l'url renseignée
      var url = this._getCapRequestUrl = this._serviceUrlImportInput.value;
      if (!url) {
        logger.error("[ol.control.LayerImport] url parameter is mandatory");
        return;
      }
      logger.log("url : ", url);

      // on supprime les éventuels espaces avant ou après
      if (url.trim) {
        url = url.trim();
      }
      // Info : on ajoute des paramètres uniquement si l'utilisateur n'en a pas déjà saisi (on vérifie la position du caractère "?")
      var questionMarkIndex = url.indexOf("?");
      if (questionMarkIndex < 0) {
        // dans le cas d'une url du type https://data.geopf.fr/wmts
        url += "?SERVICE=" + this._currentImportType + "&REQUEST=GetCapabilities";
      } else if (questionMarkIndex === url.length - 1) {
        // dans le cas où l'url se termine par "?"
        url += "SERVICE=" + this._currentImportType + "&REQUEST=GetCapabilities";
      }
      // si on n'est pas dans ces deux cas : l'utilisateur a déjà saisit des paramètres après "?" => on ne fait rien.

      // 2. récupération proxy
      if (this.options.webServicesOptions && this.options.webServicesOptions.proxyUrl) {
        url = _Utils_ProxyUtils__WEBPACK_IMPORTED_MODULE_28__["default"].proxifyUrl(url, this.options.webServicesOptions);
      }

      // 3. affichage d'une patience le temps de la requête
      this._displayWaitingContainer();

      // 4. send getcapabilities request (XHR protocol => proxy Url is needed)
      var context = this;
      geoportal_access_lib__WEBPACK_IMPORTED_MODULE_20__["default"].Protocols.XHR.call({
        url: url,
        method: "GET",
        timeOut: 15000,
        // on success callback : display results in container
        onResponse: function onResponse(response) {
          context._hideWaitingContainer();
          context._displayGetCapResponseLayers(response);
        },
        // on error callback : log error
        onFailure: function onFailure(error) {
          // en cas d'erreur, on revient au panel initial et on cache la patience
          context._hideWaitingContainer();
          logger.error("[ol.control.LayerImport] getCapabilities request failed : ", error);
        }
      });
    }

    /**
     * this method is called by this._importServiceLayers method
     * and display layers list from getcapabilities response
     *
     * @param {Object} xmlResponse - getCapabilities response (xml format)
     * @private
     */
  }, {
    key: "_displayGetCapResponseLayers",
    value: function _displayGetCapResponseLayers(xmlResponse) {
      var parser;
      var layers;
      var layerDescription = {
        content: null,
        title: null
      };
      var projection;
      this._getCapResponseWMSLayers = [];

      // sauvegarde du content d'un GetCapabilities
      this.contentService = xmlResponse;

      // Affichage du panel des couches accessibles
      this._importPanel.style.display = "none";
      this._getCapPanel.style.display = "block";

      // Parse GetCapabilities Response
      if (this._currentImportType === "WMS") {
        parser = new (ol_format_WMSCapabilities__WEBPACK_IMPORTED_MODULE_8___default())();
        var getCapResponseWMS = this._getCapResponseWMS = parser.read(xmlResponse);
        logger.log("getCapabilities response : ", getCapResponseWMS);
        if (getCapResponseWMS && getCapResponseWMS.Capability && getCapResponseWMS.Capability.Layer) {
          // info: le parser Openlayers récupère la première layer de <Capability> comme un unique objet (il écrase les précédents s'il y a pls <Layer> à la racine de <Capability>)
          // /!\ être vigilant si le parser est modifié (notamment pour récupérer les différentes layers à la racine. ex  http://geoservices.brgm.fr/geologie?SERVICE=WMS&VERSION=1.3.0&REQUEST=GetCapabilities)

          var getCapLayer = getCapResponseWMS.Capability.Layer;
          // on va lire le contenu de la (ou les) <Layer> pour l'afficher ou en afficher les couches disponibles
          if (Array.isArray(getCapLayer)) {
            // cas où on a plusieurs <Layer> à la racine, mais non géré encore par ol.format.WMSCapabilities jusqu'à la v3.18.2.
            for (var i = 0; i < getCapLayer.length; i++) {
              this._displayGetCapResponseWMSLayer(getCapLayer[i]);
            }
          } else {
            // cas du parser ol.format.WMSCapabilities jusqu'à la v3.18.2.
            this._displayGetCapResponseWMSLayer(getCapLayer);
          }
        }
      } else if (this._currentImportType === "WMTS") {
        parser = new (ol_format_WMTSCapabilities__WEBPACK_IMPORTED_MODULE_9___default())();
        var getCapResponseWMTS = this._getCapResponseWMTS = parser.read(xmlResponse);
        logger.log("getCapabilities response : ", getCapResponseWMTS);
        if (getCapResponseWMTS && getCapResponseWMTS.Contents && getCapResponseWMTS.Contents.Layer) {
          layers = getCapResponseWMTS.Contents.Layer;
          if (Array.isArray(layers)) {
            // on stocke la liste des couches pour faire le lien avec le DOM
            this._getCapResponseWMTSLayers = layers;
            for (var j = 0; j < layers.length; j++) {
              // on vérifie que la projection de la couche WMTS est compatible avec celle de la carte
              // (ie elle doit être connue par ol.proj)
              projection = this._getWMTSLayerProjection(layers[j], getCapResponseWMTS);
              if (projection && typeof projection === "string") {
                if ((0,ol_proj__WEBPACK_IMPORTED_MODULE_6__.get)(projection) || (0,ol_proj__WEBPACK_IMPORTED_MODULE_6__.get)(projection.toUpperCase())) {
                  // si la projection de la couche est connue par ol.proj,
                  // on ajoute chaque couche de la réponse dans la liste des couches accessibles
                  layerDescription = {
                    content: layers[j].Title,
                    title: layers[j].Abstract || layers[j].Title
                  };
                  if (this._getCapResultsListContainer) {
                    this._addImportGetCapResultLayer(layerDescription, j, this._getCapResultsListContainer);
                  }
                } else {
                  // si la projection de la couche n'est pas connue par ol.proj,
                  // on n'affiche pas la couche dans le panel des résultats
                  logger.warn("[ol.control.LayerImport] wmts layer cannot be added to map : unknown projection", layers[j]);
                  continue;
                }
              }
            }
          }
        }
      }
    }

    /**
     * this method is called by this._displayGetCapResponseLayers method
     * and display WMS layer in list from getcapabilities response
     *
     * @param {Object} layerObj - object corresponding to <Layer> content in WMS GetCapabilities response
     * @param {Object} [parentLayersInfos] - object corresponding to parents <Layer> content in WMS GetCapabilities response (without children <Layer> infos)
     * @private
     */
  }, {
    key: "_displayGetCapResponseWMSLayer",
    value: function _displayGetCapResponseWMSLayer(layerObj, parentLayersInfos) {
      if (!layerObj) {
        logger.warn("[ol.control.LayerImport] _displayGetCapResponseWMSLayer : getCapabilities layer object not found");
        return;
      }
      logger.log("[ol.control.LayerImport] _displayGetCapResponseWMSLayer - layerObj : ", layerObj);

      // récupération de la projection de la map (pour vérifier que l'on peut reprojeter les couches disponibles)
      var mapProjCode = this._getMapProjectionCode();
      var projection;
      var layerDescription = {
        content: null,
        title: null
      };

      // 1. héritage éventuels des informations de la couche parent
      if (parentLayersInfos) {
        var key;
        var i;

        // propriétés héritées à ajouter aux propriétés parent
        var addKeys = ["CRS", "Style"
        // "AuthorityURL" // TODO
        ];
        for (i = 0; i < addKeys.length; i++) {
          key = addKeys[i];
          if (Array.isArray(parentLayersInfos[key]) && parentLayersInfos[key].length !== 0) {
            if (Array.isArray(layerObj[key]) && layerObj[key].length !== 0) {
              // on ajoute celles de la couche parent
              for (var n = 0; n < parentLayersInfos[key].length; n++) {
                if (layerObj[key].indexOf(parentLayersInfos[key][n]) === -1) {
                  // si le CRS/Style parent n'est pas dans les CRS/Style de la couche, on l'ajoute
                  layerObj[key].push(parentLayersInfos[key][n]);
                }
              }
            } else {
              // si la couche n'a pas de CRS ou Style, on récupère ceux de la couche parent
              layerObj[key] = parentLayersInfos[key];
            }
          }
        }

        // propriétés qui remplacent les valeurs des propriétés héritées,
        // càd on récupère la propriété parent seulement si elle n'est pas définie pour l'élément enfant
        var replaceKeys = ["BoundingBox", "EX_GeographicBoundingBox", "MaxScaleDenominator", "MinScaleDenominator", "Attribution", "Dimension", "queryable", "cascaded", "opaque", "noSubsets", "fixedWidth", "fixedHeight"];
        for (i = 0; i < replaceKeys.length; i++) {
          key = replaceKeys[i];
          if (parentLayersInfos[key] && !layerObj[key]) {
            layerObj[key] = parentLayersInfos[key];
          }
        }
      } else {
        // si on n'a pas d'infos de couche parent, on est à la racine du Capability, on le note
        layerObj._isRootLayer = true;
        layerObj._container = this._getCapResultsListContainer;
        if (!layerObj.Title) {
          layerObj.Title = "Liste des couches";
        }
      }

      // 2. si on a d'autres couches <Layer> imbriquées, on descend d'un niveau, sinon on affiche la couche dans la liste des résultats
      if (layerObj.Layer) {
        if (Array.isArray(layerObj.Layer)) {
          var _container = layerObj ? layerObj._container : parentLayersInfos._container;
          var _title = layerObj ? layerObj.Title : parentLayersInfos.Title;
          layerObj._container = this._addImportGetCapResultListRubrique(_title, _container).lastChild;
          for (var j = 0; j < layerObj.Layer.length; j++) {
            // on recommence pour chaque sous couche, avec les infos éventuellement héritées
            var bRubriqueExist = false;
            var lstRubrique = layerObj._container.getElementsByClassName("GPimportGetCapRubriqueTitle");
            for (var ii = 0; ii < lstRubrique.length; ii++) {
              if (lstRubrique[ii].title === layerObj.Title) {
                bRubriqueExist = true;
                layerObj.Layer[j]._container = lstRubrique[ii].parentElement;
              }
            }
            if (!bRubriqueExist) {
              layerObj.Layer[j]._container = this._addImportGetCapResultRubrique(layerObj.Title, layerObj._container).lastChild;
            }
            this._displayGetCapResponseWMSLayer(layerObj.Layer[j], layerObj);
          }
        }
      } else {
        // on récupère la longueur de la liste des couches déjà récupérées, pour avoir ce qui sera l'index de la couche à ajouter.
        var lastIndex = this._getCapResponseWMSLayers.length;

        // on vérifie que la couche ait une projection compatible avec celle de la carte
        // ou soit connue par proj4js, et on stocke cette projection dans les infos de la couche.
        projection = this._getWMSLayerProjection(layerObj, mapProjCode);
        if (!projection) {
          // si aucune projection n'est compatible avec celle de la carte ou connue par ol.proj,
          // on n'affiche pas la couche dans le panel des résultats
          logger.warn("[ol.control.LayerImport] wms layer cannot be added to map : unknown projection", layerObj);
        } else {
          // si on a une projection compatible : on la stocke et la couche sera éventuellement reprojetée à l'ajout
          layerObj._projection = projection;
          // on ajoute chaque couche de la réponse dans la liste des couches accessibles
          layerDescription = {
            content: layerObj.Title,
            title: layerObj.Abstract || layerObj.Title
          };
          // FIXME beurk !?
          var _isGoodContainer = layerObj._container;
          if (_isGoodContainer.localName === "ul") {
            _isGoodContainer = _isGoodContainer.lastChild;
          }
          this._addImportGetCapResultLayer(layerDescription, lastIndex, _isGoodContainer);

          // puis on stoke la couche dans la liste pour faire le lien avec le DOM
          this._getCapResponseWMSLayers[lastIndex] = layerObj;
        }
      }
    }

    /**
     * this method is called on 'GPimportGetCapProposal' div click
     * and add corresponding layer to map
     *
     * @param {Object} e - HTMLElement
     * @private
     */
  }, {
    key: "_onGetCapResponseLayerClick",
    value: function _onGetCapResponseLayerClick(e) {
      if (e.target && e.target.id) {
        var proposalId = parseInt(e.target.id.substr(23), 10);
        if (isNaN(proposalId)) {
          return;
        }
        var layerInfo;
        if (this._currentImportType === "WMS") {
          // récupération des informations liées à la couche
          layerInfo = this._getCapResponseWMSLayers[proposalId];
          // ajout de la couche à la carte
          this._addGetCapWMSLayer(layerInfo);
        } else if (this._currentImportType === "WMTS") {
          // récupération des informations liées à la couche
          layerInfo = this._getCapResponseWMTSLayers[proposalId];
          // ajout de la couche à la carte
          this._addGetCapWMTSLayer(layerInfo);
        }
      }
    }

    // ################################################################### //
    // ######### create WMS layer from getCapabilities response ######### //
    // ################################################################### //

    /**
     * this method is called by this._onGetCapResponseLayerClick
     * and add WMS layer to map using parameters from getCapabilities response
     *
     * @param {Object} layerInfo - layer information from getCapabilities response
     * @private
     */
  }, {
    key: "_addGetCapWMSLayer",
    value: function _addGetCapWMSLayer(layerInfo) {
      var map = this.getMap();
      if (!map) {
        logger.warn("[ol.control.LayerImport] _addGetCapWMSLayer error : map is not defined");
        return;
      }
      if (!layerInfo) {
        logger.warn("[ol.control.LayerImport] _addGetCapWMSLayer error : layerInfo is not defined");
        return;
      }

      // récupération de la projection de la carte
      var mapProjCode = this._getMapProjectionCode();
      var wmsSourceOptions = {};

      // Récupération de l'url
      var getMapUrl = this._getWMSLayerGetMapUrl();
      // on essaie de récupérer l'url du service dans le getCapbilities
      if (getMapUrl) {
        wmsSourceOptions.url = getMapUrl;
      } else {
        // sinon, on récupère l'url du getCapabilities, à laquelle on enlève éventuellement les paramètres
        var questionMarkIndex = this._getCapRequestUrl.indexOf("?");
        if (questionMarkIndex !== -1) {
          wmsSourceOptions.url = this._getCapRequestUrl.substring(0, questionMarkIndex);
        } else {
          wmsSourceOptions.url = this._getCapRequestUrl;
        }
      }
      wmsSourceOptions.params = {};
      if (layerInfo.Name) {
        wmsSourceOptions.params["LAYERS"] = layerInfo.Name;
      } else {
        logger.warn("[ol.control.LayerImport] unable to add wms layer : mandatory layer 'name' parameter cannot be found", layerInfo);
        return;
      }
      wmsSourceOptions.params["SERVICE"] = "WMS";
      if (this._getCapResponseWMS.version) {
        wmsSourceOptions.params["VERSION"] = this._getCapResponseWMS.version;
      }

      // on a déjà vérifié que la couche peut être reprojetée,
      // on vérifie que la couche ait une projection compatible avec celle de la carte
      // ou soit connue par proj4js
      var projection = layerInfo._projection;
      if (!projection) {
        logger.warn("[ol.control.LayerImport] wms layer cannot be added to map : unknown projection");
        return;
      } else if (projection !== mapProjCode) {
        // si la projection de la carte n'est pas disponible pour cette couche,
        // on spécifie une projection (qui doit avoir été définie dans proj4js) pour reprojection par Openlayers
        wmsSourceOptions.projection = projection;
      }

      // récupération du premier style disponible (pas d'info default?)
      var legend;
      if (layerInfo.Style && Array.isArray(layerInfo.Style)) {
        var style = layerInfo.Style[0];
        wmsSourceOptions.params["STYLES"] = style.Name;
        if (style.LegendURL && Array.isArray(style.LegendURL) && style.LegendURL.length !== 0) {
          legend = style.LegendURL[0].OnlineResource;
        }
      }

      // Création de la source (tester un try catch ?)
      var wmsSource = new (ol_source_TileWMS__WEBPACK_IMPORTED_MODULE_15___default())(wmsSourceOptions);
      // ajout des informations pour le layerSwitcher (titre, description, legendes, metadata) ou originators
      this._getWMSLayerInfoForLayerSwitcher(layerInfo, legend, wmsSource);
      var layerTileOptions = {};
      layerTileOptions["source"] = wmsSource;
      // récupération des résolutions min et max de la layer à partir des dénominateurs d'échelle
      this._getWMSLayerMinMaxResolution(layerInfo, mapProjCode, layerTileOptions);
      // récupération de l'étendue (bbox)
      this._getWMSLayerExtent(layerInfo, mapProjCode, layerTileOptions);

      // création de la couche à partir de la source
      var wmsLayer = new (ol_layer_Tile__WEBPACK_IMPORTED_MODULE_12___default())(layerTileOptions);
      // on rajoute le champ gpResultLayerId permettant d'identifier une couche crée par le composant. (pour layerSwitcher par ex)
      wmsLayer.gpResultLayerId = "layerimport:WMS";
      // on rajoute le champ gpGFIparams permettant d'identifier si la couche est queryable, et de transmettre les formats reconnus par GetFeatureInfo
      if (layerInfo.queryable) {
        wmsLayer.gpGFIparams = {
          queryable: true
        };
        // récupération des différents formats reconnus par le GetFeatureInfo
        if (this._getCapResponseWMS && this._getCapResponseWMS.Capability && this._getCapResponseWMS.Capability.Request && this._getCapResponseWMS.Capability.Request.GetFeatureInfo && this._getCapResponseWMS.Capability.Request.GetFeatureInfo.Format && Array.isArray(this._getCapResponseWMS.Capability.Request.GetFeatureInfo.Format)) {
          wmsLayer.gpGFIparams.formats = this._getCapResponseWMS.Capability.Request.GetFeatureInfo.Format;
        }
      }
      map.addLayer(wmsLayer);
    }

    /**
     * this method is called by this._addGetCapWMSLayer
     * and gets service getMap request url
     *
     * @return {String} getmapurl - service getMap request url
     * @private
     */
  }, {
    key: "_getWMSLayerGetMapUrl",
    value: function _getWMSLayerGetMapUrl() {
      var getmapurl;
      if (this._getCapResponseWMS && this._getCapResponseWMS.Capability && this._getCapResponseWMS.Capability.Request && this._getCapResponseWMS.Capability.Request.GetMap) {
        var getmap = this._getCapResponseWMS.Capability.Request.GetMap;
        if (getmap.DCPType && Array.isArray(getmap.DCPType) && getmap.DCPType.length !== 0) {
          var url = getmap.DCPType[0];
          if (url && url.HTTP && url.HTTP.Get) {
            getmapurl = url.HTTP.Get.OnlineResource;
          }
        }
      }
      return getmapurl;
    }

    /**
     * this method is called by this._addGetCapWMSLayer
     * and gets a projection both available for a given layer and already defined in proj4js (ol.proj)
     * (openlayers raster reprojection will be then able to reproject layer in map projection)
     *
     * @param {Object} layerInfo - layer information from getCapabilities response
     * @param {String} mapProjCode - map projection code (e.g. "EPSG:4326")
     * @return {String} projection - ol.proj projection alias (e.g. "EPSG:4326")
     * @private
     */
  }, {
    key: "_getWMSLayerProjection",
    value: function _getWMSLayerProjection(layerInfo, mapProjCode) {
      var projection;
      if (!layerInfo || _typeof(layerInfo) !== "object") {
        logger.warn("missing layer information (from getCapabilities)");
        return;
      }

      // on va parcourir la liste des CRS disponibles pour la couche
      // si on trouve la projection de la carte : c'est parfait
      // si on trouve une projection qui est connue par ol.proj : Openlayers gère la reprojection
      var CRSList = layerInfo.CRS;
      if (Array.isArray(CRSList)) {
        // on check si la projection de la carte est dans le tableau de projections issues du getCap,
        // si oui, on la prend
        if (CRSList.includes(mapProjCode)) {
          projection = mapProjCode;
          return projection;
        }
        var layerCRS, i;
        // si aucune projection du getCap pour la couche n'est égale à celle de la carte
        // on retourne la première projection listée dans le getCap qui est gérée par openLayers
        for (i = 0; i < CRSList.length; i++) {
          layerCRS = CRSList[i];
          if (layerCRS && typeof layerCRS === "string") {
            if ((0,ol_proj__WEBPACK_IMPORTED_MODULE_6__.get)(layerCRS) || (0,ol_proj__WEBPACK_IMPORTED_MODULE_6__.get)(layerCRS.toUpperCase())) {
              projection = layerCRS;
              // on renvoie la première projection gérée par openLayers
              return projection;
            }
          }
        }
      }
      // si la liste des projections n'est pas un tableau ou si aucune projection n'est égale à celle de la carte ou si aucune n'est gérée par openLayers
      // on return undefined (comportement d'origine de la fonction)
      return projection;
    }

    /**
     * this method is called by this._addGetCapWMSLayer
     * and sets minResolution and maxResolution parameters for WMS layer (if available in getCapabilities response)
     *
     * @param {Object} layerInfo - layer information from getCapabilities response
     * @param {String} mapProjCode - map projection code (e.g. "EPSG:4326")
     * @param {Object} layerTileOptions - options for ol.layer.Tile (to be filled)
     * @private
     */
  }, {
    key: "_getWMSLayerMinMaxResolution",
    value: function _getWMSLayerMinMaxResolution(layerInfo, mapProjCode, layerTileOptions) {
      // récupération des résolutions min et max à partir des dénominateurs d'échelle
      var mapUnits = (0,ol_proj__WEBPACK_IMPORTED_MODULE_6__.get)(mapProjCode).getUnits();
      if (mapUnits === "m") {
        // info : 1 pixel = 0.00028 m
        if (layerInfo.MinScaleDenominator) {
          layerTileOptions.minResolution = layerInfo.MinScaleDenominator * 0.00028;
        }
        if (layerInfo.MaxScaleDenominator) {
          layerTileOptions.maxResolution = layerInfo.MaxScaleDenominator * 0.00028;
        }
      } else if (mapUnits === "degrees") {
        // info : 6378137 * 2 * pi / 360 = rayon de la terre (ellipsoide WGS84)
        var cste = 0.00028 * 180 / (Math.PI * 6378137);
        if (layerInfo.MinScaleDenominator) {
          layerTileOptions.minResolution = layerInfo.MinScaleDenominator * cste;
        }
        if (layerInfo.MaxScaleDenominator) {
          layerTileOptions.maxResolution = layerInfo.MaxScaleDenominator * cste;
        }
      }
    }

    /**
     * this method is called by this._addGetCapWMSLayer
     * and sets extent for WMS layer in map projection (if available in getCapabilities response)
     *
     * @param {Object} layerInfo - layer information from getCapabilities response
     * @param {String} mapProjCode - map projection code (e.g. "EPSG:4326")
     * @param {Object} layerTileOptions - options for ol.layer.Tile (to be filled)
     * @private
     */
  }, {
    key: "_getWMSLayerExtent",
    value: function _getWMSLayerExtent(layerInfo, mapProjCode, layerTileOptions) {
      if (!layerInfo) {
        logger.warn("[ol.control.LayerImport] _getWMSLayerExtent error : layerInfo is not defined");
        return;
      }

      // récupération des 2 propriétés qui peuvent spécifier l'étendue (bbox) selon les specs OGC WMS 1.3.0 :
      // 1. layerInfo.EX_GeographicBoundingBox est un tableau de type [westBoundLongitude, southBoundLatitude, eastBoundLongitude, northBoundLatitude] en WGS84
      var exGeographicBoundingBox = layerInfo["EX_GeographicBoundingBox"];
      // 2. layerInfo.BoundingBox est un tableau dont chaque élément est un objet (balise bbox) avec les propriétés suivantes :
      // crs (String) et extent (tableau de type [minx, miny, maxx, maxy])
      var boundingBox = layerInfo.BoundingBox;
      if (exGeographicBoundingBox && Array.isArray(exGeographicBoundingBox)) {
        if (mapProjCode === "EPSG:4326") {
          // si la projection de la carte est la même que celle de l'extent (EPSG:4326), on la passe telle quelle
          layerTileOptions.extent = exGeographicBoundingBox;
        } else {
          layerTileOptions.extent = (0,ol_proj__WEBPACK_IMPORTED_MODULE_6__.transformExtent)(exGeographicBoundingBox, "EPSG:4326", mapProjCode);
        }

        // si jamais EX_GeographicBoundingBox n'est pas ou est mal renseigné, on essaie de récupérer via le paramètre BoundingBox
      } else if (boundingBox && Array.isArray(boundingBox)) {
        var crs;
        var extent;
        for (var i = 0; i < boundingBox.length; i++) {
          // on peut avoir plusieurs BoundingBox
          crs = boundingBox[i].crs;
          extent = boundingBox[i].extent;
          if (crs) {
            if (crs === mapProjCode) {
              // si la bbox est dans la projection de la carte, on la passe telle quelle
              layerTileOptions.extent = extent;
              break;
            } else {
              if (typeof crs === "string") {
                var olProj = (0,ol_proj__WEBPACK_IMPORTED_MODULE_6__.get)(crs) ? (0,ol_proj__WEBPACK_IMPORTED_MODULE_6__.get)(crs) : (0,ol_proj__WEBPACK_IMPORTED_MODULE_6__.get)(crs.toUpperCase());
                // if ( olGetProj(crs) || olGetProj(crs.toUpperCase()) ) {
                if (olProj) {
                  // si la bbox est dans une projection connue, on va la reprojeter
                  // tout d'abord, on gère le cas des systèmes EPSG géographiques : inversion des axes x et y
                  if (olProj.getUnits() === "degrees" && crs.toUpperCase().indexOf("EPSG") === 0) {
                    // le tableau extent est inversé, on a besoin de : [miny, minx, maxx, maxy]
                    var reversedExtent = [extent[1], extent[0], extent[3], extent[2]];
                    layerTileOptions.extent = (0,ol_proj__WEBPACK_IMPORTED_MODULE_6__.transformExtent)(reversedExtent, olProj, mapProjCode);
                  } else {
                    // reprojection dans la projection de la carte
                    layerTileOptions.extent = (0,ol_proj__WEBPACK_IMPORTED_MODULE_6__.transformExtent)(extent, olProj, mapProjCode);
                  }
                  break;
                }
              }
            }
          }
        }
      }
    }

    /**
     * this method is called by this._addGetCapWMSLayer
     * and sets more information about layer (legends, title, description, metadata, originators) for layerSwitcher or attributions controls
     *
     * @param {Object} layerInfo - layer information from getCapabilities response
     * @param {String} legend - legend url
     * @param {Object} wmsSource - options for ol.source.TileWMS (to be filled)
     * @private
     */
  }, {
    key: "_getWMSLayerInfoForLayerSwitcher",
    value: function _getWMSLayerInfoForLayerSwitcher(layerInfo, legend, wmsSource) {
      // ajout des informations pour le layerSwitcher (titre, description)
      if (layerInfo.Title) {
        wmsSource._title = layerInfo.Title;
        wmsSource._description = layerInfo.Abstract ? layerInfo.Abstract : layerInfo.Title;
      } else {
        wmsSource._title = layerInfo.Name;
        wmsSource._description = layerInfo.Abstract ? layerInfo.Abstract : layerInfo.Name;
      }
      // ajout de légende si on en a trouvé
      if (legend) {
        wmsSource._legends = [{
          url: legend
        }];
      }
      // ajout d'éventuelles métadonnées
      if (layerInfo.MetadataURL && Array.isArray(layerInfo.MetadataURL)) {
        wmsSource._metadata = [];
        for (var i = 0; i < layerInfo.MetadataURL.length; i++) {
          var metadata = layerInfo.MetadataURL[i].OnlineResource;
          if (metadata) {
            wmsSource._metadata.push({
              url: metadata
            });
          }
        }
      }
      // ajout d'éventuelles attributions / originators
      if (layerInfo.Attribution) {
        var attribution = layerInfo.Attribution;
        wmsSource._originators = {};
        if (attribution.OnlineResource) {
          wmsSource._originators.url = attribution.OnlineResource;
        }
        if (attribution.Title) {
          wmsSource._originators.name = wmsSource._originators.attribution = attribution.Title;
        }
        if (attribution.LogoURL && attribution.LogoURL.OnlineResource) {
          wmsSource._originators.logo = attribution.LogoURL.OnlineResource;
        }
      }
    }

    // ################################################################### //
    // ######### create WMTS layer from getCapabilities response ######### //
    // ################################################################### //

    /**
     * this method is called by this._onGetCapResponseLayerClick
     * and add WMTS layer to map using parameters from getCapabilities response
     *
     * @param {Object} layerInfo - layer information from getCapabilities response
     * @private
     */
  }, {
    key: "_addGetCapWMTSLayer",
    value: function _addGetCapWMTSLayer(layerInfo) {
      if (!layerInfo || !layerInfo.Identifier) {
        logger.warn("[ol.control.LayerImport] layer information not found in getCapabilities response for layer ");
        return;
      }
      var map = this.getMap();
      if (!map) {
        return;
      }
      var wmtsSourceOptions = {};
      wmtsSourceOptions.layer = layerInfo.Identifier;
      // service version
      if (this._getCapResponseWMTS.version) {
        wmtsSourceOptions.version = this._getCapResponseWMTS.version;
      }
      // Récupération de l'url
      var getMapUrl = this._getWMTSLayerGetTileUrl();
      // on essaie de récupérer l'url du service dans le getCapbilities
      if (getMapUrl) {
        wmtsSourceOptions.url = getMapUrl;
      } else {
        // sinon, on récupère l'url du getCapabilities, à laquelle on enlève éventuellement les paramètres
        var questionMarkIndex = this._getCapRequestUrl.indexOf("?");
        if (questionMarkIndex !== -1) {
          wmtsSourceOptions.url = this._getCapRequestUrl.substring(0, questionMarkIndex);
        } else {
          wmtsSourceOptions.url = this._getCapRequestUrl;
        }
      }

      // Récupération des informations de la pyramide (tileGrid information) : matrixIds, resolutions, origin et projection
      var tmsOptions = this._getTMSParams(layerInfo);
      wmtsSourceOptions.matrixSet = tmsOptions.tms;
      wmtsSourceOptions.projection = tmsOptions.projCode;
      wmtsSourceOptions.tileGrid = new (ol_tilegrid_WMTS__WEBPACK_IMPORTED_MODULE_5___default())({
        resolutions: tmsOptions.resolutions,
        matrixIds: tmsOptions.matrixIds,
        origin: tmsOptions.origin
      });

      // Récupération du style par défaut
      var defaultStyle;
      var legend;
      if (layerInfo.Style && Array.isArray(layerInfo.Style)) {
        var style;
        for (var s = 0; s < layerInfo.Style.length; s++) {
          style = layerInfo.Style[s];
          // on récupère le style
          defaultStyle = style.Identifier;
          if (style.isDefault) {
            // si c'est celui par défaut, on le garde (on ne boucle plus sur les autres styles)
            break;
          }
          // et une éventuelle légende
          if (style.LegendURL && Array.isArray(style.LegendURL) && style.LegendURL.length !== 0) {
            legend = style.LegendURL[0].href;
          }
        }
      }
      if (defaultStyle == null) {
        logger.warn("[ol.control.LayerImport] style information not found in getCapabilities response for layer " + layerInfo.Identifier);
      }
      wmtsSourceOptions.style = defaultStyle;

      // Récupération du format (le premier trouvé)
      var format;
      if (layerInfo.Format && Array.isArray(layerInfo.Format)) {
        format = layerInfo.Format[0];
      }
      if (format == null) {
        logger.warn("[ol.control.LayerImport] format information not found in getCapabilities response for layer " + layerInfo.Identifier);
      }
      wmtsSourceOptions.format = format;

      // Création de la source (tester un try catch ?)
      var wmtsSource = new (ol_source_WMTS__WEBPACK_IMPORTED_MODULE_16___default())(wmtsSourceOptions);

      // ajout des informations pour le layerSwitcher (titre, description)
      if (layerInfo.Title) {
        wmtsSource._title = layerInfo.Title;
        wmtsSource._description = layerInfo.Abstract ? layerInfo.Abstract : layerInfo.Title;
      } else {
        wmtsSource._title = layerInfo.Identifier;
        wmtsSource._description = layerInfo.Abstract ? layerInfo.Abstract : layerInfo.Identifier;
      }
      // ajout d'une éventuelle légende
      if (legend) {
        wmtsSource._legends = [{
          url: legend
        }];
      }
      var layerTileOptions = {};
      layerTileOptions.source = wmtsSource;
      // récupération de l'étendue (bbox)
      layerTileOptions.extent = this._getWMTSLayerExtent(layerInfo);
      var wmtsLayer;
      try {
        wmtsLayer = new (ol_layer_Tile__WEBPACK_IMPORTED_MODULE_12___default())(layerTileOptions);
      } catch (e) {
        logger.warn("[ol.control.LayerImport] an error occured while trying to create ol.layer.Tile from getCapabilities information. error : ", e);
        return;
      }
      // on rajoute le champ gpResultLayerId permettant d'identifier une couche crée par le composant. (pour layerSwitcher par ex)
      wmtsLayer.gpResultLayerId = "layerimport:WMTS";
      map.addLayer(wmtsLayer);
    }

    /**
     * this method is called by this._addGetCapWMTSLayer
     * and gets service getTile request url
     *
     * @return {String} gettileurl - service getTile request url
     * @private
     */
  }, {
    key: "_getWMTSLayerGetTileUrl",
    value: function _getWMTSLayerGetTileUrl() {
      var gettileurl;
      if (this._getCapResponseWMTS && this._getCapResponseWMTS.OperationsMetadata && this._getCapResponseWMTS.OperationsMetadata.GetTile) {
        var gettile = this._getCapResponseWMTS.OperationsMetadata.GetTile;
        if (gettile.DCP && gettile.DCP.HTTP && gettile.DCP.HTTP.Get && Array.isArray(gettile.DCP.HTTP.Get) && gettile.DCP.HTTP.Get.length !== 0) {
          gettileurl = gettile.DCP.HTTP.Get[0].href;
        }
      }
      return gettileurl;
    }

    /**
     * this method is called by this._displayGetCapResponseLayers
     * and gets layer TileMatrixSet projection if defined in proj4js
     *
     * @param {Object} layerInfo - layer information from getCapabilities response
     * @param {Object} getCapResponseWMTS - whole getCapabilities response
     * @return {String} projection - ol.proj projection alias (e.g. "EPSG:4326")
     * @private
     */
  }, {
    key: "_getWMTSLayerProjection",
    value: function _getWMTSLayerProjection(layerInfo, getCapResponseWMTS) {
      var projection;
      if (!layerInfo || _typeof(layerInfo) !== "object") {
        logger.warn("missing layer information (from getCapabilities)");
        return;
      }
      if (!getCapResponseWMTS || _typeof(getCapResponseWMTS) !== "object") {
        logger.warn("missing getCapabilities response");
        return;
      }
      if (layerInfo.TileMatrixSetLink && Array.isArray(layerInfo.TileMatrixSetLink)) {
        var tms = layerInfo.TileMatrixSetLink[0].TileMatrixSet;
        var crs;
        if (getCapResponseWMTS.Contents && Array.isArray(getCapResponseWMTS.Contents.TileMatrixSet)) {
          var tileMatrixSets = getCapResponseWMTS.Contents.TileMatrixSet;
          for (var i = 0; i < tileMatrixSets.length; i++) {
            if (tileMatrixSets[i].Identifier === tms && tileMatrixSets[i].TileMatrix) {
              // on a trouvé le TMS correspondant
              var tileMatrixSet = tileMatrixSets[i];
              crs = tileMatrixSet.SupportedCRS;
              if (crs && typeof crs === "string") {
                if ((0,ol_proj__WEBPACK_IMPORTED_MODULE_6__.get)(crs) || (0,ol_proj__WEBPACK_IMPORTED_MODULE_6__.get)(crs.toUpperCase())) {
                  projection = crs;
                }
              }
              break;
            }
          }
        }
      }
      ;
      return projection;
    }

    /**
     * this method is called by this._addGetCapWMTSLayer
     * and get ol.tileGrid.WMTS parameters using getCapabilities response
     *
     * @param {Object} layerInfo - layer information from getCapabilities response
     * @return {Object} tmsOptions - ol.tileGrid.WMTS options
     * @private
     */
  }, {
    key: "_getTMSParams",
    value: function _getTMSParams(layerInfo) {
      var tmsOptions = {};
      var matrixIds = [];
      var resolutions = [];
      var origin = [];
      var tms;
      var projCode;
      var projection;

      // TODO : recup TOUS les autres params d'un tileGrid ! (tileSize, width...)

      var map = this.getMap();
      if (!map) {
        return;
      }

      // Récupération des informations de la pyramide (tileGrid information) : matrixIds, resolutions, origin
      if (layerInfo.TileMatrixSetLink && Array.isArray(layerInfo.TileMatrixSetLink)) {
        tms = layerInfo.TileMatrixSetLink[0].TileMatrixSet;
        if (this._getCapResponseWMTS.Contents && Array.isArray(this._getCapResponseWMTS.Contents.TileMatrixSet)) {
          var tileMatrixSets = this._getCapResponseWMTS.Contents.TileMatrixSet;
          for (var i = 0; i < tileMatrixSets.length; i++) {
            if (tileMatrixSets[i].Identifier === tms && tileMatrixSets[i].TileMatrix) {
              // on a trouvé le TMS correspondant
              var tileMatrixSet = tileMatrixSets[i];
              var tilematrix;
              var id;
              var scaledenominator;
              var resolution;
              var units;
              if (tileMatrixSet.SupportedCRS) {
                projCode = tileMatrixSet.SupportedCRS;
                projection = (0,ol_proj__WEBPACK_IMPORTED_MODULE_6__.get)(projCode);
              }
              if (projection && projection.getUnits) {
                units = projection.getUnits();
              }
              if (Array.isArray(tileMatrixSet.TileMatrix)) {
                for (var j = 0; j < tileMatrixSet.TileMatrix.length; j++) {
                  // construction du tableau des matrixIds
                  tilematrix = tileMatrixSet.TileMatrix[j];
                  if (tilematrix.Identifier != null) {
                    id = parseInt(tilematrix.Identifier, 10);
                    matrixIds.push(id);
                  }

                  // construction du tableau des résolutions, calculées à partir des dénominateurs d'échelle (scaledenominator)
                  scaledenominator = tilematrix.ScaleDenominator;
                  // calcul des résolutions selon la projection du TMS : selon si on a des coordonnées planes ou géographiques
                  if (units === "degrees") {
                    // info : 6378137 * 2 * pi / 360 = rayon de la terre (ellipsoide WGS84)
                    resolution = scaledenominator * 0.00028 * 180 / (Math.PI * 6378137);
                  } else {
                    // info : 1 pixel = 0.00028 m
                    resolution = scaledenominator * 0.00028;
                  }
                  resolutions.push(resolution);
                  origin = tilematrix.TopLeftCorner;
                }
              }

              // tri des résolutions par ordre décroissant
              if (resolutions.sort !== undefined) {
                resolutions.sort(function (x, y) {
                  return y - x;
                });
              }
              // tri des identifiants des niveaux de pyramide (matrixIds) par ordre croissant
              if (matrixIds.sort !== undefined) {
                matrixIds.sort(function (x, y) {
                  return x - y;
                });
              }
            }
          }
        } else {
          logger.warn("[ol.control.LayerImport] TileMatrixSet data not found in getCapabilities response for layer " + layerInfo.Identifier);
        }
      } else {
        return;
      }
      tmsOptions.tms = tms;
      tmsOptions.projCode = projCode;
      tmsOptions.matrixIds = matrixIds;
      tmsOptions.resolutions = resolutions;
      tmsOptions.origin = origin;
      return tmsOptions;
    }

    /**
     * this method is called by this._addGetCapWMTSLayer
     * and sets extent for WMTS layer in map projection (if available in getCapabilities response)
     *
     * @param {Object} layerInfo - layer information from getCapabilities response
     * @return {Array} extent - layer extent
     * @private
     */
  }, {
    key: "_getWMTSLayerExtent",
    value: function _getWMTSLayerExtent(layerInfo) {
      var extent;
      var mapProjCode = this._getMapProjectionCode();

      // récupération de l'étendue (bbox)
      if (layerInfo.WGS84BoundingBox && Array.isArray(layerInfo.WGS84BoundingBox)) {
        extent = (0,ol_proj__WEBPACK_IMPORTED_MODULE_6__.transformExtent)(layerInfo.WGS84BoundingBox, "EPSG:4326", mapProjCode);
      }
      return extent;
    }

    // ################################################################### //
    // ################################ utils ############################ //
    // ################################################################### //

    /**
     * gets control map projection code
     *
     * @return {String} mapProjCode - control map projection code (e.g. "EPSG:3857")
     * @private
     */
  }, {
    key: "_getMapProjectionCode",
    value: function _getMapProjectionCode() {
      var map = this.getMap();
      if (!map || !map.getView || !map.getView().getProjection) {
        logger.warn("unable to get layerimport's map");
        return;
      }
      var mapProjCode = map.getView().getProjection().getCode();
      return mapProjCode;
    }

    // ################################################################### //
    // ################################ clean ############################ //
    // ################################################################### //

    /**
     * this method displays waiting container and sets a timeout
     *
     * @private
     */
  }, {
    key: "_displayWaitingContainer",
    value: function _displayWaitingContainer() {
      this._waitingContainer.className = "GPwaitingContainer GPwaitingContainerVisible gpf-waiting gpf-waiting--visible";
      this._waiting = true;

      // mise en place d'un timeout pour réinitialiser le panel (cacher la patience)
      // si on est toujours en attente (si la requête est bloquée par exemple)
      if (this._timer) {
        clearTimeout(this._timer);
        this._timer = null;
      }
      var context = this;
      this._timer = setTimeout(function () {
        if (context._waiting === true) {
          context._hideWaitingContainer();
        } else {
          if (context._timer) {
            clearTimeout(context._timer);
          }
        }
      }, 16000);
    }

    /**
     * this method hides waiting container and clears timeout
     *
     * @private
     */
  }, {
    key: "_hideWaitingContainer",
    value: function _hideWaitingContainer() {
      if (this._waiting) {
        this._waitingContainer.className = "GPwaitingContainer GPwaitingContainerHidden gpf-waiting gpf-waiting--hidden";
        this._waiting = false;
        clearTimeout(this._timer);
        this._timer = null;
      }
    }

    /**
     * this method empties getCap results list (DOM element)
     *
     * @private
     */
  }, {
    key: "cleanGetCapResultsList",
    value: function cleanGetCapResultsList() {
      this._getCapRequestUrl = null;
      this._getCapResponseWMS = null;
      this._getCapResponseWMTS = null;
      this._getCapResponseWMSLayers = null;
      this._getCapResponseWMTSLayers = null;
      if (this._getCapResultsListContainer) {
        while (this._getCapResultsListContainer.firstChild) {
          this._getCapResultsListContainer.removeChild(this._getCapResultsListContainer.firstChild);
        }
      }
    }

    /**
     * this method empties MapBox results list (DOM element)
     *
     * @private
     */
  }, {
    key: "cleanMapBoxResultsList",
    value: function cleanMapBoxResultsList() {
      this._hasMapBoxResults = false;
      if (this._mapBoxResultsListContainer) {
        while (this._mapBoxResultsListContainer.firstChild) {
          this._mapBoxResultsListContainer.removeChild(this._mapBoxResultsListContainer.firstChild);
        }
      }
    }

    /**
     * this method empties MapBox results list (DOM element)
     *
     * @param {*} id - DOM id
     * @private
     */
  }, {
    key: "cleanMapBoxResults",
    value: function cleanMapBoxResults(id) {
      this._hasMapBoxResults = false;
      if (this._mapBoxResultsListContainer) {
        var nodes = this._mapBoxResultsListContainer.childNodes;
        for (var index = 0; index < nodes.length; index++) {
          var element = nodes[index];
          if (element.id === "GPEditorMapBoxContainer_ID_" + id) {
            element.remove();
          }
        }
      }
    }
  }]);
}(_Control__WEBPACK_IMPORTED_MODULE_1__["default"]), _defineProperty(_LayerImport, "DefaultStyles", {
  image: new ol_style__WEBPACK_IMPORTED_MODULE_18__.Icon({
    src: _Utils_Markers__WEBPACK_IMPORTED_MODULE_22__["default"]["lightOrange"],
    anchor: [25.5, 38],
    anchorOrigin: "top-left",
    anchorXUnits: "pixels",
    anchorYUnits: "pixels"
  }),
  stroke: new ol_style__WEBPACK_IMPORTED_MODULE_18__.Stroke({
    color: "rgba(0,42,80,0.8)",
    width: 4
  }),
  fill: new ol_style__WEBPACK_IMPORTED_MODULE_18__.Fill({
    color: "rgba(0, 183, 152, 0.5)"
  }),
  text: new ol_style__WEBPACK_IMPORTED_MODULE_18__.Text({
    font: "16px Sans",
    textAlign: "left",
    fill: new ol_style__WEBPACK_IMPORTED_MODULE_18__.Fill({
      color: "rgba(255, 255, 255, 1)"
    }),
    stroke: new ol_style__WEBPACK_IMPORTED_MODULE_18__.Stroke({
      color: "rgba(0, 0, 0, 1)",
      width: 2
    })
  })
}), _LayerImport);

// on récupère les méthodes de la classe commune LayerImport
Object.assign(LayerImport.prototype, _LayerImportDOM__WEBPACK_IMPORTED_MODULE_29__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LayerImport);

// Expose LayerImport as ol.control.LayerImport (for a build bundle)
if (window.ol && window.ol.control) {
  window.ol.control.LayerImport = LayerImport;
}
})();

LayerImport = __webpack_exports__["default"];
/******/ })()
;
//# sourceMappingURL=LayerImport.js.map